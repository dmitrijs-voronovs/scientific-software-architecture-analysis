id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:15383,Modifiability,config,config,15383,"fig.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms), ; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms), ; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp, ; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus, ; atol=tol); ; cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(); ; _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method, ; order=options.order, atol=options.atol, ; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step, ; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initial_vector, tlist[0]); exec(code, locals()); ; #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:17646,Modifiability,config,config,17646,"s = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(); ; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(); ; if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname); ; if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:17697,Modifiability,config,config,17697,"s = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(); ; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(); ; if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname); ; if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.6/modules/qutip/continuous_variables.html:2185,Deployability,continuous,continuous,2185,"re without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. """"""; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields.; """""". __all__ = ['correlation_matrix', 'covariance_matrix',; 'correlation_matrix_field', 'correlation_matrix_quadrature',; 'wigner_covariance_matrix', 'logarithmic_negativity']. from qutip.expect import expect; import numpy as np. [docs]def correlation_matrix(basis, rho=None):; r""""""; Given a basis set of operators :math:`\{a\}_n`, calculate the correlation; matrix:. .. math::. C_{mn} = \langle a_m a_n \rangle. Parameters; ----------; basis : list; List of operators that defines the basis for the correlation matrix.; rho : Qobj; Density matrix for which to calculate the correlation matrix. If; `rho` is `None`, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns; -------; corr_mat : ndarray; A 2-dimensional *array* of correlation values or operators. """"""; if rho is None:; # return array of operators; out = np.empty((len(basis), len(basis)), dt",MatchSource.WIKI,docs/4.6/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.6/modules/qutip/continuous_variables.html:9484,Deployability,update,updated,9484,"range(4)]; for j in range(4)], dtype=np.float64); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=np.float64); elif a1 is not None and a2 is not None:; if rho is not None:; x1 = (a1 + a1.dag()) / g; p1 = -1j * (a1 - a1.dag()) / g; x2 = (a2 + a2.dag()) / g; p2 = -1j * (a2 - a2.dag()) / g; return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""); else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V, g=np.sqrt(2)):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`.; The value of `g` is related to the value of `hbar` in the commutation ; relation `[x, y] = i * hbar` via `hbar=2/g ** 2` giving the default ; value `hbar=1`. . Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """"""; A = 0.5 * V[0:2, 0:2] * g ** 2; B = 0.5 * V[2:4, 2:4] * g ** 2; C = 0.5 * V[0:2, 2:4] * g ** 2; sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu); return logneg. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.6/modules/qutip/continuous_variables.html:2196,Modifiability,variab,variable,2196,"re without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. """"""; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields.; """""". __all__ = ['correlation_matrix', 'covariance_matrix',; 'correlation_matrix_field', 'correlation_matrix_quadrature',; 'wigner_covariance_matrix', 'logarithmic_negativity']. from qutip.expect import expect; import numpy as np. [docs]def correlation_matrix(basis, rho=None):; r""""""; Given a basis set of operators :math:`\{a\}_n`, calculate the correlation; matrix:. .. math::. C_{mn} = \langle a_m a_n \rangle. Parameters; ----------; basis : list; List of operators that defines the basis for the correlation matrix.; rho : Qobj; Density matrix for which to calculate the correlation matrix. If; `rho` is `None`, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns; -------; corr_mat : ndarray; A 2-dimensional *array* of correlation values or operators. """"""; if rho is None:; # return array of operators; out = np.empty((len(basis), len(basis)), dt",MatchSource.WIKI,docs/4.6/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.6/modules/qutip/continuous_variables.html:8269,Testability,log,logarithmic,8269,"in the commutation ; relation `[x, y] = i * hbar` via `hbar=2/g ** 2` giving the default ; value `hbar=1`. . Returns; -------; cov_mat : ndarray; A 2-dimensional array of covariance values. """"""; if R is not None:; if rho is None:; return np.array([[0.5 * np.real(R[i, j] + R[j, i]); for i in range(4)]; for j in range(4)], dtype=np.float64); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=np.float64); elif a1 is not None and a2 is not None:; if rho is not None:; x1 = (a1 + a1.dag()) / g; p1 = -1j * (a1 - a1.dag()) / g; x2 = (a2 + a2.dag()) / g; p2 = -1j * (a2 - a2.dag()) / g; return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""); else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V, g=np.sqrt(2)):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`.; The value of `g` is related to the value of `hbar` in the commutation ; relation `[x, y] = i * hbar` via `hbar=2/g ** 2` giving the default ; value `hbar=1`. . Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """"""; A = 0.5 * V[0:2, 0:2] * g ** 2; B = 0.5 * V[2:4, 2:4] * g ** 2; C = 0.5 * V[0:2, 2:4] * g ** 2; sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu); return logneg",MatchSource.WIKI,docs/4.6/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.6/modules/qutip/continuous_variables.html:8838,Testability,log,logarithmic,8838,"range(4)]; for j in range(4)], dtype=np.float64); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=np.float64); elif a1 is not None and a2 is not None:; if rho is not None:; x1 = (a1 + a1.dag()) / g; p1 = -1j * (a1 - a1.dag()) / g; x2 = (a2 + a2.dag()) / g; p2 = -1j * (a2 - a2.dag()) / g; return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""); else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V, g=np.sqrt(2)):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`.; The value of `g` is related to the value of `hbar` in the commutation ; relation `[x, y] = i * hbar` via `hbar=2/g ** 2` giving the default ; value `hbar=1`. . Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """"""; A = 0.5 * V[0:2, 0:2] * g ** 2; B = 0.5 * V[2:4, 2:4] * g ** 2; C = 0.5 * V[0:2, 2:4] * g ** 2; sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu); return logneg. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.6/modules/qutip/continuous_variables.html:9232,Testability,log,lognu,9232,"range(4)]; for j in range(4)], dtype=np.float64); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=np.float64); elif a1 is not None and a2 is not None:; if rho is not None:; x1 = (a1 + a1.dag()) / g; p1 = -1j * (a1 - a1.dag()) / g; x2 = (a2 + a2.dag()) / g; p2 = -1j * (a2 - a2.dag()) / g; return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""); else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V, g=np.sqrt(2)):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`.; The value of `g` is related to the value of `hbar` in the commutation ; relation `[x, y] = i * hbar` via `hbar=2/g ** 2` giving the default ; value `hbar=1`. . Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """"""; A = 0.5 * V[0:2, 0:2] * g ** 2; B = 0.5 * V[2:4, 2:4] * g ** 2; C = 0.5 * V[0:2, 2:4] * g ** 2; sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu); return logneg. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.6/modules/qutip/continuous_variables.html:9244,Testability,log,log,9244,"range(4)]; for j in range(4)], dtype=np.float64); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=np.float64); elif a1 is not None and a2 is not None:; if rho is not None:; x1 = (a1 + a1.dag()) / g; p1 = -1j * (a1 - a1.dag()) / g; x2 = (a2 + a2.dag()) / g; p2 = -1j * (a2 - a2.dag()) / g; return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""); else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V, g=np.sqrt(2)):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`.; The value of `g` is related to the value of `hbar` in the commutation ; relation `[x, y] = i * hbar` via `hbar=2/g ** 2` giving the default ; value `hbar=1`. . Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """"""; A = 0.5 * V[0:2, 0:2] * g ** 2; B = 0.5 * V[2:4, 2:4] * g ** 2; C = 0.5 * V[0:2, 2:4] * g ** 2; sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu); return logneg. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.6/modules/qutip/continuous_variables.html:9257,Testability,log,logneg,9257,"range(4)]; for j in range(4)], dtype=np.float64); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=np.float64); elif a1 is not None and a2 is not None:; if rho is not None:; x1 = (a1 + a1.dag()) / g; p1 = -1j * (a1 - a1.dag()) / g; x2 = (a2 + a2.dag()) / g; p2 = -1j * (a2 - a2.dag()) / g; return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""); else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V, g=np.sqrt(2)):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`.; The value of `g` is related to the value of `hbar` in the commutation ; relation `[x, y] = i * hbar` via `hbar=2/g ** 2` giving the default ; value `hbar=1`. . Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """"""; A = 0.5 * V[0:2, 0:2] * g ** 2; B = 0.5 * V[2:4, 2:4] * g ** 2; C = 0.5 * V[0:2, 2:4] * g ** 2; sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu); return logneg. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.6/modules/qutip/continuous_variables.html:9273,Testability,log,lognu,9273,"range(4)]; for j in range(4)], dtype=np.float64); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=np.float64); elif a1 is not None and a2 is not None:; if rho is not None:; x1 = (a1 + a1.dag()) / g; p1 = -1j * (a1 - a1.dag()) / g; x2 = (a2 + a2.dag()) / g; p2 = -1j * (a2 - a2.dag()) / g; return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""); else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V, g=np.sqrt(2)):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`.; The value of `g` is related to the value of `hbar` in the commutation ; relation `[x, y] = i * hbar` via `hbar=2/g ** 2` giving the default ; value `hbar=1`. . Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """"""; A = 0.5 * V[0:2, 0:2] * g ** 2; B = 0.5 * V[2:4, 2:4] * g ** 2; C = 0.5 * V[0:2, 2:4] * g ** 2; sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu); return logneg. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.6/modules/qutip/continuous_variables.html:9288,Testability,log,logneg,9288,"range(4)]; for j in range(4)], dtype=np.float64); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=np.float64); elif a1 is not None and a2 is not None:; if rho is not None:; x1 = (a1 + a1.dag()) / g; p1 = -1j * (a1 - a1.dag()) / g; x2 = (a2 + a2.dag()) / g; p2 = -1j * (a2 - a2.dag()) / g; return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""); else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V, g=np.sqrt(2)):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`.; The value of `g` is related to the value of `hbar` in the commutation ; relation `[x, y] = i * hbar` via `hbar=2/g ** 2` giving the default ; value `hbar=1`. . Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """"""; A = 0.5 * V[0:2, 0:2] * g ** 2; B = 0.5 * V[2:4, 2:4] * g ** 2; C = 0.5 * V[0:2, 2:4] * g ** 2; sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu); return logneg. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:4866,Availability,error,errors,4866," : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; reverse : bool {False, True}; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`.; solver : str {'me', 'mc', 'es'}; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; Solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : ndarray; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if reverse:; A_op = a_op; B_op = b_op; C_op = 1; else:; A_op = 1; B_op = a_op; C_op = b_op. return _correlation_2t(H, state0, [0], taulist, c_ops, A_op, B_op, C_op,; solver=solver, args=args, options=options)[0]. [docs]def correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state de",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:7090,Availability,error,errors,7090,"rray_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; reverse : bool {False, True}; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_mat : ndarray; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if tlist is None:; return correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op,; solver=solver, reverse=reverse, args=args,; options=options); else:; if reverse:; A_op = a_op; B_op = b_op; C_op = 1; else:; A_op = 1; B_op = a_op; C_op = b_op. return _correlation_2t(H, state0, tlist, taulist,; c_ops, A_op, B_op, C_op,; solver=solver, args=args, options=options). [docs]def correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the three-operator two-time correlation function:; :",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:9349,Availability,error,errors,9349,":`\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; c_op : Qobj; operator C.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : array; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). return _correlation_2t(H, state0, [0], taulist, c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options)[0]. [docs]def correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the three-operator two-time correlation function:; :math:`\left<A(t)B(t+\tau)C(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initi",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:11475,Availability,error,errors,11475," used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; c_op : Qobj; operator C.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if tlist is None:; return correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options); else:; return _correlation_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options). # high level correlation. [docs]def coherence_function_g1(H, state0, taulist, c_ops, a_op, solver=""me"",; args={}, options=Options(ntraj=[20, 100])):; r""""""; Calculate the normalized first-order quantum coherence function:. .. math::. g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle ",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:13558,Availability,error,errors,13558,"m regression theorem and the evolution solver indicated by; the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; solver : str; choice of solver (`me` for master-equation and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; g1, G1 : tuple; The normalized and unnormalized second-order coherence function. """""". # first calculate the photon number; if state0 is None:; state0 = steadystate(H, c_ops); n = np.array([expect(state0, a_op.dag() * a_op)]); else:; n = mesolve(H, state0, taulist, c_ops, [a_op.dag() * a_op],; options=options).expect[0]. # calculate the correlation function G1 and normalize with n to obtain g1; G1 = correlation_2op_1t(H, state0, taulist, c_ops, a_op.dag(), a_op,; solver=solver, args=args, options=options); g1 = G1 / np.sqrt(n[0] * n). return g1, G1. [docs]def coherence_function_g2(H, state0, taulist, c_ops, a_op, solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the normalized second-order quantum coherence function:. .. math::. g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}. using the quan",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:15623,Availability,error,errors,15623,"e `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; args : dict; Dictionary of arguments to be passed to solver.; solver : str; choice of solver (`me` for master-equation and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; g2, G2 : tuple; The normalized and unnormalized second-order coherence function. """""". # first calculate the photon number; if state0 is None:; state0 = steadystate(H, c_ops); n = np.array([expect(state0, a_op.dag() * a_op)]); else:; n = mesolve(H, state0, taulist, c_ops, [a_op.dag() * a_op], args=args).expect[0]. # calculate the correlation function G2 and normalize with n to obtain g2; G2 = correlation_3op_1t(H, state0, taulist, c_ops,; a_op.dag(), a_op.dag()*a_op, a_op,; solver=solver, args=args, options=options); g2 = G2 / (n[0] * n). return g2, G2. # spectrum. [docs]def spectrum(H, wlist, c_ops, a_op, b_op, solver=""es"", use_pinv=False):; r""""""; Calculate the spectrum of the correlation function; :math:`\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>`,; i.e., the Fourier transform of the correlation function:. .. math::. S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:20230,Availability,error,errors,20230,"he two-operator two-time correlation function:. .. math::. \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>. along one time axis (given steady-state initial conditions) using the; quantum regression theorem and the evolution solver indicated by the; `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian. taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : *bool*; If `True`, calculate; :math:`\lim_{t \to \infty} \left<A(t)B(t+\tau)\right>` instead of; :math:`\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>`. solver : str; choice of solver (`me` for master-equation and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_vec : array; An array of correlation values for the times specified by `tlist`. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation_ss() now legacy, please use correlation_2op_1t() with"" +; ""initial state as None"", FutureWarning). if debug:; print(inspect.stack()[0][3]). return correlation_2op_1t(H, None, taulist, c_ops, a_op, b_op,; solver=solver, reverse=reverse, args=args,; options=options). [docs]def correlation(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`. state0 : Qobj",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:22458,Availability,error,errors,22458," solvers. tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : *bool*; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation() now legacy, please use correlation_2op_2t()"",; FutureWarning). if debug:; print(inspect.stack()[0][3]). return correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=solver, reverse=reverse, args=args,; options=options). [docs]def correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the four-operator two-time correlation function:; :math:`\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>`; along one time axis using the quantum regression theorem and the; evolution solver indicated by th",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:24600,Availability,error,errors,24600,"s; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : array; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. .. note:: Deprecated in QuTiP 3.1; Use correlation_3op_1t() instead. """""". warn(""correlation_4op_1t() now legacy, please use correlation_3op_1t()"",; FutureWarning); warn(""the reverse argument has been removed as it did not contain any"" +; ""new physical information"", DeprecationWarning). if debug:; print(inspect.stack()[0][3]). return correlation_3op_1t(H, state0, taulist, c_ops,; a_op, b_op * c_op, d_op,; solver=solver, args=args, options=options). [docs]def correlation_4op_2t(H, state0, tlist, taulist, c_ops,; a_op, b_op, c_op, d_op, solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the four-operator two-time correlation function:; :math:`\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>`; along two time axes using the quantum regression theorem and t",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:27041,Availability,error,errors,27041,"ial state. The 'steady-state' is only implemented; for the `me` and `es` solvers. tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation_4op_2t() now legacy, please use correlation_3op_2t()"",; FutureWarning); warn(""the reverse argument has been removed as it did not contain any"" +; ""new physical information"", DeprecationWarning). if debug:; print(inspect.stack()[0][3]). return correlation_3op_2t(H, state0, tlist, taulist, c_ops,; a_op, b_op * c_op, d_op,; solver=solver, args=args, options=options). # spectrum. [docs]def spectrum_ss(H, wlist, c_ops, a_op, b_op):; r""""""; Calculate the spectrum of the correlation function; :math:`\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>`,; i.e., the Fourier transform of the correlation ",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:37294,Availability,error,errors,37294,"s; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H_shifted, chi_0/chi_0.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers; def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; r""""""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\tau)B(0)\right>",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:40400,Deployability,update,updated,40400,"at.full())). rho_ss = steadystate(L); rho = np.transpose(mat2vec(rho_ss.full())). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. # auxiliary; def _transform_shift_one_coeff(op, args):; if isinstance(op, types.FunctionType):; # function-list based time-dependence; if isinstance(args, dict):; def fn(t, args_i):; return op(t + args_i[""_t0""], args_i); fn = lambda t, args_i: \; op(t + args_i[""_t0""], args_i); else:; def fn(t, args_i):; return op(t + args_i[""_t0""], args_i[""_user_args""]); else:; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", "" "" + op + "" ""); return fn. def _transform_shift_one_op(op, args={}):; if isinstance(op, Qobj):; new_op = op; elif isinstance(op, QobjEvo):; new_op = op; new_op._shift; elif callable(op):; def new_op(t, args_i):; return op(t + args_i[""_t0""], args_i); elif isinstance(op, list):; new_op = []; for block in op:; if isinstance(block, list):; new_op.append([block[0],; _transform_shift_one_coeff(block[1], args)]); else:; new_op.append(block); return new_op. def _transform_L_t_shift_new(H, c_ops, args={}):; H_shifted = _transform_shift_one_op(H, args); c_ops_shifted = [_transform_shift_one_op(op, args) for op in c_ops]; if args is None:; _args = {""_t0"": 0}; elif isinstance(args, dict):; _args = args.copy(); _args[""_t0""] = 0; else:; _args = {""_user_args"": args, ""_t0"": 0}. return H_shifted, c_ops_shifted, _args. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:17715,Energy Efficiency,power,power,17715,"is spectrum; is only defined for stationary statistics (uses steady state rho0). Parameters; ----------; H : :class:`qutip.qobj`; system Hamiltonian.; wlist : array_like; list of frequencies for :math:`\omega`.; c_ops : list; list of collapse operators.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; solver : str; choice of solver (`es` for exponential series and; `pi` for psuedo-inverse).; use_pinv : bool; For use with the `pi` solver: if `True` use numpy's pinv method,; otherwise use a generic solver. Returns; -------; spectrum : array; An array with spectrum :math:`S(\omega)` for the frequencies; specified in `wlist`. """""". if debug:; print(inspect.stack()[0][3]). if solver == ""es"":; return _spectrum_es(H, wlist, c_ops, a_op, b_op); elif solver == ""pi"":; return _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use es or pi)."" % solver). [docs]def spectrum_correlation_fft(tlist, y, inverse=False):; """"""; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters; ----------; tlist : array_like; list/array of times :math:`t` which the correlation function is given.; y : array_like; list/array of correlations corresponding to time delays :math:`t`.; inverse: boolean; boolean parameter for using a positive exponent in the Fourier Transform instead. Default is False. Returns; -------; w, S : tuple; Returns an array of angular frequencies 'w' and the corresponding; two-sided power spectrum 'S(w)'. """""". if debug:; print(inspect.stack()[0][3]); tlist = np.asarray(tlist); N = tlist.shape[0]; dt = tlist[1] - tlist[0]; if not np.allclose(np.diff(tlist), dt*np.ones(N-1,dtype=float)):; raise Exception('tlist must be equally spaced for FFT.'). if inverse:; F = N * scipy.fftpack.ifft(y); else:; F = scipy.fftpack.fft(y). # calculate the frequencies for the components in F; f = scipy.fftpack.fftfreq(N, dt). # re-order frequencies from most negative to most positive (cent",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:18218,Energy Efficiency,power,power,18218,"py's pinv method,; otherwise use a generic solver. Returns; -------; spectrum : array; An array with spectrum :math:`S(\omega)` for the frequencies; specified in `wlist`. """""". if debug:; print(inspect.stack()[0][3]). if solver == ""es"":; return _spectrum_es(H, wlist, c_ops, a_op, b_op); elif solver == ""pi"":; return _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use es or pi)."" % solver). [docs]def spectrum_correlation_fft(tlist, y, inverse=False):; """"""; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters; ----------; tlist : array_like; list/array of times :math:`t` which the correlation function is given.; y : array_like; list/array of correlations corresponding to time delays :math:`t`.; inverse: boolean; boolean parameter for using a positive exponent in the Fourier Transform instead. Default is False. Returns; -------; w, S : tuple; Returns an array of angular frequencies 'w' and the corresponding; two-sided power spectrum 'S(w)'. """""". if debug:; print(inspect.stack()[0][3]); tlist = np.asarray(tlist); N = tlist.shape[0]; dt = tlist[1] - tlist[0]; if not np.allclose(np.diff(tlist), dt*np.ones(N-1,dtype=float)):; raise Exception('tlist must be equally spaced for FFT.'). if inverse:; F = N * scipy.fftpack.ifft(y); else:; F = scipy.fftpack.fft(y). # calculate the frequencies for the components in F; f = scipy.fftpack.fftfreq(N, dt). # re-order frequencies from most negative to most positive (centre on 0); idx = np.array([], dtype = 'int'); idx = np.append(idx, np.where(f < 0.0)); idx = np.append(idx, np.where(f >= 0.0)). return 2 * np.pi * f[idx], 2 * dt * np.real(F[idx]). # -----------------------------------------------------------------------------; # LEGACY API; # -----------------------------------------------------------------------------. # low level correlation. [docs]def correlation_ss(H, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=Fa",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:3825,Integrability,depend,dependent,3825,"ate import rhs_clear, _td_wrap_array_str; from qutip.cy.utilities import _cython_build_cleanup; from qutip.settings import debug; from qutip.solver import Options, config; from qutip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.superoperator import liouvillian, spre, mat2vec; from qutip.tensor import tensor. if debug:; import inspect. # -----------------------------------------------------------------------------; # PUBLIC API; # -----------------------------------------------------------------------------. # low level correlation. [docs]def correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along one time axis using the quantum regression theorem and the evolution; solver indicated by the `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; reverse : bool {False, True}; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`.; solver : str {'me', 'mc', 'es'}; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; Solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:4287,Integrability,depend,dependent,4287,"IC API; # -----------------------------------------------------------------------------. # low level correlation. [docs]def correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along one time axis using the quantum regression theorem and the evolution; solver indicated by the `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; reverse : bool {False, True}; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`.; solver : str {'me', 'mc', 'es'}; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; Solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : ndarray; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if reverse:; A_op = a_op; B_op = b_op; C_op = 1; else:; A_op = 1; B_op = a_op; C_op = b_op. return _correlation_2t(H, state0, [0], ",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:5801,Integrability,depend,dependent,5801,"vely; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : ndarray; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if reverse:; A_op = a_op; B_op = b_op; C_op = 1; else:; A_op = 1; B_op = a_op; C_op = b_op. return _correlation_2t(H, state0, [0], taulist, c_ops, A_op, B_op, C_op,; solver=solver, args=args, options=options)[0]. [docs]def correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho_0` or state vector; :math:`\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; reverse : bool {False, True}; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`.; solver : str; choice of so",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:6530,Integrability,depend,dependent,6530,"ulate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho_0` or state vector; :math:`\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; reverse : bool {False, True}; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_mat : ndarray; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:8438,Integrability,depend,dependent,8438,"nces; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if tlist is None:; return correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op,; solver=solver, reverse=reverse, args=args,; options=options); else:; if reverse:; A_op = a_op; B_op = b_op; C_op = 1; else:; A_op = 1; B_op = a_op; C_op = b_op. return _correlation_2t(H, state0, tlist, taulist,; c_ops, A_op, B_op, C_op,; solver=solver, args=args, options=options). [docs]def correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the three-operator two-time correlation function:; :math:`\left<A(t)B(t+\tau)C(t)\right>`; along one time axis using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; c_op : Qobj; operator C.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; ----",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:8898,Integrability,depend,dependent,8898,"ptions). [docs]def correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the three-operator two-time correlation function:; :math:`\left<A(t)B(t+\tau)C(t)\right>`; along one time axis using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; c_op : Qobj; operator C.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : array; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). return _correlation_2t(H, state0, [0], taulist, c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options)[0]. [docs]def correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):;",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:10297,Integrability,depend,dependent,10297,"ult,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : array; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). return _correlation_2t(H, state0, [0], taulist, c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options)[0]. [docs]def correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the three-operator two-time correlation function:; :math:`\left<A(t)B(t+\tau)C(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\rho_0` or state vector; :math:`\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; c_op : Qobj; operator C.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; so",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:11024,Integrability,depend,dependent,11024,"es using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\rho_0` or state vector; :math:`\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; c_op : Qobj; operator C.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if tlist is None:; return correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op,; solver=solv",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:12720,Integrability,depend,dependent,12720," If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if tlist is None:; return correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options); else:; return _correlation_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options). # high level correlation. [docs]def coherence_function_g1(H, state0, taulist, c_ops, a_op, solver=""me"",; args={}, options=Options(ntraj=[20, 100])):; r""""""; Calculate the normalized first-order quantum coherence function:. .. math::. g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}. using the quantum regression theorem and the evolution solver indicated by; the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; solver : str; choice of solver (`me` for master-equation and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; g1, G1 : tuple; The normalized and unnormalized second-order coheren",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:13182,Integrability,depend,dependent,13182,"s). # high level correlation. [docs]def coherence_function_g1(H, state0, taulist, c_ops, a_op, solver=""me"",; args={}, options=Options(ntraj=[20, 100])):; r""""""; Calculate the normalized first-order quantum coherence function:. .. math::. g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}. using the quantum regression theorem and the evolution solver indicated by; the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; solver : str; choice of solver (`me` for master-equation and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; g1, G1 : tuple; The normalized and unnormalized second-order coherence function. """""". # first calculate the photon number; if state0 is None:; state0 = steadystate(H, c_ops); n = np.array([expect(state0, a_op.dag() * a_op)]); else:; n = mesolve(H, state0, taulist, c_ops, [a_op.dag() * a_op],; options=options).expect[0]. # calculate the correlation function G1 and normalize with n to obtain g1; G1 = correlation_2op_1t(H, state0, taulist, c_ops, a_op.dag(), a_op,; solver=solver, args=args, options=options); g1 = G1 / np.sqrt(n[0] * ",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:14723,Integrability,depend,dependent,14723,"function. """""". # first calculate the photon number; if state0 is None:; state0 = steadystate(H, c_ops); n = np.array([expect(state0, a_op.dag() * a_op)]); else:; n = mesolve(H, state0, taulist, c_ops, [a_op.dag() * a_op],; options=options).expect[0]. # calculate the correlation function G1 and normalize with n to obtain g1; G1 = correlation_2op_1t(H, state0, taulist, c_ops, a_op.dag(), a_op,; solver=solver, args=args, options=options); g1 = G1 / np.sqrt(n[0] * n). return g1, G1. [docs]def coherence_function_g2(H, state0, taulist, c_ops, a_op, solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the normalized second-order quantum coherence function:. .. math::. g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}. using the quantum regression theorem and the evolution solver indicated by; the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; args : dict; Dictionary of arguments to be passed to solver.; solver : str; choice of solver (`me` for master-equation and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; g2, G2",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:15185,Integrability,depend,dependent,15185,". return g1, G1. [docs]def coherence_function_g2(H, state0, taulist, c_ops, a_op, solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the normalized second-order quantum coherence function:. .. math::. g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}. using the quantum regression theorem and the evolution solver indicated by; the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; args : dict; Dictionary of arguments to be passed to solver.; solver : str; choice of solver (`me` for master-equation and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; g2, G2 : tuple; The normalized and unnormalized second-order coherence function. """""". # first calculate the photon number; if state0 is None:; state0 = steadystate(H, c_ops); n = np.array([expect(state0, a_op.dag() * a_op)]); else:; n = mesolve(H, state0, taulist, c_ops, [a_op.dag() * a_op], args=args).expect[0]. # calculate the correlation function G2 and normalize with n to obtain g2; G2 = correlation_3op_1t(H, state0, taulist, c_ops,; a_op.dag(), a_op.dag()*a_op, a_o",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:21184,Integrability,depend,dependent,21184,"100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_vec : array; An array of correlation values for the times specified by `tlist`. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation_ss() now legacy, please use correlation_2op_1t() with"" +; ""initial state as None"", FutureWarning). if debug:; print(inspect.stack()[0][3]). return correlation_2op_1t(H, None, taulist, c_ops, a_op, b_op,; solver=solver, reverse=reverse, args=args,; options=options). [docs]def correlation(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`. state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers. tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : *bool*; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`. solver : str; choice of solver (`me` for master-equa",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:21915,Integrability,depend,dependent,21915,"te the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`. state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers. tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : *bool*; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation() now legacy, please use correlat",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:23669,Integrability,depend,dependent,23669,"dex) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation() now legacy, please use correlation_2op_2t()"",; FutureWarning). if debug:; print(inspect.stack()[0][3]). return correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=solver, reverse=reverse, args=args,; options=options). [docs]def correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the four-operator two-time correlation function:; :math:`\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>`; along one time axis using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:24129,Integrability,depend,dependent,24129,"]def correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the four-operator two-time correlation function:; :math:`\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>`; along one time axis using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : array; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. .. note:: Deprecated in QuTiP 3.1; Use correlation_3op_1t() instead. """""". warn(""correlation_4op_1t() now legacy, please use correlation_3op_1t()"",; FutureWarning); warn(""the reverse argument has been removed as it did not contain any"" +; ""new physical information"", DeprecationWarning). ",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:25847,Integrability,depend,dependent,25847,"eprecated in QuTiP 3.1; Use correlation_3op_1t() instead. """""". warn(""correlation_4op_1t() now legacy, please use correlation_3op_1t()"",; FutureWarning); warn(""the reverse argument has been removed as it did not contain any"" +; ""new physical information"", DeprecationWarning). if debug:; print(inspect.stack()[0][3]). return correlation_3op_1t(H, state0, taulist, c_ops,; a_op, b_op * c_op, d_op,; solver=solver, args=args, options=options). [docs]def correlation_4op_2t(H, state0, tlist, taulist, c_ops,; a_op, b_op, c_op, d_op, solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the four-operator two-time correlation function:; :math:`\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\tau<0`. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`. rho0 : Qobj; Initial state density matrix :math:`\rho_0` or state vector; :math:`\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers. tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:26570,Integrability,depend,dependent,26570," axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\tau<0`. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`. rho0 : Qobj; Initial state density matrix :math:`\rho_0` or state vector; :math:`\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers. tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation_4op_2t() now legacy, please use correlation_3op_2t()"",; FutureWarning); warn(""the reverse argument has be",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:39096,Integrability,depend,dependence,39096,"n; :math:`\left<A(\tau)B(0)\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.transpose(mat2vec(tr_mat.full())). rho_ss = steadystate(L); rho = np.transpose(mat2vec(rho_ss.full())). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. # auxiliary; def _transform_shift_one_coeff(op, args):; if isinstance(op, types.FunctionType):; # function-list based time-dependence; if isinstance(args, dict):; def fn(t, args_i):; return op(t + args_i[""_t0""], args_i); fn = lambda t, args_i: \; op(t + args_i[""_t0""], args_i); else:; def fn(t, args_i):; return op(t + args_i[""_t0""], args_i[""_user_args""]); else:; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", "" "" + op + "" ""); return fn. def _transform_shift_one_op(op, args={}):; if isinstance(op, Qobj):; new_op = op; elif isinstance(op, QobjEvo):; new_op = op; new_op._shift; elif callable(op):; def new_op(t, args_i):; return op(t + args_i[""_t0""], args_i); elif isinstance(op, list):; new_op = []; for block in op:; if isinstance(block, list):; new_op.append([block[0],; _transform_shift_one_coeff(block[1], args)]); else:; new_op.append(block); return new_op. def _transform_L_t_shift_new(H, c_ops, args={}):; H_shifted = _transform_shift_one_op(H, args); c_ops_shifted = [_transform_shift_one_op(op, args) for op in c_ops]; if args is None:; _args = {""_t0"": 0}; elif isinstance(args, dict):; _args = args.copy(); _args[""_t0""] = 0; else:; _args = {""_user_args"": args, ""_t0"": 0}. return H_shifted, c_ops_shifted, _args. © Copyright 2011 and later,",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:2990,Modifiability,config,config,2990,"BILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['correlation_2op_1t', 'correlation_2op_2t', 'correlation_3op_1t',; 'correlation_3op_2t', 'coherence_function_g1',; 'coherence_function_g2', 'spectrum', 'spectrum_correlation_fft',; 'correlation_ss', 'correlation', 'correlation_4op_1t',; 'correlation_4op_2t', 'spectrum_ss', 'spectrum_pi']. from re import sub; from warnings import warn; import warnings; import types. import numpy as np; import scipy.fftpack. from qutip.eseries import esval, esspec; from qutip.essolve import ode2es; from qutip.expect import expect; from qutip.mesolve import mesolve; from qutip.mcsolve import mcsolve; from qutip.operators import qeye; from qutip.qobj import Qobj, isket, issuper; from qutip.qobjevo import QobjEvo; from qutip.rhs_generate import rhs_clear, _td_wrap_array_str; from qutip.cy.utilities import _cython_build_cleanup; from qutip.settings import debug; from qutip.solver import Options, config; from qutip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.superoperator import liouvillian, spre, mat2vec; from qutip.tensor import tensor. if debug:; import inspect. # -----------------------------------------------------------------------------; # PUBLIC API; # -----------------------------------------------------------------------------. # low level correlation. [docs]def correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along one time axis using the quantum regression theorem and the evolution; solver indicated by the `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'No",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:30988,Modifiability,config,config,30988,", c_ops, a_op, b_op,; solver=""pi"", use_pinv=use_pinv). # -----------------------------------------------------------------------------; # PRIVATE SOLVER METHODS; # -----------------------------------------------------------------------------. # master 2t correlation solver. def _correlation_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={}, options=Options()):; """"""; Internal function for calling solvers in order to calculate the; three-operator two-time correlation function:; <A(t)B(t+tau)C(t)>; """""". # Note: the current form of the correlator is sufficient for all possible; # two-time correlations (incuding those with 2ops vs 3). Ex: to compute a; # correlation of the form <A(t+tau)B(t)>: a_op = identity, b_op = A,; # and c_op = B. if debug:; print(inspect.stack()[0][3]). if min(tlist) != 0:; raise TypeError(""tlist must be positive and contain the element 0.""); if min(taulist) != 0:; raise TypeError(""taulist must be positive and contain the element 0.""). if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(); H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). if solver == ""me"":; return _correlation_me_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; args=args, options=options); elif solver == ""mc"":; return _correlation_mc_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; args=args, options=options); elif solver == ""es"":; return _correlation_es_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use me, mc, or es)."" % solver). # master equation solvers. def _correlation_me_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadysta",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:31026,Modifiability,config,config,31026,"ver=""pi"", use_pinv=use_pinv). # -----------------------------------------------------------------------------; # PRIVATE SOLVER METHODS; # -----------------------------------------------------------------------------. # master 2t correlation solver. def _correlation_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={}, options=Options()):; """"""; Internal function for calling solvers in order to calculate the; three-operator two-time correlation function:; <A(t)B(t+tau)C(t)>; """""". # Note: the current form of the correlator is sufficient for all possible; # two-time correlations (incuding those with 2ops vs 3). Ex: to compute a; # correlation of the form <A(t+tau)B(t)>: a_op = identity, b_op = A,; # and c_op = B. if debug:; print(inspect.stack()[0][3]). if min(tlist) != 0:; raise TypeError(""tlist must be positive and contain the element 0.""); if min(taulist) != 0:; raise TypeError(""taulist must be positive and contain the element 0.""). if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(); H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). if solver == ""me"":; return _correlation_me_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; args=args, options=options); elif solver == ""mc"":; return _correlation_mc_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; args=args, options=options); elif solver == ""es"":; return _correlation_es_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use me, mc, or es)."" % solver). # master equation solvers. def _correlation_me_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:32355,Modifiability,config,config,32355,"tlist, taulist,; c_ops, a_op, b_op, c_op,; args=args, options=options); elif solver == ""es"":; return _correlation_es_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use me, mc, or es)."" % solver). # master equation solvers. def _correlation_me_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). rho_t = mesolve(H, rho0, tlist, c_ops, [],; args=args, options=options).states; corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); H_shifted, c_ops_shifted, _args = _transform_L_t_shift_new(H, c_ops, args); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). for t_idx, rho in enumerate(rho_t):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. corr_mat[t_idx, :] = mesolve(; H_shifted, c_op * rho * a_op, taulist, c_ops_shifted,; [b_op], args=_args, options=options; ).expect[0]. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # exponential series solvers. def _correlation_es_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using an exponential series solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:32393,Modifiability,config,config,32393,"olver == ""es"":; return _correlation_es_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use me, mc, or es)."" % solver). # master equation solvers. def _correlation_me_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). rho_t = mesolve(H, rho0, tlist, c_ops, [],; args=args, options=options).states; corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); H_shifted, c_ops_shifted, _args = _transform_L_t_shift_new(H, c_ops, args); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). for t_idx, rho in enumerate(rho_t):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. corr_mat[t_idx, :] = mesolve(; H_shifted, c_op * rho * a_op, taulist, c_ops_shifted,; [b_op], args=_args, options=options; ).expect[0]. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # exponential series solvers. def _correlation_es_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using an exponential series solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). # contruct the Liouvillian; L = liouvillian(H, c_ops). corr_mat = np.z",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:32698,Modifiability,config,config,32698,"s()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). rho_t = mesolve(H, rho0, tlist, c_ops, [],; args=args, options=options).states; corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); H_shifted, c_ops_shifted, _args = _transform_L_t_shift_new(H, c_ops, args); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). for t_idx, rho in enumerate(rho_t):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. corr_mat[t_idx, :] = mesolve(; H_shifted, c_op * rho * a_op, taulist, c_ops_shifted,; [b_op], args=_args, options=options; ).expect[0]. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # exponential series solvers. def _correlation_es_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using an exponential series solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). # contruct the Liouvillian; L = liouvillian(H, c_ops). corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex). # The user-facing eseries and ode2es are deprecated from QuTiP 4.6, pending; # removal in QuTiP 5.0, however they are being maintained for internal use; # in correlation, so should not raise warnings to the user not matter what; # their settings.; with warnings.",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:32736,Modifiability,config,config,32736,"tion for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). rho_t = mesolve(H, rho0, tlist, c_ops, [],; args=args, options=options).states; corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); H_shifted, c_ops_shifted, _args = _transform_L_t_shift_new(H, c_ops, args); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). for t_idx, rho in enumerate(rho_t):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. corr_mat[t_idx, :] = mesolve(; H_shifted, c_op * rho * a_op, taulist, c_ops_shifted,; [b_op], args=_args, options=options; ).expect[0]. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # exponential series solvers. def _correlation_es_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using an exponential series solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). # contruct the Liouvillian; L = liouvillian(H, c_ops). corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex). # The user-facing eseries and ode2es are deprecated from QuTiP 4.6, pending; # removal in QuTiP 5.0, however they are being maintained for internal use; # in correlation, so should not raise warnings to the user not matter what; # their settings.; with warnings.catch_warnings():; warni",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:36134,Modifiability,config,config,36134,"m; return esspec(cov_es, wlist). # Monte Carlo solvers. def _correlation_mc_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a Monte Carlo solver.; """""". if not c_ops:; raise TypeError(""If no collapse operators are required, use the `me`"" +; ""or `es` solvers""). # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; raise NotImplementedError(""steady state not implemented for "" +; ""mc solver, please use `es` or `me`""); elif not isket(state0):; raise TypeError(""state0 must be a state vector.""); psi0 = state0. if debug:; print(inspect.stack()[0][3]). psi_t_mat = mcsolve(; H, psi0, tlist, c_ops, [],; args=args, ntraj=options.ntraj[0], options=options, progress_bar=None; ).states. corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); H_shifted, c_ops_shifted, _args = _transform_L_t_shift_new(H, c_ops, args); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). # calculation of <A(t)B(t+tau)C(t)> from only knowledge of psi0 requires; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H_shifted, chi_0/chi_0.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:36172,Modifiability,config,config,36172,"(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a Monte Carlo solver.; """""". if not c_ops:; raise TypeError(""If no collapse operators are required, use the `me`"" +; ""or `es` solvers""). # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; raise NotImplementedError(""steady state not implemented for "" +; ""mc solver, please use `es` or `me`""); elif not isket(state0):; raise TypeError(""state0 must be a state vector.""); psi0 = state0. if debug:; print(inspect.stack()[0][3]). psi_t_mat = mcsolve(; H, psi0, tlist, c_ops, [],; args=args, ntraj=options.ntraj[0], options=options, progress_bar=None; ).states. corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); H_shifted, c_ops_shifted, _args = _transform_L_t_shift_new(H, c_ops, args); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). # calculation of <A(t)B(t+tau)C(t)> from only knowledge of psi0 requires; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H_shifted, chi_0/chi_0.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.d",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:36647,Modifiability,evolve,evolve,36647,"""mc solver, please use `es` or `me`""); elif not isket(state0):; raise TypeError(""state0 must be a state vector.""); psi0 = state0. if debug:; print(inspect.stack()[0][3]). psi_t_mat = mcsolve(; H, psi0, tlist, c_ops, [],; args=args, ntraj=options.ntraj[0], options=options, progress_bar=None; ).states. corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); H_shifted, c_ops_shifted, _args = _transform_L_t_shift_new(H, c_ops, args); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). # calculation of <A(t)B(t+tau)C(t)> from only knowledge of psi0 requires; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H_shifted, chi_0/chi_0.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:37444,Modifiability,evolve,evolve,37444,"nstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H_shifted, chi_0/chi_0.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers; def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; r""""""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\tau)B(0)\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:37986,Modifiability,config,config,37986,"ptions.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers; def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; r""""""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\tau)B(0)\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.transpose(mat2vec(tr_mat.full())). rho_ss = steadystate(L); rho = np.transpose(mat2vec(rho_ss.full())). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. # auxiliary; de",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:38024,Modifiability,config,config,38024," otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers; def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; r""""""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\tau)B(0)\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.transpose(mat2vec(tr_mat.full())). rho_ss = steadystate(L); rho = np.transpose(mat2vec(rho_ss.full())). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. # auxiliary; def _transform_shift_one_c",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/correlation.html:37254,Performance,load,loaded,37254,"s; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H_shifted, chi_0/chi_0.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops_shifted,; [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers; def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; r""""""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\tau)B(0)\right>",MatchSource.WIKI,docs/4.6/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html
https://qutip.org/docs/4.6/modules/qutip/dimensions.html:2225,Availability,avail,available,2225," permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; Internal use module for manipulating dims specifications.; """""". __all__ = [] # Everything should be explicitly imported, not made available; # by default. import numpy as np; from operator import getitem; from functools import partial. [docs]def is_scalar(dims):; """"""; Returns True if a dims specification is effectively; a scalar (has dimension 1).; """"""; return np.prod(flatten(dims)) == 1. def is_vector(dims):; return (; isinstance(dims, list) and; isinstance(dims[0], (int, np.integer)); ). def is_vectorized_oper(dims):; return (; isinstance(dims, list) and; isinstance(dims[0], list); ). def type_from_dims(dims, enforce_square=False):; bra_like, ket_like = map(is_scalar, dims). if bra_like:; if is_vector(dims[1]):; return 'bra'; elif is_vectorized_oper(dims[1]):; return 'operator-bra'. if ket_like:; if is_vector(dims[0]):; return 'ket'; elif is_vectorized_oper(dims[0]):; return 'operator-ket'. elif is_vector(dims[0]) and (dims[0] == dims[1] or not enforce_square):; return 'oper'. elif (; is_vectorized_oper(dims[0]) and; (; (; dims[0] == dims[1] and; dims[0][0] == dims[1][0]; ) or not enforce_s",MatchSource.WIKI,docs/4.6/modules/qutip/dimensions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/dimensions.html
https://qutip.org/docs/4.6/modules/qutip/dimensions.html:3383,Availability,down,down,3383," a dims specification is effectively; a scalar (has dimension 1).; """"""; return np.prod(flatten(dims)) == 1. def is_vector(dims):; return (; isinstance(dims, list) and; isinstance(dims[0], (int, np.integer)); ). def is_vectorized_oper(dims):; return (; isinstance(dims, list) and; isinstance(dims[0], list); ). def type_from_dims(dims, enforce_square=False):; bra_like, ket_like = map(is_scalar, dims). if bra_like:; if is_vector(dims[1]):; return 'bra'; elif is_vectorized_oper(dims[1]):; return 'operator-bra'. if ket_like:; if is_vector(dims[0]):; return 'ket'; elif is_vectorized_oper(dims[0]):; return 'operator-ket'. elif is_vector(dims[0]) and (dims[0] == dims[1] or not enforce_square):; return 'oper'. elif (; is_vectorized_oper(dims[0]) and; (; (; dims[0] == dims[1] and; dims[0][0] == dims[1][0]; ) or not enforce_square; ); ):; return 'super'. return 'other'. [docs]def flatten(l):; """"""Flattens a list of lists to the first level. Given a list containing a mix of scalars and lists,; flattens down to a list of the scalars within the original; list. Examples; --------. >>> flatten([[[0], 1], 2]) # doctest: +SKIP; [0, 1, 2]. """"""; if not isinstance(l, list):; return [l]; else:; return sum(map(flatten, l), []). [docs]def deep_remove(l, *what):; """"""Removes scalars from all levels of a nested list. Given a list containing a mix of scalars and lists,; returns a list of the same structure, but where one or; more scalars have been removed. Examples; --------. >>> deep_remove([[[[0, 1, 2]], [3, 4], [5], [6, 7]]], 0, 5) # doctest: +SKIP; [[[[1, 2]], [3, 4], [], [6, 7]]]. """"""; if isinstance(l, list):; # Make a shallow copy at this level.; l = l[:]; for to_remove in what:; if to_remove in l:; l.remove(to_remove); else:; l = list(map(lambda elem: deep_remove(elem, to_remove), l)); return l. [docs]def unflatten(l, idxs):; """"""Unflattens a list by a given structure. Given a list of scalars and a deep list of indices; as produced by `flatten`, returns an ""unflattened""; form of the list. T",MatchSource.WIKI,docs/4.6/modules/qutip/dimensions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/dimensions.html
https://qutip.org/docs/4.6/modules/qutip/dimensions.html:11116,Deployability,update,updated,11116," We'll then rebuild indices using this permutation. if dims_type in ('operator-ket', 'super'):; # Swap the input and output spaces of the right part of; # perm.; perm[1] = list(reversed(perm[1])). if dims_type in ('operator-bra', 'super'):; # Ditto, but for the left indices.; perm[0] = list(reversed(perm[0])). return flatten(perm). [docs]def dims_to_tensor_shape(dims):; """"""; Given the dims of a Qobj instance, returns the shape of the; corresponding tensor. This helps, for instance, resolve the; column-stacking convention for superoperators. Parameters; ----------. dims : list; Dimensions specification for a Qobj. Returns; -------. tensor_shape : tuple; NumPy shape of the corresponding tensor.; """""". perm = dims_to_tensor_perm(dims); dims = flatten(dims). return tuple(map(partial(getitem, dims), perm)). [docs]def dims_idxs_to_tensor_idxs(dims, indices):; """"""; Given the dims of a Qobj instance, and some indices into; dims, returns the corresponding tensor indices. This helps; resolve, for instance, that column-stacking for superoperators,; oper-ket and oper-bra implies that the input and output tensor; indices are reversed from their order in dims. Parameters; ----------. dims : list; Dimensions specification for a Qobj. indices : int, list or tuple; Indices to convert to tensor indices. Can be specified; as a single index, or as a collection of indices.; In the latter case, this can be nested arbitrarily; deep. For instance, [0, [0, (2, 3)]]. Returns; -------. tens_indices : int, list or tuple; Container of the same structure as indices containing; the tensor indices for each element of indices.; """""". perm = dims_to_tensor_perm(dims); return deep_map(partial(getitem, perm), indices). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/dimensions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/dimensions.html
https://qutip.org/docs/4.6/modules/qutip/distributions.html:8127,Deployability,update,update,8127,"bes the marginal; distribution. """"""; return Distribution(data=self.data.mean(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs] def project(self, dim=0):; """"""; Calculate the projection (max value) distribution function along the; dimension `dim`. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; projected distribution. Returns; -------; d : Distributions; A new instances of Distribution that describes the projection. """"""; return Distribution(data=self.data.max(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs]class WignerDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = wigner(rho, self.xvecs[0], self.xvecs[1]). [docs]class QDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = qfunc(rho, self.xvecs[0], self.xvecs[1]). [docs]class TwoModeQuadratureCorrelation(Distribution):. def __init__(self, state=None, theta1=0.0, theta2=0.0,; extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$X_1(\theta_1)$', r'$X_2(\theta_2)$']. self.theta1 = theta1; self.theta2 = theta2. self.update(state). [docs] def update(self, state):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction",MatchSource.WIKI,docs/4.6/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/distributions.html
https://qutip.org/docs/4.6/modules/qutip/distributions.html:8144,Deployability,update,update,8144,"distribution. """"""; return Distribution(data=self.data.mean(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs] def project(self, dim=0):; """"""; Calculate the projection (max value) distribution function along the; dimension `dim`. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; projected distribution. Returns; -------; d : Distributions; A new instances of Distribution that describes the projection. """"""; return Distribution(data=self.data.max(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs]class WignerDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = wigner(rho, self.xvecs[0], self.xvecs[1]). [docs]class QDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = qfunc(rho, self.xvecs[0], self.xvecs[1]). [docs]class TwoModeQuadratureCorrelation(Distribution):. def __init__(self, state=None, theta1=0.0, theta2=0.0,; extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$X_1(\theta_1)$', r'$X_2(\theta_2)$']. self.theta1 = theta1; self.theta2 = theta2. self.update(state). [docs] def update(self, state):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix",MatchSource.WIKI,docs/4.6/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/distributions.html
https://qutip.org/docs/4.6/modules/qutip/distributions.html:8517,Deployability,update,update,8517,"int; The dimension (coordinate index) along which to obtain the; projected distribution. Returns; -------; d : Distributions; A new instances of Distribution that describes the projection. """"""; return Distribution(data=self.data.max(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs]class WignerDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = wigner(rho, self.xvecs[0], self.xvecs[1]). [docs]class QDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = qfunc(rho, self.xvecs[0], self.xvecs[1]). [docs]class TwoModeQuadratureCorrelation(Distribution):. def __init__(self, state=None, theta1=0.0, theta2=0.0,; extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$X_1(\theta_1)$', r'$X_2(\theta_2)$']. self.theta1 = theta1; self.theta2 = theta2. self.update(state). [docs] def update(self, state):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix; """"""; if isket(state):; self.update_psi(state); else:; self.update_rho(state). [docs] def update_psi(self, psi):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction; """""". X1, X2 = np.meshgrid(self.xvecs[0], self.xvecs[1]). p = np.zeros((len(self.xvecs[0]), len(self.xvecs[1])), dtype=complex); N = psi.dims[0][0]. f",MatchSource.WIKI,docs/4.6/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/distributions.html
https://qutip.org/docs/4.6/modules/qutip/distributions.html:8534,Deployability,update,update,8534," (coordinate index) along which to obtain the; projected distribution. Returns; -------; d : Distributions; A new instances of Distribution that describes the projection. """"""; return Distribution(data=self.data.max(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs]class WignerDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = wigner(rho, self.xvecs[0], self.xvecs[1]). [docs]class QDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = qfunc(rho, self.xvecs[0], self.xvecs[1]). [docs]class TwoModeQuadratureCorrelation(Distribution):. def __init__(self, state=None, theta1=0.0, theta2=0.0,; extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$X_1(\theta_1)$', r'$X_2(\theta_2)$']. self.theta1 = theta1; self.theta2 = theta2. self.update(state). [docs] def update(self, state):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix; """"""; if isket(state):; self.update_psi(state); else:; self.update_rho(state). [docs] def update_psi(self, psi):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction; """""". X1, X2 = np.meshgrid(self.xvecs[0], self.xvecs[1]). p = np.zeros((len(self.xvecs[0]), len(self.xvecs[1])), dtype=complex); N = psi.dims[0][0]. for n1 in range(N):",MatchSource.WIKI,docs/4.6/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/distributions.html
https://qutip.org/docs/4.6/modules/qutip/distributions.html:8979,Deployability,update,update,8979,"[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = wigner(rho, self.xvecs[0], self.xvecs[1]). [docs]class QDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = qfunc(rho, self.xvecs[0], self.xvecs[1]). [docs]class TwoModeQuadratureCorrelation(Distribution):. def __init__(self, state=None, theta1=0.0, theta2=0.0,; extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$X_1(\theta_1)$', r'$X_2(\theta_2)$']. self.theta1 = theta1; self.theta2 = theta2. self.update(state). [docs] def update(self, state):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix; """"""; if isket(state):; self.update_psi(state); else:; self.update_rho(state). [docs] def update_psi(self, psi):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction; """""". X1, X2 = np.meshgrid(self.xvecs[0], self.xvecs[1]). p = np.zeros((len(self.xvecs[0]), len(self.xvecs[1])), dtype=complex); N = psi.dims[0][0]. for n1 in range(N):; kn1 = exp(-1j * self.theta1 * n1) / \; sqrt(sqrt(pi) * 2 ** n1 * factorial(n1)) * \; exp(-X1 ** 2 / 2.0) * np.polyval(hermite(n1), X1). for n2 in range(N):; kn2 = exp(-1j * self.theta2 * n2) / \; sqrt(sqrt(pi) * 2 ** n2 * factorial(n2)) * \; exp(-X2 ** 2 / 2.0) * np.polyval(hermite(n2), X2); i = state_number_index([N, N], [n1, n2]); p += kn1 * kn2 * psi.data[i, 0]. self.data = abs(p) ** 2. [docs] def update_rho(self, rho):; """"""; calculate ",MatchSource.WIKI,docs/4.6/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/distributions.html
https://qutip.org/docs/4.6/modules/qutip/distributions.html:9005,Deployability,update,update,9005,"', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = wigner(rho, self.xvecs[0], self.xvecs[1]). [docs]class QDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = qfunc(rho, self.xvecs[0], self.xvecs[1]). [docs]class TwoModeQuadratureCorrelation(Distribution):. def __init__(self, state=None, theta1=0.0, theta2=0.0,; extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$X_1(\theta_1)$', r'$X_2(\theta_2)$']. self.theta1 = theta1; self.theta2 = theta2. self.update(state). [docs] def update(self, state):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix; """"""; if isket(state):; self.update_psi(state); else:; self.update_rho(state). [docs] def update_psi(self, psi):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction; """""". X1, X2 = np.meshgrid(self.xvecs[0], self.xvecs[1]). p = np.zeros((len(self.xvecs[0]), len(self.xvecs[1])), dtype=complex); N = psi.dims[0][0]. for n1 in range(N):; kn1 = exp(-1j * self.theta1 * n1) / \; sqrt(sqrt(pi) * 2 ** n1 * factorial(n1)) * \; exp(-X1 ** 2 / 2.0) * np.polyval(hermite(n1), X1). for n2 in range(N):; kn2 = exp(-1j * self.theta2 * n2) / \; sqrt(sqrt(pi) * 2 ** n2 * factorial(n2)) * \; exp(-X2 ** 2 / 2.0) * np.polyval(hermite(n2), X2); i = state_number_index([N, N], [n1, n2]); p += kn1 * kn2 * psi.data[i, 0]. self.data = abs(p) ** 2. [docs] def update_rho(self, rho):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix; """""". X",MatchSource.WIKI,docs/4.6/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/distributions.html
https://qutip.org/docs/4.6/modules/qutip/distributions.html:11269,Deployability,update,update,11269,"(self.xvecs[1])), dtype=complex); M2 = np.zeros(; (N, N, len(self.xvecs[0]), len(self.xvecs[1])), dtype=complex). for m in range(N):; for n in range(N):; M1[m, n] = exp(-1j * self.theta1 * (m - n)) / \; sqrt(pi * 2 ** (m + n) * factorial(n) * factorial(m)) * \; exp(-X1 ** 2) * np.polyval(; hermite(m), X1) * np.polyval(hermite(n), X1); M2[m, n] = exp(-1j * self.theta2 * (m - n)) / \; sqrt(pi * 2 ** (m + n) * factorial(n) * factorial(m)) * \; exp(-X2 ** 2) * np.polyval(; hermite(m), X2) * np.polyval(hermite(n), X2). for n1 in range(N):; for n2 in range(N):; i = state_number_index([N, N], [n1, n2]); for p1 in range(N):; for p2 in range(N):; j = state_number_index([N, N], [p1, p2]); p += M1[n1, p1] * M2[n2, p2] * rho.data[i, j]. self.data = p. [docs]class HarmonicOscillatorWaveFunction(Distribution):. def __init__(self, psi=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if psi:; self.update(psi). [docs] def update(self, psi):; """"""; Calculate the wavefunction for the given state of an harmonic; oscillator; """""". self.data = np.zeros(len(self.xvecs[0]), dtype=complex); N = psi.shape[0]. for n in range(N):; k = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += k * psi.data[n, 0]. [docs]class HarmonicOscillatorProbabilityFunction(Distribution):. def __init__(self, rho=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if rho:; self.update(rho). [docs] def update(self, rho):; """"""; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix); """""". if isket(rho):; rho = ket2dm(rho). self.data = np.zeros(len(self.xvecs[0]), dtype=complex); M, N = rho.shape. for m in range(M):; k_m = pow(self.omega / pi, 0.25) / \; sqrt(2 ** m * factorial(m)) *",MatchSource.WIKI,docs/4.6/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/distributions.html
https://qutip.org/docs/4.6/modules/qutip/distributions.html:11293,Deployability,update,update,11293,"f.xvecs[0]), len(self.xvecs[1])), dtype=complex). for m in range(N):; for n in range(N):; M1[m, n] = exp(-1j * self.theta1 * (m - n)) / \; sqrt(pi * 2 ** (m + n) * factorial(n) * factorial(m)) * \; exp(-X1 ** 2) * np.polyval(; hermite(m), X1) * np.polyval(hermite(n), X1); M2[m, n] = exp(-1j * self.theta2 * (m - n)) / \; sqrt(pi * 2 ** (m + n) * factorial(n) * factorial(m)) * \; exp(-X2 ** 2) * np.polyval(; hermite(m), X2) * np.polyval(hermite(n), X2). for n1 in range(N):; for n2 in range(N):; i = state_number_index([N, N], [n1, n2]); for p1 in range(N):; for p2 in range(N):; j = state_number_index([N, N], [p1, p2]); p += M1[n1, p1] * M2[n2, p2] * rho.data[i, j]. self.data = p. [docs]class HarmonicOscillatorWaveFunction(Distribution):. def __init__(self, psi=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if psi:; self.update(psi). [docs] def update(self, psi):; """"""; Calculate the wavefunction for the given state of an harmonic; oscillator; """""". self.data = np.zeros(len(self.xvecs[0]), dtype=complex); N = psi.shape[0]. for n in range(N):; k = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += k * psi.data[n, 0]. [docs]class HarmonicOscillatorProbabilityFunction(Distribution):. def __init__(self, rho=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if rho:; self.update(rho). [docs] def update(self, rho):; """"""; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix); """""". if isket(rho):; rho = ket2dm(rho). self.data = np.zeros(len(self.xvecs[0]), dtype=complex); M, N = rho.shape. for m in range(M):; k_m = pow(self.omega / pi, 0.25) / \; sqrt(2 ** m * factorial(m)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(m), s",MatchSource.WIKI,docs/4.6/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/distributions.html
https://qutip.org/docs/4.6/modules/qutip/distributions.html:11921,Deployability,update,update,11921,"N], [n1, n2]); for p1 in range(N):; for p2 in range(N):; j = state_number_index([N, N], [p1, p2]); p += M1[n1, p1] * M2[n2, p2] * rho.data[i, j]. self.data = p. [docs]class HarmonicOscillatorWaveFunction(Distribution):. def __init__(self, psi=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if psi:; self.update(psi). [docs] def update(self, psi):; """"""; Calculate the wavefunction for the given state of an harmonic; oscillator; """""". self.data = np.zeros(len(self.xvecs[0]), dtype=complex); N = psi.shape[0]. for n in range(N):; k = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += k * psi.data[n, 0]. [docs]class HarmonicOscillatorProbabilityFunction(Distribution):. def __init__(self, rho=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if rho:; self.update(rho). [docs] def update(self, rho):; """"""; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix); """""". if isket(rho):; rho = ket2dm(rho). self.data = np.zeros(len(self.xvecs[0]), dtype=complex); M, N = rho.shape. for m in range(M):; k_m = pow(self.omega / pi, 0.25) / \; sqrt(2 ** m * factorial(m)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(m), self.xvecs[0]). for n in range(N):; k_n = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += np.conjugate(k_n) * k_m * rho.data[m, n]. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/distributions.html
https://qutip.org/docs/4.6/modules/qutip/distributions.html:11945,Deployability,update,update,11945,"N], [n1, n2]); for p1 in range(N):; for p2 in range(N):; j = state_number_index([N, N], [p1, p2]); p += M1[n1, p1] * M2[n2, p2] * rho.data[i, j]. self.data = p. [docs]class HarmonicOscillatorWaveFunction(Distribution):. def __init__(self, psi=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if psi:; self.update(psi). [docs] def update(self, psi):; """"""; Calculate the wavefunction for the given state of an harmonic; oscillator; """""". self.data = np.zeros(len(self.xvecs[0]), dtype=complex); N = psi.shape[0]. for n in range(N):; k = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += k * psi.data[n, 0]. [docs]class HarmonicOscillatorProbabilityFunction(Distribution):. def __init__(self, rho=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if rho:; self.update(rho). [docs] def update(self, rho):; """"""; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix); """""". if isket(rho):; rho = ket2dm(rho). self.data = np.zeros(len(self.xvecs[0]), dtype=complex); M, N = rho.shape. for m in range(M):; k_m = pow(self.omega / pi, 0.25) / \; sqrt(2 ** m * factorial(m)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(m), self.xvecs[0]). for n in range(N):; k_n = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += np.conjugate(k_n) * k_m * rho.data[m, n]. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/distributions.html
https://qutip.org/docs/4.6/modules/qutip/distributions.html:12763,Deployability,update,updated,12763,"N], [n1, n2]); for p1 in range(N):; for p2 in range(N):; j = state_number_index([N, N], [p1, p2]); p += M1[n1, p1] * M2[n2, p2] * rho.data[i, j]. self.data = p. [docs]class HarmonicOscillatorWaveFunction(Distribution):. def __init__(self, psi=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if psi:; self.update(psi). [docs] def update(self, psi):; """"""; Calculate the wavefunction for the given state of an harmonic; oscillator; """""". self.data = np.zeros(len(self.xvecs[0]), dtype=complex); N = psi.shape[0]. for n in range(N):; k = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += k * psi.data[n, 0]. [docs]class HarmonicOscillatorProbabilityFunction(Distribution):. def __init__(self, rho=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if rho:; self.update(rho). [docs] def update(self, rho):; """"""; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix); """""". if isket(rho):; rho = ket2dm(rho). self.data = np.zeros(len(self.xvecs[0]), dtype=complex); M, N = rho.shape. for m in range(M):; k_m = pow(self.omega / pi, 0.25) / \; sqrt(2 ** m * factorial(m)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(m), self.xvecs[0]). for n in range(N):; k_n = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += np.conjugate(k_n) * k_m * rho.data[m, n]. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/distributions.html
https://qutip.org/docs/4.6/modules/qutip/distributions.html:6896,Energy Efficiency,reduce,reduced,6896,"igsize); ax = Axes3D(fig, azim=-62, elev=25). if cmap is None:; cmap = mpl.cm.get_cmap('RdBu'). lim = abs(self.data).max(). X, Y = np.meshgrid(self.xvecs[0], self.xvecs[1]); s = ax.plot_surface(X, Y, self.data,; norm=mpl.colors.Normalize(-lim, lim),; rstride=5, cstride=5, cmap=cmap, lw=0.1). if show_xlabel:; ax.set_xlabel(self.xlabels[0], fontsize=12); if show_ylabel:; ax.set_ylabel(self.xlabels[1], fontsize=12). if colorbar:; cb = fig.colorbar(s, ax=ax, shrink=0.5). return fig, ax. def visualize_1d(self, fig=None, ax=None, figsize=(8, 6),; show_xlabel=True, show_ylabel=True):. if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). p = ax.plot(self.xvecs[0], self.data). if show_xlabel:; ax.set_xlabel(self.xlabels[0], fontsize=12); if show_ylabel:; ax.set_ylabel(""Marginal distribution"", fontsize=12). return fig, ax. [docs] def marginal(self, dim=0):; """"""; Calculate the marginal distribution function along the dimension; `dim`. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; marginal distribution. Returns; -------. d : Distributions; A new instances of Distribution that describes the marginal; distribution. """"""; return Distribution(data=self.data.mean(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs] def project(self, dim=0):; """"""; Calculate the projection (max value) distribution function along the; dimension `dim`. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; projected distribution. Returns; -------; d : Distributions; A new instances of Distribution that describes the projection. """"""; return Distribution(data=self.data.max(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs]class WignerDistribution(Distribution):. def __init__(self,",MatchSource.WIKI,docs/4.6/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/distributions.html
https://qutip.org/docs/4.6/modules/qutip/distributions.html:7456,Energy Efficiency,reduce,reduced-dimensionality,7456,"=True, show_ylabel=True):. if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). p = ax.plot(self.xvecs[0], self.data). if show_xlabel:; ax.set_xlabel(self.xlabels[0], fontsize=12); if show_ylabel:; ax.set_ylabel(""Marginal distribution"", fontsize=12). return fig, ax. [docs] def marginal(self, dim=0):; """"""; Calculate the marginal distribution function along the dimension; `dim`. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; marginal distribution. Returns; -------. d : Distributions; A new instances of Distribution that describes the marginal; distribution. """"""; return Distribution(data=self.data.mean(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs] def project(self, dim=0):; """"""; Calculate the projection (max value) distribution function along the; dimension `dim`. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; projected distribution. Returns; -------; d : Distributions; A new instances of Distribution that describes the projection. """"""; return Distribution(data=self.data.max(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs]class WignerDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = wigner(rho, self.xvecs[0], self.xvecs[1]). [docs]class QDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.x",MatchSource.WIKI,docs/4.6/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/distributions.html
https://qutip.org/docs/4.6/modules/qutip/distributions.html:3846,Integrability,depend,depending,3846,"cs]class Distribution:; """"""A class for representation spatial distribution functions. The Distribution class can be used to prepresent spatial distribution; functions of arbitray dimension (although only 1D and 2D distributions; are used so far). It is indented as a base class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters; ----------; data : array_like; Data for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs.; xvecs : list; List of arrays that spans the space for each coordinate.; xlabels : list; List of labels for each coordinate. """""". def __init__(self, data=None, xvecs=[], xlabels=[]):; self.data = data; self.xvecs = xvecs; self.xlabels = xlabels. [docs] def visualize(self, fig=None, ax=None, figsize=(8, 6),; colorbar=True, cmap=None, style=""colormap"",; show_xlabel=True, show_ylabel=True):; """"""; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution. Parameters:. fig : matplotlib Figure instance; If given, use this figure instance for the visualization,. ax : matplotlib Axes instance; If given, render the visualization using this axis instance. figsize : tuple; Size of the new Figure instance, if one needs to be created. colorbar: Bool; Whether or not the colorbar (in 2D visualization) should be used. cmap: matplotlib colormap instance; If given, use this colormap for 2D visualizations. style : string; Type of visualization: 'colormap' (default) or 'surface'. Returns; -------. fig, ax : tuple; A tuple of matplotlib figure and axes instances. """"""; n = len(self.xvecs); if n == 2:; if style == ""colormap"":; return self.visualize_2d_colormap(fig=fig, ax=ax,; figsize=figsize,; colorbar=colorbar,; cmap=cmap,; show_xlabel=show_xlabel,; show_ylabel=show_ylabel); else:; return self.visualize_2d_surface(fig=fi",MatchSource.WIKI,docs/4.6/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/distributions.html
https://qutip.org/docs/4.6/modules/qutip/entropy.html:5018,Availability,mask,mask,5018,"ho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def negativity(rho, subsys, method='tracenorm', logarithmic=False):; """"""; Compute the negativity for a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters; ----------; rho : qobj; Density matrix for composite quantum systems; selA : int/list; `int` or `list` of first selected density matrix components.; selB : int/list; `int` or `list` of second selected density matrix components.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_mut : float; Mutual information between selected components. """"""; if isinstance(selA, int):; selA = [selA]; if isinstance(selB",MatchSource.WIKI,docs/4.6/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html
https://qutip.org/docs/4.6/modules/qutip/entropy.html:5111,Availability,mask,mask,5111,"st be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def negativity(rho, subsys, method='tracenorm', logarithmic=False):; """"""; Compute the negativity for a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters; ----------; rho : qobj; Density matrix for composite quantum systems; selA : int/list; `int` or `list` of first selected density matrix components.; selB : int/list; `int` or `list` of second selected density matrix components.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_mut : float; Mutual information between selected components. """"""; if isinstance(selA, int):; selA = [selA]; if isinstance(selB, int):; selB = [selB]; if rho.type != 'oper':; raise",MatchSource.WIKI,docs/4.6/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html
https://qutip.org/docs/4.6/modules/qutip/entropy.html:11653,Deployability,update,updated,11653," sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effective number of states for a density matrix. The participation is unity for pure states, and maximally N,; where N is the Hilbert space dimensionality, for completely; mixed states. Parameters; ----------; rho : qobj; Density matrix. Returns; -------; pr : float; Effective number of states in the density matrix. """"""; if rho.type == 'ket' or rho.type == 'bra':; return 1.0; else:; return 1.0 / (rho ** 2).tr(). def entangling_power(U):; """"""; Calculate the entangling power of a two-qubit gate U, which; is zero of nonentangling gates and 1 and 2/9 for maximally; entangling gates. Parameters; ----------; U : qobj; Qobj instance representing a two-qubit gate. Returns; -------; ep : float; The entanglement power of U (real number between 0 and 1). References:. Explorations in Quantum Computing, Colin P. Williams (Springer, 2011); """""". if not U.isoper:; raise Exception(""U must be an operator.""). if U.dims != [[2, 2], [2, 2]]:; raise Exception(""U must be a two-qubit gate.""). from qutip.qip.operations.gates import swap; a = (tensor(U, U).dag() * swap(N=4, targets=[1, 3]) *; tensor(U, U) * swap(N=4, targets=[1, 3])); b = (tensor(swap() * U, swap() * U).dag() * swap(N=4, targets=[1, 3]) *; tensor(swap() * U, swap() * U) * swap(N=4, targets=[1, 3])). return 5.0/9 - 1.0/36 * (a.tr() + b.tr()).real. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html
https://qutip.org/docs/4.6/modules/qutip/entropy.html:10628,Energy Efficiency,power,power,10628,"ject; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effective number of states for a density matrix. The participation is unity for pure states, and maximally N,; where N is the Hilbert space dimensionality, for completely; mixed states. Parameters; ----------; rho : qobj; Density matrix. Returns; -------; pr : float; Effective number of states in the density matrix. """"""; if rho.type == 'ket' or rho.type == 'bra':; return 1.0; else:; return 1.0 / (rho ** 2).tr(). def entangling_power(U):; """"""; Calculate the entangling power of a two-qubit gate U, which; is zero of nonentangling gates and 1 and 2/9 for maximally; entangling gates. Parameters; ----------; U : qobj; Qobj instance representing a two-qubit gate. Returns; -------; ep : float; The entanglement power of U (real number between 0 and 1). References:. Explorations in Quantum Computing, Colin P. Williams (Springer, 2011); """""". if not U.isoper:; raise Exception(""U must be an operator.""). if U.dims != [[2, 2], [2, 2]]:; raise Exception(""U must be a two-qubit gate.""). from qutip.qip.operations.gates import swap; a = (tensor(U, U).dag() * swap(N=4, targets=[1, 3]) *; tensor(U, U) * swap(N=4, targets=[1, 3])); b = (tensor(swap() * U, swap() * U).dag() * swap(N=4, targets=[1, 3]) *; tensor(swap() * U, swap() * U) * swap(N=4, targets=[1, 3])). return 5.0/9 - 1.0/36 * (a.tr() + b.tr()).real. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last upd",MatchSource.WIKI,docs/4.6/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html
https://qutip.org/docs/4.6/modules/qutip/entropy.html:10868,Energy Efficiency,power,power,10868," sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effective number of states for a density matrix. The participation is unity for pure states, and maximally N,; where N is the Hilbert space dimensionality, for completely; mixed states. Parameters; ----------; rho : qobj; Density matrix. Returns; -------; pr : float; Effective number of states in the density matrix. """"""; if rho.type == 'ket' or rho.type == 'bra':; return 1.0; else:; return 1.0 / (rho ** 2).tr(). def entangling_power(U):; """"""; Calculate the entangling power of a two-qubit gate U, which; is zero of nonentangling gates and 1 and 2/9 for maximally; entangling gates. Parameters; ----------; U : qobj; Qobj instance representing a two-qubit gate. Returns; -------; ep : float; The entanglement power of U (real number between 0 and 1). References:. Explorations in Quantum Computing, Colin P. Williams (Springer, 2011); """""". if not U.isoper:; raise Exception(""U must be an operator.""). if U.dims != [[2, 2], [2, 2]]:; raise Exception(""U must be a two-qubit gate.""). from qutip.qip.operations.gates import swap; a = (tensor(U, U).dag() * swap(N=4, targets=[1, 3]) *; tensor(U, U) * swap(N=4, targets=[1, 3])); b = (tensor(swap() * U, swap() * U).dag() * swap(N=4, targets=[1, 3]) *; tensor(swap() * U, swap() * U) * swap(N=4, targets=[1, 3])). return 5.0/9 - 1.0/36 * (a.tr() + b.tr()).real. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html
https://qutip.org/docs/4.6/modules/qutip/entropy.html:2158,Performance,concurren,concurrence,2158,"tware without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['entropy_vn', 'entropy_linear', 'entropy_mutual', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power',; 'entropy_relative']. from numpy import conj, e, inf, imag, inner, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == ",MatchSource.WIKI,docs/4.6/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html
https://qutip.org/docs/4.6/modules/qutip/entropy.html:3693,Performance,concurren,concurrence,3693,"garithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def nega",MatchSource.WIKI,docs/4.6/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html
https://qutip.org/docs/4.6/modules/qutip/entropy.html:3731,Performance,concurren,concurrence,3731,"garithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def nega",MatchSource.WIKI,docs/4.6/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html
https://qutip.org/docs/4.6/modules/qutip/entropy.html:4541,Safety,avoid,avoid,4541,"rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def negativity(rho, subsys, method='tracenorm', logarithmic=False):; """"""; Compute the negativity for a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters;",MatchSource.WIKI,docs/4.6/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html
https://qutip.org/docs/4.6/modules/qutip/entropy.html:7056,Safety,detect,detect,7056,"ho.type != 'oper':; raise TypeError(""Input must be a density matrix.""); if (len(selA) + len(selB)) != len(rho.dims[0]):; raise TypeError(""Number of selected components must match "" +; ""total number.""). rhoA = ptrace(rho, selA); rhoB = ptrace(rho, selB); out = (entropy_vn(rhoA, base, sparse=sparse) +; entropy_vn(rhoB, base, sparse=sparse) -; entropy_vn(rho, base, sparse=sparse)); return out. [docs]def entropy_relative(rho, sigma, base=e, sparse=False, tol=1e-12):; """"""; Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters; ----------; rho : :class:`qutip.Qobj`; First density matrix (or ket which will be converted to a density; matrix).; sigma : :class:`qutip.Qobj`; Second density matrix (or ket which will be converted to a density; matrix).; base : {e,2}; Base of logarithm. Defaults to e.; sparse : bool; Flag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False.; tol : float; Tolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns; -------; rel_ent : float; Value of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. Examples; --------. First we define two density matrices:. >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. ``log2``); and base e (i.e. ``log``). >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. References; ----------. See Nielsen & Chuang, ""Quantum Computation and Quantum Information"",; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; """"""; if rho.isket:; rho = ket2dm(rho); if sigma.isket:; sigma = ket2dm(sigma); if not rho.isoper or not sigma.isoper:; raise TypeError(""Inputs must be density matrices.""); if rho.dims != sigma.dims:; raise ValueE",MatchSource.WIKI,docs/4.6/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html
https://qutip.org/docs/4.6/modules/qutip/entropy.html:9355,Safety,avoid,avoid,9355," e:; log_base = log; else:; raise ValueError(""Base must be 2 or e.""); # S(rho || sigma) = sum_i(p_i log p_i) - sum_ij(p_i P_ij log q_i); #; # S is +inf if the kernel of sigma (i.e. svecs[svals == 0]) has non-trivial; # intersection with the support of rho (i.e. rvecs[rvals != 0]).; rvals, rvecs = sp_eigs(rho.data, rho.isherm, vecs=True, sparse=sparse); if any(abs(imag(rvals)) >= tol):; raise ValueError(""Input rho has non-real eigenvalues.""); rvals = real(rvals); svals, svecs = sp_eigs(sigma.data, sigma.isherm, vecs=True, sparse=sparse); if any(abs(imag(svals)) >= tol):; raise ValueError(""Input sigma has non-real eigenvalues.""); svals = real(svals); # Calculate inner products of eigenvectors and return +inf if kernel; # of sigma overlaps with support of rho.; P = abs(inner(rvecs, conj(svecs))) ** 2; if (rvals >= tol) @ (P >= tol) @ (svals < tol):; return inf; # Avoid -inf from log(0) -- these terms will be multiplied by zero later; # anyway; svals[abs(svals) < tol] = 1; nzrvals = rvals[abs(rvals) >= tol]; # Calculate S; S = nzrvals @ log_base(nzrvals) - rvals @ P @ log_base(svals); # the relative entropy is guaranteed to be >= 0, so we clamp the; # calculated value to 0 to avoid small violations of the lower bound.; return max(0, S). [docs]def entropy_conditional(rho, selB, base=e, sparse=False):; """"""; Calculates the conditional entropy :math:`S(A|B)=S(A,B)-S(B)`; of a selected density matrix component. Parameters; ----------; rho : qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effectiv",MatchSource.WIKI,docs/4.6/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html
https://qutip.org/docs/4.6/modules/qutip/entropy.html:2330,Testability,log,log,2330,"CLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['entropy_vn', 'entropy_linear', 'entropy_mutual', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power',; 'entropy_relative']. from numpy import conj, e, inf, imag, inner, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a",MatchSource.WIKI,docs/4.6/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html
https://qutip.org/docs/4.6/modules/qutip/entropy.html:2732,Testability,log,logarithm,2732,"FITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['entropy_vn', 'entropy_linear', 'entropy_mutual', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power',; 'entropy_relative']. from numpy import conj, e, inf, imag, inner, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculat",MatchSource.WIKI,docs/4.6/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html
https://qutip.org/docs/4.6/modules/qutip/entropy.html:3121,Testability,log,logvals,3121,"al', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power',; 'entropy_relative']. from numpy import conj, e, inf, imag, inner, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif r",MatchSource.WIKI,docs/4.6/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html
https://qutip.org/docs/4.6/modules/qutip/entropy.html:3162,Testability,log,logvals,3162,"al', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power',; 'entropy_relative']. from numpy import conj, e, inf, imag, inner, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif r",MatchSource.WIKI,docs/4.6/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html
https://qutip.org/docs/4.6/modules/qutip/entropy.html:3172,Testability,log,log,3172,"al', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power',; 'entropy_relative']. from numpy import conj, e, inf, imag, inner, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif r",MatchSource.WIKI,docs/4.6/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html
https://qutip.org/docs/4.6/modules/qutip/entropy.html:3266,Testability,log,logvals,3266,"t conj, e, inf, imag, inner, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.is",MatchSource.WIKI,docs/4.6/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html
https://qutip.org/docs/4.6/modules/qutip/entropy.html:4774,Testability,log,logarithmic,4774,"; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def negativity(rho, subsys, method='tracenorm', logarithmic=False):; """"""; Compute the negativity for a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters; ----------; rho : qobj; Density matrix for composite quantum systems; selA : int/list; `int` or `list` of first selected density matrix components.; selB : int/list; `int` or `list` of second selected density matrix components.;",MatchSource.WIKI,docs/4.6/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html
https://qutip.org/docs/4.6/modules/qutip/entropy.html:5345,Testability,log,logarithmic,5345,"rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def negativity(rho, subsys, method='tracenorm', logarithmic=False):; """"""; Compute the negativity for a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters; ----------; rho : qobj; Density matrix for composite quantum systems; selA : int/list; `int` or `list` of first selected density matrix components.; selB : int/list; `int` or `list` of second selected density matrix components.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_mut : float; Mutual information between selected components. """"""; if isinstance(selA, int):; selA = [selA]; if isinstance(selB, int):; selB = [selB]; if rho.type != 'oper':; raise TypeError(""Input must be a density matrix.""); if (len(selA) + len(selB)) != len(rho.dims[0]):; raise TypeError(""Number of selected components must match "" +; ""total number.""). rhoA = ptrace(rho, selA); rhoB = ptrace(rho, selB); out = (entropy_vn(rhoA, base, sparse=sparse) +; ",MatchSource.WIKI,docs/4.6/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html
https://qutip.org/docs/4.6/modules/qutip/entropy.html:5833,Testability,log,logarithm,5833," a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters; ----------; rho : qobj; Density matrix for composite quantum systems; selA : int/list; `int` or `list` of first selected density matrix components.; selB : int/list; `int` or `list` of second selected density matrix components.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_mut : float; Mutual information between selected components. """"""; if isinstance(selA, int):; selA = [selA]; if isinstance(selB, int):; selB = [selB]; if rho.type != 'oper':; raise TypeError(""Input must be a density matrix.""); if (len(selA) + len(selB)) != len(rho.dims[0]):; raise TypeError(""Number of selected components must match "" +; ""total number.""). rhoA = ptrace(rho, selA); rhoB = ptrace(rho, selB); out = (entropy_vn(rhoA, base, sparse=sparse) +; entropy_vn(rhoB, base, sparse=sparse) -; entropy_vn(rho, base, sparse=sparse)); return out. [docs]def entropy_relative(rho, sigma, base=e, sparse=False, tol=1e-12):; """"""; Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters; ----------; rho : :class:`qutip.Qobj`; First density matrix (or ket which will be converted to a density; matrix).; sigma : :class:`qutip.Qobj`; Second density matrix (or ket which will be convert",MatchSource.WIKI,docs/4.6/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html
https://qutip.org/docs/4.6/modules/qutip/entropy.html:6875,Testability,log,logarithm,6875,"Use sparse eigensolver. Returns; -------; ent_mut : float; Mutual information between selected components. """"""; if isinstance(selA, int):; selA = [selA]; if isinstance(selB, int):; selB = [selB]; if rho.type != 'oper':; raise TypeError(""Input must be a density matrix.""); if (len(selA) + len(selB)) != len(rho.dims[0]):; raise TypeError(""Number of selected components must match "" +; ""total number.""). rhoA = ptrace(rho, selA); rhoB = ptrace(rho, selB); out = (entropy_vn(rhoA, base, sparse=sparse) +; entropy_vn(rhoB, base, sparse=sparse) -; entropy_vn(rho, base, sparse=sparse)); return out. [docs]def entropy_relative(rho, sigma, base=e, sparse=False, tol=1e-12):; """"""; Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters; ----------; rho : :class:`qutip.Qobj`; First density matrix (or ket which will be converted to a density; matrix).; sigma : :class:`qutip.Qobj`; Second density matrix (or ket which will be converted to a density; matrix).; base : {e,2}; Base of logarithm. Defaults to e.; sparse : bool; Flag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False.; tol : float; Tolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns; -------; rel_ent : float; Value of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. Examples; --------. First we define two density matrices:. >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. ``log2``); and base e (i.e. ``log``). >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. References; ----------. See Nielsen & Chuang, ""Quantum Computation and Quantum Information"",; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; """"""; if rho",MatchSource.WIKI,docs/4.6/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html
https://qutip.org/docs/4.6/modules/qutip/entropy.html:7560,Testability,log,log,7560,"ve entropy S(rho||sigma) between two density; matrices. Parameters; ----------; rho : :class:`qutip.Qobj`; First density matrix (or ket which will be converted to a density; matrix).; sigma : :class:`qutip.Qobj`; Second density matrix (or ket which will be converted to a density; matrix).; base : {e,2}; Base of logarithm. Defaults to e.; sparse : bool; Flag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False.; tol : float; Tolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns; -------; rel_ent : float; Value of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. Examples; --------. First we define two density matrices:. >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. ``log2``); and base e (i.e. ``log``). >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. References; ----------. See Nielsen & Chuang, ""Quantum Computation and Quantum Information"",; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; """"""; if rho.isket:; rho = ket2dm(rho); if sigma.isket:; sigma = ket2dm(sigma); if not rho.isoper or not sigma.isoper:; raise TypeError(""Inputs must be density matrices.""); if rho.dims != sigma.dims:; raise ValueError(""Inputs must have the same shape and dims.""); if base == 2:; log_base = log2; elif base == e:; log_base = log; else:; raise ValueError(""Base must be 2 or e.""); # S(rho || sigma) = sum_i(p_i log p_i) - sum_ij(p_i P_ij log q_i); #; # S is +inf if the kernel of sigma (i.e. svecs[svals == 0]) has non-trivial; # intersection with the support of rho (i.e. rvecs[rvals != 0]).; rvals, rvecs = sp_eigs(rho.data, rho.isherm, vecs=True, sparse=sparse); if any(abs(imag(rvals)) >= tol):; raise Val",MatchSource.WIKI,docs/4.6/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html
https://qutip.org/docs/4.6/modules/qutip/entropy.html:8180,Testability,log,log,8180,"lue of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. Examples; --------. First we define two density matrices:. >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. ``log2``); and base e (i.e. ``log``). >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. References; ----------. See Nielsen & Chuang, ""Quantum Computation and Quantum Information"",; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; """"""; if rho.isket:; rho = ket2dm(rho); if sigma.isket:; sigma = ket2dm(sigma); if not rho.isoper or not sigma.isoper:; raise TypeError(""Inputs must be density matrices.""); if rho.dims != sigma.dims:; raise ValueError(""Inputs must have the same shape and dims.""); if base == 2:; log_base = log2; elif base == e:; log_base = log; else:; raise ValueError(""Base must be 2 or e.""); # S(rho || sigma) = sum_i(p_i log p_i) - sum_ij(p_i P_ij log q_i); #; # S is +inf if the kernel of sigma (i.e. svecs[svals == 0]) has non-trivial; # intersection with the support of rho (i.e. rvecs[rvals != 0]).; rvals, rvecs = sp_eigs(rho.data, rho.isherm, vecs=True, sparse=sparse); if any(abs(imag(rvals)) >= tol):; raise ValueError(""Input rho has non-real eigenvalues.""); rvals = real(rvals); svals, svecs = sp_eigs(sigma.data, sigma.isherm, vecs=True, sparse=sparse); if any(abs(imag(svals)) >= tol):; raise ValueError(""Input sigma has non-real eigenvalues.""); svals = real(svals); # Calculate inner products of eigenvectors and return +inf if kernel; # of sigma overlaps with support of rho.; P = abs(inner(rvecs, conj(svecs))) ** 2; if (rvals >= tol) @ (P >= tol) @ (svals < tol):; return inf; # Avoid -inf from log(0) -- these terms will be multiplied by zero later; # anyway; svals[abs(svals) < tol] = 1; nzrvals = rvals[abs(rvals",MatchSource.WIKI,docs/4.6/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html
https://qutip.org/docs/4.6/modules/qutip/entropy.html:8264,Testability,log,log,8264,"entical. Examples; --------. First we define two density matrices:. >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. ``log2``); and base e (i.e. ``log``). >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. References; ----------. See Nielsen & Chuang, ""Quantum Computation and Quantum Information"",; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; """"""; if rho.isket:; rho = ket2dm(rho); if sigma.isket:; sigma = ket2dm(sigma); if not rho.isoper or not sigma.isoper:; raise TypeError(""Inputs must be density matrices.""); if rho.dims != sigma.dims:; raise ValueError(""Inputs must have the same shape and dims.""); if base == 2:; log_base = log2; elif base == e:; log_base = log; else:; raise ValueError(""Base must be 2 or e.""); # S(rho || sigma) = sum_i(p_i log p_i) - sum_ij(p_i P_ij log q_i); #; # S is +inf if the kernel of sigma (i.e. svecs[svals == 0]) has non-trivial; # intersection with the support of rho (i.e. rvecs[rvals != 0]).; rvals, rvecs = sp_eigs(rho.data, rho.isherm, vecs=True, sparse=sparse); if any(abs(imag(rvals)) >= tol):; raise ValueError(""Input rho has non-real eigenvalues.""); rvals = real(rvals); svals, svecs = sp_eigs(sigma.data, sigma.isherm, vecs=True, sparse=sparse); if any(abs(imag(svals)) >= tol):; raise ValueError(""Input sigma has non-real eigenvalues.""); svals = real(svals); # Calculate inner products of eigenvectors and return +inf if kernel; # of sigma overlaps with support of rho.; P = abs(inner(rvecs, conj(svecs))) ** 2; if (rvals >= tol) @ (P >= tol) @ (svals < tol):; return inf; # Avoid -inf from log(0) -- these terms will be multiplied by zero later; # anyway; svals[abs(svals) < tol] = 1; nzrvals = rvals[abs(rvals) >= tol]; # Calculate S; S = nzrvals @ log_base(nzrvals) - rvals @ P @ log_base(svals); # the relative entropy i",MatchSource.WIKI,docs/4.6/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html
https://qutip.org/docs/4.6/modules/qutip/entropy.html:8291,Testability,log,log,8291,"entical. Examples; --------. First we define two density matrices:. >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. ``log2``); and base e (i.e. ``log``). >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. References; ----------. See Nielsen & Chuang, ""Quantum Computation and Quantum Information"",; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; """"""; if rho.isket:; rho = ket2dm(rho); if sigma.isket:; sigma = ket2dm(sigma); if not rho.isoper or not sigma.isoper:; raise TypeError(""Inputs must be density matrices.""); if rho.dims != sigma.dims:; raise ValueError(""Inputs must have the same shape and dims.""); if base == 2:; log_base = log2; elif base == e:; log_base = log; else:; raise ValueError(""Base must be 2 or e.""); # S(rho || sigma) = sum_i(p_i log p_i) - sum_ij(p_i P_ij log q_i); #; # S is +inf if the kernel of sigma (i.e. svecs[svals == 0]) has non-trivial; # intersection with the support of rho (i.e. rvecs[rvals != 0]).; rvals, rvecs = sp_eigs(rho.data, rho.isherm, vecs=True, sparse=sparse); if any(abs(imag(rvals)) >= tol):; raise ValueError(""Input rho has non-real eigenvalues.""); rvals = real(rvals); svals, svecs = sp_eigs(sigma.data, sigma.isherm, vecs=True, sparse=sparse); if any(abs(imag(svals)) >= tol):; raise ValueError(""Input sigma has non-real eigenvalues.""); svals = real(svals); # Calculate inner products of eigenvectors and return +inf if kernel; # of sigma overlaps with support of rho.; P = abs(inner(rvecs, conj(svecs))) ** 2; if (rvals >= tol) @ (P >= tol) @ (svals < tol):; return inf; # Avoid -inf from log(0) -- these terms will be multiplied by zero later; # anyway; svals[abs(svals) < tol] = 1; nzrvals = rvals[abs(rvals) >= tol]; # Calculate S; S = nzrvals @ log_base(nzrvals) - rvals @ P @ log_base(svals); # the relative entropy i",MatchSource.WIKI,docs/4.6/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html
https://qutip.org/docs/4.6/modules/qutip/entropy.html:9053,Testability,log,log,9053," e:; log_base = log; else:; raise ValueError(""Base must be 2 or e.""); # S(rho || sigma) = sum_i(p_i log p_i) - sum_ij(p_i P_ij log q_i); #; # S is +inf if the kernel of sigma (i.e. svecs[svals == 0]) has non-trivial; # intersection with the support of rho (i.e. rvecs[rvals != 0]).; rvals, rvecs = sp_eigs(rho.data, rho.isherm, vecs=True, sparse=sparse); if any(abs(imag(rvals)) >= tol):; raise ValueError(""Input rho has non-real eigenvalues.""); rvals = real(rvals); svals, svecs = sp_eigs(sigma.data, sigma.isherm, vecs=True, sparse=sparse); if any(abs(imag(svals)) >= tol):; raise ValueError(""Input sigma has non-real eigenvalues.""); svals = real(svals); # Calculate inner products of eigenvectors and return +inf if kernel; # of sigma overlaps with support of rho.; P = abs(inner(rvecs, conj(svecs))) ** 2; if (rvals >= tol) @ (P >= tol) @ (svals < tol):; return inf; # Avoid -inf from log(0) -- these terms will be multiplied by zero later; # anyway; svals[abs(svals) < tol] = 1; nzrvals = rvals[abs(rvals) >= tol]; # Calculate S; S = nzrvals @ log_base(nzrvals) - rvals @ P @ log_base(svals); # the relative entropy is guaranteed to be >= 0, so we clamp the; # calculated value to 0 to avoid small violations of the lower bound.; return max(0, S). [docs]def entropy_conditional(rho, selB, base=e, sparse=False):; """"""; Calculates the conditional entropy :math:`S(A|B)=S(A,B)-S(B)`; of a selected density matrix component. Parameters; ----------; rho : qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effectiv",MatchSource.WIKI,docs/4.6/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html
https://qutip.org/docs/4.6/modules/qutip/entropy.html:9743,Testability,log,logarithm,9743,".isherm, vecs=True, sparse=sparse); if any(abs(imag(svals)) >= tol):; raise ValueError(""Input sigma has non-real eigenvalues.""); svals = real(svals); # Calculate inner products of eigenvectors and return +inf if kernel; # of sigma overlaps with support of rho.; P = abs(inner(rvecs, conj(svecs))) ** 2; if (rvals >= tol) @ (P >= tol) @ (svals < tol):; return inf; # Avoid -inf from log(0) -- these terms will be multiplied by zero later; # anyway; svals[abs(svals) < tol] = 1; nzrvals = rvals[abs(rvals) >= tol]; # Calculate S; S = nzrvals @ log_base(nzrvals) - rvals @ P @ log_base(svals); # the relative entropy is guaranteed to be >= 0, so we clamp the; # calculated value to 0 to avoid small violations of the lower bound.; return max(0, S). [docs]def entropy_conditional(rho, selB, base=e, sparse=False):; """"""; Calculates the conditional entropy :math:`S(A|B)=S(A,B)-S(B)`; of a selected density matrix component. Parameters; ----------; rho : qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effective number of states for a density matrix. The participation is unity for pure states, and maximally N,; where N is the Hilbert space dimensionality, for completely; mixed states. Parameters; ----------; rho : qobj; Density matrix. Returns; -------; pr : float; Effective number of states in the density matrix. """"""; if rho.type == 'ket' or rho.type == 'bra':; return 1.0; else:; return 1.0 / (rho ** 2).tr(). def entangling_power(U):; """"""; Calculate the entangling power of a two-qubit gate U, which; is zero",MatchSource.WIKI,docs/4.6/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html
https://qutip.org/docs/4.6/modules/qutip/eseries.html:11329,Deployability,update,updated,11329,"x == -1:; # no matching rate, add it; unique_rates[ur_len] = self.rates[r_idx]; ampl_dict[ur_len] = [self.ampl[r_idx]]; ur_len = len(unique_rates); else:; # found matching rate, append amplitude to its list; ampl_dict[idx].append(self.ampl[r_idx]). # create new amplitude and rate list with only unique rates, and; # nonzero amplitudes; rates, ampl = [], []; for ur_key in unique_rates.keys():; total_ampl = sum(ampl_dict[ur_key]); if (isinstance(total_ampl, float) or; isinstance(total_ampl, complex)):; if abs(total_ampl) > ampl_tol:; rates.append(unique_rates[ur_key]); ampl.append(total_ampl); else:; if abs(total_ampl.full()).max() > ampl_tol:; rates.append(unique_rates[ur_key]); ampl.append(total_ampl); self.rates = np.array(rates); self.ampl = np.empty((len(ampl),), dtype=object); self.ampl[:] = ampl; return self. # -----------------------------------------------------------------------------; #; # wrapper functions for accessing the class methods (for compatibility with; # quantum optics toolbox); #; def esval(es, tlist):; """"""; Evaluates an exponential series at the times listed in ``tlist``. Parameters; ----------; tlist : ndarray; Times at which to evaluate exponential series. Returns; -------; val_list : ndarray; Values of exponential at times in ``tlist``. """"""; return es.value(tlist). def esspec(es, wlist):; """"""Evaluate the spectrum of an exponential series at frequencies; in ``wlist``. Parameters; ----------; wlist : array_like; Array/list of frequenies. Returns; -------; val_list : ndarray; Values of exponential series at frequencies in ``wlist``. """"""; return es.spec(wlist). def estidy(es, *args):; """"""; Returns a tidier version of exponential series.; """"""; return es.tidyup(). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/eseries.html
https://qutip.org/docs/4.6/modules/qutip/eseries.html:2320,Integrability,depend,dependent,2320,"AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['eseries', 'esval', 'esspec', 'estidy']. import numpy as np; import scipy.sparse as sp; from qutip.qobj import Qobj. import warnings. [docs]class eseries():; """"""; Class representation of an exponential-series expansion of; time-dependent quantum objects. .. deprecated:: 4.6.0; :obj:`~eseries` will be removed in QuTiP 5. Please use :obj:`~QobjEvo`; for general time-dependence. Attributes; ----------; ampl : ndarray; Array of amplitudes for exponential series.; rates : ndarray; Array of rates for exponential series.; dims : list; Dimensions of exponential series components; shape : list; Shape corresponding to exponential series components. Methods; -------; value(tlist); Evaluate an exponential series at the times listed in tlist; spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist.; tidyup(); Returns a tidier version of the exponential series. """"""; __array_priority__ = 101. def __init__(self, q=None, s=np.array([])):; warnings.warn(; ""eseries is to be removed in QuTiP 5.0,""; "" consider swapping to QobjEvo for general time dependence."",; DeprecationWarning, stacklevel=2,; ). if isinstance(s, (int, float, complex)):; s = np.array([s]). if q is No",MatchSource.WIKI,docs/4.6/modules/qutip/eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/eseries.html
https://qutip.org/docs/4.6/modules/qutip/eseries.html:2459,Integrability,depend,dependence,2459,"RPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['eseries', 'esval', 'esspec', 'estidy']. import numpy as np; import scipy.sparse as sp; from qutip.qobj import Qobj. import warnings. [docs]class eseries():; """"""; Class representation of an exponential-series expansion of; time-dependent quantum objects. .. deprecated:: 4.6.0; :obj:`~eseries` will be removed in QuTiP 5. Please use :obj:`~QobjEvo`; for general time-dependence. Attributes; ----------; ampl : ndarray; Array of amplitudes for exponential series.; rates : ndarray; Array of rates for exponential series.; dims : list; Dimensions of exponential series components; shape : list; Shape corresponding to exponential series components. Methods; -------; value(tlist); Evaluate an exponential series at the times listed in tlist; spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist.; tidyup(); Returns a tidier version of the exponential series. """"""; __array_priority__ = 101. def __init__(self, q=None, s=np.array([])):; warnings.warn(; ""eseries is to be removed in QuTiP 5.0,""; "" consider swapping to QobjEvo for general time dependence."",; DeprecationWarning, stacklevel=2,; ). if isinstance(s, (int, float, complex)):; s = np.array([s]). if q is None:; self.ampl = np.array([]); self.rates = np.array([]); self.dims = [[1, 1]]; self.shape = [1, 1]. elif (len(s) == 0):; if isinstance(q, eseries):; self.a",MatchSource.WIKI,docs/4.6/modules/qutip/eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/eseries.html
https://qutip.org/docs/4.6/modules/qutip/eseries.html:3162,Integrability,depend,dependence,3162,"umpy as np; import scipy.sparse as sp; from qutip.qobj import Qobj. import warnings. [docs]class eseries():; """"""; Class representation of an exponential-series expansion of; time-dependent quantum objects. .. deprecated:: 4.6.0; :obj:`~eseries` will be removed in QuTiP 5. Please use :obj:`~QobjEvo`; for general time-dependence. Attributes; ----------; ampl : ndarray; Array of amplitudes for exponential series.; rates : ndarray; Array of rates for exponential series.; dims : list; Dimensions of exponential series components; shape : list; Shape corresponding to exponential series components. Methods; -------; value(tlist); Evaluate an exponential series at the times listed in tlist; spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist.; tidyup(); Returns a tidier version of the exponential series. """"""; __array_priority__ = 101. def __init__(self, q=None, s=np.array([])):; warnings.warn(; ""eseries is to be removed in QuTiP 5.0,""; "" consider swapping to QobjEvo for general time dependence."",; DeprecationWarning, stacklevel=2,; ). if isinstance(s, (int, float, complex)):; s = np.array([s]). if q is None:; self.ampl = np.array([]); self.rates = np.array([]); self.dims = [[1, 1]]; self.shape = [1, 1]. elif (len(s) == 0):; if isinstance(q, eseries):; self.ampl = q.ampl; self.rates = q.rates; self.dims = q.dims; self.shape = q.shape; elif isinstance(q, (np.ndarray, list)):; num = len(q) # number of elements in q; if any([Qobj(x).shape != Qobj(q[0]).shape for x in q]):; raise TypeError('All amplitudes must have same dimension.'); self.ampl = np.empty((num,), dtype=object); self.ampl[:] = q; self.rates = np.zeros((num,)); self.dims = self.ampl[0].dims; self.shape = self.ampl[0].shape; elif isinstance(q, Qobj):; qo = Qobj(q); self.ampl = np.empty((1,), dtype=object); self.ampl[0] = qo; self.rates = np.array([0]); self.dims = qo.dims; self.shape = qo.shape; else:; self.ampl = np.array([q]); self.rates = np.array([0]); self.dims = [[1, 1]]; self.sh",MatchSource.WIKI,docs/4.6/modules/qutip/eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/eseries.html
https://qutip.org/docs/4.6/modules/qutip/eseries.html:10341,Integrability,wrap,wrapper,10341,"e_tol:; idx = ur_key; break; if idx == -1:; # no matching rate, add it; unique_rates[ur_len] = self.rates[r_idx]; ampl_dict[ur_len] = [self.ampl[r_idx]]; ur_len = len(unique_rates); else:; # found matching rate, append amplitude to its list; ampl_dict[idx].append(self.ampl[r_idx]). # create new amplitude and rate list with only unique rates, and; # nonzero amplitudes; rates, ampl = [], []; for ur_key in unique_rates.keys():; total_ampl = sum(ampl_dict[ur_key]); if (isinstance(total_ampl, float) or; isinstance(total_ampl, complex)):; if abs(total_ampl) > ampl_tol:; rates.append(unique_rates[ur_key]); ampl.append(total_ampl); else:; if abs(total_ampl.full()).max() > ampl_tol:; rates.append(unique_rates[ur_key]); ampl.append(total_ampl); self.rates = np.array(rates); self.ampl = np.empty((len(ampl),), dtype=object); self.ampl[:] = ampl; return self. # -----------------------------------------------------------------------------; #; # wrapper functions for accessing the class methods (for compatibility with; # quantum optics toolbox); #; def esval(es, tlist):; """"""; Evaluates an exponential series at the times listed in ``tlist``. Parameters; ----------; tlist : ndarray; Times at which to evaluate exponential series. Returns; -------; val_list : ndarray; Values of exponential at times in ``tlist``. """"""; return es.value(tlist). def esspec(es, wlist):; """"""Evaluate the spectrum of an exponential series at frequencies; in ``wlist``. Parameters; ----------; wlist : array_like; Array/list of frequenies. Returns; -------; val_list : ndarray; Values of exponential series at frequencies in ``wlist``. """"""; return es.spec(wlist). def estidy(es, *args):; """"""; Returns a tidier version of exponential series.; """"""; return es.tidyup(). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme",MatchSource.WIKI,docs/4.6/modules/qutip/eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/eseries.html
https://qutip.org/docs/4.6/modules/qutip/eseries.html:10363,Security,access,accessing,10363,"e_tol:; idx = ur_key; break; if idx == -1:; # no matching rate, add it; unique_rates[ur_len] = self.rates[r_idx]; ampl_dict[ur_len] = [self.ampl[r_idx]]; ur_len = len(unique_rates); else:; # found matching rate, append amplitude to its list; ampl_dict[idx].append(self.ampl[r_idx]). # create new amplitude and rate list with only unique rates, and; # nonzero amplitudes; rates, ampl = [], []; for ur_key in unique_rates.keys():; total_ampl = sum(ampl_dict[ur_key]); if (isinstance(total_ampl, float) or; isinstance(total_ampl, complex)):; if abs(total_ampl) > ampl_tol:; rates.append(unique_rates[ur_key]); ampl.append(total_ampl); else:; if abs(total_ampl.full()).max() > ampl_tol:; rates.append(unique_rates[ur_key]); ampl.append(total_ampl); self.rates = np.array(rates); self.ampl = np.empty((len(ampl),), dtype=object); self.ampl[:] = ampl; return self. # -----------------------------------------------------------------------------; #; # wrapper functions for accessing the class methods (for compatibility with; # quantum optics toolbox); #; def esval(es, tlist):; """"""; Evaluates an exponential series at the times listed in ``tlist``. Parameters; ----------; tlist : ndarray; Times at which to evaluate exponential series. Returns; -------; val_list : ndarray; Values of exponential at times in ``tlist``. """"""; return es.value(tlist). def esspec(es, wlist):; """"""Evaluate the spectrum of an exponential series at frequencies; in ``wlist``. Parameters; ----------; wlist : array_like; Array/list of frequenies. Returns; -------; val_list : ndarray; Values of exponential series at frequencies in ``wlist``. """"""; return es.spec(wlist). def estidy(es, *args):; """"""; Returns a tidier version of exponential series.; """"""; return es.tidyup(). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme",MatchSource.WIKI,docs/4.6/modules/qutip/eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/eseries.html
https://qutip.org/docs/4.6/modules/qutip/essolve.html:5842,Availability,error,error,5842,".isherm else results[n, :]; for n, e in enumerate(e_ops)]. return data. # -----------------------------------------------------------------------------; #; #; [docs]@_deprecate(""direct eigenstate and -value calculation""); def ode2es(L, rho0):; """"""Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) `rho0`, given the Liouvillian; (or Hamiltonian) `L`. .. deprecated:: 4.6.0; :obj:`~ode2es` will be removed in QuTiP 5. Please use; :obj:`Qobj.eigenstates` to get the eigenstates and -values, and use; :obj:`~QobjEvo` for general time-dependence. Parameters; ----------; L : qobj; Liouvillian of the system. rho0 : qobj; Initial state vector or density matrix. Returns; -------; eseries : :class:`qutip.eseries`; ``eseries`` represention of the system dynamics. """"""; if issuper(L):; # check initial state; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(); # check if state is below error threshold; if abs(rho0.full()).sum() < 1e-10 + 1e-24:; # enforce zero operator; return eseries(qzero(rho0.dims[0])); w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = mat2vec(rho0.full()); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(vec2mat(vv[:, i]), dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, w[i]); else:; out = eseries(qo, w[i]). elif isoper(L):. if not isket(rho0):; raise TypeError('Second argument must be a ket if first' +; 'is a Hamiltonian.'). # check if state is below error threshold; if abs(rho0.full()).sum() < 1e-5 + 1e-20:; # enforce zero operator; dims = rho0.dims; return eseries(Qobj(sp.csr_matrix((dims[0][0], dims[1][0]),; dtype=complex))). w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 =",MatchSource.WIKI,docs/4.6/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/essolve.html
https://qutip.org/docs/4.6/modules/qutip/essolve.html:6511,Availability,error,error,6511,"of the system. rho0 : qobj; Initial state vector or density matrix. Returns; -------; eseries : :class:`qutip.eseries`; ``eseries`` represention of the system dynamics. """"""; if issuper(L):; # check initial state; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(); # check if state is below error threshold; if abs(rho0.full()).sum() < 1e-10 + 1e-24:; # enforce zero operator; return eseries(qzero(rho0.dims[0])); w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = mat2vec(rho0.full()); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(vec2mat(vv[:, i]), dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, w[i]); else:; out = eseries(qo, w[i]). elif isoper(L):. if not isket(rho0):; raise TypeError('Second argument must be a ket if first' +; 'is a Hamiltonian.'). # check if state is below error threshold; if abs(rho0.full()).sum() < 1e-5 + 1e-20:; # enforce zero operator; dims = rho0.dims; return eseries(Qobj(sp.csr_matrix((dims[0][0], dims[1][0]),; dtype=complex))). w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = rho0.full(); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(np.array(vv[:, i]).T, dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, -1.0j * w[i]); else:; out = eseries(qo, -1.0j * w[i]). else:; raise TypeError('First argument must be a Hamiltonian or Liouvillian.'). return estidy(out). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/essolve.html
https://qutip.org/docs/4.6/modules/qutip/essolve.html:3588,Deployability,integrat,integration,3588,"ge = (; f""{f.__name__} is to be removed in QuTiP 5.0""; f"", consider swapping to {alternative}.""; ). @functools.wraps(f); def out(*args, **kwargs):; warnings.warn(message, DeprecationWarning, stacklevel=2); return f(*args, **kwargs); return out; return decorated. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]@_deprecate(""mesolve""); def essolve(H, rho0, tlist, c_op_list, e_ops):; """"""; Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (`tlist`), or the; expectation values of the supplied operators (`e_ops`). .. deprecated:: 4.6.0; :obj:`~essolev` will be removed in QuTiP 5. Please use :obj:`~sesolve`; or :obj:`~mesolve` for general-purpose integration of the; Schroedinger/Lindblad master equation. This will likely be faster than; :obj:`~essolve` for you. Parameters; ----------; H : qobj/function_type; System Hamiltonian. rho0 : :class:`qutip.qobj`; Initial state density matrix. tlist : list/array; ``list`` of times for :math:`t`. c_op_list : list of :class:`qutip.qobj`; ``list`` of :class:`qutip.qobj` collapse operators. e_ops : list of :class:`qutip.qobj`; ``list`` of :class:`qutip.qobj` operators for which to evaluate; expectation values. Returns; -------; expt_array : array; Expectation values of wavefunctions/density matrices for the; times specified in ``tlist``. .. note:: This solver does not support time-dependent Hamiltonians. """"""; n_expt_op = len(e_ops); n_tsteps = len(tlist). # Calculate the Liouvillian; if (c_op_list is None or len(c_op_list) == 0) and isket(rho0):; L = H; else:; L = liouvillian(H, c_op_list). es = ode2es(L, rho0). # evaluate the expectation values; if n_expt_op == 0:; results = [Qobj()] ",MatchSource.WIKI,docs/4.6/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/essolve.html
https://qutip.org/docs/4.6/modules/qutip/essolve.html:7391,Deployability,update,updated,7391,"of the system. rho0 : qobj; Initial state vector or density matrix. Returns; -------; eseries : :class:`qutip.eseries`; ``eseries`` represention of the system dynamics. """"""; if issuper(L):; # check initial state; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(); # check if state is below error threshold; if abs(rho0.full()).sum() < 1e-10 + 1e-24:; # enforce zero operator; return eseries(qzero(rho0.dims[0])); w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = mat2vec(rho0.full()); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(vec2mat(vv[:, i]), dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, w[i]); else:; out = eseries(qo, w[i]). elif isoper(L):. if not isket(rho0):; raise TypeError('Second argument must be a ket if first' +; 'is a Hamiltonian.'). # check if state is below error threshold; if abs(rho0.full()).sum() < 1e-5 + 1e-20:; # enforce zero operator; dims = rho0.dims; return eseries(Qobj(sp.csr_matrix((dims[0][0], dims[1][0]),; dtype=complex))). w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = rho0.full(); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(np.array(vv[:, i]).T, dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, -1.0j * w[i]); else:; out = eseries(qo, -1.0j * w[i]). else:; raise TypeError('First argument must be a Hamiltonian or Liouvillian.'). return estidy(out). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/essolve.html
https://qutip.org/docs/4.6/modules/qutip/essolve.html:2578,Integrability,message,message,2578,"ENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['essolve', 'ode2es']. import numpy as np; import scipy.linalg as la; import scipy.sparse as sp. from qutip.qobj import Qobj, issuper, isket, isoper; from qutip.eseries import eseries, estidy, esval; from qutip.expect import expect; from qutip.superoperator import liouvillian, mat2vec, vec2mat; from qutip.solver import Result; from qutip.operators import qzero. # Only used for deprecation warnings.; import functools; import warnings. def _deprecate(alternative):; def decorated(f):; message = (; f""{f.__name__} is to be removed in QuTiP 5.0""; f"", consider swapping to {alternative}.""; ). @functools.wraps(f); def out(*args, **kwargs):; warnings.warn(message, DeprecationWarning, stacklevel=2); return f(*args, **kwargs); return out; return decorated. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]@_deprecate(""mesolve""); def essolve(H, rho0, tlist, c_op_list, e_ops):; """"""; Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (`tlist`), or the; expectation values of the supplied operators (`e_ops`). .. deprecated:: 4.6.0; :obj:`~essolev` will be removed in QuTiP 5. Please use :obj:`~sesolve`; or :obj:`~mes",MatchSource.WIKI,docs/4.6/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/essolve.html
https://qutip.org/docs/4.6/modules/qutip/essolve.html:2694,Integrability,wrap,wraps,2694,", OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['essolve', 'ode2es']. import numpy as np; import scipy.linalg as la; import scipy.sparse as sp. from qutip.qobj import Qobj, issuper, isket, isoper; from qutip.eseries import eseries, estidy, esval; from qutip.expect import expect; from qutip.superoperator import liouvillian, mat2vec, vec2mat; from qutip.solver import Result; from qutip.operators import qzero. # Only used for deprecation warnings.; import functools; import warnings. def _deprecate(alternative):; def decorated(f):; message = (; f""{f.__name__} is to be removed in QuTiP 5.0""; f"", consider swapping to {alternative}.""; ). @functools.wraps(f); def out(*args, **kwargs):; warnings.warn(message, DeprecationWarning, stacklevel=2); return f(*args, **kwargs); return out; return decorated. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]@_deprecate(""mesolve""); def essolve(H, rho0, tlist, c_op_list, e_ops):; """"""; Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (`tlist`), or the; expectation values of the supplied operators (`e_ops`). .. deprecated:: 4.6.0; :obj:`~essolev` will be removed in QuTiP 5. Please use :obj:`~sesolve`; or :obj:`~mesolve` for general-purpose integration of the; Schroedinger/Lindblad master equation. This will likely be faster than; :obj:`~essolve` for you. Parameters; ",MatchSource.WIKI,docs/4.6/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/essolve.html
https://qutip.org/docs/4.6/modules/qutip/essolve.html:2745,Integrability,message,message,2745," OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['essolve', 'ode2es']. import numpy as np; import scipy.linalg as la; import scipy.sparse as sp. from qutip.qobj import Qobj, issuper, isket, isoper; from qutip.eseries import eseries, estidy, esval; from qutip.expect import expect; from qutip.superoperator import liouvillian, mat2vec, vec2mat; from qutip.solver import Result; from qutip.operators import qzero. # Only used for deprecation warnings.; import functools; import warnings. def _deprecate(alternative):; def decorated(f):; message = (; f""{f.__name__} is to be removed in QuTiP 5.0""; f"", consider swapping to {alternative}.""; ). @functools.wraps(f); def out(*args, **kwargs):; warnings.warn(message, DeprecationWarning, stacklevel=2); return f(*args, **kwargs); return out; return decorated. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]@_deprecate(""mesolve""); def essolve(H, rho0, tlist, c_op_list, e_ops):; """"""; Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (`tlist`), or the; expectation values of the supplied operators (`e_ops`). .. deprecated:: 4.6.0; :obj:`~essolev` will be removed in QuTiP 5. Please use :obj:`~sesolve`; or :obj:`~mesolve` for general-purpose integration of the; Schroedinger/Lindblad master equation. This will likely be faster than; :obj:`~essolve` for you. Parameters; ----------; H : qobj/function_type; System Hamiltonian. rho0 : :class:`qutip",MatchSource.WIKI,docs/4.6/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/essolve.html
https://qutip.org/docs/4.6/modules/qutip/essolve.html:2986,Integrability,depend,depending,2986,"RE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['essolve', 'ode2es']. import numpy as np; import scipy.linalg as la; import scipy.sparse as sp. from qutip.qobj import Qobj, issuper, isket, isoper; from qutip.eseries import eseries, estidy, esval; from qutip.expect import expect; from qutip.superoperator import liouvillian, mat2vec, vec2mat; from qutip.solver import Result; from qutip.operators import qzero. # Only used for deprecation warnings.; import functools; import warnings. def _deprecate(alternative):; def decorated(f):; message = (; f""{f.__name__} is to be removed in QuTiP 5.0""; f"", consider swapping to {alternative}.""; ). @functools.wraps(f); def out(*args, **kwargs):; warnings.warn(message, DeprecationWarning, stacklevel=2); return f(*args, **kwargs); return out; return decorated. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]@_deprecate(""mesolve""); def essolve(H, rho0, tlist, c_op_list, e_ops):; """"""; Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (`tlist`), or the; expectation values of the supplied operators (`e_ops`). .. deprecated:: 4.6.0; :obj:`~essolev` will be removed in QuTiP 5. Please use :obj:`~sesolve`; or :obj:`~mesolve` for general-purpose integration of the; Schroedinger/Lindblad master equation. This will likely be faster than; :obj:`~essolve` for you. Parameters; ----------; H : qobj/function_type; System Hamiltonian. rho0 : :class:`qutip.qobj`; Initial state density matrix. tlist : list/array; ``list`` of times for :math:`t`. c_op_list : list of :class:`qutip.qobj`; ``list`` of :class:`",MatchSource.WIKI,docs/4.6/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/essolve.html
https://qutip.org/docs/4.6/modules/qutip/essolve.html:3588,Integrability,integrat,integration,3588,"ge = (; f""{f.__name__} is to be removed in QuTiP 5.0""; f"", consider swapping to {alternative}.""; ). @functools.wraps(f); def out(*args, **kwargs):; warnings.warn(message, DeprecationWarning, stacklevel=2); return f(*args, **kwargs); return out; return decorated. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]@_deprecate(""mesolve""); def essolve(H, rho0, tlist, c_op_list, e_ops):; """"""; Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (`tlist`), or the; expectation values of the supplied operators (`e_ops`). .. deprecated:: 4.6.0; :obj:`~essolev` will be removed in QuTiP 5. Please use :obj:`~sesolve`; or :obj:`~mesolve` for general-purpose integration of the; Schroedinger/Lindblad master equation. This will likely be faster than; :obj:`~essolve` for you. Parameters; ----------; H : qobj/function_type; System Hamiltonian. rho0 : :class:`qutip.qobj`; Initial state density matrix. tlist : list/array; ``list`` of times for :math:`t`. c_op_list : list of :class:`qutip.qobj`; ``list`` of :class:`qutip.qobj` collapse operators. e_ops : list of :class:`qutip.qobj`; ``list`` of :class:`qutip.qobj` operators for which to evaluate; expectation values. Returns; -------; expt_array : array; Expectation values of wavefunctions/density matrices for the; times specified in ``tlist``. .. note:: This solver does not support time-dependent Hamiltonians. """"""; n_expt_op = len(e_ops); n_tsteps = len(tlist). # Calculate the Liouvillian; if (c_op_list is None or len(c_op_list) == 0) and isket(rho0):; L = H; else:; L = liouvillian(H, c_op_list). es = ode2es(L, rho0). # evaluate the expectation values; if n_expt_op == 0:; results = [Qobj()] ",MatchSource.WIKI,docs/4.6/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/essolve.html
https://qutip.org/docs/4.6/modules/qutip/essolve.html:4273,Integrability,depend,dependent,4273,"by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (`tlist`), or the; expectation values of the supplied operators (`e_ops`). .. deprecated:: 4.6.0; :obj:`~essolev` will be removed in QuTiP 5. Please use :obj:`~sesolve`; or :obj:`~mesolve` for general-purpose integration of the; Schroedinger/Lindblad master equation. This will likely be faster than; :obj:`~essolve` for you. Parameters; ----------; H : qobj/function_type; System Hamiltonian. rho0 : :class:`qutip.qobj`; Initial state density matrix. tlist : list/array; ``list`` of times for :math:`t`. c_op_list : list of :class:`qutip.qobj`; ``list`` of :class:`qutip.qobj` collapse operators. e_ops : list of :class:`qutip.qobj`; ``list`` of :class:`qutip.qobj` operators for which to evaluate; expectation values. Returns; -------; expt_array : array; Expectation values of wavefunctions/density matrices for the; times specified in ``tlist``. .. note:: This solver does not support time-dependent Hamiltonians. """"""; n_expt_op = len(e_ops); n_tsteps = len(tlist). # Calculate the Liouvillian; if (c_op_list is None or len(c_op_list) == 0) and isket(rho0):; L = H; else:; L = liouvillian(H, c_op_list). es = ode2es(L, rho0). # evaluate the expectation values; if n_expt_op == 0:; results = [Qobj()] * n_tsteps; else:; results = np.zeros([n_expt_op, n_tsteps], dtype=complex). for n, e in enumerate(e_ops):; results[n, :] = expect(e, esval(es, tlist)). data = Result(); data.solver = ""essolve""; data.times = tlist; data.expect = [np.real(results[n, :]) if e.isherm else results[n, :]; for n, e in enumerate(e_ops)]. return data. # -----------------------------------------------------------------------------; #; #; [docs]@_deprecate(""direct eigenstate and -value calculation""); def ode2es(L, rho0):; """"""Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) `rho0`, given the Liouvillian; (or Hamiltonian) `L`. .. depreca",MatchSource.WIKI,docs/4.6/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/essolve.html
https://qutip.org/docs/4.6/modules/qutip/essolve.html:5434,Integrability,depend,dependence,5434," None or len(c_op_list) == 0) and isket(rho0):; L = H; else:; L = liouvillian(H, c_op_list). es = ode2es(L, rho0). # evaluate the expectation values; if n_expt_op == 0:; results = [Qobj()] * n_tsteps; else:; results = np.zeros([n_expt_op, n_tsteps], dtype=complex). for n, e in enumerate(e_ops):; results[n, :] = expect(e, esval(es, tlist)). data = Result(); data.solver = ""essolve""; data.times = tlist; data.expect = [np.real(results[n, :]) if e.isherm else results[n, :]; for n, e in enumerate(e_ops)]. return data. # -----------------------------------------------------------------------------; #; #; [docs]@_deprecate(""direct eigenstate and -value calculation""); def ode2es(L, rho0):; """"""Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) `rho0`, given the Liouvillian; (or Hamiltonian) `L`. .. deprecated:: 4.6.0; :obj:`~ode2es` will be removed in QuTiP 5. Please use; :obj:`Qobj.eigenstates` to get the eigenstates and -values, and use; :obj:`~QobjEvo` for general time-dependence. Parameters; ----------; L : qobj; Liouvillian of the system. rho0 : qobj; Initial state vector or density matrix. Returns; -------; eseries : :class:`qutip.eseries`; ``eseries`` represention of the system dynamics. """"""; if issuper(L):; # check initial state; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(); # check if state is below error threshold; if abs(rho0.full()).sum() < 1e-10 + 1e-24:; # enforce zero operator; return eseries(qzero(rho0.dims[0])); w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = mat2vec(rho0.full()); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(vec2mat(vv[:, i]), dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, w[i]); else:; out = eseries(qo, w[i]). elif isoper(L):. if not isket",MatchSource.WIKI,docs/4.6/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/essolve.html
https://qutip.org/docs/4.6/modules/qutip/expect.html:5723,Deployability,update,updated,5723,"or('Arguments must be quantum objects or eseries'). def _single_qobj_expect(oper, state):; """"""; Private function used by expect to calculate expectation values of Qobjs.; """"""; if isoper(oper):; if oper.dims[1] != state.dims[0]:; raise Exception('Operator and state do not have same tensor ' +; 'structure: %s and %s' %; (oper.dims[1], state.dims[0])). if state.type == 'oper':; # calculates expectation value via TR(op*rho); return cy_spmm_tr(oper.data, state.data,; oper.isherm and state.isherm). elif state.type == 'ket':; # calculates expectation value via <psi|op|psi>; return expect_csr_ket(oper.data, state.data,; oper.isherm); else:; raise TypeError('Invalid operand types'). def _single_eseries_expect(oper, state):; """"""; Private function used by expect to calculate expectation values for; eseries.; """""". out = eseries(). if isoper(state.ampl[0]):; out.rates = state.rates; out.ampl = np.array([expect(oper, a) for a in state.ampl]). else:; out.rates = np.array([]); out.ampl = np.array([]). for m in range(len(state.rates)):; op_m = state.ampl[m].data.conj().T * oper.data. for n in range(len(state.rates)):; a = op_m * state.ampl[n].data. if isinstance(a, sp.spmatrix):; a = a.todense(). out.rates = np.append(out.rates, state.rates[n] -; state.rates[m]); out.ampl = np.append(out.ampl, a). return out. [docs]def variance(oper, state):; """"""; Variance of an operator for the given state vector or density matrix. Parameters; ----------; oper : qobj; Operator for expectation value. state : qobj/list; A single or `list` of quantum states or density matrices.. Returns; -------; var : float; Variance of operator 'oper' for given state. """"""; return expect(oper ** 2, state) - expect(oper, state) ** 2. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/expect.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/expect.html
https://qutip.org/docs/4.6/modules/qutip/fileio.html:7933,Deployability,update,updated,7933," == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = complex(item); n += 1; m += 1. else:; data = np.zeros((M, N), dtype=""float""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = float(item); n += 1; m += 1. f.close(). return data. [docs]def qsave(data, name='qutip_data'):; """"""; Saves given data to file named 'filename.qu' in current directory. Parameters; ----------; data : instance/array_like; Input Python object to be stored.; filename : str; Name of output data file. """"""; # open the file for writing; fileObject = open(name + '.qu', 'wb'); # this writes the object a to the file named 'filename.qu'; pickle.dump(data, fileObject); fileObject.close(). [docs]def qload(name):; """"""; Loads data file from file named 'filename.qu' in current directory. Parameters; ----------; name : str; Name of data file to be loaded. Returns; -------; qobject : instance / array_like; Object retrieved from requested file. """"""; with open(name + "".qu"", ""rb"") as fileObject:; if sys.version_info >= (3, 0):; out = pickle.load(fileObject, encoding='latin1'); else:; out = pickle.load(fileObject); if isinstance(out, Qobj): # for quantum objects; print('Loaded Qobj object:'); str1 = ""Quantum object: "" + ""dims = "" + str(out.dims) \; + "", shape = "" + str(out.shape) + "", type = "" + out.type; if out.type == 'oper' or out.type == 'super':; str1 += "", isHerm = "" + str(out.isherm) + ""\n""; else:; str1 += ""\n""; print(str1); elif isinstance(out, Result):; print('Loaded Result object:'); print(out); else:; print(""Loaded "" + str(type(out).__name__) + "" object.""); return out. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/fileio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/fileio.html
https://qutip.org/docs/4.6/modules/qutip/fileio.html:7003,Performance,load,loaded,7003," = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = complex(item); n += 1; m += 1. else:; data = np.zeros((M, N), dtype=""float""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = float(item); n += 1; m += 1. f.close(). return data. [docs]def qsave(data, name='qutip_data'):; """"""; Saves given data to file named 'filename.qu' in current directory. Parameters; ----------; data : instance/array_like; Input Python object to be stored.; filename : str; Name of output data file. """"""; # open the file for writing; fileObject = open(name + '.qu', 'wb'); # this writes the object a to the file named 'filename.qu'; pickle.dump(data, fileObject); fileObject.close(). [docs]def qload(name):; """"""; Loads data file from file named 'filename.qu' in current directory. Parameters; ----------; name : str; Name of data file to be loaded. Returns; -------; qobject : instance / array_like; Object retrieved from requested file. """"""; with open(name + "".qu"", ""rb"") as fileObject:; if sys.version_info >= (3, 0):; out = pickle.load(fileObject, encoding='latin1'); else:; out = pickle.load(fileObject); if isinstance(out, Qobj): # for quantum objects; print('Loaded Qobj object:'); str1 = ""Quantum object: "" + ""dims = "" + str(out.dims) \; + "", shape = "" + str(out.shape) + "", type = "" + out.type; if out.type == 'oper' or out.type == 'super':; str1 += "", isHerm = "" + str(out.isherm) + ""\n""; else:; str1 += ""\n""; print(str1); elif isinstance(out, Result):; print('Loaded Result object:'); print(out); else:; print(""Loaded "" + str(type(out).__name__) + "" object.""); return out. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built wit",MatchSource.WIKI,docs/4.6/modules/qutip/fileio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/fileio.html
https://qutip.org/docs/4.6/modules/qutip/fileio.html:7196,Performance,load,load,7196," == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = complex(item); n += 1; m += 1. else:; data = np.zeros((M, N), dtype=""float""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = float(item); n += 1; m += 1. f.close(). return data. [docs]def qsave(data, name='qutip_data'):; """"""; Saves given data to file named 'filename.qu' in current directory. Parameters; ----------; data : instance/array_like; Input Python object to be stored.; filename : str; Name of output data file. """"""; # open the file for writing; fileObject = open(name + '.qu', 'wb'); # this writes the object a to the file named 'filename.qu'; pickle.dump(data, fileObject); fileObject.close(). [docs]def qload(name):; """"""; Loads data file from file named 'filename.qu' in current directory. Parameters; ----------; name : str; Name of data file to be loaded. Returns; -------; qobject : instance / array_like; Object retrieved from requested file. """"""; with open(name + "".qu"", ""rb"") as fileObject:; if sys.version_info >= (3, 0):; out = pickle.load(fileObject, encoding='latin1'); else:; out = pickle.load(fileObject); if isinstance(out, Qobj): # for quantum objects; print('Loaded Qobj object:'); str1 = ""Quantum object: "" + ""dims = "" + str(out.dims) \; + "", shape = "" + str(out.shape) + "", type = "" + out.type; if out.type == 'oper' or out.type == 'super':; str1 += "", isHerm = "" + str(out.isherm) + ""\n""; else:; str1 += ""\n""; print(str1); elif isinstance(out, Result):; print('Loaded Result object:'); print(out); else:; print(""Loaded "" + str(type(out).__name__) + "" object.""); return out. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/fileio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/fileio.html
https://qutip.org/docs/4.6/modules/qutip/fileio.html:7253,Performance,load,load,7253," == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = complex(item); n += 1; m += 1. else:; data = np.zeros((M, N), dtype=""float""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = float(item); n += 1; m += 1. f.close(). return data. [docs]def qsave(data, name='qutip_data'):; """"""; Saves given data to file named 'filename.qu' in current directory. Parameters; ----------; data : instance/array_like; Input Python object to be stored.; filename : str; Name of output data file. """"""; # open the file for writing; fileObject = open(name + '.qu', 'wb'); # this writes the object a to the file named 'filename.qu'; pickle.dump(data, fileObject); fileObject.close(). [docs]def qload(name):; """"""; Loads data file from file named 'filename.qu' in current directory. Parameters; ----------; name : str; Name of data file to be loaded. Returns; -------; qobject : instance / array_like; Object retrieved from requested file. """"""; with open(name + "".qu"", ""rb"") as fileObject:; if sys.version_info >= (3, 0):; out = pickle.load(fileObject, encoding='latin1'); else:; out = pickle.load(fileObject); if isinstance(out, Qobj): # for quantum objects; print('Loaded Qobj object:'); str1 = ""Quantum object: "" + ""dims = "" + str(out.dims) \; + "", shape = "" + str(out.shape) + "", type = "" + out.type; if out.type == 'oper' or out.type == 'super':; str1 += "", isHerm = "" + str(out.isherm) + ""\n""; else:; str1 += ""\n""; print(str1); elif isinstance(out, Result):; print('Loaded Result object:'); print(out); else:; print(""Loaded "" + str(type(out).__name__) + "" object.""); return out. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/fileio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/fileio.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:12257,Deployability,patch,patch,12257,"bj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """""". f_states_t = floquet_states_t(f_modes_0, f_energies, t, H, T, args); return sum([f_states_t[i] * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_state_decomposition(f_states, f_energies, psi):; r""""""; Decompose the wavefunction `psi` (typically an initial state) in terms of; the Floquet states, :math:`\psi = \sum_\alpha c_\alpha \psi_\alpha(0)`. Parameters; ----------. f_states : list of :class:`qutip.qobj` (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\alpha` in the Floquet state decomposition. """"""; # [:1,:1][0, 0] patch around scipy 1.3.0 bug; return [(f_states[i].dag() * psi).data[:1, :1][0, 0]; for i in np.arange(len(f_energies))]. [docs]def fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100):; """"""; Solve the Schrodinger equation using the Floquet formalism. Parameters; ----------. H : :class:`qutip.qobj.Qobj`; System Hamiltonian, time-dependent with period `T`. psi0 : :class:`qutip.qobj`; Initial state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in `tlist` will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. `Tsteps` should be an even number. Returns",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:17054,Deployability,patch,patch,17054,"_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table` (optional). Returns; -------. output : list. A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. """""". N = len(f_energies); M = 2 * kmax + 1. omega = (2 * pi) / T. Delta = np.zeros((N, N, M)); X = np.zeros((N, N, M), dtype=complex); Gamma = np.zeros((N, N, M)); A = np.zeros((N, N)). nT = 100; dT = T / nT; tlist = np.arange(dT, T + dT / 2, dT). if f_modes_table_t is None:; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T, nT + 1), H, T,; args). for t in tlist:; # TODO: repeated invocations of floquet_modes_t is; # inefficient... make a and b outer loops and use the mesolve; # instead of the propagator. # f_modes_t = floquet_modes_t(f_modes_0, f_energies, t, H, T, args); f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); for a in range(N):; for b in range(N):; k_idx = 0; for k in range(-kmax, kmax + 1, 1):; # [:1,:1][0, 0] patch around scipy 1.3.0 bug; X[a, b, k_idx] += (dT / T) * exp(-1j * k * omega * t) * \; (f_modes_t[a].dag() * c_op * f_modes_t[b])[:1, :1][0, 0]; k_idx += 1. Heaviside = lambda x: ((np.sign(x) + 1) / 2.0); for a in range(N):; for b in range(N):; k_idx = 0; for k in range(-kmax, kmax + 1, 1):; Delta[a, b, k_idx] = f_energies[a] - f_energies[b] + k * omega; Gamma[a, b, k_idx] = 2 * pi * Heaviside(Delta[a, b, k_idx]) * \; J_cb(Delta[a, b, k_idx]) * abs(X[a, b, k_idx]) ** 2; k_idx += 1. for a in range(N):; for b in range(N):; for k in range(-kmax, kmax + 1, 1):; k1_idx = k + kmax; k2_idx = -k + kmax; A[a, b] += Gamma[a, b, k1_idx] + \; n_thermal(abs(Delta[a, b, k1_idx]), w_th) * \; (Gamma[a, b, k1_idx] + Gamma[b, a, k2_idx]). return Delta, X, Gamma, A. def floquet_collapse_operators(A):; """"""; Construct collapse operators corresponding to the Floquet-Markov; master-equation rate matrix",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:21628,Deployability,integrat,integrator,21628,"nitial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]. output = Result(); output.solver = ""fmmesolve""; output.times = tlist. if isinstance(e_ops, FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; output.states = []; else:; if not f_modes_table:; raise TypeError(""The Floquet mode table has to be provided "" +; ""when requesting expectation values.""). output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # transform the initial density matrix to the eigenbasis: from; # computational basis to the floquet basis; #; if ekets is not None:; rho0 = rho0.transform(ekets). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; rho = Qobj(rho0). t_idx = 0; for t in tlist:; if not r.successful():; break. rho = Qobj(vec2mat(r.y), rho0.dims, rho0.shape). if expt_callback:; # use callback method; if floquet_basis:; e_ops(t, Qobj(rho)); else:; f_modes_table_t, T = f_modes_table; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); e_ops(t, Qobj(rho).transform(f_modes_t, True)); else:; # calculate all the expectation values, or output rho if; # no operators; if n_expt_op == 0:; if floquet_basis:; output.states.append(Qobj(rho)); else:; f_modes_table_t, T = f_modes_table; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); output.states.append(Qobj(rho).transform(f_modes_t, True)); else",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:21692,Deployability,integrat,integrate,21692,"dm(rho0). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]. output = Result(); output.solver = ""fmmesolve""; output.times = tlist. if isinstance(e_ops, FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; output.states = []; else:; if not f_modes_table:; raise TypeError(""The Floquet mode table has to be provided "" +; ""when requesting expectation values.""). output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # transform the initial density matrix to the eigenbasis: from; # computational basis to the floquet basis; #; if ekets is not None:; rho0 = rho0.transform(ekets). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; rho = Qobj(rho0). t_idx = 0; for t in tlist:; if not r.successful():; break. rho = Qobj(vec2mat(r.y), rho0.dims, rho0.shape). if expt_callback:; # use callback method; if floquet_basis:; e_ops(t, Qobj(rho)); else:; f_modes_table_t, T = f_modes_table; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); e_ops(t, Qobj(rho).transform(f_modes_t, True)); else:; # calculate all the expectation values, or output rho if; # no operators; if n_expt_op == 0:; if floquet_basis:; output.states.append(Qobj(rho)); else:; f_modes_table_t, T = f_modes_table; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); output.states.append(Qobj(rho).transform(f_modes_t, True)); else:; f_modes_table_t, T = f_modes_table; f_modes_t = f",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:22856,Deployability,integrat,integrate,22856,"opt.rtol, max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; rho = Qobj(rho0). t_idx = 0; for t in tlist:; if not r.successful():; break. rho = Qobj(vec2mat(r.y), rho0.dims, rho0.shape). if expt_callback:; # use callback method; if floquet_basis:; e_ops(t, Qobj(rho)); else:; f_modes_table_t, T = f_modes_table; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); e_ops(t, Qobj(rho).transform(f_modes_t, True)); else:; # calculate all the expectation values, or output rho if; # no operators; if n_expt_op == 0:; if floquet_basis:; output.states.append(Qobj(rho)); else:; f_modes_table_t, T = f_modes_table; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); output.states.append(Qobj(rho).transform(f_modes_t, True)); else:; f_modes_table_t, T = f_modes_table; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); for m in range(0, n_expt_op):; output.expect[m][t_idx] = \; expect(e_ops[m], rho.transform(f_modes_t, False)). r.integrate(r.t + dt); t_idx += 1. return output. # -----------------------------------------------------------------------------; # Solve the Floquet-Markov master equation; #; #; [docs]def fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None,; args={}, options=Options(), floquet_basis=True, kmax=5,; _safe_mode=True):; """"""; Solve the dynamics for the system using the Floquet-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of fre",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:26166,Deployability,update,updated,26166,"f finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion. >>> temperature = 25e-3 # unit K # doctest: +SKIP; >>> h = 6.626e-34 # doctest: +SKIP; >>> kB = 1.38e-23 # doctest: +SKIP; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 \; #doctest: +SKIP. options : :class:`qutip.solver`; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns; -------. output : :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`.; """""". if _safe_mode:; _solver_safety_check(H, rho0, c_ops, e_ops, args). if T is None:; T = max(tlist). if len(spectra_cb) == 0:; # add white noise callbacks if absent; spectra_cb = [lambda w: 1.0] * len(c_ops). f_modes_0, f_energies = floquet_modes(H, T, args). f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T, 500 + 1),; H, T, args). # get w_th from args if it exists; if 'w_th' in args:; w_th = args['w_th']; else:; w_th = 0. # TODO: loop over input c_ops and spectra_cb, calculate one R for each set. # calculate the rate-matrices for the floquet-markov master equation; Delta, X, Gamma, Amat = floquet_master_equation_rates(; f_modes_0, f_energies, c_ops[0], H, T, args, spectra_cb[0],; w_th, kmax, f_modes_table_t). # the floquet-markov master equation tensor; R = floquet_master_equation_tensor(Amat, f_energies). return floquet_markov_mesolve(R, f_modes_0, rho0, tlist, e_ops,; f_modes_table=(f_modes_table_t, T),; options=options,; floquet_basis=floquet_basis). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:4590,Energy Efficiency,energy,energy,4590,"ort`; decides if the output is to be sorted in increasing quasienergies or not. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.array(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; s",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:4839,Energy Efficiency,energy,energy,4839," float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.array(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. Returns; -------. output : list of kets. The Floquet modes as kets ",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:15723,Energy Efficiency,power,power,15723,"lculate all the expectation values, or output psi if; # no expectation value operators where defined; if output.num_expect == 0:; output.states.append(Qobj(psi_t)); else:; for e_idx, e in enumerate(e_ops):; output.expect[e_idx][t_idx] = expect(e, psi_t). return output. [docs]def floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T,; args, J_cb, w_th, kmax=5,; f_modes_table_t=None):; """"""; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes. f_energies : array; The Floquet energies. c_op : :class:`qutip.qobj`; The collapse operators describing the dissipation. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`. w_th : float; The temperature in units of frequency. k_max : int; The truncation of the number of sidebands (default 5). f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table` (optional). Returns; -------. output : list. A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. """""". N = len(f_energies); M = 2 * kmax + 1. omega = (2 * pi) / T. Delta = np.zeros((N, N, M)); X = np.zeros((N, N, M), dtype=complex); Gamma = np.zeros((N, N, M)); A = np.zeros((N, N)). nT = 100; dT = T / nT; tlist = np.arange(dT, T + dT / 2, dT). if f_modes_table_t is None:; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T, nT + 1), H, T,; args). for t in tlist:; # TODO: repeated invocations of floquet_modes_t is; # ",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:23826,Energy Efficiency,power,power,23826,"o.transform(f_modes_t, False)). r.integrate(r.t + dt); t_idx += 1. return output. # -----------------------------------------------------------------------------; # Solve the Floquet-Markov master equation; #; #; [docs]def fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None,; args={}, options=Options(), floquet_basis=True, kmax=5,; _safe_mode=True):; """"""; Solve the dynamics for the system using the Floquet-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. This dictionary should also contain an entry 'w_th', which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion. >>> temperature = 25e-3 # unit K # doctest: +SKIP; >>> h = 6.626e-34 # doctest: +SKIP; >>> kB = 1.38e-23 # doctest: +SKIP; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 \; #doctest: +SKIP. options : :class:`qutip.solver`; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns; -------. output : :class:`q",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:24285,Energy Efficiency,energy,energy,24285,"t-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. This dictionary should also contain an entry 'w_th', which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion. >>> temperature = 25e-3 # unit K # doctest: +SKIP; >>> h = 6.626e-34 # doctest: +SKIP; >>> kB = 1.38e-23 # doctest: +SKIP; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 \; #doctest: +SKIP. options : :class:`qutip.solver`; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns; -------. output : :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`.; """""". if _safe_mode:; _solver_safety_check(H, rho0, c_ops, e_ops, args). if T is None:; T = max(tlist). if len(spectra_cb) == 0:; # add white noise callbacks if absent; spectra_cb = [lambda w: 1.0] * len(c_ops). f_modes_0, f_energies = floquet_modes(H, T, args). f_modes_",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:3744,Integrability,depend,dependent,3744,", vec2mat; #from qutip.mesolve import mesolve; from qutip.sesolve import sesolve; from qutip.rhs_generate import rhs_clear; from qutip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.states import projection; from qutip.solver import Options; from qutip.propagator import propagator; from qutip.solver import Result, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.expect import expect; from qutip.utilities import n_thermal. [docs]def floquet_modes(H, T, args=None, sort=False, U=None):; """"""; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T. Returns a list of :class:`qutip.qobj` instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter `sort`; decides if the output is to be sorted in increasing quasienergies or not. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs +",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:3874,Integrability,depend,dependence,3874,"utip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.states import projection; from qutip.solver import Options; from qutip.propagator import propagator; from qutip.solver import Result, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.expect import expect; from qutip.utilities import n_thermal. [docs]def floquet_modes(H, T, args=None, sort=False, U=None):; """"""; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T. Returns a list of :class:`qutip.qobj` instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter `sort`; decides if the output is to be sorted in increasing quasienergies or not. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.args",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:4049,Integrability,depend,dependent,4049,"r; from qutip.solver import Result, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.expect import expect; from qutip.utilities import n_thermal. [docs]def floquet_modes(H, T, args=None, sort=False, U=None):; """"""; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T. Returns a list of :class:`qutip.qobj` instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter `sort`; decides if the output is to be sorted in increasing quasienergies or not. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; ",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:5615,Integrability,depend,dependent,5615,"val [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.array(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. Returns; -------. output : list of kets. The Floquet modes as kets at time :math:`t`. """"""; # find t in [0,T] such that t_orig = t + n * T for integer n; t = t - int(t / T) * T; f_modes_t = []. # get the unitary propagator from 0 to t; if t > 0.0:; U = propagator(H, t, [], args). for n in np.arange(len(f_modes_0)):; f_modes_t.append(U * f_modes_0[n] * exp(1j * f_energies[n] * t)); else:; f_modes_t = f_modes_0. return f_modes_t. [docs]def floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None):; """"""; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. tlist : array; The list of t",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:5745,Integrability,depend,dependence,5745," (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.array(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. Returns; -------. output : list of kets. The Floquet modes as kets at time :math:`t`. """"""; # find t in [0,T] such that t_orig = t + n * T for integer n; t = t - int(t / T) * T; f_modes_t = []. # get the unitary propagator from 0 to t; if t > 0.0:; U = propagator(H, t, [], args). for n in np.arange(len(f_modes_0)):; f_modes_t.append(U * f_modes_0[n] * exp(1j * f_energies[n] * t)); else:; f_modes_t = f_modes_0. return f_modes_t. [docs]def floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None):; """"""; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. T : float",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:6707,Integrability,depend,dependent,6707,"ate H. T : float; The period of the time-dependence of the hamiltonian. Returns; -------. output : list of kets. The Floquet modes as kets at time :math:`t`. """"""; # find t in [0,T] such that t_orig = t + n * T for integer n; t = t - int(t / T) * T; f_modes_t = []. # get the unitary propagator from 0 to t; if t > 0.0:; U = propagator(H, t, [], args). for n in np.arange(len(f_modes_0)):; f_modes_t.append(U * f_modes_0[n] * exp(1j * f_energies[n] * t)); else:; f_modes_t = f_modes_0. return f_modes_t. [docs]def floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None):; """"""; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; dictionary with variables required to evaluate H. Returns; -------. output : nested list. A nested list of Floquet modes as kets for each time in `tlist`. """"""; # truncate tlist to the driving period; tlist_period = tlist[np.where(tlist <= T)]. f_modes_table_t = [[] for t in tlist_period]. opt = Options(); opt.rhs_reuse = True; rhs_clear(). for n, f_mode in enumerate(f_modes_0):; output = sesolve(H, f_mode, tlist_period, [], args, opt); for t_idx, f_state_t in enumerate(output.states):; f_modes_table_t[t_idx].append(; f_state_t * exp(1j * f_energies[n] * tlist_period[t_idx])). return f_modes_table_t. [docs]def floquet_modes_t_lookup(f_modes_table_t, t, T):; """"""; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters; ----------. f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A looku",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:6768,Integrability,depend,dependence,6768,"miltonian. Returns; -------. output : list of kets. The Floquet modes as kets at time :math:`t`. """"""; # find t in [0,T] such that t_orig = t + n * T for integer n; t = t - int(t / T) * T; f_modes_t = []. # get the unitary propagator from 0 to t; if t > 0.0:; U = propagator(H, t, [], args). for n in np.arange(len(f_modes_0)):; f_modes_t.append(U * f_modes_0[n] * exp(1j * f_energies[n] * t)); else:; f_modes_t = f_modes_0. return f_modes_t. [docs]def floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None):; """"""; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; dictionary with variables required to evaluate H. Returns; -------. output : nested list. A nested list of Floquet modes as kets for each time in `tlist`. """"""; # truncate tlist to the driving period; tlist_period = tlist[np.where(tlist <= T)]. f_modes_table_t = [[] for t in tlist_period]. opt = Options(); opt.rhs_reuse = True; rhs_clear(). for n, f_mode in enumerate(f_modes_0):; output = sesolve(H, f_mode, tlist_period, [], args, opt); for t_idx, f_state_t in enumerate(output.states):; f_modes_table_t[t_idx].append(; f_state_t * exp(1j * f_energies[n] * tlist_period[t_idx])). return f_modes_table_t. [docs]def floquet_modes_t_lookup(f_modes_table_t, t, T):; """"""; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters; ----------. f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qut",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:7600,Integrability,depend,dependence,7600,"; Floquet modes at :math:`t`. f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; dictionary with variables required to evaluate H. Returns; -------. output : nested list. A nested list of Floquet modes as kets for each time in `tlist`. """"""; # truncate tlist to the driving period; tlist_period = tlist[np.where(tlist <= T)]. f_modes_table_t = [[] for t in tlist_period]. opt = Options(); opt.rhs_reuse = True; rhs_clear(). for n, f_mode in enumerate(f_modes_0):; output = sesolve(H, f_mode, tlist_period, [], args, opt); for t_idx, f_state_t in enumerate(output.states):; f_modes_table_t[t_idx].append(; f_state_t * exp(1j * f_energies[n] * tlist_period[t_idx])). return f_modes_table_t. [docs]def floquet_modes_t_lookup(f_modes_table_t, t, T):; """"""; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters; ----------. f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table`. t : float; The time for which to evaluate the Floquet modes. T : float; The period of the time-dependence of the hamiltonian. Returns; -------. output : nested list. A list of Floquet modes as kets for the time that most closely matching; the time `t` in the supplied table of Floquet modes.; """""". # find t_wrap in [0,T] such that t = t_wrap + n * T for integer n; t_wrap = t - int(t / T) * T. # find the index in the table that corresponds to t_wrap (= tlist[t_idx]); t_idx = int(t_wrap / T * len(f_modes_table_t)). # XXX: might want to give a warning if the cast of t_idx to int discard; # a significant fraction in t_idx, which would happen if the list of time; # values isn't perfect matching the driving period; # ",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:7894,Integrability,depend,dependence,7894,"t : nested list. A nested list of Floquet modes as kets for each time in `tlist`. """"""; # truncate tlist to the driving period; tlist_period = tlist[np.where(tlist <= T)]. f_modes_table_t = [[] for t in tlist_period]. opt = Options(); opt.rhs_reuse = True; rhs_clear(). for n, f_mode in enumerate(f_modes_0):; output = sesolve(H, f_mode, tlist_period, [], args, opt); for t_idx, f_state_t in enumerate(output.states):; f_modes_table_t[t_idx].append(; f_state_t * exp(1j * f_energies[n] * tlist_period[t_idx])). return f_modes_table_t. [docs]def floquet_modes_t_lookup(f_modes_table_t, t, T):; """"""; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters; ----------. f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table`. t : float; The time for which to evaluate the Floquet modes. T : float; The period of the time-dependence of the hamiltonian. Returns; -------. output : nested list. A list of Floquet modes as kets for the time that most closely matching; the time `t` in the supplied table of Floquet modes.; """""". # find t_wrap in [0,T] such that t = t_wrap + n * T for integer n; t_wrap = t - int(t / T) * T. # find the index in the table that corresponds to t_wrap (= tlist[t_idx]); t_idx = int(t_wrap / T * len(f_modes_table_t)). # XXX: might want to give a warning if the cast of t_idx to int discard; # a significant fraction in t_idx, which would happen if the list of time; # values isn't perfect matching the driving period; # if debug: print ""t = %f -> t_wrap = %f @ %d of %d"" % (t, t_wrap, t_idx,; # N). return f_modes_table_t[t_idx]. [docs]def floquet_states(f_modes_t, f_energies, t):; """"""; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of Floquet modes for time :math:`t`. f_energies : a",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:9592,Integrability,depend,dependent,9592,"; # N). return f_modes_table_t[t_idx]. [docs]def floquet_states(f_modes_t, f_energies, t):; """"""; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of Floquet modes for time :math:`t`. f_energies : array; The Floquet energies. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : list. A list of Floquet states for the time :math:`t`. """""". return [(f_modes_t[i] * exp(-1j * f_energies[i] * t)); for i in np.arange(len(f_energies))]. [docs]def floquet_states_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Evaluate the floquet states at time t given the initial Floquet modes. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. t : float; The time for which to evaluate the Floquet states. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns; -------. output : list. A list of Floquet states for the time :math:`t`. """""". f_modes_t = floquet_modes_t(f_modes_0, f_energies, t, H, T, args); return [(f_modes_t[i] * exp(-1j * f_energies[i] * t)); for i in np.arange(len(f_energies))]. [docs]def floquet_wavefunction(f_modes_t, f_energies, f_coeff, t):; """"""; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time `t`. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :m",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:9653,Integrability,depend,dependence,9653,"es(f_modes_t, f_energies, t):; """"""; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of Floquet modes for time :math:`t`. f_energies : array; The Floquet energies. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : list. A list of Floquet states for the time :math:`t`. """""". return [(f_modes_t[i] * exp(-1j * f_energies[i] * t)); for i in np.arange(len(f_energies))]. [docs]def floquet_states_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Evaluate the floquet states at time t given the initial Floquet modes. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. t : float; The time for which to evaluate the Floquet states. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns; -------. output : list. A list of Floquet states for the time :math:`t`. """""". f_modes_t = floquet_modes_t(f_modes_0, f_energies, t, H, T, args); return [(f_modes_t[i] * exp(-1j * f_energies[i] * t)); for i in np.arange(len(f_energies))]. [docs]def floquet_wavefunction(f_modes_t, f_energies, f_coeff, t):; """"""; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time `t`. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """"""; return sum([f_modes_t[i] * exp(-1j * f_energies[",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:11286,Integrability,depend,dependent,11286,"et modes (for time :math:`t=0`). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """"""; return sum([f_modes_t[i] * exp(-1j * f_energies[i] * t) * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None):; """"""; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """""". f_states_t = floquet_states_t(f_modes_0, f_energies, t, H, T, args); return sum([f_states_t[i] * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_state_decomposition(f_states, f_energies, psi):; r""""""; Decompose the wavefunction `psi` (typically an initial state) in terms of; the Floquet states, :math:`\psi = \sum_\alpha c_\alpha \psi_\alpha(0)`. Parameters; ----------. f_states : list of :class:`qutip.qobj` (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\alpha` in the Floquet state decomposition. """"""; # [:1,:1][0, 0] patch around scipy 1.3.0 b",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:11347,Integrability,depend,dependence,11347,"uet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """"""; return sum([f_modes_t[i] * exp(-1j * f_energies[i] * t) * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None):; """"""; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """""". f_states_t = floquet_states_t(f_modes_0, f_energies, t, H, T, args); return sum([f_states_t[i] * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_state_decomposition(f_states, f_energies, psi):; r""""""; Decompose the wavefunction `psi` (typically an initial state) in terms of; the Floquet states, :math:`\psi = \sum_\alpha c_\alpha \psi_\alpha(0)`. Parameters; ----------. f_states : list of :class:`qutip.qobj` (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\alpha` in the Floquet state decomposition. """"""; # [:1,:1][0, 0] patch around scipy 1.3.0 bug; return [(f_states[i].dag() * psi).data[:1, :1][0, 0]; for ",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:12599,Integrability,depend,dependent,12599," H, T, args); return sum([f_states_t[i] * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_state_decomposition(f_states, f_energies, psi):; r""""""; Decompose the wavefunction `psi` (typically an initial state) in terms of; the Floquet states, :math:`\psi = \sum_\alpha c_\alpha \psi_\alpha(0)`. Parameters; ----------. f_states : list of :class:`qutip.qobj` (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\alpha` in the Floquet state decomposition. """"""; # [:1,:1][0, 0] patch around scipy 1.3.0 bug; return [(f_states[i].dag() * psi).data[:1, :1][0, 0]; for i in np.arange(len(f_energies))]. [docs]def fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100):; """"""; Solve the Schrodinger equation using the Floquet formalism. Parameters; ----------. H : :class:`qutip.qobj.Qobj`; System Hamiltonian, time-dependent with period `T`. psi0 : :class:`qutip.qobj`; Initial state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in `tlist` will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. `Tsteps` should be an even number. Returns; -------. output : :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which; contains either an *array* of expectation values or an array of; state vectors, for the times specified by `tlist`.; """""". if not T:; # assume that tlist span exactly one period of the driving; T = tlist[-1]. # find the floquet ",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:13004,Integrability,depend,dependence,13004,"es. f_energies : array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\alpha` in the Floquet state decomposition. """"""; # [:1,:1][0, 0] patch around scipy 1.3.0 bug; return [(f_states[i].dag() * psi).data[:1, :1][0, 0]; for i in np.arange(len(f_energies))]. [docs]def fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100):; """"""; Solve the Schrodinger equation using the Floquet formalism. Parameters; ----------. H : :class:`qutip.qobj.Qobj`; System Hamiltonian, time-dependent with period `T`. psi0 : :class:`qutip.qobj`; Initial state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in `tlist` will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. `Tsteps` should be an even number. Returns; -------. output : :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which; contains either an *array* of expectation values or an array of; state vectors, for the times specified by `tlist`.; """""". if not T:; # assume that tlist span exactly one period of the driving; T = tlist[-1]. # find the floquet modes for the time-dependent hamiltonian; f_modes_0, f_energies = floquet_modes(H, T, args). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T, Tsteps + 1),; H, T, args). # setup Result for storing the results; output = Result(); output.times = tlist; output.solver = ""fsesolve"". if isinstance(e_ops, FunctionType",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:13615,Integrability,depend,dependent,13615," :class:`qutip.qobj`; Initial state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in `tlist` will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. `Tsteps` should be an even number. Returns; -------. output : :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which; contains either an *array* of expectation values or an array of; state vectors, for the times specified by `tlist`.; """""". if not T:; # assume that tlist span exactly one period of the driving; T = tlist[-1]. # find the floquet modes for the time-dependent hamiltonian; f_modes_0, f_energies = floquet_modes(H, T, args). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T, Tsteps + 1),; H, T, args). # setup Result for storing the results; output = Result(); output.times = tlist; output.solver = ""fsesolve"". if isinstance(e_ops, FunctionType):; output.num_expect = 0; expt_callback = True. elif isinstance(e_ops, list):. output.num_expect = len(e_ops); expt_callback = False. if output.num_expect == 0:; output.states = []; else:; output.expect = []; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(len(tlist))); else:; output.expect.append(np.zeros(len(tlist), dtype=complex)). else:; raise TypeError(""e_ops must be a list Qobj or a callback function""). psi0_fb = psi0.transform(f_modes_0); for t_idx, t in enumerate(tlist):; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); f_states_t = floquet_states(f_modes_t, f_energies, t); psi_t = psi0_fb",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:15491,Integrability,depend,dependent,15491,"erate(tlist):; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); f_states_t = floquet_states(f_modes_t, f_energies, t); psi_t = psi0_fb.transform(f_states_t, True). if expt_callback:; # use callback method; e_ops(t, psi_t); else:; # calculate all the expectation values, or output psi if; # no expectation value operators where defined; if output.num_expect == 0:; output.states.append(Qobj(psi_t)); else:; for e_idx, e in enumerate(e_ops):; output.expect[e_idx][t_idx] = expect(e, psi_t). return output. [docs]def floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T,; args, J_cb, w_th, kmax=5,; f_modes_table_t=None):; """"""; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes. f_energies : array; The Floquet energies. c_op : :class:`qutip.qobj`; The collapse operators describing the dissipation. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`. w_th : float; The temperature in units of frequency. k_max : int; The truncation of the number of sidebands (default 5). f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table` (optional). Returns; -------. output : list. A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. """""". N = len(f_energies); M = 2 * kmax + 1. omega = (2 * pi) / T. Delta = np.zeros((N, N, M)); X = np.zeros((N, N, M), dtype=complex); Gamma = np.zeros((N, N, M)); A = np.zeros((N, N)). nT = 100; dT = T / nT",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:15552,Integrability,depend,dependence,15552,"le_t, t, T); f_states_t = floquet_states(f_modes_t, f_energies, t); psi_t = psi0_fb.transform(f_states_t, True). if expt_callback:; # use callback method; e_ops(t, psi_t); else:; # calculate all the expectation values, or output psi if; # no expectation value operators where defined; if output.num_expect == 0:; output.states.append(Qobj(psi_t)); else:; for e_idx, e in enumerate(e_ops):; output.expect[e_idx][t_idx] = expect(e, psi_t). return output. [docs]def floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T,; args, J_cb, w_th, kmax=5,; f_modes_table_t=None):; """"""; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes. f_energies : array; The Floquet energies. c_op : :class:`qutip.qobj`; The collapse operators describing the dissipation. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`. w_th : float; The temperature in units of frequency. k_max : int; The truncation of the number of sidebands (default 5). f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table` (optional). Returns; -------. output : list. A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. """""". N = len(f_energies); M = 2 * kmax + 1. omega = (2 * pi) / T. Delta = np.zeros((N, N, M)); X = np.zeros((N, N, M), dtype=complex); Gamma = np.zeros((N, N, M)); A = np.zeros((N, N)). nT = 100; dT = T / nT; tlist = np.arange(dT, T + dT / 2, dT). if f_modes_table_t is",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:21628,Integrability,integrat,integrator,21628,"nitial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]. output = Result(); output.solver = ""fmmesolve""; output.times = tlist. if isinstance(e_ops, FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; output.states = []; else:; if not f_modes_table:; raise TypeError(""The Floquet mode table has to be provided "" +; ""when requesting expectation values.""). output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # transform the initial density matrix to the eigenbasis: from; # computational basis to the floquet basis; #; if ekets is not None:; rho0 = rho0.transform(ekets). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; rho = Qobj(rho0). t_idx = 0; for t in tlist:; if not r.successful():; break. rho = Qobj(vec2mat(r.y), rho0.dims, rho0.shape). if expt_callback:; # use callback method; if floquet_basis:; e_ops(t, Qobj(rho)); else:; f_modes_table_t, T = f_modes_table; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); e_ops(t, Qobj(rho).transform(f_modes_t, True)); else:; # calculate all the expectation values, or output rho if; # no operators; if n_expt_op == 0:; if floquet_basis:; output.states.append(Qobj(rho)); else:; f_modes_table_t, T = f_modes_table; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); output.states.append(Qobj(rho).transform(f_modes_t, True)); else",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:21692,Integrability,integrat,integrate,21692,"dm(rho0). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]. output = Result(); output.solver = ""fmmesolve""; output.times = tlist. if isinstance(e_ops, FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; output.states = []; else:; if not f_modes_table:; raise TypeError(""The Floquet mode table has to be provided "" +; ""when requesting expectation values.""). output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # transform the initial density matrix to the eigenbasis: from; # computational basis to the floquet basis; #; if ekets is not None:; rho0 = rho0.transform(ekets). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; rho = Qobj(rho0). t_idx = 0; for t in tlist:; if not r.successful():; break. rho = Qobj(vec2mat(r.y), rho0.dims, rho0.shape). if expt_callback:; # use callback method; if floquet_basis:; e_ops(t, Qobj(rho)); else:; f_modes_table_t, T = f_modes_table; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); e_ops(t, Qobj(rho).transform(f_modes_t, True)); else:; # calculate all the expectation values, or output rho if; # no operators; if n_expt_op == 0:; if floquet_basis:; output.states.append(Qobj(rho)); else:; f_modes_table_t, T = f_modes_table; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); output.states.append(Qobj(rho).transform(f_modes_t, True)); else:; f_modes_table_t, T = f_modes_table; f_modes_t = f",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:22856,Integrability,integrat,integrate,22856,"opt.rtol, max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; rho = Qobj(rho0). t_idx = 0; for t in tlist:; if not r.successful():; break. rho = Qobj(vec2mat(r.y), rho0.dims, rho0.shape). if expt_callback:; # use callback method; if floquet_basis:; e_ops(t, Qobj(rho)); else:; f_modes_table_t, T = f_modes_table; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); e_ops(t, Qobj(rho).transform(f_modes_t, True)); else:; # calculate all the expectation values, or output rho if; # no operators; if n_expt_op == 0:; if floquet_basis:; output.states.append(Qobj(rho)); else:; f_modes_table_t, T = f_modes_table; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); output.states.append(Qobj(rho).transform(f_modes_t, True)); else:; f_modes_table_t, T = f_modes_table; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); for m in range(0, n_expt_op):; output.expect[m][t_idx] = \; expect(e_ops[m], rho.transform(f_modes_t, False)). r.integrate(r.t + dt); t_idx += 1. return output. # -----------------------------------------------------------------------------; # Solve the Floquet-Markov master equation; #; #; [docs]def fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None,; args={}, options=Options(), floquet_basis=True, kmax=5,; _safe_mode=True):; """"""; Solve the dynamics for the system using the Floquet-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of fre",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:23942,Integrability,depend,dependence,23942,"--------------------------------------------; # Solve the Floquet-Markov master equation; #; #; [docs]def fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None,; args={}, options=Options(), floquet_basis=True, kmax=5,; _safe_mode=True):; """"""; Solve the dynamics for the system using the Floquet-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. This dictionary should also contain an entry 'w_th', which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion. >>> temperature = 25e-3 # unit K # doctest: +SKIP; >>> h = 6.626e-34 # doctest: +SKIP; >>> kB = 1.38e-23 # doctest: +SKIP; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 \; #doctest: +SKIP. options : :class:`qutip.solver`; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns; -------. output : :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values ",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:24119,Integrability,depend,dependent,24119," args={}, options=Options(), floquet_basis=True, kmax=5,; _safe_mode=True):; """"""; Solve the dynamics for the system using the Floquet-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. This dictionary should also contain an entry 'w_th', which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion. >>> temperature = 25e-3 # unit K # doctest: +SKIP; >>> h = 6.626e-34 # doctest: +SKIP; >>> kB = 1.38e-23 # doctest: +SKIP; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 \; #doctest: +SKIP. options : :class:`qutip.solver`; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns; -------. output : :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`.; """""". if _safe_mode:; _solver_safety_check(H, rho0, c_ops, e_ops, args). if T is None:; T = max(tlist). if len(spectra_cb) == 0:; # add whi",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:3806,Modifiability,variab,variables,3806,"ve import sesolve; from qutip.rhs_generate import rhs_clear; from qutip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.states import projection; from qutip.solver import Options; from qutip.propagator import propagator; from qutip.solver import Result, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.expect import expect; from qutip.utilities import n_thermal. [docs]def floquet_modes(H, T, args=None, sort=False, U=None):; """"""; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T. Returns a list of :class:`qutip.qobj` instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter `sort`; decides if the output is to be sorted in increasing quasienergies or not. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi ",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:5677,Modifiability,variab,variables,5677,"s += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.array(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. Returns; -------. output : list of kets. The Floquet modes as kets at time :math:`t`. """"""; # find t in [0,T] such that t_orig = t + n * T for integer n; t = t - int(t / T) * T; f_modes_t = []. # get the unitary propagator from 0 to t; if t > 0.0:; U = propagator(H, t, [], args). for n in np.arange(len(f_modes_0)):; f_modes_t.append(U * f_modes_0[n] * exp(1j * f_energies[n] * t)); else:; f_modes_t = f_modes_0. return f_modes_t. [docs]def floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None):; """"""; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : :class:`qutip.q",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:6834,Modifiability,variab,variables,6834,"es as kets at time :math:`t`. """"""; # find t in [0,T] such that t_orig = t + n * T for integer n; t = t - int(t / T) * T; f_modes_t = []. # get the unitary propagator from 0 to t; if t > 0.0:; U = propagator(H, t, [], args). for n in np.arange(len(f_modes_0)):; f_modes_t.append(U * f_modes_0[n] * exp(1j * f_energies[n] * t)); else:; f_modes_t = f_modes_0. return f_modes_t. [docs]def floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None):; """"""; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; dictionary with variables required to evaluate H. Returns; -------. output : nested list. A nested list of Floquet modes as kets for each time in `tlist`. """"""; # truncate tlist to the driving period; tlist_period = tlist[np.where(tlist <= T)]. f_modes_table_t = [[] for t in tlist_period]. opt = Options(); opt.rhs_reuse = True; rhs_clear(). for n, f_mode in enumerate(f_modes_0):; output = sesolve(H, f_mode, tlist_period, [], args, opt); for t_idx, f_state_t in enumerate(output.states):; f_modes_table_t[t_idx].append(; f_state_t * exp(1j * f_energies[n] * tlist_period[t_idx])). return f_modes_table_t. [docs]def floquet_modes_t_lookup(f_modes_table_t, t, T):; """"""; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters; ----------. f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table`. t : float; The time for which to e",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:9719,Modifiability,variab,variables,9719,"time t given the Floquet modes at that time. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of Floquet modes for time :math:`t`. f_energies : array; The Floquet energies. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : list. A list of Floquet states for the time :math:`t`. """""". return [(f_modes_t[i] * exp(-1j * f_energies[i] * t)); for i in np.arange(len(f_energies))]. [docs]def floquet_states_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Evaluate the floquet states at time t given the initial Floquet modes. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. t : float; The time for which to evaluate the Floquet states. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns; -------. output : list. A list of Floquet states for the time :math:`t`. """""". f_modes_t = floquet_modes_t(f_modes_0, f_energies, t, H, T, args); return [(f_modes_t[i] * exp(-1j * f_energies[i] * t)); for i in np.arange(len(f_energies))]. [docs]def floquet_wavefunction(f_modes_t, f_energies, f_coeff, t):; """"""; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time `t`. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """"""; return sum([f_modes_t[i] * exp(-1j * f_energies[i] * t) * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:11413,Modifiability,variab,variables,11413,"sition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """"""; return sum([f_modes_t[i] * exp(-1j * f_energies[i] * t) * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None):; """"""; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes (for time :math:`t=0`). f_energies : array; The Floquet energies. f_coeff : array; The coefficients for Floquet decomposition of the initial wavefunction. t : float; The time for which to evaluate the Floquet states. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Returns; -------. output : :class:`qutip.qobj`. The wavefunction for the time :math:`t`. """""". f_states_t = floquet_states_t(f_modes_0, f_energies, t, H, T, args); return sum([f_states_t[i] * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_state_decomposition(f_states, f_energies, psi):; r""""""; Decompose the wavefunction `psi` (typically an initial state) in terms of; the Floquet states, :math:`\psi = \sum_\alpha c_\alpha \psi_\alpha(0)`. Parameters; ----------. f_states : list of :class:`qutip.qobj` (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\alpha` in the Floquet state decomposition. """"""; # [:1,:1][0, 0] patch around scipy 1.3.0 bug; return [(f_states[i].dag() * psi).data[:1, :1][0, 0]; for i in np.arange(len(f_energies))]. [docs]def fsesolve(H, psi0, tlist",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:13070,Modifiability,variab,variables,13070,"obj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\alpha` in the Floquet state decomposition. """"""; # [:1,:1][0, 0] patch around scipy 1.3.0 bug; return [(f_states[i].dag() * psi).data[:1, :1][0, 0]; for i in np.arange(len(f_energies))]. [docs]def fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100):; """"""; Solve the Schrodinger equation using the Floquet formalism. Parameters; ----------. H : :class:`qutip.qobj.Qobj`; System Hamiltonian, time-dependent with period `T`. psi0 : :class:`qutip.qobj`; Initial state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in `tlist` will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. `Tsteps` should be an even number. Returns; -------. output : :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which; contains either an *array* of expectation values or an array of; state vectors, for the times specified by `tlist`.; """""". if not T:; # assume that tlist span exactly one period of the driving; T = tlist[-1]. # find the floquet modes for the time-dependent hamiltonian; f_modes_0, f_energies = floquet_modes(H, T, args). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T, Tsteps + 1),; H, T, args). # setup Result for storing the results; output = Result(); output.times = tlist; output.solver = ""fsesolve"". if isinstance(e_ops, FunctionType):; output.num_expect = 0; expt_callback = True. elif isinstance(e_",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:15618,Modifiability,variab,variables,15618," psi_t = psi0_fb.transform(f_states_t, True). if expt_callback:; # use callback method; e_ops(t, psi_t); else:; # calculate all the expectation values, or output psi if; # no expectation value operators where defined; if output.num_expect == 0:; output.states.append(Qobj(psi_t)); else:; for e_idx, e in enumerate(e_ops):; output.expect[e_idx][t_idx] = expect(e, psi_t). return output. [docs]def floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T,; args, J_cb, w_th, kmax=5,; f_modes_table_t=None):; """"""; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes. f_energies : array; The Floquet energies. c_op : :class:`qutip.qobj`; The collapse operators describing the dissipation. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`. w_th : float; The temperature in units of frequency. k_max : int; The truncation of the number of sidebands (default 5). f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table` (optional). Returns; -------. output : list. A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. """""". N = len(f_energies); M = 2 * kmax + 1. omega = (2 * pi) / T. Delta = np.zeros((N, N, M)); X = np.zeros((N, N, M), dtype=complex); Gamma = np.zeros((N, N, M)); A = np.zeros((N, N)). nT = 100; dT = T / nT; tlist = np.arange(dT, T + dT / 2, dT). if f_modes_table_t is None:; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/floquet.html:19034,Usability,simpl,simple,19034,"on Bloch-Redfield form, or perhaps; # we can use the Lindblad form master equation with some rotating frame; # approximations? ...; #; for a in range(N):; for b in range(N):; if a != b and abs(A[a, b]) > 0.0:; # only relaxation terms included...; c_ops.append(sqrt(A[a, b]) * projection(N, a, b)). return c_ops. def floquet_master_equation_tensor(Alist, f_energies):; """"""; Construct a tensor that represents the master equation in the floquet; basis (with constant Hamiltonian and collapse operators). Simplest RWA approximation [Grifoni et al, Phys.Rep. 304 229 (1998)]. Parameters; ----------. Alist : list; A list of Floquet-Markov master equation rate matrices. f_energies : array; The Floquet energies. Returns; -------. output : array. The Floquet-Markov master equation tensor `R`. """""". if isinstance(Alist, list):; # Alist can be a list of rate matrices corresponding; # to different operators that couple to the environment; N, M = np.shape(Alist[0]); else:; # or a simple rate matrix, in which case we put it in a list; Alist = [Alist]; N, M = np.shape(Alist[0]). Rdata_lil = scipy.sparse.lil_matrix((N * N, N * N), dtype=complex); for I in range(N * N):; a, b = vec2mat_index(N, I); for J in range(N * N):; c, d = vec2mat_index(N, J). R = -1.0j * (f_energies[a] - f_energies[b])*(a == c)*(b == d); Rdata_lil[I, J] = R. for A in Alist:; s1 = s2 = 0; for n in range(N):; s1 += A[a, n] * (n == c) * (n == d) - A[n, a] * \; (a == c) * (a == d); s2 += (A[n, a] + A[n, b]) * (a == c) * (b == d). dR = (a == b) * s1 - 0.5 * (1 - (a == b)) * s2. if dR != 0.0:; Rdata_lil[I, J] += dR. return Qobj(Rdata_lil, [[N, N], [N, N]], [N*N, N*N]). [docs]def floquet_master_equation_steadystate(H, A):; """"""; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation.; """"""; c_ops = floquet_collapse_operators(A); rho_ss = steadystate(H, c_ops); return rho_ss. [docs]def floquet_basis_transform(f_modes, f_energies, rho0):; """"""; Make a basis transform that takes rho",MatchSource.WIKI,docs/4.6/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html
https://qutip.org/docs/4.6/modules/qutip/graph.html:9775,Deployability,update,updated,9775,"uare CSC; sparse matrix. Such a permutation is always possible provided that the; matrix is nonsingular. This function looks at both the structure and ABS values of the underlying; matrix. Parameters; ----------; A : csc_matrix; Input matrix. perm_type : str {'row', 'column'}; Type of permutation to generate. Returns; -------; perm : array; Array of row or column permutations. Notes; -----; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and are; traversed in descending order by weight. When performing the BFS; traversal, the row associated to a given column is the one with maximum; weight. Unlike other techniques[1]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method. References; ----------; I. S. Duff and J. Koster, ""The design and use of algorithms for permuting; large entries to the diagonal of sparse matrices"", SIAM J. Matrix Anal.; and Applics. 20, no. 4, 889 (1997).; """"""; _deprecate(); nrows = A.shape[0]; if A.shape[0] != A.shape[1]:; raise ValueError('weighted_bfs_matching requires a square matrix.'); if sp.isspmatrix_csr(A) or sp.isspmatrix_coo(A):; A = A.tocsc(); elif not sp.isspmatrix_csc(A):; raise TypeError(""matrix must be in CSC, CSR, or COO format.""). if perm_type == 'column':; A = A.transpose().tocsc(); perm = _weighted_bipartite_matching(; np.asarray(np.abs(A.data), dtype=float),; A.indices, A.indptr, nrows); if np.any(perm == -1):; raise Exception('Possibly singular input matrix.'); return perm. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/graph.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/graph.html
https://qutip.org/docs/4.6/modules/qutip/graph.html:2130,Integrability,rout,routines,2130," endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains a collection of graph theory routines used mainly; to reorder matrices for iterative steady state solvers.; """""". __all__ = ['graph_degree', 'column_permutation', 'breadth_first_search',; 'reverse_cuthill_mckee', 'maximum_bipartite_matching',; 'weighted_bipartite_matching']. import numpy as np; import scipy.sparse as sp; from qutip.cy.graph_utils import (; _breadth_first_search, _node_degrees,; _reverse_cuthill_mckee, _maximum_bipartite_matching,; _weighted_bipartite_matching); import warnings. def _deprecate():; warnings.warn((""qutip graph functions are deprecated.""; "" Consider using scipy.sparse.csgraph instead.""),; DeprecationWarning). [docs]def graph_degree(A):; """"""; Returns the degree for the nodes (rows) of a symmetric graph in sparse CSR; or CSC format, or a qobj. Parameters; ----------; A : qobj, csr_matrix, csc_matrix; Input quantum object or csr_matrix. Returns; -------; degree : array; Array of integers giving the degree for each node (row).; """"""; _deprecate(); if not (sp.is",MatchSource.WIKI,docs/4.6/modules/qutip/graph.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/graph.html
https://qutip.org/docs/4.6/modules/qutip/graph.html:5024,Integrability,rout,routine,5024,"pe[0]; start = int(start); order, levels = _breadth_first_search(A.indices, A.indptr, num_rows, start); # since maybe not all nodes are in search, check for unused entires in; # arrays; return order[order != -1], levels[levels != -1]. def column_permutation(A):; """"""; Finds the non-symmetric column permutation of A such that the columns; are given in ascending order according to the number of nonzero entries.; This is sometimes useful for decreasing the fill-in of sparse LU; factorization. Parameters; ----------; A : csc_matrix; Input sparse CSC sparse matrix. Returns; -------; perm : array; Array of permuted row and column indices.; """"""; _deprecate(); if not sp.isspmatrix_csc(A):; A = sp.csc_matrix(A); count = np.diff(A.indptr); perm = np.argsort(count); return perm. [docs]def reverse_cuthill_mckee(A, sym=False):; """"""; Returns the permutation array that orders a sparse CSR or CSC matrix in; Reverse-Cuthill McKee ordering. Since the input matrix must be symmetric,; this routine works on the matrix A+Trans(A) if the sym flag is set to False; (Default). It is assumed by default (*sym=False*) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set *sym=True*. Parameters; ----------; A : csc_matrix, csr_matrix; Input sparse CSC or CSR sparse matrix format.; sym : bool {False, True}; Flag to set whether input matrix is symmetric. Returns; -------; perm : array; Array of permuted row and column indices. Notes; -----; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines. References; ----------; E. Cuthill and J. McKee, ""Reducing the Bandwidth of Sparse Symmetric; Matrices"", ACM '69 Proceedings of the 1969 24th national conference,; (1969).; """"""; _deprecate(); if not (sp.isspmatrix_csc(A) or sp.isspmatrix_csr(A",MatchSource.WIKI,docs/4.6/modules/qutip/graph.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/graph.html
https://qutip.org/docs/4.6/modules/qutip/graph.html:5682,Integrability,rout,routine,5682," A = sp.csc_matrix(A); count = np.diff(A.indptr); perm = np.argsort(count); return perm. [docs]def reverse_cuthill_mckee(A, sym=False):; """"""; Returns the permutation array that orders a sparse CSR or CSC matrix in; Reverse-Cuthill McKee ordering. Since the input matrix must be symmetric,; this routine works on the matrix A+Trans(A) if the sym flag is set to False; (Default). It is assumed by default (*sym=False*) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set *sym=True*. Parameters; ----------; A : csc_matrix, csr_matrix; Input sparse CSC or CSR sparse matrix format.; sym : bool {False, True}; Flag to set whether input matrix is symmetric. Returns; -------; perm : array; Array of permuted row and column indices. Notes; -----; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines. References; ----------; E. Cuthill and J. McKee, ""Reducing the Bandwidth of Sparse Symmetric; Matrices"", ACM '69 Proceedings of the 1969 24th national conference,; (1969).; """"""; _deprecate(); if not (sp.isspmatrix_csc(A) or sp.isspmatrix_csr(A)):; raise TypeError('Input must be CSC or CSR sparse matrix.'); nrows = A.shape[0]; if not sym:; A = A + A.transpose(); return _reverse_cuthill_mckee(A.indices, A.indptr, nrows). [docs]def maximum_bipartite_matching(A, perm_type='row'):; """"""; Returns an array of row or column permutations that removes nonzero; elements from the diagonal of a nonsingular square CSC sparse matrix. Such; a permutation is always possible provided that the matrix is nonsingular.; This function looks at the structure of the matrix only. The input matrix will be converted to CSC matrix format if necessary. Parameters; ----------; A : sparse matrix; Input matrix. perm_type : str {'row', 'column'}; Type o",MatchSource.WIKI,docs/4.6/modules/qutip/graph.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/graph.html
https://qutip.org/docs/4.6/modules/qutip/graph.html:5788,Integrability,rout,routines,5788," A = sp.csc_matrix(A); count = np.diff(A.indptr); perm = np.argsort(count); return perm. [docs]def reverse_cuthill_mckee(A, sym=False):; """"""; Returns the permutation array that orders a sparse CSR or CSC matrix in; Reverse-Cuthill McKee ordering. Since the input matrix must be symmetric,; this routine works on the matrix A+Trans(A) if the sym flag is set to False; (Default). It is assumed by default (*sym=False*) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set *sym=True*. Parameters; ----------; A : csc_matrix, csr_matrix; Input sparse CSC or CSR sparse matrix format.; sym : bool {False, True}; Flag to set whether input matrix is symmetric. Returns; -------; perm : array; Array of permuted row and column indices. Notes; -----; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines. References; ----------; E. Cuthill and J. McKee, ""Reducing the Bandwidth of Sparse Symmetric; Matrices"", ACM '69 Proceedings of the 1969 24th national conference,; (1969).; """"""; _deprecate(); if not (sp.isspmatrix_csc(A) or sp.isspmatrix_csr(A)):; raise TypeError('Input must be CSC or CSR sparse matrix.'); nrows = A.shape[0]; if not sym:; A = A + A.transpose(); return _reverse_cuthill_mckee(A.indices, A.indptr, nrows). [docs]def maximum_bipartite_matching(A, perm_type='row'):; """"""; Returns an array of row or column permutations that removes nonzero; elements from the diagonal of a nonsingular square CSC sparse matrix. Such; a permutation is always possible provided that the matrix is nonsingular.; This function looks at the structure of the matrix only. The input matrix will be converted to CSC matrix format if necessary. Parameters; ----------; A : sparse matrix; Input matrix. perm_type : str {'row', 'column'}; Type o",MatchSource.WIKI,docs/4.6/modules/qutip/graph.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/graph.html
https://qutip.org/docs/4.6/modules/qutip/graph.html:8533,Performance,perform,performing,8533,"s); if np.any(perm == -1):; raise Exception('Possibly singular input matrix.'); return perm. [docs]def weighted_bipartite_matching(A, perm_type='row'):; """"""; Returns an array of row permutations that attempts to maximize the product; of the ABS values of the diagonal elements in a nonsingular square CSC; sparse matrix. Such a permutation is always possible provided that the; matrix is nonsingular. This function looks at both the structure and ABS values of the underlying; matrix. Parameters; ----------; A : csc_matrix; Input matrix. perm_type : str {'row', 'column'}; Type of permutation to generate. Returns; -------; perm : array; Array of row or column permutations. Notes; -----; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and are; traversed in descending order by weight. When performing the BFS; traversal, the row associated to a given column is the one with maximum; weight. Unlike other techniques[1]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method. References; ----------; I. S. Duff and J. Koster, ""The design and use of algorithms for permuting; large entries to the diagonal of sparse matrices"", SIAM J. Matrix Anal.; and Applics. 20, no. 4, 889 (1997).; """"""; _deprecate(); nrows = A.shape[0]; if A.shape[0] != A.shape[1]:; raise ValueError('weighted_bfs_matching requires a square matrix.'); if sp.isspmatrix_csr(A) or sp.isspmatrix_coo(A):; A = A.tocsc(); elif not sp.isspmatrix_csc(A):; raise TypeError(""matrix must be in CSC, CSR, or COO format.""). if perm_type == 'column':; A = A.transpose().tocsc(); perm = _weighted_bipartite_matching(; np.asarray(np.abs(A.data), dtype=float),; A.indices, A.indptr, nrows); if np.any(perm == -1):; raise Exception('Possibly singular input matrix.'); return",MatchSource.WIKI,docs/4.6/modules/qutip/graph.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/graph.html
https://qutip.org/docs/4.6/modules/qutip/interpolate.html:4890,Deployability,update,updated,4890,"ting function.; ; Habermann & Kindermann, ""Multidimensional Spline Interpolation: ; Theory and Applications"", Comput Econ 30, 153 (2007). ; ; '''; ; def __init__(self, a, b, y, alpha=0, beta=0):; y = np.asarray(y); n = y.shape[0] - 1; h = (b - a)/n. coeff = np.zeros(n + 3, dtype=y.dtype); # Solutions to boundary coeffcients of spline; coeff[1] = 1/6. * (y[0] - (alpha * h**2)/6) #C2 in paper; coeff[n + 1] = 1/6. * (y[n] - (beta * h**2)/6) #cn+2 in paper. # Compressed tridiagonal matrix ; ab = np.ones((3, n - 1), dtype=float); ab[0,0] = 0 # Because top row is upper diag with one less elem; ab[1, :] = 4; ab[-1,-1] = 0 # Because bottom row is lower diag with one less elem; ; B = y[1:-1].copy() #grabs elements y[1] - > y[n-2] for reduced array; B[0] -= coeff[1]; B[-1] -= coeff[n + 1]. coeff[2:-2] = la.solve_banded((1, 1), ab, B, overwrite_ab=True, ; overwrite_b=True, check_finite=False). coeff[0] = alpha * h**2/6. + 2 * coeff[1] - coeff[2]; coeff[-1] = beta * h**2/6. + 2 * coeff[-2] - coeff[-3]. self.a = a # Lower-bound of domain; self.b = b # Uppser-bound of domain; self.coeffs = coeff # Spline coefficients; self.is_complex = (y.dtype == complex) #Tells which dtype solver to use; ; def __call__(self, pnts, *args):; #If requesting a single return value; if isinstance(pnts, (int, float, complex)):; if self.is_complex:; return zinterp(pnts, self.a, ; self.b, self.coeffs); else:; return interp(pnts, self.a, self.b, self.coeffs); #If requesting multiple return values from array_like; elif isinstance(pnts, (np.ndarray,list)):; pnts = np.asarray(pnts); if self.is_complex:; return arr_zinterp(pnts, self.a, ; self.b, self.coeffs); else:; return arr_interp(pnts, self.a, self.b, self.coeffs); ; . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/interpolate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/interpolate.html
https://qutip.org/docs/4.6/modules/qutip/interpolate.html:3726,Energy Efficiency,reduce,reduced,3726," the interval.; b : float; Upper bound of the interval.; coeffs : ndarray; Array of coeffcients defining cubic spline.; ; Notes; -----; This object can be called like a normal function with a; single or array of input points at which to evaluate; the interplating function.; ; Habermann & Kindermann, ""Multidimensional Spline Interpolation: ; Theory and Applications"", Comput Econ 30, 153 (2007). ; ; '''; ; def __init__(self, a, b, y, alpha=0, beta=0):; y = np.asarray(y); n = y.shape[0] - 1; h = (b - a)/n. coeff = np.zeros(n + 3, dtype=y.dtype); # Solutions to boundary coeffcients of spline; coeff[1] = 1/6. * (y[0] - (alpha * h**2)/6) #C2 in paper; coeff[n + 1] = 1/6. * (y[n] - (beta * h**2)/6) #cn+2 in paper. # Compressed tridiagonal matrix ; ab = np.ones((3, n - 1), dtype=float); ab[0,0] = 0 # Because top row is upper diag with one less elem; ab[1, :] = 4; ab[-1,-1] = 0 # Because bottom row is lower diag with one less elem; ; B = y[1:-1].copy() #grabs elements y[1] - > y[n-2] for reduced array; B[0] -= coeff[1]; B[-1] -= coeff[n + 1]. coeff[2:-2] = la.solve_banded((1, 1), ab, B, overwrite_ab=True, ; overwrite_b=True, check_finite=False). coeff[0] = alpha * h**2/6. + 2 * coeff[1] - coeff[2]; coeff[-1] = beta * h**2/6. + 2 * coeff[-2] - coeff[-3]. self.a = a # Lower-bound of domain; self.b = b # Uppser-bound of domain; self.coeffs = coeff # Spline coefficients; self.is_complex = (y.dtype == complex) #Tells which dtype solver to use; ; def __call__(self, pnts, *args):; #If requesting a single return value; if isinstance(pnts, (int, float, complex)):; if self.is_complex:; return zinterp(pnts, self.a, ; self.b, self.coeffs); else:; return interp(pnts, self.a, self.b, self.coeffs); #If requesting multiple return values from array_like; elif isinstance(pnts, (np.ndarray,list)):; pnts = np.asarray(pnts); if self.is_complex:; return arr_zinterp(pnts, self.a, ; self.b, self.coeffs); else:; return arr_interp(pnts, self.a, self.b, self.coeffs); ; . © Copyright 2011 and later, P.",MatchSource.WIKI,docs/4.6/modules/qutip/interpolate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/interpolate.html
https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html:10888,Availability,avail,available,10888,"Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; writer=""avconv"", codec=""libx264"", verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the ",MatchSource.WIKI,docs/4.6/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html:4975,Deployability,update,update,4975,"""IPython"", IPython.__version__),; (""Python"", sys.version),; (""OS"", ""%s [%s]"" % (os.name, sys.platform)); ]. for name, version in packages:; html += ""<tr><td>%s</td><td>%s</td></tr>"" % (name, version). if verbose:; html += ""<tr><th colspan='2'>Additional information</th></tr>""; qutip_install_path = os.path.dirname(inspect.getsourcefile(qutip)); html += (""<tr><td>Installation path</td><td>%s</td></tr>"" %; qutip_install_path); try:; import getpass; html += (""<tr><td>User</td><td>%s</td></tr>"" %; getpass.getuser()); except:; pass. html += ""<tr><td colspan='2'>%s</td></tr>"" % time.strftime(; '%a %b %d %H:%M:%S %Y %Z'); html += ""</table>"". return HTML(html). class HTMLProgressBar(BaseProgressBar):; """"""; A simple HTML progress bar for using in IPython notebooks. Based on; IPython ProgressBar demo notebook:; https://github.com/ipython/ipython/tree/master/examples/notebooks. Example usage:. n_vec = linspace(0, 10, 100); pbar = HTMLProgressBar(len(n_vec)); for n in n_vec:; pbar.update(n); compute_with_n(n); """""". def __init__(self, iterations=0, chunk_size=1.0):; self.divid = str(uuid.uuid4()); self.textid = str(uuid.uuid4()); self.pb = HTML(""""""\; <div style=""border: 2px solid grey; width: 600px"">; <div id=""%s"" \; style=""background-color: rgba(121,195,106,0.75); width:0%%"">&nbsp;</div>; </div>; <p id=""%s""></p>; """""" % (self.divid, self.textid)); display(self.pb); super(HTMLProgressBar, self).start(iterations, chunk_size). def start(self, iterations=0, chunk_size=1.0):; super(HTMLProgressBar, self).start(iterations, chunk_size). def update(self, n):; p = (n / self.N) * 100.0; if p >= self.p_chunk:; lbl = (""Elapsed time: %s. "" % self.time_elapsed() +; ""Est. remaining time: %s."" % self.time_remaining_est(p)); js_code = (""$('div#%s').width('%i%%');"" % (self.divid, p) +; ""$('p#%s').text('%s');"" % (self.textid, lbl)); display(Javascript(js_code)); # display(Javascript(""$('div#%s').width('%i%%')"" % (self.divid,; # p))); self.p_chunk += self.p_chunk_size. def finished(self):; self.t_do",MatchSource.WIKI,docs/4.6/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html:5538,Deployability,update,update,5538,"2'>%s</td></tr>"" % time.strftime(; '%a %b %d %H:%M:%S %Y %Z'); html += ""</table>"". return HTML(html). class HTMLProgressBar(BaseProgressBar):; """"""; A simple HTML progress bar for using in IPython notebooks. Based on; IPython ProgressBar demo notebook:; https://github.com/ipython/ipython/tree/master/examples/notebooks. Example usage:. n_vec = linspace(0, 10, 100); pbar = HTMLProgressBar(len(n_vec)); for n in n_vec:; pbar.update(n); compute_with_n(n); """""". def __init__(self, iterations=0, chunk_size=1.0):; self.divid = str(uuid.uuid4()); self.textid = str(uuid.uuid4()); self.pb = HTML(""""""\; <div style=""border: 2px solid grey; width: 600px"">; <div id=""%s"" \; style=""background-color: rgba(121,195,106,0.75); width:0%%"">&nbsp;</div>; </div>; <p id=""%s""></p>; """""" % (self.divid, self.textid)); display(self.pb); super(HTMLProgressBar, self).start(iterations, chunk_size). def start(self, iterations=0, chunk_size=1.0):; super(HTMLProgressBar, self).start(iterations, chunk_size). def update(self, n):; p = (n / self.N) * 100.0; if p >= self.p_chunk:; lbl = (""Elapsed time: %s. "" % self.time_elapsed() +; ""Est. remaining time: %s."" % self.time_remaining_est(p)); js_code = (""$('div#%s').width('%i%%');"" % (self.divid, p) +; ""$('p#%s').text('%s');"" % (self.textid, lbl)); display(Javascript(js_code)); # display(Javascript(""$('div#%s').width('%i%%')"" % (self.divid,; # p))); self.p_chunk += self.p_chunk_size. def finished(self):; self.t_done = time.time(); lbl = ""Elapsed time: %s"" % self.time_elapsed(); js_code = (""$('div#%s').width('%i%%');"" % (self.divid, 100.0) +; ""$('p#%s').text('%s');"" % (self.textid, lbl)); display(Javascript(js_code)). def _visualize_parfor_data(metadata):; """"""; Visualizing the task scheduling meta data collected from AsyncResults.; """"""; res = numpy.array(metadata); fig, ax = plt.subplots(figsize=(10, res.shape[1])). yticks = []; yticklabels = []; tmin = min(res[:, 1]); for n, pid in enumerate(numpy.unique(res[:, 0])):; yticks.append(n); yticklabels.append(""%d"" % p",MatchSource.WIKI,docs/4.6/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html:11363,Deployability,update,update,11363,"vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; writer=""avconv"", codec=""libx264"", verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the qutip evolution solvers. .. note :: experimental; """""". fig, axes = plot_setup_func(result). def update(n):; return plot_func(result, n, fig=fig, axes=axes). anim = animation.FuncAnimation(; fig, update, frames=len(result.times), blit=True). anim.save(name + '.mp4', fps=10, writer=writer, codec=codec). plt.close(fig). if verbose:; print(""Created %s.m4v"" % name). video = open(name + '.mp4', ""rb"").read(); video_encoded = b64encode(video).decode(""ascii""); video_tag = '<vi",MatchSource.WIKI,docs/4.6/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html:11433,Deployability,update,update,11433," {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; writer=""avconv"", codec=""libx264"", verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the qutip evolution solvers. .. note :: experimental; """""". fig, axes = plot_setup_func(result). def update(n):; return plot_func(result, n, fig=fig, axes=axes). anim = animation.FuncAnimation(; fig, update, frames=len(result.times), blit=True). anim.save(name + '.mp4', fps=10, writer=writer, codec=codec). plt.close(fig). if verbose:; print(""Created %s.m4v"" % name). video = open(name + '.mp4', ""rb"").read(); video_encoded = b64encode(video).decode(""ascii""); video_tag = '<video controls src=""data:video/x-m4v;base64,{0}"">'.format(; video_encoded); re",MatchSource.WIKI,docs/4.6/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html:11997,Deployability,update,update,11997,"e:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; writer=""avconv"", codec=""libx264"", verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the qutip evolution solvers. .. note :: experimental; """""". fig, axes = plot_setup_func(result). def update(n):; return plot_func(result, n, fig=fig, axes=axes). anim = animation.FuncAnimation(; fig, update, frames=len(result.times), blit=True). anim.save(name + '.mp4', fps=10, writer=writer, codec=codec). plt.close(fig). if verbose:; print(""Created %s.m4v"" % name). video = open(name + '.mp4', ""rb"").read(); video_encoded = b64encode(video).decode(""ascii""); video_tag = '<video controls src=""data:video/x-m4v;base64,{0}"">'.format(; video_encoded); return HTML(video_tag). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html:12096,Deployability,update,update,12096,"e:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; writer=""avconv"", codec=""libx264"", verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the qutip evolution solvers. .. note :: experimental; """""". fig, axes = plot_setup_func(result). def update(n):; return plot_func(result, n, fig=fig, axes=axes). anim = animation.FuncAnimation(; fig, update, frames=len(result.times), blit=True). anim.save(name + '.mp4', fps=10, writer=writer, codec=codec). plt.close(fig). if verbose:; print(""Created %s.m4v"" % name). video = open(name + '.mp4', ""rb"").read(); video_encoded = b64encode(video).decode(""ascii""); video_tag = '<video controls src=""data:video/x-m4v;base64,{0}"">'.format(; video_encoded); return HTML(video_tag). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html:12659,Deployability,update,updated,12659,"e:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; writer=""avconv"", codec=""libx264"", verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the qutip evolution solvers. .. note :: experimental; """""". fig, axes = plot_setup_func(result). def update(n):; return plot_func(result, n, fig=fig, axes=axes). anim = animation.FuncAnimation(; fig, update, frames=len(result.times), blit=True). anim.save(name + '.mp4', fps=10, writer=writer, codec=codec). plt.close(fig). if verbose:; print(""Created %s.m4v"" % name). video = open(name + '.mp4', ""rb"").read(); video_encoded = b64encode(video).decode(""ascii""); video_tag = '<video controls src=""data:video/x-m4v;base64,{0}"">'.format(; video_encoded); return HTML(video_tag). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html:6265,Energy Efficiency,schedul,scheduling,6265,",0.75); width:0%%"">&nbsp;</div>; </div>; <p id=""%s""></p>; """""" % (self.divid, self.textid)); display(self.pb); super(HTMLProgressBar, self).start(iterations, chunk_size). def start(self, iterations=0, chunk_size=1.0):; super(HTMLProgressBar, self).start(iterations, chunk_size). def update(self, n):; p = (n / self.N) * 100.0; if p >= self.p_chunk:; lbl = (""Elapsed time: %s. "" % self.time_elapsed() +; ""Est. remaining time: %s."" % self.time_remaining_est(p)); js_code = (""$('div#%s').width('%i%%');"" % (self.divid, p) +; ""$('p#%s').text('%s');"" % (self.textid, lbl)); display(Javascript(js_code)); # display(Javascript(""$('div#%s').width('%i%%')"" % (self.divid,; # p))); self.p_chunk += self.p_chunk_size. def finished(self):; self.t_done = time.time(); lbl = ""Elapsed time: %s"" % self.time_elapsed(); js_code = (""$('div#%s').width('%i%%');"" % (self.divid, 100.0) +; ""$('p#%s').text('%s');"" % (self.textid, lbl)); display(Javascript(js_code)). def _visualize_parfor_data(metadata):; """"""; Visualizing the task scheduling meta data collected from AsyncResults.; """"""; res = numpy.array(metadata); fig, ax = plt.subplots(figsize=(10, res.shape[1])). yticks = []; yticklabels = []; tmin = min(res[:, 1]); for n, pid in enumerate(numpy.unique(res[:, 0])):; yticks.append(n); yticklabels.append(""%d"" % pid); for m in numpy.where(res[:, 0] == pid)[0]:; ax.add_patch(plt.Rectangle((res[m, 1] - tmin, n - 0.25),; res[m, 2] - res[m, 1], 0.5, color=""green"", alpha=0.5)). ax.set_ylim(-.5, n + .5); ax.set_xlim(0, max(res[:, 2]) - tmin + 0.); ax.set_yticks(yticks); ax.set_yticklabels(yticklabels); ax.set_ylabel(""Engine""); ax.set_xlabel(""seconds""); ax.set_title(""Task schedule""). [docs]def parfor(task, task_vec, args=None, client=None, view=None,; show_scheduling=False, show_progressbar=False):; """"""; Call the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``cl",MatchSource.WIKI,docs/4.6/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html:6694,Energy Efficiency,green,green,6694,"remaining_est(p)); js_code = (""$('div#%s').width('%i%%');"" % (self.divid, p) +; ""$('p#%s').text('%s');"" % (self.textid, lbl)); display(Javascript(js_code)); # display(Javascript(""$('div#%s').width('%i%%')"" % (self.divid,; # p))); self.p_chunk += self.p_chunk_size. def finished(self):; self.t_done = time.time(); lbl = ""Elapsed time: %s"" % self.time_elapsed(); js_code = (""$('div#%s').width('%i%%');"" % (self.divid, 100.0) +; ""$('p#%s').text('%s');"" % (self.textid, lbl)); display(Javascript(js_code)). def _visualize_parfor_data(metadata):; """"""; Visualizing the task scheduling meta data collected from AsyncResults.; """"""; res = numpy.array(metadata); fig, ax = plt.subplots(figsize=(10, res.shape[1])). yticks = []; yticklabels = []; tmin = min(res[:, 1]); for n, pid in enumerate(numpy.unique(res[:, 0])):; yticks.append(n); yticklabels.append(""%d"" % pid); for m in numpy.where(res[:, 0] == pid)[0]:; ax.add_patch(plt.Rectangle((res[m, 1] - tmin, n - 0.25),; res[m, 2] - res[m, 1], 0.5, color=""green"", alpha=0.5)). ax.set_ylim(-.5, n + .5); ax.set_xlim(0, max(res[:, 2]) - tmin + 0.); ax.set_yticks(yticks); ax.set_yticklabels(yticklabels); ax.set_ylabel(""Engine""); ax.set_xlabel(""seconds""); ax.set_title(""Task schedule""). [docs]def parfor(task, task_vec, args=None, client=None, view=None,; show_scheduling=False, show_progressbar=False):; """"""; Call the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional addition",MatchSource.WIKI,docs/4.6/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html:6911,Energy Efficiency,schedul,schedule,6911,"lf.divid,; # p))); self.p_chunk += self.p_chunk_size. def finished(self):; self.t_done = time.time(); lbl = ""Elapsed time: %s"" % self.time_elapsed(); js_code = (""$('div#%s').width('%i%%');"" % (self.divid, 100.0) +; ""$('p#%s').text('%s');"" % (self.textid, lbl)); display(Javascript(js_code)). def _visualize_parfor_data(metadata):; """"""; Visualizing the task scheduling meta data collected from AsyncResults.; """"""; res = numpy.array(metadata); fig, ax = plt.subplots(figsize=(10, res.shape[1])). yticks = []; yticklabels = []; tmin = min(res[:, 1]); for n, pid in enumerate(numpy.unique(res[:, 0])):; yticks.append(n); yticklabels.append(""%d"" % pid); for m in numpy.where(res[:, 0] == pid)[0]:; ax.add_patch(plt.Rectangle((res[m, 1] - tmin, n - 0.25),; res[m, 2] - res[m, 1], 0.5, color=""green"", alpha=0.5)). ax.set_ylim(-.5, n + .5); ax.set_xlim(0, max(res[:, 2]) - tmin + 0.); ax.set_yticks(yticks); ax.set_yticklabels(yticklabels); ax.set_ylabel(""Engine""); ax.set_xlabel(""seconds""); ax.set_title(""Task schedule""). [docs]def parfor(task, task_vec, args=None, client=None, view=None,; show_scheduling=False, show_progressbar=False):; """"""; Call the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional additional argument to the ``task`` function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPy",MatchSource.WIKI,docs/4.6/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html:7967,Energy Efficiency,schedul,scheduling,7967,"client=None, view=None,; show_scheduling=False, show_progressbar=False):; """"""; Call the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional additional argument to the ``task`` function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of ``task(value, args)`` for each; value in ``task_vec``, that is, it should be equivalent to; ``[task(v, args) for v in task_vec]``.; """""". if show_progressbar:; progress_bar = HTMLProgressBar(); else:; progress_bar = None. return parallel_map(task, task_vec, task_args=args,; client=client, view=view, progress_bar=progress_bar,; show_scheduling=show_scheduling). [docs]def parallel_map(task, values, task_",MatchSource.WIKI,docs/4.6/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html:8322,Energy Efficiency,schedul,scheduled,8322,"` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional additional argument to the ``task`` function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of ``task(value, args)`` for each; value in ``task_vec``, that is, it should be equivalent to; ``[task(v, args) for v in task_vec]``.; """""". if show_progressbar:; progress_bar = HTMLProgressBar(); else:; progress_bar = None. return parallel_map(task, task_vec, task_args=args,; client=client, view=view, progress_bar=progress_bar,; show_scheduling=show_scheduling). [docs]def parallel_map(task, values, task_args=None, task_kwargs=None,; client=None, view=None, progress_bar=None,; show_scheduling=False, **kwargs):; """"""; Call the function ``task`` for each value in ``values`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, *args, **kwargs)``. The `",MatchSource.WIKI,docs/4.6/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html:10029,Energy Efficiency,schedul,scheduling,10029,"s_bar=None,; show_scheduling=False, **kwargs):; """"""; Call the function ``task`` for each value in ``values`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, *args, **kwargs)``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. values: array / list; The list or array of values for which the ``task`` function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the ``task`` function. task_kwargs: list / dictionary; The optional additional keyword argument to the ``task`` function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanc",MatchSource.WIKI,docs/4.6/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html:10384,Energy Efficiency,schedul,scheduled,10384,"oad-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. values: array / list; The list or array of values for which the ``task`` function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the ``task`` function. task_kwargs: list / dictionary; The optional additional keyword argument to the ``task`` function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progr",MatchSource.WIKI,docs/4.6/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html:2325,Integrability,rout,routines,2325,"ED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains utility functions for using QuTiP with IPython notebooks.; """"""; from qutip.ui.progressbar import BaseProgressBar; from qutip.utilities import _blas_info, available_cpu_count; import IPython. #IPython parallel routines moved to ipyparallel in V4; #IPython parallel routines not in Anaconda by default; if IPython.version_info[0] >= 4:; try:; from ipyparallel import Client; __all__ = ['version_table', 'parfor', 'plot_animation',; 'parallel_map', 'HTMLProgressBar']; except:; __all__ = ['version_table', 'plot_animation', 'HTMLProgressBar']; else:; try:; from IPython.parallel import Client; __all__ = ['version_table', 'parfor', 'plot_animation',; 'parallel_map', 'HTMLProgressBar']; except:; __all__ = ['version_table', 'plot_animation', 'HTMLProgressBar']. from IPython.display import HTML, Javascript, display. import matplotlib.pyplot as plt; from matplotlib import animation; from base64 import b64encode. import datetime; import uuid; import sys; import os; import time; import inspect. import qutip; import numpy; import scipy; import Cython; import matplotlib; import IPython. [docs]def version_table(verbose=False):; """"""; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show",MatchSource.WIKI,docs/4.6/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html:2380,Integrability,rout,routines,2380,"ED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains utility functions for using QuTiP with IPython notebooks.; """"""; from qutip.ui.progressbar import BaseProgressBar; from qutip.utilities import _blas_info, available_cpu_count; import IPython. #IPython parallel routines moved to ipyparallel in V4; #IPython parallel routines not in Anaconda by default; if IPython.version_info[0] >= 4:; try:; from ipyparallel import Client; __all__ = ['version_table', 'parfor', 'plot_animation',; 'parallel_map', 'HTMLProgressBar']; except:; __all__ = ['version_table', 'plot_animation', 'HTMLProgressBar']; else:; try:; from IPython.parallel import Client; __all__ = ['version_table', 'parfor', 'plot_animation',; 'parallel_map', 'HTMLProgressBar']; except:; __all__ = ['version_table', 'plot_animation', 'HTMLProgressBar']. from IPython.display import HTML, Javascript, display. import matplotlib.pyplot as plt; from matplotlib import animation; from base64 import b64encode. import datetime; import uuid; import sys; import os; import time; import inspect. import qutip; import numpy; import scipy; import Cython; import matplotlib; import IPython. [docs]def version_table(verbose=False):; """"""; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show",MatchSource.WIKI,docs/4.6/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html:3317,Integrability,depend,dependencies,3317,"nfo, available_cpu_count; import IPython. #IPython parallel routines moved to ipyparallel in V4; #IPython parallel routines not in Anaconda by default; if IPython.version_info[0] >= 4:; try:; from ipyparallel import Client; __all__ = ['version_table', 'parfor', 'plot_animation',; 'parallel_map', 'HTMLProgressBar']; except:; __all__ = ['version_table', 'plot_animation', 'HTMLProgressBar']; else:; try:; from IPython.parallel import Client; __all__ = ['version_table', 'parfor', 'plot_animation',; 'parallel_map', 'HTMLProgressBar']; except:; __all__ = ['version_table', 'plot_animation', 'HTMLProgressBar']. from IPython.display import HTML, Javascript, display. import matplotlib.pyplot as plt; from matplotlib import animation; from base64 import b64encode. import datetime; import uuid; import sys; import os; import time; import inspect. import qutip; import numpy; import scipy; import Cython; import matplotlib; import IPython. [docs]def version_table(verbose=False):; """"""; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns; --------; version_table: string; Return an HTML-formatted string containing version information for; QuTiP dependencies. """""". html = ""<table>""; html += ""<tr><th>Software</th><th>Version</th></tr>"". packages = [(""QuTiP"", qutip.__version__),; (""Numpy"", numpy.__version__),; (""SciPy"", scipy.__version__),; (""matplotlib"", matplotlib.__version__),; (""Cython"", Cython.__version__),; (""Number of CPUs"", available_cpu_count()),; (""BLAS Info"", _blas_info()),; (""IPython"", IPython.__version__),; (""Python"", sys.version),; (""OS"", ""%s [%s]"" % (os.name, sys.platform)); ]. for name, version in packages:; html += ""<tr><td>%s</td><td>%s</td></tr>"" % (name, version). if verbose:; html += ""<tr><th colspan='2'>Additional information</th></t",MatchSource.WIKI,docs/4.6/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html:3647,Integrability,depend,dependencies,3647,"l__ = ['version_table', 'plot_animation', 'HTMLProgressBar']; else:; try:; from IPython.parallel import Client; __all__ = ['version_table', 'parfor', 'plot_animation',; 'parallel_map', 'HTMLProgressBar']; except:; __all__ = ['version_table', 'plot_animation', 'HTMLProgressBar']. from IPython.display import HTML, Javascript, display. import matplotlib.pyplot as plt; from matplotlib import animation; from base64 import b64encode. import datetime; import uuid; import sys; import os; import time; import inspect. import qutip; import numpy; import scipy; import Cython; import matplotlib; import IPython. [docs]def version_table(verbose=False):; """"""; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns; --------; version_table: string; Return an HTML-formatted string containing version information for; QuTiP dependencies. """""". html = ""<table>""; html += ""<tr><th>Software</th><th>Version</th></tr>"". packages = [(""QuTiP"", qutip.__version__),; (""Numpy"", numpy.__version__),; (""SciPy"", scipy.__version__),; (""matplotlib"", matplotlib.__version__),; (""Cython"", Cython.__version__),; (""Number of CPUs"", available_cpu_count()),; (""BLAS Info"", _blas_info()),; (""IPython"", IPython.__version__),; (""Python"", sys.version),; (""OS"", ""%s [%s]"" % (os.name, sys.platform)); ]. for name, version in packages:; html += ""<tr><td>%s</td><td>%s</td></tr>"" % (name, version). if verbose:; html += ""<tr><th colspan='2'>Additional information</th></tr>""; qutip_install_path = os.path.dirname(inspect.getsourcefile(qutip)); html += (""<tr><td>Installation path</td><td>%s</td></tr>"" %; qutip_install_path); try:; import getpass; html += (""<tr><td>User</td><td>%s</td></tr>"" %; getpass.getuser()); except:; pass. html += ""<tr><td colspan='2'>%s</td></tr>"" % time.strftime(; '%a %b %d",MatchSource.WIKI,docs/4.6/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html:7314,Performance,load,load-balanced,7314,"rray(metadata); fig, ax = plt.subplots(figsize=(10, res.shape[1])). yticks = []; yticklabels = []; tmin = min(res[:, 1]); for n, pid in enumerate(numpy.unique(res[:, 0])):; yticks.append(n); yticklabels.append(""%d"" % pid); for m in numpy.where(res[:, 0] == pid)[0]:; ax.add_patch(plt.Rectangle((res[m, 1] - tmin, n - 0.25),; res[m, 2] - res[m, 1], 0.5, color=""green"", alpha=0.5)). ax.set_ylim(-.5, n + .5); ax.set_xlim(0, max(res[:, 2]) - tmin + 0.); ax.set_yticks(yticks); ax.set_yticklabels(yticklabels); ax.set_ylabel(""Engine""); ax.set_xlabel(""seconds""); ax.set_title(""Task schedule""). [docs]def parfor(task, task_vec, args=None, client=None, view=None,; show_scheduling=False, show_progressbar=False):; """"""; Call the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional additional argument to the ``task`` function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on",MatchSource.WIKI,docs/4.6/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html:8026,Performance,load,load-balanced,8026,"all the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional additional argument to the ``task`` function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of ``task(value, args)`` for each; value in ``task_vec``, that is, it should be equivalent to; ``[task(v, args) for v in task_vec]``.; """""". if show_progressbar:; progress_bar = HTMLProgressBar(); else:; progress_bar = None. return parallel_map(task, task_vec, task_args=args,; client=client, view=view, progress_bar=progress_bar,; show_scheduling=show_scheduling). [docs]def parallel_map(task, values, task_args=None, task_kwargs=None,; client=None, view=None, progress_bar=None,; show_",MatchSource.WIKI,docs/4.6/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html:9323,Performance,load,load-balanced,9323,"hon engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of ``task(value, args)`` for each; value in ``task_vec``, that is, it should be equivalent to; ``[task(v, args) for v in task_vec]``.; """""". if show_progressbar:; progress_bar = HTMLProgressBar(); else:; progress_bar = None. return parallel_map(task, task_vec, task_args=args,; client=client, view=view, progress_bar=progress_bar,; show_scheduling=show_scheduling). [docs]def parallel_map(task, values, task_args=None, task_kwargs=None,; client=None, view=None, progress_bar=None,; show_scheduling=False, **kwargs):; """"""; Call the function ``task`` for each value in ``values`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, *args, **kwargs)``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. values: array / list; The list or array of values for which the ``task`` function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the ``task`` function. task_kwargs: list / dictionary; The optional additional keyword argument to the ``task`` function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` ",MatchSource.WIKI,docs/4.6/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html:10088,Performance,load,load-balanced,10088,"for each value in ``values`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, *args, **kwargs)``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. values: array / list; The list or array of values for which the ``task`` function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the ``task`` function. task_kwargs: list / dictionary; The optional additional keyword argument to the ``task`` function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs);",MatchSource.WIKI,docs/4.6/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html:11405,Safety,timeout,timeout,11405,"ython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; writer=""avconv"", codec=""libx264"", verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the qutip evolution solvers. .. note :: experimental; """""". fig, axes = plot_setup_func(result). def update(n):; return plot_func(result, n, fig=fig, axes=axes). anim = animation.FuncAnimation(; fig, update, frames=len(result.times), blit=True). anim.save(name + '.mp4', fps=10, writer=writer, codec=codec). plt.close(fig). if verbose:; print(""Created %s.m4v"" % name). video = open(name + '.mp4', ""rb"").read(); video_encoded = b64encode(video).decode(""ascii""); video_tag = '<video controls src=""data:video/x",MatchSource.WIKI,docs/4.6/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html:4701,Usability,simpl,simple,4701,"tware</th><th>Version</th></tr>"". packages = [(""QuTiP"", qutip.__version__),; (""Numpy"", numpy.__version__),; (""SciPy"", scipy.__version__),; (""matplotlib"", matplotlib.__version__),; (""Cython"", Cython.__version__),; (""Number of CPUs"", available_cpu_count()),; (""BLAS Info"", _blas_info()),; (""IPython"", IPython.__version__),; (""Python"", sys.version),; (""OS"", ""%s [%s]"" % (os.name, sys.platform)); ]. for name, version in packages:; html += ""<tr><td>%s</td><td>%s</td></tr>"" % (name, version). if verbose:; html += ""<tr><th colspan='2'>Additional information</th></tr>""; qutip_install_path = os.path.dirname(inspect.getsourcefile(qutip)); html += (""<tr><td>Installation path</td><td>%s</td></tr>"" %; qutip_install_path); try:; import getpass; html += (""<tr><td>User</td><td>%s</td></tr>"" %; getpass.getuser()); except:; pass. html += ""<tr><td colspan='2'>%s</td></tr>"" % time.strftime(; '%a %b %d %H:%M:%S %Y %Z'); html += ""</table>"". return HTML(html). class HTMLProgressBar(BaseProgressBar):; """"""; A simple HTML progress bar for using in IPython notebooks. Based on; IPython ProgressBar demo notebook:; https://github.com/ipython/ipython/tree/master/examples/notebooks. Example usage:. n_vec = linspace(0, 10, 100); pbar = HTMLProgressBar(len(n_vec)); for n in n_vec:; pbar.update(n); compute_with_n(n); """""". def __init__(self, iterations=0, chunk_size=1.0):; self.divid = str(uuid.uuid4()); self.textid = str(uuid.uuid4()); self.pb = HTML(""""""\; <div style=""border: 2px solid grey; width: 600px"">; <div id=""%s"" \; style=""background-color: rgba(121,195,106,0.75); width:0%%"">&nbsp;</div>; </div>; <p id=""%s""></p>; """""" % (self.divid, self.textid)); display(self.pb); super(HTMLProgressBar, self).start(iterations, chunk_size). def start(self, iterations=0, chunk_size=1.0):; super(HTMLProgressBar, self).start(iterations, chunk_size). def update(self, n):; p = (n / self.N) * 100.0; if p >= self.p_chunk:; lbl = (""Elapsed time: %s. "" % self.time_elapsed() +; ""Est. remaining time: %s."" % self.time_remainin",MatchSource.WIKI,docs/4.6/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html:4713,Usability,progress bar,progress bar,4713,"tware</th><th>Version</th></tr>"". packages = [(""QuTiP"", qutip.__version__),; (""Numpy"", numpy.__version__),; (""SciPy"", scipy.__version__),; (""matplotlib"", matplotlib.__version__),; (""Cython"", Cython.__version__),; (""Number of CPUs"", available_cpu_count()),; (""BLAS Info"", _blas_info()),; (""IPython"", IPython.__version__),; (""Python"", sys.version),; (""OS"", ""%s [%s]"" % (os.name, sys.platform)); ]. for name, version in packages:; html += ""<tr><td>%s</td><td>%s</td></tr>"" % (name, version). if verbose:; html += ""<tr><th colspan='2'>Additional information</th></tr>""; qutip_install_path = os.path.dirname(inspect.getsourcefile(qutip)); html += (""<tr><td>Installation path</td><td>%s</td></tr>"" %; qutip_install_path); try:; import getpass; html += (""<tr><td>User</td><td>%s</td></tr>"" %; getpass.getuser()); except:; pass. html += ""<tr><td colspan='2'>%s</td></tr>"" % time.strftime(; '%a %b %d %H:%M:%S %Y %Z'); html += ""</table>"". return HTML(html). class HTMLProgressBar(BaseProgressBar):; """"""; A simple HTML progress bar for using in IPython notebooks. Based on; IPython ProgressBar demo notebook:; https://github.com/ipython/ipython/tree/master/examples/notebooks. Example usage:. n_vec = linspace(0, 10, 100); pbar = HTMLProgressBar(len(n_vec)); for n in n_vec:; pbar.update(n); compute_with_n(n); """""". def __init__(self, iterations=0, chunk_size=1.0):; self.divid = str(uuid.uuid4()); self.textid = str(uuid.uuid4()); self.pb = HTML(""""""\; <div style=""border: 2px solid grey; width: 600px"">; <div id=""%s"" \; style=""background-color: rgba(121,195,106,0.75); width:0%%"">&nbsp;</div>; </div>; <p id=""%s""></p>; """""" % (self.divid, self.textid)); display(self.pb); super(HTMLProgressBar, self).start(iterations, chunk_size). def start(self, iterations=0, chunk_size=1.0):; super(HTMLProgressBar, self).start(iterations, chunk_size). def update(self, n):; p = (n / self.N) * 100.0; if p >= self.p_chunk:; lbl = (""Elapsed time: %s. "" % self.time_elapsed() +; ""Est. remaining time: %s."" % self.time_remainin",MatchSource.WIKI,docs/4.6/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html:8438,Usability,progress bar,progress bar,8438,"ed. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional additional argument to the ``task`` function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of ``task(value, args)`` for each; value in ``task_vec``, that is, it should be equivalent to; ``[task(v, args) for v in task_vec]``.; """""". if show_progressbar:; progress_bar = HTMLProgressBar(); else:; progress_bar = None. return parallel_map(task, task_vec, task_args=args,; client=client, view=view, progress_bar=progress_bar,; show_scheduling=show_scheduling). [docs]def parallel_map(task, values, task_args=None, task_kwargs=None,; client=None, view=None, progress_bar=None,; show_scheduling=False, **kwargs):; """"""; Call the function ``task`` for each value in ``values`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, *args, **kwargs)``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will",MatchSource.WIKI,docs/4.6/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html:10500,Usability,progress bar,progress bar,10500,"The function that is to be called for each value in ``task_vec``. values: array / list; The list or array of values for which the ``task`` function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the ``task`` function. task_kwargs: list / dictionary; The optional additional keyword argument to the ``task`` function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_schedu",MatchSource.WIKI,docs/4.6/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html
https://qutip.org/docs/4.6/modules/qutip/lattice.html:15098,Deployability,configurat,configuration,15098,"ell_num_site, cell_num_site-1); bN0 = basis(cell_num_site, 0); siteT = -bNm * bN0.dag(); inter_hop = tensor(Qobj(siteT), qeye(self.cell_site_dof)); dih = inter_hop.dims[0]; if all(x == 1 for x in dih):; dih = [1]; else:; while 1 in dih:; dih.remove(1); self._H_inter_list = [Qobj(inter_hop, dims=[dih, dih],; type='oper')]; self._H_inter = Qobj(inter_hop, dims=[dih, dih], type='oper'); else:; raise Exception(""inter_hop is required to be a Qobj or a \; list of Qobjs.""). self.positions_of_sites = [(i/self.cell_num_site) for i in; range(self.cell_num_site)]; self._inter_vec_list = [[1] for i in range(len(self._H_inter_list))]; self._Brav_lattice_vectors_list = [[1]] # unit vectors; self.is_real = is_real. def __repr__(self):; s = """"; s += (""Lattice1d object: "" +; ""Number of cells = "" + str(self.num_cell) +; "",\nNumber of sites in the cell = "" + str(self.cell_num_site) +; "",\nDegrees of freedom per site = "" +; str(; self.lattice_tensor_config[2:len(self.lattice_tensor_config)]) +; "",\nLattice tensor configuration = "" +; str(self.lattice_tensor_config) +; "",\nbasis_Hamiltonian = "" + str(self._H_intra) +; "",\ninter_hop = "" + str(self._H_inter_list) +; "",\ncell_tensor_config = "" + str(self.cell_tensor_config) +; ""\n""); if self.period_bnd_cond_x == 1:; s += ""Boundary Condition: Periodic""; else:; s += ""Boundary Condition: Hardwall""; return s. [docs] def Hamiltonian(self):; """"""; Returns the lattice Hamiltonian for the instance of Lattice1d. Returns; ----------; Qobj(Hamil) : qutip.Qobj; oper type Quantum object representing the lattice Hamiltonian.; """"""; D = qeye(self.num_cell); T = np.diag(np.zeros(self.num_cell-1)+1, 1); Tdag = np.diag(np.zeros(self.num_cell-1)+1, -1). if self.period_bnd_cond_x == 1 and self.num_cell > 2:; Tdag[0][self.num_cell-1] = 1; T[self.num_cell-1][0] = 1; T = Qobj(T); Tdag = Qobj(Tdag); Hamil = tensor(D, self._H_intra) + tensor(; T, self._H_inter) + tensor(Tdag, self._H_inter.dag()); dim_H = [self.lattice_tensor_config, self.lattice_tensor_config]; retu",MatchSource.WIKI,docs/4.6/modules/qutip/lattice.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/lattice.html
https://qutip.org/docs/4.6/modules/qutip/lattice.html:41359,Deployability,update,updated,41359," if i == csn-1:; continue. for j in range(i+1, csn):. if (Hcell[i][j].full() == 0).all():; continue; c_cen = self.positions_of_sites[i]; c_cen = (c_cen+self.positions_of_sites[j])/2; c_cen = c_cen + x_cell. c_radius = self.positions_of_sites[j]; c_radius = (c_radius-self.positions_of_sites[i])/2. circle1 = plt.Circle((c_cen, 0),; c_radius, color='g', fill=False); ax.add_artist(circle1); if (self.period_bnd_cond_x == 1):; x_cell = 0; x_b = 2*x_cell-1+self.positions_of_sites[csn-1]; x_b = (x_b+self.positions_of_sites[0])/2. plt.text(x=x_b, y=0.1, s='T', horizontalalignment='center',; verticalalignment='center'); ax.plot([x_cell-1+self.positions_of_sites[csn-1],; x_cell+self.positions_of_sites[0]], [0.0, 0.0],; ""-"", c=""r"", lw=1.5, zorder=7). x_cell = self.num_cell; x_b = 2*x_cell-1+self.positions_of_sites[csn-1]; x_b = (x_b+self.positions_of_sites[0])/2. plt.text(x=x_b, y=0.1, s='T', horizontalalignment='center',; verticalalignment='center'); ax.plot([x_cell-1+self.positions_of_sites[csn-1],; x_cell+self.positions_of_sites[0]], [0.0, 0.0],; ""-"", c=""r"", lw=1.5, zorder=7). x2 = (1+self.positions_of_sites[csn-1])/2; x1 = x2-1; h = 0.5. if self.num_cell > 2:; xu = 1 # The index of cell over which the black box is drawn; x1 = x1+xu; x2 = x2+xu; ax.plot([x1, x1], [-h, h], ""-"", c=""k"", lw=1.5, zorder=7, alpha=0.3); ax.plot([x2, x2], [-h, h], ""-"", c=""k"", lw=1.5, zorder=7, alpha=0.3); ax.plot([x1, x2], [h, h], ""-"", c=""k"", lw=1.5, zorder=7, alpha=0.3); ax.plot([x1, x2], [-h, -h], ""-"", c=""k"", lw=1.5, zorder=7, alpha=0.3); plt.axis('off'); plt.show(); plt.close(); dim_site = list(np.delete(self.cell_tensor_config, [0], None)); dims_site = [dim_site, dim_site]; return Qobj(inter_T, dims=dims_site). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/lattice.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/lattice.html
https://qutip.org/docs/4.6/modules/qutip/lattice.html:24711,Energy Efficiency,energy,energy,24711,"ots the dispersion relationship for the lattice with the specified; number of unit cells. The dispersion of the infinte crystal is also; plotted if num_cell is smaller than MAXc.; """"""; MAXc = 20 # Cell numbers above which we do not plot the infinite; # crystal dispersion; if self.period_bnd_cond_x == 0:; raise Exception(""The lattice is not periodic.""). if self.num_cell <= MAXc:; (kxA, val_ks) = self.get_dispersion(101); (knxA, val_kns) = self.get_dispersion(); fig, ax = plt.subplots(); if self.num_cell <= MAXc:; for g in range(self._length_of_unit_cell):; ax.plot(kxA/np.pi, val_ks[g, :]). for g in range(self._length_of_unit_cell):; if self.num_cell % 2 == 0:; ax.plot(np.append(knxA, [np.pi])/np.pi,; np.append(val_kns[g, :], val_kns[g, 0]), 'ro'); else:; ax.plot(knxA/np.pi, val_kns[g, :], 'ro'); ax.set_ylabel('Energy'); ax.set_xlabel(r'$k_x(\pi/a)$'); plt.show(fig); fig.savefig('./Dispersion.pdf'). [docs] def get_dispersion(self, knpoints=0):; """"""; Returns dispersion relationship for the lattice with the specified; number of unit cells with a k array and a band energy array. Returns; -------; knxa : np.array; knxA[j][0] is the jth good Quantum number k. val_kns : np.array; val_kns[j][:] is the array of band energies of the jth band good at; all the good Quantum numbers of k.; """"""; # The _k_space_calculations() function is not used for get_dispersion; # because we calculate the infinite crystal dispersion in; # plot_dispersion using this coode and we do not want to calculate; # all the eigen-values, eigenvectors of the bulk Hamiltonian for too; # many points, as is done in the _k_space_calculations() function.; if self.period_bnd_cond_x == 0:; raise Exception(""The lattice is not periodic.""); if knpoints == 0:; knpoints = self.num_cell. a = 1 # The unit cell length is always considered 1; kn_start = 0; kn_end = 2*np.pi/a; val_kns = np.zeros((self._length_of_unit_cell, knpoints), dtype=float); knxA = np.zeros((knpoints, 1), dtype=float); G0_H = self._H_intra; # knxA = n",MatchSource.WIKI,docs/4.6/modules/qutip/lattice.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/lattice.html
https://qutip.org/docs/4.6/modules/qutip/lattice.html:7943,Modifiability,coupling,coupling,7943,"("":cell(i+1) >""); llt = ''.join(llt); T_inter_cell_s[ir][jr] = llt. H_cell = np.zeros(np.shape(H_cell_s), dtype=complex); T_inter_cell = np.zeros(np.shape(T_inter_cell_s), dtype=complex); return (H_cell_s, T_inter_cell_s, H_cell, T_inter_cell). [docs]class Lattice1d():; """"""A class for representing a 1d crystal. The Lattice1d class can be defined with any specific unit cells and a; specified number of unit cells in the crystal. It can return dispersion; relationship, position operators, Hamiltonian in the position represention; etc. Parameters; ----------; num_cell : int; The number of cells in the crystal.; boundary : str; Specification of the type of boundary the crystal is defined with.; cell_num_site : int; The number of sites in the unit cell.; cell_site_dof : list of int/ int; The tensor structure of the degrees of freedom at each site of a unit; cell.; Hamiltonian_of_cell : qutip.Qobj; The Hamiltonian of the unit cell.; inter_hop : qutip.Qobj / list of Qobj; The coupling between the unit cell at i and at (i+unit vector). Attributes; ----------; num_cell : int; The number of unit cells in the crystal.; cell_num_site : int; The nuber of sites in a unit cell.; length_for_site : int; The length of the dimension per site of a unit cell.; cell_tensor_config : list of int; The tensor structure of the cell in the form; [cell_num_site,cell_site_dof[:][0] ]; lattice_tensor_config : list of int; The tensor structure of the crystal in the; form [num_cell,cell_num_site,cell_site_dof[:][0]]; length_of_unit_cell : int; The length of the dimension for a unit cell.; period_bnd_cond_x : int; 1 indicates ""periodic"" and 0 indicates ""hardwall"" boundary condition; inter_vec_list : list of list; The list of list of coefficients of inter unitcell vectors' components; along Cartesian uit vectors.; lattice_vectors_list : list of list; The list of list of coefficients of lattice basis vectors' components; along Cartesian unit vectors.; H_intra : qutip.Qobj; The Qobj storing the Hamilton",MatchSource.WIKI,docs/4.6/modules/qutip/lattice.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/lattice.html
https://qutip.org/docs/4.6/modules/qutip/lattice.html:9037,Modifiability,coupling,coupling,9037,"r of unit cells in the crystal.; cell_num_site : int; The nuber of sites in a unit cell.; length_for_site : int; The length of the dimension per site of a unit cell.; cell_tensor_config : list of int; The tensor structure of the cell in the form; [cell_num_site,cell_site_dof[:][0] ]; lattice_tensor_config : list of int; The tensor structure of the crystal in the; form [num_cell,cell_num_site,cell_site_dof[:][0]]; length_of_unit_cell : int; The length of the dimension for a unit cell.; period_bnd_cond_x : int; 1 indicates ""periodic"" and 0 indicates ""hardwall"" boundary condition; inter_vec_list : list of list; The list of list of coefficients of inter unitcell vectors' components; along Cartesian uit vectors.; lattice_vectors_list : list of list; The list of list of coefficients of lattice basis vectors' components; along Cartesian unit vectors.; H_intra : qutip.Qobj; The Qobj storing the Hamiltonian of the unnit cell.; H_inter_list : list of Qobj/ qutip.Qobj; The list of coupling terms between unit cells of the lattice.; is_real : bool; Indicates if the Hamiltonian is real or not.; """"""; def __init__(self, num_cell=10, boundary=""periodic"", cell_num_site=1,; cell_site_dof=[1], Hamiltonian_of_cell=None,; inter_hop=None):. self.num_cell = num_cell; self.cell_num_site = cell_num_site; if (not isinstance(cell_num_site, int)) or cell_num_site < 0:; raise Exception(""cell_num_site is required to be a positive \; integer.""). if isinstance(cell_site_dof, list):; l_v = 1; for i, csd_i in enumerate(cell_site_dof):; if (not isinstance(csd_i, int)) or csd_i < 0:; raise Exception(""Invalid cell_site_dof list element at \; index: "", i, ""Elements of cell_site_dof \; required to be positive integers.""); l_v = l_v * cell_site_dof[i]; self.cell_site_dof = cell_site_dof. elif isinstance(cell_site_dof, int):; if cell_site_dof < 0:; raise Exception(""cell_site_dof is required to be a positive \; integer.""); else:; l_v = cell_site_dof; self.cell_site_dof = [cell_site_dof]; else:; raise Exceptio",MatchSource.WIKI,docs/4.6/modules/qutip/lattice.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/lattice.html
https://qutip.org/docs/4.6/modules/qutip/lattice.html:15098,Modifiability,config,configuration,15098,"ell_num_site, cell_num_site-1); bN0 = basis(cell_num_site, 0); siteT = -bNm * bN0.dag(); inter_hop = tensor(Qobj(siteT), qeye(self.cell_site_dof)); dih = inter_hop.dims[0]; if all(x == 1 for x in dih):; dih = [1]; else:; while 1 in dih:; dih.remove(1); self._H_inter_list = [Qobj(inter_hop, dims=[dih, dih],; type='oper')]; self._H_inter = Qobj(inter_hop, dims=[dih, dih], type='oper'); else:; raise Exception(""inter_hop is required to be a Qobj or a \; list of Qobjs.""). self.positions_of_sites = [(i/self.cell_num_site) for i in; range(self.cell_num_site)]; self._inter_vec_list = [[1] for i in range(len(self._H_inter_list))]; self._Brav_lattice_vectors_list = [[1]] # unit vectors; self.is_real = is_real. def __repr__(self):; s = """"; s += (""Lattice1d object: "" +; ""Number of cells = "" + str(self.num_cell) +; "",\nNumber of sites in the cell = "" + str(self.cell_num_site) +; "",\nDegrees of freedom per site = "" +; str(; self.lattice_tensor_config[2:len(self.lattice_tensor_config)]) +; "",\nLattice tensor configuration = "" +; str(self.lattice_tensor_config) +; "",\nbasis_Hamiltonian = "" + str(self._H_intra) +; "",\ninter_hop = "" + str(self._H_inter_list) +; "",\ncell_tensor_config = "" + str(self.cell_tensor_config) +; ""\n""); if self.period_bnd_cond_x == 1:; s += ""Boundary Condition: Periodic""; else:; s += ""Boundary Condition: Hardwall""; return s. [docs] def Hamiltonian(self):; """"""; Returns the lattice Hamiltonian for the instance of Lattice1d. Returns; ----------; Qobj(Hamil) : qutip.Qobj; oper type Quantum object representing the lattice Hamiltonian.; """"""; D = qeye(self.num_cell); T = np.diag(np.zeros(self.num_cell-1)+1, 1); Tdag = np.diag(np.zeros(self.num_cell-1)+1, -1). if self.period_bnd_cond_x == 1 and self.num_cell > 2:; Tdag[0][self.num_cell-1] = 1; T[self.num_cell-1][0] = 1; T = Qobj(T); Tdag = Qobj(Tdag); Hamil = tensor(D, self._H_intra) + tensor(; T, self._H_inter) + tensor(Tdag, self._H_inter.dag()); dim_H = [self.lattice_tensor_config, self.lattice_tensor_config]; retu",MatchSource.WIKI,docs/4.6/modules/qutip/lattice.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/lattice.html
https://qutip.org/docs/4.6/modules/qutip/lattice.html:37634,Modifiability,coupling,coupling,37634,"radius = (self.positions_of_sites[; j]-self.positions_of_sites[i])/2. circle1 = plt.Circle((c_cen, 0), c_radius, color='g',; fill=False); ax.add_artist(circle1); if label_on is True:; x_b = c_cen; y_b = c_radius - 0.025; plt.text(x=x_b, y=y_b, s='H'+str(i)+str(j),; horizontalalignment='center',; verticalalignment='center'); x2 = (1+self.positions_of_sites[CNS-1])/2; x1 = x2-1; h = (self.positions_of_sites[; CNS-1]-self.positions_of_sites[0])*8/15; ax.plot([x1, x1], [-h, h], ""-"", c=""k"", lw=1.5, zorder=7); ax.plot([x2, x2], [-h, h], ""-"", c=""k"", lw=1.5, zorder=7); ax.plot([x1, x2], [h, h], ""-"", c=""k"", lw=1.5, zorder=7); ax.plot([x1, x2], [-h, -h], ""-"", c=""k"", lw=1.5, zorder=7); plt.axis('off'); plt.show(); plt.close(); return Hcell. [docs] def display_lattice(self):; r""""""; Produces a graphic portraying the lattice symbolically with a unit cell; marked in it. Returns; -------; inter_T : Qobj; The coefficient of $\psi_{i,N}^{\dagger}\psi_{0,i+1}$, i.e. the; coupling between the two boundary sites of the two unit cells i and; i+1.; """"""; dim_I = [self.cell_tensor_config, self.cell_tensor_config]; H_inter = Qobj(np.zeros((self._length_of_unit_cell,; self._length_of_unit_cell)), dims=dim_I); for no, inter_hop_no in enumerate(self._H_inter_list):; H_inter = H_inter + inter_hop_no. H_inter = np.array(H_inter); csn = self.cell_num_site; Hcell = [[{} for i in range(csn)] for j in range(csn)]. for i0 in range(csn):; for j0 in range(csn):; Qin = np.zeros((self._length_for_site, self._length_for_site),; dtype=complex); for i in range(self._length_for_site):; for j in range(self._length_for_site):; Qin[i, j] = self._H_intra[; i0*self._length_for_site+i,; j0*self._length_for_site+j]; dim_site = list(np.delete(self.cell_tensor_config, [0], None)); dims_site = [dim_site, dim_site]; Hcell[i0][j0] = Qobj(Qin, dims=dims_site). j0 = 0; i0 = csn-1; Qin = np.zeros((self._length_for_site, self._length_for_site),; dtype=complex); for i in range(self._length_for_site):; for j in range(self._leng",MatchSource.WIKI,docs/4.6/modules/qutip/lattice.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/lattice.html
https://qutip.org/docs/4.6/modules/qutip/matplotlib_utilities.html:6823,Deployability,update,updated,6823,"][0:3] = (1.0 - interp) * \; min_color[0:3] + interp * neg_color[0:3]; elif k > zero_pos:; interp = (k - zero_pos) / (num_pos + 1.0); adjust_RGBA[k][0:3] = (1.0 - interp) * \; mid_color[0:3] + interp * max_color[0:3]; # create colormap; wig_cmap = mpl.colors.LinearSegmentedColormap.from_list('wigner_cmap',; adjust_RGBA,; N=levels); return wig_cmap. [docs]def complex_phase_cmap():; """"""; Create a cyclic colormap for representing the phase of complex variables. Returns; -------; cmap :; A matplotlib linear segmented colormap.; """"""; cdict = {'blue': ((0.00, 0.0, 0.0),; (0.25, 0.0, 0.0),; (0.50, 1.0, 1.0),; (0.75, 1.0, 1.0),; (1.00, 0.0, 0.0)),; 'green': ((0.00, 0.0, 0.0),; (0.25, 1.0, 1.0),; (0.50, 0.0, 0.0),; (0.75, 1.0, 1.0),; (1.00, 0.0, 0.0)),; 'red': ((0.00, 1.0, 1.0),; (0.25, 0.5, 0.5),; (0.50, 0.0, 0.0),; (0.75, 0.0, 0.0),; (1.00, 1.0, 1.0))}. cmap = mpl.colors.LinearSegmentedColormap('phase_colormap', cdict, 256). return cmap. class MidpointNorm(Normalize):; """"""Normalization for a colormap centered about a given midpoint. Parameters; ----------; midpoint : float (optional, default=0); Midpoint about which colormap is centered.; vmin: float (optional); Minimal value for colormap. Calculated from data by default.; vmax: float (optional); Maximal value for colormap. Calculated from data by default. Returns; -------; Returns a Matplotlib colormap normalization that can be used; with any colormap. """""". def __init__(self, midpoint=0, vmin=None, vmax=None, clip=False):; self.midpoint = midpoint; Normalize.__init__(self, vmin, vmax, clip). def __call__(self, value, clip=None):; x, y = [self.vmin, self.midpoint, self.vmax], [0, 0.5, 1]; return np.ma.masked_array(np.interp(value, x, y)). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/matplotlib_utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/matplotlib_utilities.html
https://qutip.org/docs/4.6/modules/qutip/matplotlib_utilities.html:5574,Energy Efficiency,green,green,5574,")), np.ones((levels, 1)))); zero_pos = int(np.round(levels * np.abs(shift - bounds[0]); / (bounds[1] - bounds[0]))); num_pos = levels - zero_pos; num_neg = zero_pos - 1; # set zero values to mid_color; adjust_RGBA[zero_pos] = mid_color; # interpolate colors; for k in range(0, levels):; if k < zero_pos:; interp = k / (num_neg + 1.0); adjust_RGBA[k][0:3] = (1.0 - interp) * \; min_color[0:3] + interp * neg_color[0:3]; elif k > zero_pos:; interp = (k - zero_pos) / (num_pos + 1.0); adjust_RGBA[k][0:3] = (1.0 - interp) * \; mid_color[0:3] + interp * max_color[0:3]; # create colormap; wig_cmap = mpl.colors.LinearSegmentedColormap.from_list('wigner_cmap',; adjust_RGBA,; N=levels); return wig_cmap. [docs]def complex_phase_cmap():; """"""; Create a cyclic colormap for representing the phase of complex variables. Returns; -------; cmap :; A matplotlib linear segmented colormap.; """"""; cdict = {'blue': ((0.00, 0.0, 0.0),; (0.25, 0.0, 0.0),; (0.50, 1.0, 1.0),; (0.75, 1.0, 1.0),; (1.00, 0.0, 0.0)),; 'green': ((0.00, 0.0, 0.0),; (0.25, 1.0, 1.0),; (0.50, 0.0, 0.0),; (0.75, 1.0, 1.0),; (1.00, 0.0, 0.0)),; 'red': ((0.00, 1.0, 1.0),; (0.25, 0.5, 0.5),; (0.50, 0.0, 0.0),; (0.75, 0.0, 0.0),; (1.00, 1.0, 1.0))}. cmap = mpl.colors.LinearSegmentedColormap('phase_colormap', cdict, 256). return cmap. class MidpointNorm(Normalize):; """"""Normalization for a colormap centered about a given midpoint. Parameters; ----------; midpoint : float (optional, default=0); Midpoint about which colormap is centered.; vmin: float (optional); Minimal value for colormap. Calculated from data by default.; vmax: float (optional); Maximal value for colormap. Calculated from data by default. Returns; -------; Returns a Matplotlib colormap normalization that can be used; with any colormap. """""". def __init__(self, midpoint=0, vmin=None, vmax=None, clip=False):; self.midpoint = midpoint; Normalize.__init__(self, vmin, vmax, clip). def __call__(self, value, clip=None):; x, y = [self.vmin, self.midpoint, self.vmax], [0, 0.",MatchSource.WIKI,docs/4.6/modules/qutip/matplotlib_utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/matplotlib_utilities.html
https://qutip.org/docs/4.6/modules/qutip/matplotlib_utilities.html:2169,Modifiability,enhance,enhance,2169,"roducts derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. """"""; This module contains utility functions that enhance Matplotlib; in one way or another.; """""". __all__ = ['wigner_cmap', 'MidpointNorm', 'complex_phase_cmap']. import numpy as np. try:; import matplotlib as mpl; from matplotlib import cm; from matplotlib.colors import (Normalize, ColorConverter); except:; class Normalize(object):; def __init__(self, vmin=None, vmax=None, clip=False):; pass. [docs]def wigner_cmap(W, levels=1024, shift=0, max_color='#09224F',; mid_color='#FFFFFF', min_color='#530017',; neg_color='#FF97D4', invert=False):; """"""A custom colormap that emphasizes negative values by creating a; nonlinear colormap. Parameters; ----------; W : array; Wigner function array, or any array.; levels : int; Number of color levels to create.; shift : float; Shifts the value at which Wigner elements are emphasized.; This parameter should typically be negative and small (i.e -1e-5).; max_color : str; String for color corresponding to maximum value of data. Accepts; any string format compatible with the Matplotlib.colors.ColorCon",MatchSource.WIKI,docs/4.6/modules/qutip/matplotlib_utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/matplotlib_utilities.html
https://qutip.org/docs/4.6/modules/qutip/matplotlib_utilities.html:5376,Modifiability,variab,variables,5376,"gba(min_color), dtype=float); neg_color = np.array(cc.to_rgba(neg_color), dtype=float); # get min and max values from Wigner function; bounds = [W.min(), W.max()]; # create empty array for RGBA colors; adjust_RGBA = np.hstack((np.zeros((levels, 3)), np.ones((levels, 1)))); zero_pos = int(np.round(levels * np.abs(shift - bounds[0]); / (bounds[1] - bounds[0]))); num_pos = levels - zero_pos; num_neg = zero_pos - 1; # set zero values to mid_color; adjust_RGBA[zero_pos] = mid_color; # interpolate colors; for k in range(0, levels):; if k < zero_pos:; interp = k / (num_neg + 1.0); adjust_RGBA[k][0:3] = (1.0 - interp) * \; min_color[0:3] + interp * neg_color[0:3]; elif k > zero_pos:; interp = (k - zero_pos) / (num_pos + 1.0); adjust_RGBA[k][0:3] = (1.0 - interp) * \; mid_color[0:3] + interp * max_color[0:3]; # create colormap; wig_cmap = mpl.colors.LinearSegmentedColormap.from_list('wigner_cmap',; adjust_RGBA,; N=levels); return wig_cmap. [docs]def complex_phase_cmap():; """"""; Create a cyclic colormap for representing the phase of complex variables. Returns; -------; cmap :; A matplotlib linear segmented colormap.; """"""; cdict = {'blue': ((0.00, 0.0, 0.0),; (0.25, 0.0, 0.0),; (0.50, 1.0, 1.0),; (0.75, 1.0, 1.0),; (1.00, 0.0, 0.0)),; 'green': ((0.00, 0.0, 0.0),; (0.25, 1.0, 1.0),; (0.50, 0.0, 0.0),; (0.75, 1.0, 1.0),; (1.00, 0.0, 0.0)),; 'red': ((0.00, 1.0, 1.0),; (0.25, 0.5, 0.5),; (0.50, 0.0, 0.0),; (0.75, 0.0, 0.0),; (1.00, 1.0, 1.0))}. cmap = mpl.colors.LinearSegmentedColormap('phase_colormap', cdict, 256). return cmap. class MidpointNorm(Normalize):; """"""Normalization for a colormap centered about a given midpoint. Parameters; ----------; midpoint : float (optional, default=0); Midpoint about which colormap is centered.; vmin: float (optional); Minimal value for colormap. Calculated from data by default.; vmax: float (optional); Maximal value for colormap. Calculated from data by default. Returns; -------; Returns a Matplotlib colormap normalization that can be used; with ",MatchSource.WIKI,docs/4.6/modules/qutip/matplotlib_utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/matplotlib_utilities.html
https://qutip.org/docs/4.6/modules/qutip/mcsolve.html:2220,Deployability,integrat,integrate,2220,"ED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['mcsolve']. import os; import numpy as np; from numpy.random import RandomState, randint; import scipy.sparse as sp; from scipy.integrate import ode; from scipy.integrate._ode import zvode. from types import FunctionType, BuiltinFunctionType; from functools import partial; from qutip.fastsparse import csr2fast; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.mcsolve import CyMcOde, CyMcOdeDiag; from qutip.cy.spconvert import dense1D_to_fastcsr_ket; from qutip.sesolve import sesolve; from qutip.solver import (Options, Result, ExpectOps,; solver_safe, SolverSystem); from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions. # Todo: use real warning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; retu",MatchSource.WIKI,docs/4.6/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mcsolve.html
https://qutip.org/docs/4.6/modules/qutip/mcsolve.html:2253,Deployability,integrat,integrate,2253,"LDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['mcsolve']. import os; import numpy as np; from numpy.random import RandomState, randint; import scipy.sparse as sp; from scipy.integrate import ode; from scipy.integrate._ode import zvode. from types import FunctionType, BuiltinFunctionType; from functools import partial; from qutip.fastsparse import csr2fast; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.mcsolve import CyMcOde, CyMcOdeDiag; from qutip.cy.spconvert import dense1D_to_fastcsr_ket; from qutip.sesolve import sesolve; from qutip.solver import (Options, Result, ExpectOps,; solver_safe, SolverSystem); from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions. # Todo: use real warning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsol",MatchSource.WIKI,docs/4.6/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mcsolve.html
https://qutip.org/docs/4.6/modules/qutip/mcsolve.html:12187,Deployability,update,update,12187,"rn. if args and args != self.ss.args:; self.ss.set_args(self.ss, args); self.reset(). if e_ops and e_ops != self.e_ops:; self.set_e_ops(e_ops); self.reset(). if psi0 is not None and psi0 != self.psi0:; self.psi0 = psi0; self.reset(). tlist = np.array(tlist); if tlist is not None and np.all(tlist != self.tlist):; self.tlist = tlist; self.reset(). if self.ran:; if options.store_states and self._psi_out[0].shape[0] == 1:; self.reset(); else:; # if not reset here, add trajectories; self.add_traj(num_traj, progress_bar, map_func, map_kwargs); return. if not num_traj:; num_traj = options.ntraj. if options.num_cpus == 1 or num_traj == 1:; map_func = serial_map. if len(self.seeds) != num_traj:; self.seed(num_traj, self.seeds). if not progress_bar:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). # set arguments for input to monte carlo; map_kwargs_ = {'progress_bar': progress_bar,; 'num_cpus': options.num_cpus}; map_kwargs_.update(map_kwargs); map_kwargs = map_kwargs_. if self.e_ops is None:; self.set_e_ops(). if self.ss.type == ""Diagonal"":; results = map_func(self._single_traj_diag, list(range(num_traj)),; **map_kwargs); else:; results = map_func(self._single_traj, list(range(num_traj)),; **map_kwargs). self.t = self.tlist[-1]; self.num_traj = num_traj; self.ran = True. for result in results:; state_out, ss_out, expect, collapse = result; self._psi_out.append(state_out); self._ss_out.append(ss_out); self._expect_out.append(expect); self._collapse.append(collapse); self._psi_out = np.stack(self._psi_out); self._ss_out = np.stack(self._ss_out). def add_traj(self, num_traj,; progress_bar=True,; map_func=parallel_map, map_kwargs={}):; raise NotImplementedError. def continue_runs(self, num_traj, tlist, args={}, e_ops=[], options=None,; progress_bar=True,; map_func=parallel_map, map_kwargs={}):; raise NotImplementedError. # --------------------------------------------------------------------------; # results functions; # -----------",MatchSource.WIKI,docs/4.6/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mcsolve.html
https://qutip.org/docs/4.6/modules/qutip/mcsolve.html:18381,Deployability,integrat,integration,18381,"----------------------------; # single-trajectory for monte carlo; # --------------------------------------------------------------------------; def _single_traj(self, nt):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """"""; # SEED AND RNG AND GENERATE; prng = RandomState(self.seeds[nt]); opt = self.options. # set initial conditions; ss = self.ss; tlist = self.tlist; e_ops = self.e_ops.copy(); opt = self.options; rhs, ode_args = self.ss.makefunc(ss); ODE = self._build_integration_func(rhs, ode_args, opt); ODE.set_initial_value(self.initial_vector, tlist[0]); e_ops.init(tlist). cymc = CyMcOde(ss, opt); states_out, ss_out, collapses = cymc.run_ode(ODE, tlist, e_ops, prng). # Run at end of mc_alg function; # -----------------------------; if opt.steady_state_average:; ss_out /= float(len(tlist)). return (states_out, ss_out, e_ops, collapses). def _build_integration_func(self, rhs, ode_args, opt):; """"""; Create the integration function while fixing the parameters; """"""; ODE = ode(rhs); if ode_args:; ODE.set_f_params(ode_args); # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=""adams""); ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step); return ODE. # --------------------------------------------------------------------------; # In development diagonalize the Hamiltonian before solving; # Same seeds give same evolution; # 3~5 time faster; # constant system only.; # --------------------------------------------------------------------------; def make_diag_system(self, H, c_ops):; ss = SolverSystem(); ss.td_c_ops = []; ss.td_n_ops = []. H_ = H.copy(); H_ *= -1j; for c in c_ops:; H_ += -0.5 * c.dag() * c. w, v = np.linalg.eig(H_.full()); arg = np.argsort(np.abs(w)); eig = w[arg]; U = v.T[arg].T; Ud = U.T.conj(). for c in c_ops:; c_diag = Qobj(Ud @ c.full(",MatchSource.WIKI,docs/4.6/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mcsolve.html
https://qutip.org/docs/4.6/modules/qutip/mcsolve.html:22632,Deployability,update,updated,22632," args={}, opt=None):; if args:; self.set_args(args); rhs = ss.H_td.compiled_qobjevo.mul_vec; return rhs, (). def _qobjevo_args(ss, args):; var = _collapse_args(args); ss.col_args = var; ss.args = args; ss.H_td.solver_set_args(args, psi0, e_ops); for c in ss.td_c_ops:; c.solver_set_args(args, psi0, e_ops); for c in ss.td_n_ops:; c.solver_set_args(args, psi0, e_ops). def _func_set(HS, psi0=None, args={}, opt=None):; if args:; self.set_args(args); else:; args = ss.args; if ss.with_state:; rhs = _funcrhs; else:; rhs = _funcrhs_with_state; return rhs, (ss.h_func, ss.Hc_td, args). def _func_args(ss, args):; var = _collapse_args(args); ss.col_args = var; ss.args = args; for c in ss.td_c_ops:; c.solver_set_args(args, psi0, e_ops); for c in ss.td_n_ops:; c.solver_set_args(args, psi0, e_ops); return rhs, (ss.h_func, ss.Hc_td, args). # RHS of ODE for python function Hamiltonian; def _funcrhs(t, psi, h_func, Hc_td, args):; h_func_data = -1.0j * h_func(t, args).data; h_func_term = h_func_data * psi; return h_func_term + Hc_td.mul_vec(t, psi). def _funcrhs_with_state(t, psi, h_func, Hc_td, args):; h_func_data = - 1.0j * h_func(t, psi, args).data; h_func_term = h_func_data * psi; return h_func_term + Hc_td.mul_vec(t, psi). def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape = psi_list[0].shape; out_data = sum([psi.data for psi in psi_list]) / ln; return Qobj(out_data, dims=dims, shape=shape, fast='mc-dm'). def _collapse_args(args):; for key in args:; if key == ""collapse"":; if not isinstance(args[key], list):; args[key] = []; return key; return """". © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mcsolve.html
https://qutip.org/docs/4.6/modules/qutip/mcsolve.html:2220,Integrability,integrat,integrate,2220,"ED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['mcsolve']. import os; import numpy as np; from numpy.random import RandomState, randint; import scipy.sparse as sp; from scipy.integrate import ode; from scipy.integrate._ode import zvode. from types import FunctionType, BuiltinFunctionType; from functools import partial; from qutip.fastsparse import csr2fast; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.mcsolve import CyMcOde, CyMcOdeDiag; from qutip.cy.spconvert import dense1D_to_fastcsr_ket; from qutip.sesolve import sesolve; from qutip.solver import (Options, Result, ExpectOps,; solver_safe, SolverSystem); from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions. # Todo: use real warning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; retu",MatchSource.WIKI,docs/4.6/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mcsolve.html
https://qutip.org/docs/4.6/modules/qutip/mcsolve.html:2253,Integrability,integrat,integrate,2253,"LDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['mcsolve']. import os; import numpy as np; from numpy.random import RandomState, randint; import scipy.sparse as sp; from scipy.integrate import ode; from scipy.integrate._ode import zvode. from types import FunctionType, BuiltinFunctionType; from functools import partial; from qutip.fastsparse import csr2fast; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.mcsolve import CyMcOde, CyMcOdeDiag; from qutip.cy.spconvert import dense1D_to_fastcsr_ket; from qutip.sesolve import sesolve; from qutip.solver import (Options, Result, ExpectOps,; solver_safe, SolverSystem); from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions. # Todo: use real warning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsol",MatchSource.WIKI,docs/4.6/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mcsolve.html
https://qutip.org/docs/4.6/modules/qutip/mcsolve.html:3684,Integrability,depend,dependent,3684,", SolverSystem); from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions. # Todo: use real warning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0,; args={}, options=None, progress_bar=True,; map_func=parallel_map, map_kwargs={}, _safe_mode=True):; r""""""Monte Carlo evolution of a state vector :math:`|\psi \rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian with two; terms ``H0`` and ``H1``, where ``H1`` is time-dependent with coefficient; ``sin(w*t)``, and collapse operators ``C0`` and ``C1``, where ``C1`` is; time-dependent with coeffcient ``exp(-a*t)``. Here, w and a are constant; arguments with values ``W`` and ``A``. Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as::. def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write::. H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first",MatchSource.WIKI,docs/4.6/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mcsolve.html
https://qutip.org/docs/4.6/modules/qutip/mcsolve.html:3790,Integrability,depend,dependent,3790,", SolverSystem); from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions. # Todo: use real warning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0,; args={}, options=None, progress_bar=True,; map_func=parallel_map, map_kwargs={}, _safe_mode=True):; r""""""Monte Carlo evolution of a state vector :math:`|\psi \rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian with two; terms ``H0`` and ``H1``, where ``H1`` is time-dependent with coefficient; ``sin(w*t)``, and collapse operators ``C0`` and ``C1``, where ``C1`` is; time-dependent with coeffcient ``exp(-a*t)``. Here, w and a are constant; arguments with values ``W`` and ``A``. Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as::. def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write::. H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first",MatchSource.WIKI,docs/4.6/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mcsolve.html
https://qutip.org/docs/4.6/modules/qutip/mcsolve.html:3912,Integrability,depend,dependent,3912,"arning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0,; args={}, options=None, progress_bar=True,; map_func=parallel_map, map_kwargs={}, _safe_mode=True):; r""""""Monte Carlo evolution of a state vector :math:`|\psi \rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian with two; terms ``H0`` and ``H1``, where ``H1`` is time-dependent with coefficient; ``sin(w*t)``, and collapse operators ``C0`` and ``C1``, where ``C1`` is; time-dependent with coeffcient ``exp(-a*t)``. Here, w and a are constant; arguments with values ``W`` and ``A``. Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as::. def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write::. H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters; ----------; H : :class:`qutip.Qobj`, ``list``; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector. tlist : array_like; Times at which results are recorded. ntraj : int; Number of trajectories to run. c_op",MatchSource.WIKI,docs/4.6/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mcsolve.html
https://qutip.org/docs/4.6/modules/qutip/mcsolve.html:4010,Integrability,depend,dependent,4010,"arning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0,; args={}, options=None, progress_bar=True,; map_func=parallel_map, map_kwargs={}, _safe_mode=True):; r""""""Monte Carlo evolution of a state vector :math:`|\psi \rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian with two; terms ``H0`` and ``H1``, where ``H1`` is time-dependent with coefficient; ``sin(w*t)``, and collapse operators ``C0`` and ``C1``, where ``C1`` is; time-dependent with coeffcient ``exp(-a*t)``. Here, w and a are constant; arguments with values ``W`` and ``A``. Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as::. def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write::. H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters; ----------; H : :class:`qutip.Qobj`, ``list``; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector. tlist : array_like; Times at which results are recorded. ntraj : int; Number of trajectories to run. c_op",MatchSource.WIKI,docs/4.6/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mcsolve.html
https://qutip.org/docs/4.6/modules/qutip/mcsolve.html:4116,Integrability,depend,dependent,4116,"arning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0,; args={}, options=None, progress_bar=True,; map_func=parallel_map, map_kwargs={}, _safe_mode=True):; r""""""Monte Carlo evolution of a state vector :math:`|\psi \rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian with two; terms ``H0`` and ``H1``, where ``H1`` is time-dependent with coefficient; ``sin(w*t)``, and collapse operators ``C0`` and ``C1``, where ``C1`` is; time-dependent with coeffcient ``exp(-a*t)``. Here, w and a are constant; arguments with values ``W`` and ``A``. Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as::. def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write::. H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters; ----------; H : :class:`qutip.Qobj`, ``list``; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector. tlist : array_like; Times at which results are recorded. ntraj : int; Number of trajectories to run. c_op",MatchSource.WIKI,docs/4.6/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mcsolve.html
https://qutip.org/docs/4.6/modules/qutip/mcsolve.html:4255,Integrability,depend,dependent,4255,"ps=[], e_ops=[], ntraj=0,; args={}, options=None, progress_bar=True,; map_func=parallel_map, map_kwargs={}, _safe_mode=True):; r""""""Monte Carlo evolution of a state vector :math:`|\psi \rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian with two; terms ``H0`` and ``H1``, where ``H1`` is time-dependent with coefficient; ``sin(w*t)``, and collapse operators ``C0`` and ``C1``, where ``C1`` is; time-dependent with coeffcient ``exp(-a*t)``. Here, w and a are constant; arguments with values ``W`` and ``A``. Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as::. def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write::. H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters; ----------; H : :class:`qutip.Qobj`, ``list``; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector. tlist : array_like; Times at which results are recorded. ntraj : int; Number of trajectories to run. c_ops : :class:`qutip.Qobj`, ``list``; single collapse operator or a ``list`` of collapse operators. e_ops : :class:`qutip.Qobj`, ``list``; single operator as Qobj or ``list`` or equivalent of Qobj operators; for calculating expectation values. args : dict; Argum",MatchSource.WIKI,docs/4.6/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mcsolve.html
https://qutip.org/docs/4.6/modules/qutip/mcsolve.html:5295,Integrability,depend,dependent,5295," one for each collapse coefficient. Therefore, this problem could; be expressed as::. def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write::. H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters; ----------; H : :class:`qutip.Qobj`, ``list``; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector. tlist : array_like; Times at which results are recorded. ntraj : int; Number of trajectories to run. c_ops : :class:`qutip.Qobj`, ``list``; single collapse operator or a ``list`` of collapse operators. e_ops : :class:`qutip.Qobj`, ``list``; single operator as Qobj or ``list`` or equivalent of Qobj operators; for calculating expectation values. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Set to None to disable the; progress bar. map_func: function; A map function for managing the calls to the single-trajactory solver. map_kwargs: dictionary; Optional keyword arguments to the map_func function. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """"""; if isinstance(c_ops, (Qobj, QobjEvo)):; c_ops = [c_ops]. if options is None:; options = Options(). if options.rhs_reuse and not isinstance(H, SolverSystem):; # TODO: deprecate when going to class based solver.; if ""mcsolve"" in solver_safe:; # prin",MatchSource.WIKI,docs/4.6/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mcsolve.html
https://qutip.org/docs/4.6/modules/qutip/mcsolve.html:18381,Integrability,integrat,integration,18381,"----------------------------; # single-trajectory for monte carlo; # --------------------------------------------------------------------------; def _single_traj(self, nt):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """"""; # SEED AND RNG AND GENERATE; prng = RandomState(self.seeds[nt]); opt = self.options. # set initial conditions; ss = self.ss; tlist = self.tlist; e_ops = self.e_ops.copy(); opt = self.options; rhs, ode_args = self.ss.makefunc(ss); ODE = self._build_integration_func(rhs, ode_args, opt); ODE.set_initial_value(self.initial_vector, tlist[0]); e_ops.init(tlist). cymc = CyMcOde(ss, opt); states_out, ss_out, collapses = cymc.run_ode(ODE, tlist, e_ops, prng). # Run at end of mc_alg function; # -----------------------------; if opt.steady_state_average:; ss_out /= float(len(tlist)). return (states_out, ss_out, e_ops, collapses). def _build_integration_func(self, rhs, ode_args, opt):; """"""; Create the integration function while fixing the parameters; """"""; ODE = ode(rhs); if ode_args:; ODE.set_f_params(ode_args); # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=""adams""); ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step); return ODE. # --------------------------------------------------------------------------; # In development diagonalize the Hamiltonian before solving; # Same seeds give same evolution; # 3~5 time faster; # constant system only.; # --------------------------------------------------------------------------; def make_diag_system(self, H, c_ops):; ss = SolverSystem(); ss.td_c_ops = []; ss.td_n_ops = []. H_ = H.copy(); H_ *= -1j; for c in c_ops:; H_ += -0.5 * c.dag() * c. w, v = np.linalg.eig(H_.full()); arg = np.argsort(np.abs(w)); eig = w[arg]; U = v.T[arg].T; Ud = U.T.conj(). for c in c_ops:; c_diag = Qobj(Ud @ c.full(",MatchSource.WIKI,docs/4.6/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mcsolve.html
https://qutip.org/docs/4.6/modules/qutip/mcsolve.html:2927,Modifiability,variab,variables,2927,"IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['mcsolve']. import os; import numpy as np; from numpy.random import RandomState, randint; import scipy.sparse as sp; from scipy.integrate import ode; from scipy.integrate._ode import zvode. from types import FunctionType, BuiltinFunctionType; from functools import partial; from qutip.fastsparse import csr2fast; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.mcsolve import CyMcOde, CyMcOdeDiag; from qutip.cy.spconvert import dense1D_to_fastcsr_ket; from qutip.sesolve import sesolve; from qutip.solver import (Options, Result, ExpectOps,; solver_safe, SolverSystem); from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions. # Todo: use real warning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0,; args={}, options=None, progress_bar=True,; map_func=parallel_map, map_kwargs={}, _safe_mode=True):; r""""""Monte Carlo evolution of a state vector :math:`|\psi \rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian",MatchSource.WIKI,docs/4.6/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mcsolve.html
https://qutip.org/docs/4.6/modules/qutip/mcsolve.html:2975,Performance,load,loaded,2975,"IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['mcsolve']. import os; import numpy as np; from numpy.random import RandomState, randint; import scipy.sparse as sp; from scipy.integrate import ode; from scipy.integrate._ode import zvode. from types import FunctionType, BuiltinFunctionType; from functools import partial; from qutip.fastsparse import csr2fast; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.mcsolve import CyMcOde, CyMcOdeDiag; from qutip.cy.spconvert import dense1D_to_fastcsr_ket; from qutip.sesolve import sesolve; from qutip.solver import (Options, Result, ExpectOps,; solver_safe, SolverSystem); from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions. # Todo: use real warning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0,; args={}, options=None, progress_bar=True,; map_func=parallel_map, map_kwargs={}, _safe_mode=True):; r""""""Monte Carlo evolution of a state vector :math:`|\psi \rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian",MatchSource.WIKI,docs/4.6/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mcsolve.html
https://qutip.org/docs/4.6/modules/qutip/mcsolve.html:6829,Performance,load,load,6829,". .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """"""; if isinstance(c_ops, (Qobj, QobjEvo)):; c_ops = [c_ops]. if options is None:; options = Options(). if options.rhs_reuse and not isinstance(H, SolverSystem):; # TODO: deprecate when going to class based solver.; if ""mcsolve"" in solver_safe:; # print("" ""); H = solver_safe[""mcsolve""]; else:; pass; # raise Exception(""Could not find the Hamiltonian to reuse.""). if not ntraj:; ntraj = options.ntraj. if len(c_ops) == 0 and not options.rhs_reuse:; warn(""No c_ops, using sesolve""); return sesolve(H, psi0, tlist, e_ops=e_ops, args=args,; options=options, progress_bar=progress_bar,; _safe_mode=_safe_mode). try:; num_traj = int(ntraj); except TypeError:; num_traj = max(ntraj). # set the physics; if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). # load monte carlo class; mc = _MC(options). if isinstance(H, SolverSystem):; mc.ss = H; else:; mc.make_system(H, c_ops, tlist, args, options). mc.reset(tlist[0], psi0). mc.set_e_ops(e_ops). if options.seeds is not None:; mc.seed(num_traj, options.seeds). if _safe_mode:; mc.run_test(). # Run the simulation; mc.run(num_traj=num_traj, tlist=tlist,; progress_bar=progress_bar,; map_func=map_func, map_kwargs=map_kwargs). return mc.get_result(ntraj). # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """"""; def __init__(self, options=None):; if options is None:; options = Options(); self.options = options; self.ss = None; self.tlist = None; self.e_ops = None; self.ran = False; self.psi0 = None; self.seeds = []; self.t = 0.; self.num_traj = 0; self.args_col = None. self._psi_out = []; self._expect_out = [];",MatchSource.WIKI,docs/4.6/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mcsolve.html
https://qutip.org/docs/4.6/modules/qutip/mcsolve.html:5562,Usability,progress bar,progress bar,5562,", 'w': W}. or in String (Cython) format we could write::. H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters; ----------; H : :class:`qutip.Qobj`, ``list``; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector. tlist : array_like; Times at which results are recorded. ntraj : int; Number of trajectories to run. c_ops : :class:`qutip.Qobj`, ``list``; single collapse operator or a ``list`` of collapse operators. e_ops : :class:`qutip.Qobj`, ``list``; single operator as Qobj or ``list`` or equivalent of Qobj operators; for calculating expectation values. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Set to None to disable the; progress bar. map_func: function; A map function for managing the calls to the single-trajactory solver. map_kwargs: dictionary; Optional keyword arguments to the map_func function. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """"""; if isinstance(c_ops, (Qobj, QobjEvo)):; c_ops = [c_ops]. if options is None:; options = Options(). if options.rhs_reuse and not isinstance(H, SolverSystem):; # TODO: deprecate when going to class based solver.; if ""mcsolve"" in solver_safe:; # print("" ""); H = solver_safe[""mcsolve""]; else:; pass; # raise Exception(""Could not find the Hamiltonian to reuse.""). if not ntraj:; ntraj = options.ntraj. if len(c_ops) == 0 and not options.rhs_reuse:; warn(""No c_ops, using sesolve""); return sesolve(H, ps",MatchSource.WIKI,docs/4.6/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mcsolve.html
https://qutip.org/docs/4.6/modules/qutip/measurement.html:9610,Availability,down,down,9610,"ers; ----------; state : :class:`.Qobj`; The ket or density matrix specifying the state to measure. op : :class:`.Qobj`; The measurement operator. targets : list of ints, optional; Specifies a list of target ""qubit"" indices on which to apply the; measurement using :func:`qutip.qip.gates.expand_operator` to expand op; into full dimension. Returns; -------; measured_value : float; The result of the measurement (one of the eigenvalues of op). state : :class:`.Qobj`; The new state (a ket if a ket was given, otherwise a density matrix). Examples; --------. Measure the z-component of the spin of the spin-up basis state:. >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase). Measure the x-component of the spin of the spin-down basis state:. >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax. One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:. >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix.; """"""; eigenvalues, eigenstates_or_projectors, probabilities = (; measurement_statistics_observable(state, op, targets)); i = np.random.choice(range(len(eigenvalues)), p=probabilities); if state.isket:; eigenstat",MatchSource.WIKI,docs/4.6/modules/qutip/measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/measurement.html
https://qutip.org/docs/4.6/modules/qutip/measurement.html:10116,Availability,down,down,10116,"state (a ket if a ket was given, otherwise a density matrix). Examples; --------. Measure the z-component of the spin of the spin-up basis state:. >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase). Measure the x-component of the spin of the spin-down basis state:. >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax. One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:. >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix.; """"""; eigenvalues, eigenstates_or_projectors, probabilities = (; measurement_statistics_observable(state, op, targets)); i = np.random.choice(range(len(eigenvalues)), p=probabilities); if state.isket:; eigenstates = eigenstates_or_projectors; state = eigenstates[i]; else:; projectors = eigenstates_or_projectors; state = (projectors[i] * state * projectors[i]) / probabilities[i]; return eigenvalues[i], state. def measure_povm(state, ops, targets=None):; r""""""; Perform a measurement specified by list of POVMs. This function simulates a POVM measurement. The measurement collapses the; state to one of the resultant states of the measurement and returns the; index of the operator cor",MatchSource.WIKI,docs/4.6/modules/qutip/measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/measurement.html
https://qutip.org/docs/4.6/modules/qutip/measurement.html:14673,Deployability,update,updated,14673,"bj`) Either:. 1. specifying a POVM s.t. :math:`E_i = M_i^\dagger * M_i`; 2. projection operators if ops correspond to projectors (s.t.; :math:`E_i = M_i^\dagger = M_i`); 3. kets (transformed to projectors). targets : list of ints, optional; Specifies a list of target ""qubit"" indices on which to apply the; measurement using :func:`qutip.qip.gates.expand_operator` to expand ops; into full dimension.; """"""; if isinstance(ops, list):; return measurement_statistics_povm(state, ops, targets); else:; return measurement_statistics_observable(state, ops, targets). [docs]def measure(state, ops, targets=None):; r""""""; A dispatch method that provides measurement results handling both; observable style measurements and projector style measurements (POVMs and; PVMs). For return signatures, please check:. - :func:`~measure_observable` for observable measurements.; - :func:`~measure_povm` for POVM measurements. Parameters; ----------; state : :class:`.Qobj`; The ket or density matrix specifying the state to measure. ops : :class:`.Qobj` or list of :class:`.Qobj`; - measurement observable (:class:`.Qobj`); or; - list of measurement operators :math:`M_i` or kets (list of; :class:`.Qobj`) Either:. 1. specifying a POVM s.t. :math:`E_i = M_i^\dagger M_i`; 2. projection operators if ops correspond to projectors (s.t.; :math:`E_i = M_i^\dagger = M_i`); 3. kets (transformed to projectors). targets : list of ints, optional; Specifies a list of target ""qubit"" indices on which to apply the; measurement using :func:`qutip.qip.gates.expand_operator` to expand ops; into full dimension.; """"""; if isinstance(ops, list):; return measure_povm(state, ops, targets); else:; return measure_observable(state, ops, targets). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/measurement.html
https://qutip.org/docs/4.6/modules/qutip/measurement.html:9970,Performance,perform,perform,9970,"lt of the measurement (one of the eigenvalues of op). state : :class:`.Qobj`; The new state (a ket if a ket was given, otherwise a density matrix). Examples; --------. Measure the z-component of the spin of the spin-up basis state:. >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase). Measure the x-component of the spin of the spin-down basis state:. >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax. One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:. >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix.; """"""; eigenvalues, eigenstates_or_projectors, probabilities = (; measurement_statistics_observable(state, op, targets)); i = np.random.choice(range(len(eigenvalues)), p=probabilities); if state.isket:; eigenstates = eigenstates_or_projectors; state = eigenstates[i]; else:; projectors = eigenstates_or_projectors; state = (projectors[i] * state * projectors[i]) / probabilities[i]; return eigenvalues[i], state. def measure_povm(state, ops, targets=None):; r""""""; Perform a measurement specified by list of POVMs. This function simulates a POVM measurement. The measurement collapses the; state to one",MatchSource.WIKI,docs/4.6/modules/qutip/measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/measurement.html
https://qutip.org/docs/4.6/modules/qutip/measurement.html:10022,Performance,perform,perform,10022,"state (a ket if a ket was given, otherwise a density matrix). Examples; --------. Measure the z-component of the spin of the spin-up basis state:. >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase). Measure the x-component of the spin of the spin-down basis state:. >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax. One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:. >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix.; """"""; eigenvalues, eigenstates_or_projectors, probabilities = (; measurement_statistics_observable(state, op, targets)); i = np.random.choice(range(len(eigenvalues)), p=probabilities); if state.isket:; eigenstates = eigenstates_or_projectors; state = eigenstates[i]; else:; projectors = eigenstates_or_projectors; state = (projectors[i] * state * projectors[i]) / probabilities[i]; return eigenvalues[i], state. def measure_povm(state, ops, targets=None):; r""""""; Perform a measurement specified by list of POVMs. This function simulates a POVM measurement. The measurement collapses the; state to one of the resultant states of the measurement and returns the; index of the operator cor",MatchSource.WIKI,docs/4.6/modules/qutip/measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/measurement.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:17486,Availability,error,error,17486,"able(e_ops):; n_expt_op = 0; expt_callback = True; output.num_expect = 1; elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False; output.num_expect = n_expt_op; if n_expt_op == 0:; # fall back on storing states; opt.store_states = True; else:; for op in e_ops:; if op.dims != rho0.dims:; raise TypeError(f""e_ops dims ({op.dims}) are not ""; f""compatible with the state's ""; f""({rho0.dims})""); e_ops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). if opt.store_states:; output.states = []. def get_curr_state_data(r):; return vec2mat(r.y). #; # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if opt.store_states or expt_callback:; cdata = get_curr_state_data(r); fdata = dense2D_to_fastcsr_fmode(cdata, size, size). # Try to guess if there is a fast path for rho_t; if issuper(rho0) or not rho0.isherm:; rho_t = Qobj(fdata, dims=dims); else:; rho_t = Qobj(fdata, dims=dims, fast=""mc-dm""). if opt.store_states:; output.states.append(rho_t). if expt_callback:; # use callback method; output.expect.append(e_ops(t, rho_t)). for m in range(n_expt_op):; output.expect[m][t_idx] = expect_rho_vec(e_ops_data[m], r.y,; e_ops[m].isherm; and rho0.isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if opt.store_final_state:; cdata = get_curr_state_data(r); output.final_state = Qobj(cdata, dims=dims,; isherm=rho0.isherm or None). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lamb",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:2237,Deployability,integrat,integrate,2237,"PYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the Lindblad master equation and von Neumann; equation.; """""". __all__ = ['mesolve']. import numpy as np; import scipy.integrate; from qutip.qobj import Qobj, isket, isoper, issuper; from qutip.superoperator import spre, spost, liouvillian, vec2mat, lindblad_dissipator; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, solver_safe, SolverSystem; from qutip.cy.spmatfuncs import spmv; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.states import ket2dm; from qutip.sesolve import sesolve; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.qobjevo import QobjEvo. from qutip.cy.openmp.utilities import check_use_openmp. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operato",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:3426,Deployability,integrat,integrating,3426,"; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, solver_safe, SolverSystem; from qutip.cy.spmatfuncs import spmv; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.states import ket2dm; from qutip.sesolve import sesolve; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.qobjevo import QobjEvo. from qutip.cy.openmp.utilities import check_use_openmp. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian or Liouvillian (`H`) and an optional set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, `H` and `c_ops` can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (:class:`qutip.qobj`) at the first",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:5818,Deployability,integrat,integration,5818,"ouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used. *Examples*. H = [[H0, 'sin(w*t)'], [H1, 'sin(2*w*t)']]. H = [[H0, f0_t], [H1, f1_t]]. where f0_t and f1_t are python functions with signature f_t(t, args). H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the *list string format* and *list callback format*, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator). In all cases of time-dependent operators, `args` is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument. **Additional options**. Additional options to mesolve can be set via the `options` argument, which; should be an instance of :class:`qutip.solver.Options`. Many ODE; integration options can be set this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` argument. .. note::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. .. note::. On using callback functions: mesolve transforms all :class:`qutip.Qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.Qobj` objects that are used in constructing the; Hamiltonian via `args`. mesolve will check for :class:`qutip.Qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.Qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise a NotImplemented; exce",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:6482,Deployability,integrat,integrator,6482,"rator). In all cases of time-dependent operators, `args` is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument. **Additional options**. Additional options to mesolve can be set via the `options` argument, which; should be an instance of :class:`qutip.solver.Options`. Many ODE; integration options can be set this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` argument. .. note::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. .. note::. On using callback functions: mesolve transforms all :class:`qutip.Qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.Qobj` objects that are used in constructing the; Hamiltonian via `args`. mesolve will check for :class:`qutip.Qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.Qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : None / list of :class:`qutip.Qobj`; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : None / list of :class:`qutip.Qobj` / callback function single; single operator or list of operat",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:6852,Deployability,integrat,integrator,6852,"this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` argument. .. note::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. .. note::. On using callback functions: mesolve transforms all :class:`qutip.Qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.Qobj` objects that are used in constructing the; Hamiltonian via `args`. mesolve will check for :class:`qutip.Qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.Qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : None / list of :class:`qutip.Qobj`; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : None / list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : None / *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : None / :class:`qutip.Options`; with options for the solver. progress_bar : None / BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns; -------; ",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:16180,Deployability,integrat,integrate,16180,"f _ode_super_func_td(t, y, L_func, args):; L = L_func(t, y, args); ym = vec2mat(y); return (L*ym).ravel('F'). # -----------------------------------------------------------------------------; # Generic ODE solver: shared code among the various ODE solver; # -----------------------------------------------------------------------------. def _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, opt,; progress_bar, dims=None):; """"""; Internal function for solving ME.; Calculate the required expectation values or invoke; callback function at each time step.; """"""; # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%; # This function is made similar to sesolve's one for futur merging in a; # solver class; # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%. # prepare output array; n_tsteps = len(tlist); output = Result(); output.solver = ""mesolve""; output.times = tlist; size = rho0.shape[0]. initial_vector = rho0.full().ravel('F'). r = scipy.integrate.ode(func); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); if ode_args:; r.set_f_params(*ode_args); r.set_initial_value(initial_vector, tlist[0]). e_ops_data = []; output.expect = []; if callable(e_ops):; n_expt_op = 0; expt_callback = True; output.num_expect = 1; elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False; output.num_expect = n_expt_op; if n_expt_op == 0:; # fall back on storing states; opt.store_states = True; else:; for op in e_ops:; if op.dims != rho0.dims:; raise TypeError(f""e_ops dims ({op.dims}) are not ""; f""compatible with the state's ""; f""({rho0.dims})""); e_ops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). i",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:17414,Deployability,update,update,17414,"e_args); r.set_initial_value(initial_vector, tlist[0]). e_ops_data = []; output.expect = []; if callable(e_ops):; n_expt_op = 0; expt_callback = True; output.num_expect = 1; elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False; output.num_expect = n_expt_op; if n_expt_op == 0:; # fall back on storing states; opt.store_states = True; else:; for op in e_ops:; if op.dims != rho0.dims:; raise TypeError(f""e_ops dims ({op.dims}) are not ""; f""compatible with the state's ""; f""({rho0.dims})""); e_ops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). if opt.store_states:; output.states = []. def get_curr_state_data(r):; return vec2mat(r.y). #; # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if opt.store_states or expt_callback:; cdata = get_curr_state_data(r); fdata = dense2D_to_fastcsr_fmode(cdata, size, size). # Try to guess if there is a fast path for rho_t; if issuper(rho0) or not rho0.isherm:; rho_t = Qobj(fdata, dims=dims); else:; rho_t = Qobj(fdata, dims=dims, fast=""mc-dm""). if opt.store_states:; output.states.append(rho_t). if expt_callback:; # use callback method; output.expect.append(e_ops(t, rho_t)). for m in range(n_expt_op):; output.expect[m][t_idx] = expect_rho_vec(e_ops_data[m], r.y,; e_ops[m].isherm; and rho0.isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if opt.store_final_state:; cdata = get_curr_state_data(r); output.final_state = Qobj(cdata, dims=dims,; isherm=rho0.isherm or None). return output. © Copyright 2011 and later, P.",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:17474,Deployability,integrat,integration,17474,"able(e_ops):; n_expt_op = 0; expt_callback = True; output.num_expect = 1; elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False; output.num_expect = n_expt_op; if n_expt_op == 0:; # fall back on storing states; opt.store_states = True; else:; for op in e_ops:; if op.dims != rho0.dims:; raise TypeError(f""e_ops dims ({op.dims}) are not ""; f""compatible with the state's ""; f""({rho0.dims})""); e_ops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). if opt.store_states:; output.states = []. def get_curr_state_data(r):; return vec2mat(r.y). #; # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if opt.store_states or expt_callback:; cdata = get_curr_state_data(r); fdata = dense2D_to_fastcsr_fmode(cdata, size, size). # Try to guess if there is a fast path for rho_t; if issuper(rho0) or not rho0.isherm:; rho_t = Qobj(fdata, dims=dims); else:; rho_t = Qobj(fdata, dims=dims, fast=""mc-dm""). if opt.store_states:; output.states.append(rho_t). if expt_callback:; # use callback method; output.expect.append(e_ops(t, rho_t)). for m in range(n_expt_op):; output.expect[m][t_idx] = expect_rho_vec(e_ops_data[m], r.y,; e_ops[m].isherm; and rho0.isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if opt.store_final_state:; cdata = get_curr_state_data(r); output.final_state = Qobj(cdata, dims=dims,; isherm=rho0.isherm or None). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lamb",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:18190,Deployability,integrat,integrate,18190,"num_expect = n_expt_op; if n_expt_op == 0:; # fall back on storing states; opt.store_states = True; else:; for op in e_ops:; if op.dims != rho0.dims:; raise TypeError(f""e_ops dims ({op.dims}) are not ""; f""compatible with the state's ""; f""({rho0.dims})""); e_ops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). if opt.store_states:; output.states = []. def get_curr_state_data(r):; return vec2mat(r.y). #; # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if opt.store_states or expt_callback:; cdata = get_curr_state_data(r); fdata = dense2D_to_fastcsr_fmode(cdata, size, size). # Try to guess if there is a fast path for rho_t; if issuper(rho0) or not rho0.isherm:; rho_t = Qobj(fdata, dims=dims); else:; rho_t = Qobj(fdata, dims=dims, fast=""mc-dm""). if opt.store_states:; output.states.append(rho_t). if expt_callback:; # use callback method; output.expect.append(e_ops(t, rho_t)). for m in range(n_expt_op):; output.expect[m][t_idx] = expect_rho_vec(e_ops_data[m], r.y,; e_ops[m].isherm; and rho0.isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if opt.store_final_state:; cdata = get_curr_state_data(r); output.final_state = Qobj(cdata, dims=dims,; isherm=rho0.isherm or None). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:18579,Deployability,update,updated,18579,"num_expect = n_expt_op; if n_expt_op == 0:; # fall back on storing states; opt.store_states = True; else:; for op in e_ops:; if op.dims != rho0.dims:; raise TypeError(f""e_ops dims ({op.dims}) are not ""; f""compatible with the state's ""; f""({rho0.dims})""); e_ops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). if opt.store_states:; output.states = []. def get_curr_state_data(r):; return vec2mat(r.y). #; # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if opt.store_states or expt_callback:; cdata = get_curr_state_data(r); fdata = dense2D_to_fastcsr_fmode(cdata, size, size). # Try to guess if there is a fast path for rho_t; if issuper(rho0) or not rho0.isherm:; rho_t = Qobj(fdata, dims=dims); else:; rho_t = Qobj(fdata, dims=dims, fast=""mc-dm""). if opt.store_states:; output.states.append(rho_t). if expt_callback:; # use callback method; output.expect.append(e_ops(t, rho_t)). for m in range(n_expt_op):; output.expect[m][t_idx] = expect_rho_vec(e_ops_data[m], r.y,; e_ops[m].isherm; and rho0.isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if opt.store_final_state:; cdata = get_curr_state_data(r); output.final_state = Qobj(cdata, dims=dims,; isherm=rho0.isherm or None). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:2237,Integrability,integrat,integrate,2237,"PYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the Lindblad master equation and von Neumann; equation.; """""". __all__ = ['mesolve']. import numpy as np; import scipy.integrate; from qutip.qobj import Qobj, isket, isoper, issuper; from qutip.superoperator import spre, spost, liouvillian, vec2mat, lindblad_dissipator; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, solver_safe, SolverSystem; from qutip.cy.spmatfuncs import spmv; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.states import ket2dm; from qutip.sesolve import sesolve; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.qobjevo import QobjEvo. from qutip.cy.openmp.utilities import check_use_openmp. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operato",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:2960,Integrability,depend,depending,2960," THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the Lindblad master equation and von Neumann; equation.; """""". __all__ = ['mesolve']. import numpy as np; import scipy.integrate; from qutip.qobj import Qobj, isket, isoper, issuper; from qutip.superoperator import spre, spost, liouvillian, vec2mat, lindblad_dissipator; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, solver_safe, SolverSystem; from qutip.cy.spmatfuncs import spmv; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.states import ket2dm; from qutip.sesolve import sesolve; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.qobjevo import QobjEvo. from qutip.cy.openmp.utilities import check_use_openmp. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian or Liouvillian (`H`) and an optional set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return val",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:3426,Integrability,integrat,integrating,3426,"; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, solver_safe, SolverSystem; from qutip.cy.spmatfuncs import spmv; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.states import ket2dm; from qutip.sesolve import sesolve; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.qobjevo import QobjEvo. from qutip.cy.openmp.utilities import check_use_openmp. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian or Liouvillian (`H`) and an optional set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, `H` and `c_ops` can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (:class:`qutip.qobj`) at the first",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:4163,Integrability,depend,dependent,4163,"ution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian or Liouvillian (`H`) and an optional set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, `H` and `c_ops` can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (:class:`qutip.qobj`) at the first element and where; the second element is either a string (*list string format*), a callback; function (*list callback format*) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (*list; array format*) which specifies the value of the coefficient to the; corresponding operator for each value of t in `tlist`. Alternatively, `H` (but not `c_ops`) can be a callback function with the; signature `f(t, args) -> Qobj` (*callback format*), which can return the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used. *Examples*. H = [[H0, 'sin(w*t)'], [H1, 'sin(2*w*t)']]. H = [[H0, f0_t], [H1, f1_t]]. where f0_t and f1_t ar",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:4195,Integrability,depend,dependent,4195," the state vector or density matrix (`rho0`) using a given; Hamiltonian or Liouvillian (`H`) and an optional set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, `H` and `c_ops` can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (:class:`qutip.qobj`) at the first element and where; the second element is either a string (*list string format*), a callback; function (*list callback format*) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (*list; array format*) which specifies the value of the coefficient to the; corresponding operator for each value of t in `tlist`. Alternatively, `H` (but not `c_ops`) can be a callback function with the; signature `f(t, args) -> Qobj` (*callback format*), which can return the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used. *Examples*. H = [[H0, 'sin(w*t)'], [H1, 'sin(2*w*t)']]. H = [[H0, f0_t], [H1, f1_t]]. where f0_t and f1_t are python functions with signature f_t(t, args). H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In th",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:4542,Integrability,depend,dependent,4542,"; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, `H` and `c_ops` can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (:class:`qutip.qobj`) at the first element and where; the second element is either a string (*list string format*), a callback; function (*list callback format*) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (*list; array format*) which specifies the value of the coefficient to the; corresponding operator for each value of t in `tlist`. Alternatively, `H` (but not `c_ops`) can be a callback function with the; signature `f(t, args) -> Qobj` (*callback format*), which can return the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used. *Examples*. H = [[H0, 'sin(w*t)'], [H1, 'sin(2*w*t)']]. H = [[H0, f0_t], [H1, f1_t]]. where f0_t and f1_t are python functions with signature f_t(t, args). H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the *list string format* and *list callback format*, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator). In all cases of time-dependent operators, `args` is a dictionary of; parameters that is us",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:5029,Integrability,depend,dependence,5029,"ted as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, `H` and `c_ops` can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (:class:`qutip.qobj`) at the first element and where; the second element is either a string (*list string format*), a callback; function (*list callback format*) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (*list; array format*) which specifies the value of the coefficient to the; corresponding operator for each value of t in `tlist`. Alternatively, `H` (but not `c_ops`) can be a callback function with the; signature `f(t, args) -> Qobj` (*callback format*), which can return the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used. *Examples*. H = [[H0, 'sin(w*t)'], [H1, 'sin(2*w*t)']]. H = [[H0, f0_t], [H1, f1_t]]. where f0_t and f1_t are python functions with signature f_t(t, args). H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the *list string format* and *list callback format*, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator). In all cases of time-dependent operators, `args` is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument. **Additional options**. Additional options to mesolve can be set via the `options` argument, which; should be an instance of :class:`qutip.solver.Options`. Many ODE; integration options can be set this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` arg",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:5487,Integrability,depend,dependent,5487,"ates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (*list; array format*) which specifies the value of the coefficient to the; corresponding operator for each value of t in `tlist`. Alternatively, `H` (but not `c_ops`) can be a callback function with the; signature `f(t, args) -> Qobj` (*callback format*), which can return the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used. *Examples*. H = [[H0, 'sin(w*t)'], [H1, 'sin(2*w*t)']]. H = [[H0, f0_t], [H1, f1_t]]. where f0_t and f1_t are python functions with signature f_t(t, args). H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the *list string format* and *list callback format*, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator). In all cases of time-dependent operators, `args` is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument. **Additional options**. Additional options to mesolve can be set via the `options` argument, which; should be an instance of :class:`qutip.solver.Options`. Many ODE; integration options can be set this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` argument. .. note::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. .. note::. On using callback functions: mesolve transforms all :class:`qutip.Qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your cal",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:5818,Integrability,integrat,integration,5818,"ouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used. *Examples*. H = [[H0, 'sin(w*t)'], [H1, 'sin(2*w*t)']]. H = [[H0, f0_t], [H1, f1_t]]. where f0_t and f1_t are python functions with signature f_t(t, args). H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the *list string format* and *list callback format*, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator). In all cases of time-dependent operators, `args` is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument. **Additional options**. Additional options to mesolve can be set via the `options` argument, which; should be an instance of :class:`qutip.solver.Options`. Many ODE; integration options can be set this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` argument. .. note::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. .. note::. On using callback functions: mesolve transforms all :class:`qutip.Qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.Qobj` objects that are used in constructing the; Hamiltonian via `args`. mesolve will check for :class:`qutip.Qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.Qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise a NotImplemented; exce",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:6482,Integrability,integrat,integrator,6482,"rator). In all cases of time-dependent operators, `args` is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument. **Additional options**. Additional options to mesolve can be set via the `options` argument, which; should be an instance of :class:`qutip.solver.Options`. Many ODE; integration options can be set this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` argument. .. note::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. .. note::. On using callback functions: mesolve transforms all :class:`qutip.Qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.Qobj` objects that are used in constructing the; Hamiltonian via `args`. mesolve will check for :class:`qutip.Qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.Qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : None / list of :class:`qutip.Qobj`; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : None / list of :class:`qutip.Qobj` / callback function single; single operator or list of operat",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:6852,Integrability,integrat,integrator,6852,"this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` argument. .. note::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. .. note::. On using callback functions: mesolve transforms all :class:`qutip.Qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.Qobj` objects that are used in constructing the; Hamiltonian via `args`. mesolve will check for :class:`qutip.Qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.Qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : None / list of :class:`qutip.Qobj`; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : None / list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : None / *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : None / :class:`qutip.Options`; with options for the solver. progress_bar : None / BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns; -------; ",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:7019,Integrability,depend,dependent,7019,"e::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. .. note::. On using callback functions: mesolve transforms all :class:`qutip.Qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.Qobj` objects that are used in constructing the; Hamiltonian via `args`. mesolve will check for :class:`qutip.Qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.Qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : None / list of :class:`qutip.Qobj`; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : None / list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : None / *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : None / :class:`qutip.Options`; with options for the solver. progress_bar : None / BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns; -------; result: :class:`qutip.Result`. An instance of the class :class:`qutip.Result`, which contains; either an *array* `result.expect` of expectation values for the times; specif",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:7568,Integrability,depend,dependent,7568,"ass; all :class:`qutip.Qobj` objects that are used in constructing the; Hamiltonian via `args`. mesolve will check for :class:`qutip.Qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.Qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : None / list of :class:`qutip.Qobj`; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : None / list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : None / *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : None / :class:`qutip.Options`; with options for the solver. progress_bar : None / BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns; -------; result: :class:`qutip.Result`. An instance of the class :class:`qutip.Result`, which contains; either an *array* `result.expect` of expectation values for the times; specified by `tlist`, or an *array* `result.states` of state vectors or; density matrices corresponding to the times in `tlist` [if `e_ops` is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. """"""; if c_ops is None:; c_ops = []; if isinstance(c_ops, (Qobj, QobjEvo)):; c_ops = [c_ops]. if e_ops is None:; e_ops = []; if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_di",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:10903,Integrability,depend,dependent,10903,"o0.dims[0] != rho0.dims[1]):; raise ValueError(; ""input state must be a pure state vector, square density matrix, ""; ""or superoperator""; ). if isinstance(H, SolverSystem):; ss = H; elif isinstance(H, (list, Qobj, QobjEvo)):; ss = _mesolve_QobjEvo(H, c_ops, tlist, args, options); elif callable(H):; ss = _mesolve_func_td(H, c_ops, rho0, tlist, args, options); else:; raise Exception(""Invalid H type""). func, ode_args = ss.makefunc(ss, rho0, args, e_ops, options). if _safe_mode:; # This is to test safety of the function before starting the loop.; v = rho0.full().ravel('F'); func(0., v, *ode_args) + v. res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; progress_bar, dims=rho0.dims); res.num_collapse = len(c_ops). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #_mesolve_QobjEvo(H, c_ops, tlist, args, options); def _mesolve_QobjEvo(H, c_ops, tlist, args, opt):; """"""; Prepare the system for the solver, H can be an QobjEvo.; """"""; H_td = QobjEvo(H, args, tlist=tlist); if not issuper(H_td.cte):; L_td = liouvillian(H_td); else:; L_td = H_td; for op in c_ops:; # We want to avoid passing tlist where it isn't necessary, to allow a; # Hamiltonian/Liouvillian which already _has_ time-dependence not equal; # to the mesolve evaluation times to be used in conjunction with; # time-independent c_ops. If we _always_ pass it, it may appear to; # QobjEvo that there is a tlist mismatch, even though it is not used.; if isinstance(op, Qobj):; op_td = QobjEvo(op); elif isinstance(op, QobjEvo):; op_td = QobjEvo(op, args); else:; op_td = QobjEvo(op, args, tlist=tlist); if not issuper(op_td.cte):; op_td = lindblad_dissipator(op_td); L_td += op_td. if opt.rhs_with_state:; L_td._check_old_with_state(). nthread = opt.openmp_threads if opt.use_openmp else 0; L_td.compile(o",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:11392,Integrability,depend,dependence,11392,"ion(""Invalid H type""). func, ode_args = ss.makefunc(ss, rho0, args, e_ops, options). if _safe_mode:; # This is to test safety of the function before starting the loop.; v = rho0.full().ravel('F'); func(0., v, *ode_args) + v. res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; progress_bar, dims=rho0.dims); res.num_collapse = len(c_ops). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #_mesolve_QobjEvo(H, c_ops, tlist, args, options); def _mesolve_QobjEvo(H, c_ops, tlist, args, opt):; """"""; Prepare the system for the solver, H can be an QobjEvo.; """"""; H_td = QobjEvo(H, args, tlist=tlist); if not issuper(H_td.cte):; L_td = liouvillian(H_td); else:; L_td = H_td; for op in c_ops:; # We want to avoid passing tlist where it isn't necessary, to allow a; # Hamiltonian/Liouvillian which already _has_ time-dependence not equal; # to the mesolve evaluation times to be used in conjunction with; # time-independent c_ops. If we _always_ pass it, it may appear to; # QobjEvo that there is a tlist mismatch, even though it is not used.; if isinstance(op, Qobj):; op_td = QobjEvo(op); elif isinstance(op, QobjEvo):; op_td = QobjEvo(op, args); else:; op_td = QobjEvo(op, args, tlist=tlist); if not issuper(op_td.cte):; op_td = lindblad_dissipator(op_td); L_td += op_td. if opt.rhs_with_state:; L_td._check_old_with_state(). nthread = opt.openmp_threads if opt.use_openmp else 0; L_td.compile(omp=nthread). ss = SolverSystem(); ss.H = L_td; ss.makefunc = _qobjevo_set; solver_safe[""mesolve""] = ss; return ss. def _test_liouvillian_dimensions(L_dims, rho_dims):; """"""; Raise ValueError if the dimensions of the Liouvillian and the density; matrix or superoperator state are incompatible with the master equation.; """"""; if L_dims[0] != L_dims[1]:; raise ValueError(""Liouvillia",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:13201,Integrability,depend,dependence,13201," """"""; Raise ValueError if the dimensions of the Liouvillian and the density; matrix or superoperator state are incompatible with the master equation.; """"""; if L_dims[0] != L_dims[1]:; raise ValueError(""Liouvillian had nonsquare dims: "" + str(L_dims)); if not ((L_dims[1] == rho_dims) or (L_dims[1] == rho_dims[0])):; raise ValueError("""".join([; ""incompatible Liouvillian and state dimensions: "",; str(L_dims), "" and "", str(rho_dims),; ])). def _qobjevo_set(HS, rho0, args, e_ops, opt):; """"""; From the system, get the ode function and args; """"""; H_td = HS.H; H_td.solver_set_args(args, rho0, e_ops); if issuper(rho0):; func = H_td.compiled_qobjevo.ode_mul_mat_f_vec; elif rho0.isket or rho0.isoper:; func = H_td.compiled_qobjevo.mul_vec; else:; # Should be caught earlier in mesolve.; raise ValueError(""rho0 must be a ket, density matrix or superoperator""); _test_liouvillian_dimensions(H_td.cte.dims, rho0.dims); return func, (). # -----------------------------------------------------------------------------; # Master equation solver for python-function time-dependence.; #; class _LiouvillianFromFunc:; def __init__(self, func, c_ops, rho_dims):; self.f = func; self.c_ops = c_ops; self.rho_dims = rho_dims. def H2L(self, t, rho, args):; Ht = self.f(t, args); Lt = -1.0j * (spre(Ht) - spost(Ht)); _test_liouvillian_dimensions(Lt.dims, self.rho_dims); Lt = Lt.data; for op in self.c_ops:; Lt += op(t).data; return Lt. def H2L_with_state(self, t, rho, args):; Ht = self.f(t, rho, args); Lt = -1.0j * (spre(Ht) - spost(Ht)); _test_liouvillian_dimensions(Lt.dims, self.rho_dims); Lt = Lt.data; for op in self.c_ops:; Lt += op(t).data; return Lt. def L(self, t, rho, args):; Lt = self.f(t, args); _test_liouvillian_dimensions(Lt.dims, self.rho_dims); Lt = Lt.data; for op in self.c_ops:; Lt += op(t).data; return Lt. def L_with_state(self, t, rho, args):; Lt = self.f(t, rho, args); _test_liouvillian_dimensions(Lt.dims, self.rho_dims); Lt = Lt.data; for op in self.c_ops:; Lt += op(t).data; return Lt. ",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:14268,Integrability,depend,dependent,14268,"; class _LiouvillianFromFunc:; def __init__(self, func, c_ops, rho_dims):; self.f = func; self.c_ops = c_ops; self.rho_dims = rho_dims. def H2L(self, t, rho, args):; Ht = self.f(t, args); Lt = -1.0j * (spre(Ht) - spost(Ht)); _test_liouvillian_dimensions(Lt.dims, self.rho_dims); Lt = Lt.data; for op in self.c_ops:; Lt += op(t).data; return Lt. def H2L_with_state(self, t, rho, args):; Ht = self.f(t, rho, args); Lt = -1.0j * (spre(Ht) - spost(Ht)); _test_liouvillian_dimensions(Lt.dims, self.rho_dims); Lt = Lt.data; for op in self.c_ops:; Lt += op(t).data; return Lt. def L(self, t, rho, args):; Lt = self.f(t, args); _test_liouvillian_dimensions(Lt.dims, self.rho_dims); Lt = Lt.data; for op in self.c_ops:; Lt += op(t).data; return Lt. def L_with_state(self, t, rho, args):; Lt = self.f(t, rho, args); _test_liouvillian_dimensions(Lt.dims, self.rho_dims); Lt = Lt.data; for op in self.c_ops:; Lt += op(t).data; return Lt. def _mesolve_func_td(L_func, c_op_list, rho0, tlist, args, opt):; """"""; Evolve the density matrix using an ODE solver with time dependent; Hamiltonian.; """"""; c_ops = []; for op in c_op_list:; td = QobjEvo(op, args, tlist=tlist, copy=False); c_ops.append(td if td.cte.issuper else lindblad_dissipator(td)); c_ops_ = [sum(c_ops)] if c_op_list else []; L_api = _LiouvillianFromFunc(L_func, c_ops_, rho0.dims); if opt.rhs_with_state:; obj = L_func(0., rho0.full().ravel(""F""), args); L_func = L_api.L_with_state if issuper(obj) else L_api.H2L_with_state; else:; obj = L_func(0., args); L_func = L_api.L if issuper(obj) else L_api.H2L; ss = SolverSystem(); ss.L = L_func; ss.makefunc = _Lfunc_set; solver_safe[""mesolve""] = ss; return ss. def _Lfunc_set(HS, rho0, args, e_ops, opt):; """"""; From the system, get the ode function and args; """"""; L_func = HS.L; if issuper(rho0):; func = _ode_super_func_td; else:; func = _ode_rho_func_td. return func, (L_func, args). def _ode_rho_func_td(t, y, L_func, args):; L = L_func(t, y, args); return spmv(L, y). def _ode_super_func_td(t, y, L_fu",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:16180,Integrability,integrat,integrate,16180,"f _ode_super_func_td(t, y, L_func, args):; L = L_func(t, y, args); ym = vec2mat(y); return (L*ym).ravel('F'). # -----------------------------------------------------------------------------; # Generic ODE solver: shared code among the various ODE solver; # -----------------------------------------------------------------------------. def _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, opt,; progress_bar, dims=None):; """"""; Internal function for solving ME.; Calculate the required expectation values or invoke; callback function at each time step.; """"""; # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%; # This function is made similar to sesolve's one for futur merging in a; # solver class; # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%. # prepare output array; n_tsteps = len(tlist); output = Result(); output.solver = ""mesolve""; output.times = tlist; size = rho0.shape[0]. initial_vector = rho0.full().ravel('F'). r = scipy.integrate.ode(func); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); if ode_args:; r.set_f_params(*ode_args); r.set_initial_value(initial_vector, tlist[0]). e_ops_data = []; output.expect = []; if callable(e_ops):; n_expt_op = 0; expt_callback = True; output.num_expect = 1; elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False; output.num_expect = n_expt_op; if n_expt_op == 0:; # fall back on storing states; opt.store_states = True; else:; for op in e_ops:; if op.dims != rho0.dims:; raise TypeError(f""e_ops dims ({op.dims}) are not ""; f""compatible with the state's ""; f""({rho0.dims})""); e_ops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). i",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:17474,Integrability,integrat,integration,17474,"able(e_ops):; n_expt_op = 0; expt_callback = True; output.num_expect = 1; elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False; output.num_expect = n_expt_op; if n_expt_op == 0:; # fall back on storing states; opt.store_states = True; else:; for op in e_ops:; if op.dims != rho0.dims:; raise TypeError(f""e_ops dims ({op.dims}) are not ""; f""compatible with the state's ""; f""({rho0.dims})""); e_ops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). if opt.store_states:; output.states = []. def get_curr_state_data(r):; return vec2mat(r.y). #; # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if opt.store_states or expt_callback:; cdata = get_curr_state_data(r); fdata = dense2D_to_fastcsr_fmode(cdata, size, size). # Try to guess if there is a fast path for rho_t; if issuper(rho0) or not rho0.isherm:; rho_t = Qobj(fdata, dims=dims); else:; rho_t = Qobj(fdata, dims=dims, fast=""mc-dm""). if opt.store_states:; output.states.append(rho_t). if expt_callback:; # use callback method; output.expect.append(e_ops(t, rho_t)). for m in range(n_expt_op):; output.expect[m][t_idx] = expect_rho_vec(e_ops_data[m], r.y,; e_ops[m].isherm; and rho0.isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if opt.store_final_state:; cdata = get_curr_state_data(r); output.final_state = Qobj(cdata, dims=dims,; isherm=rho0.isherm or None). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lamb",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:18190,Integrability,integrat,integrate,18190,"num_expect = n_expt_op; if n_expt_op == 0:; # fall back on storing states; opt.store_states = True; else:; for op in e_ops:; if op.dims != rho0.dims:; raise TypeError(f""e_ops dims ({op.dims}) are not ""; f""compatible with the state's ""; f""({rho0.dims})""); e_ops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). if opt.store_states:; output.states = []. def get_curr_state_data(r):; return vec2mat(r.y). #; # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if opt.store_states or expt_callback:; cdata = get_curr_state_data(r); fdata = dense2D_to_fastcsr_fmode(cdata, size, size). # Try to guess if there is a fast path for rho_t; if issuper(rho0) or not rho0.isherm:; rho_t = Qobj(fdata, dims=dims); else:; rho_t = Qobj(fdata, dims=dims, fast=""mc-dm""). if opt.store_states:; output.states.append(rho_t). if expt_callback:; # use callback method; output.expect.append(e_ops(t, rho_t)). for m in range(n_expt_op):; output.expect[m][t_idx] = expect_rho_vec(e_ops_data[m], r.y,; e_ops[m].isherm; and rho0.isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if opt.store_final_state:; cdata = get_curr_state_data(r); output.final_state = Qobj(cdata, dims=dims,; isherm=rho0.isherm or None). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:3558,Modifiability,evolve,evolved,3558,"mport dense2D_to_fastcsr_fmode; from qutip.states import ket2dm; from qutip.sesolve import sesolve; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.qobjevo import QobjEvo. from qutip.cy.openmp.utilities import check_use_openmp. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian or Liouvillian (`H`) and an optional set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, `H` and `c_ops` can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (:class:`qutip.qobj`) at the first element and where; the second element is either a string (*list string format*), a callback; function (*list callback format*) that evaluates to the time-dependent; coefficien",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:10471,Safety,safe,safety,10471,"isinstance(H, list) and isinstance(H[0], Qobj) and; issuper(H[0])); or (not isinstance(H, (Qobj, QobjEvo)) and callable(H) and; not options.rhs_with_state and issuper(H(0., args))); or (not isinstance(H, (Qobj, QobjEvo)) and callable(H) and; options.rhs_with_state)). if not use_mesolve:; return sesolve(H, rho0, tlist, e_ops=e_ops, args=args, options=options,; progress_bar=progress_bar, _safe_mode=_safe_mode). if isket(rho0):; rho0 = ket2dm(rho0); if (not (rho0.isoper or rho0.issuper)) or (rho0.dims[0] != rho0.dims[1]):; raise ValueError(; ""input state must be a pure state vector, square density matrix, ""; ""or superoperator""; ). if isinstance(H, SolverSystem):; ss = H; elif isinstance(H, (list, Qobj, QobjEvo)):; ss = _mesolve_QobjEvo(H, c_ops, tlist, args, options); elif callable(H):; ss = _mesolve_func_td(H, c_ops, rho0, tlist, args, options); else:; raise Exception(""Invalid H type""). func, ode_args = ss.makefunc(ss, rho0, args, e_ops, options). if _safe_mode:; # This is to test safety of the function before starting the loop.; v = rho0.full().ravel('F'); func(0., v, *ode_args) + v. res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; progress_bar, dims=rho0.dims); res.num_collapse = len(c_ops). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #_mesolve_QobjEvo(H, c_ops, tlist, args, options); def _mesolve_QobjEvo(H, c_ops, tlist, args, opt):; """"""; Prepare the system for the solver, H can be an QobjEvo.; """"""; H_td = QobjEvo(H, args, tlist=tlist); if not issuper(H_td.cte):; L_td = liouvillian(H_td); else:; L_td = H_td; for op in c_ops:; # We want to avoid passing tlist where it isn't necessary, to allow a; # Hamiltonian/Liouvillian which already _has_ time-dependence not equal; # to the mesolve evaluation times to be used in conjunction with",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:11283,Safety,avoid,avoid,11283,"ion(""Invalid H type""). func, ode_args = ss.makefunc(ss, rho0, args, e_ops, options). if _safe_mode:; # This is to test safety of the function before starting the loop.; v = rho0.full().ravel('F'); func(0., v, *ode_args) + v. res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; progress_bar, dims=rho0.dims); res.num_collapse = len(c_ops). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #_mesolve_QobjEvo(H, c_ops, tlist, args, options); def _mesolve_QobjEvo(H, c_ops, tlist, args, opt):; """"""; Prepare the system for the solver, H can be an QobjEvo.; """"""; H_td = QobjEvo(H, args, tlist=tlist); if not issuper(H_td.cte):; L_td = liouvillian(H_td); else:; L_td = H_td; for op in c_ops:; # We want to avoid passing tlist where it isn't necessary, to allow a; # Hamiltonian/Liouvillian which already _has_ time-dependence not equal; # to the mesolve evaluation times to be used in conjunction with; # time-independent c_ops. If we _always_ pass it, it may appear to; # QobjEvo that there is a tlist mismatch, even though it is not used.; if isinstance(op, Qobj):; op_td = QobjEvo(op); elif isinstance(op, QobjEvo):; op_td = QobjEvo(op, args); else:; op_td = QobjEvo(op, args, tlist=tlist); if not issuper(op_td.cte):; op_td = lindblad_dissipator(op_td); L_td += op_td. if opt.rhs_with_state:; L_td._check_old_with_state(). nthread = opt.openmp_threads if opt.use_openmp else 0; L_td.compile(omp=nthread). ss = SolverSystem(); ss.H = L_td; ss.makefunc = _qobjevo_set; solver_safe[""mesolve""] = ss; return ss. def _test_liouvillian_dimensions(L_dims, rho_dims):; """"""; Raise ValueError if the dimensions of the Liouvillian and the density; matrix or superoperator state are incompatible with the master equation.; """"""; if L_dims[0] != L_dims[1]:; raise ValueError(""Liouvillia",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/mesolve.html:10466,Testability,test,test,10466,"isinstance(H, list) and isinstance(H[0], Qobj) and; issuper(H[0])); or (not isinstance(H, (Qobj, QobjEvo)) and callable(H) and; not options.rhs_with_state and issuper(H(0., args))); or (not isinstance(H, (Qobj, QobjEvo)) and callable(H) and; options.rhs_with_state)). if not use_mesolve:; return sesolve(H, rho0, tlist, e_ops=e_ops, args=args, options=options,; progress_bar=progress_bar, _safe_mode=_safe_mode). if isket(rho0):; rho0 = ket2dm(rho0); if (not (rho0.isoper or rho0.issuper)) or (rho0.dims[0] != rho0.dims[1]):; raise ValueError(; ""input state must be a pure state vector, square density matrix, ""; ""or superoperator""; ). if isinstance(H, SolverSystem):; ss = H; elif isinstance(H, (list, Qobj, QobjEvo)):; ss = _mesolve_QobjEvo(H, c_ops, tlist, args, options); elif callable(H):; ss = _mesolve_func_td(H, c_ops, rho0, tlist, args, options); else:; raise Exception(""Invalid H type""). func, ode_args = ss.makefunc(ss, rho0, args, e_ops, options). if _safe_mode:; # This is to test safety of the function before starting the loop.; v = rho0.full().ravel('F'); func(0., v, *ode_args) + v. res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; progress_bar, dims=rho0.dims); res.num_collapse = len(c_ops). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #_mesolve_QobjEvo(H, c_ops, tlist, args, options); def _mesolve_QobjEvo(H, c_ops, tlist, args, opt):; """"""; Prepare the system for the solver, H can be an QobjEvo.; """"""; H_td = QobjEvo(H, args, tlist=tlist); if not issuper(H_td.cte):; L_td = liouvillian(H_td); else:; L_td = H_td; for op in c_ops:; # We want to avoid passing tlist where it isn't necessary, to allow a; # Hamiltonian/Liouvillian which already _has_ time-dependence not equal; # to the mesolve evaluation times to be used in conjunction with",MatchSource.WIKI,docs/4.6/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html
https://qutip.org/docs/4.6/modules/qutip/metrics.html:12227,Availability,error,error,12227,"Ti and SchattenNorms.jl. (By contrast,; # QETLAB uses the dual problem.). # Check if A and B are both unitaries. If so, then we can without; # loss of generality choose B to be the identity by using the; # unitary invariance of the diamond norm,; # || A - B ||_♢ = || A B⁺ - I ||_♢.; # Then, using the technique mentioned by each of Johnston and; # da Silva,; # || A B⁺ - I ||_♢ = max_{i, j} | \lambda_i(A B⁺) - \lambda_j(A B⁺) |,; # where \lambda_i(U) is the ith eigenvalue of U. if (; # There's a lot of conditions to check for this path.; not force_solve and B is not None and; # Only check if they aren't superoperators.; A.type == ""oper"" and B.type == ""oper"" and; # The difference of unitaries optimization is currently; # only implemented for d == 2. Much of the code below is more general,; # though, in anticipation of generalizing the optimization.; A.shape[0] == 2; ):; # Make an identity the same size as A and B to; # compare against.; I = qeye(A.dims[0]); # Compare to B first, so that an error is raised; # as soon as possible.; Bd = B.dag(); if (; (B * Bd - I).norm() < 1e-6 and; (A * A.dag() - I).norm() < 1e-6; ):; # Now we are on the fast path, so let's compute the; # eigenvalues, then find the diameter of the smallest circle; # containing all of them.; #; # For now, this is only implemented for dim = 2, such that; # generalizing here will allow for generalizing the optimization.; # A reasonable approach would probably be to use Welzl's algorithm; # (https://en.wikipedia.org/wiki/Smallest-circle_problem).; U = A * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A). if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positiv",MatchSource.WIKI,docs/4.6/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html
https://qutip.org/docs/4.6/modules/qutip/metrics.html:11055,Deployability,install,installed,11055,"e_solve=False,; sparse=True):; """"""; Calculates the diamond norm of the quantum map q_oper, using; the simplified semidefinite program of [Wat12]_. The diamond norm SDP is solved by using CVXPY_. Parameters; ----------; A : Qobj; Quantum map to take the diamond norm of.; B : Qobj or None; If provided, the diamond norm of :math:`A - B` is taken instead.; solver : str; Solver to use with CVXPY. One of ""CVXOPT"" (default) or ""SCS"". The; latter tends to be significantly faster, but somewhat less accurate.; verbose : bool; If True, prints additional information about the solution.; force_solve : bool; If True, forces dnorm to solve the associated SDP, even if a special; case is known for the argument.; sparse : bool; Whether to use sparse matrices in the convex optimisation problem.; Default True. Returns; -------; dn : float; Diamond norm of q_oper. Raises; ------; ImportError; If CVXPY cannot be imported. .. _cvxpy: http://www.cvxpy.org/en/latest/; """"""; if cvxpy is None: # pragma: no cover; raise ImportError(""dnorm() requires CVXPY to be installed.""). # We follow the strategy of using Watrous' simpler semidefinite; # program in its primal form. This is the same strategy used,; # for instance, by both pyGSTi and SchattenNorms.jl. (By contrast,; # QETLAB uses the dual problem.). # Check if A and B are both unitaries. If so, then we can without; # loss of generality choose B to be the identity by using the; # unitary invariance of the diamond norm,; # || A - B ||_♢ = || A B⁺ - I ||_♢.; # Then, using the technique mentioned by each of Johnston and; # da Silva,; # || A B⁺ - I ||_♢ = max_{i, j} | \lambda_i(A B⁺) - \lambda_j(A B⁺) |,; # where \lambda_i(U) is the ith eigenvalue of U. if (; # There's a lot of conditions to check for this path.; not force_solve and B is not None and; # Only check if they aren't superoperators.; A.type == ""oper"" and B.type == ""oper"" and; # The difference of unitaries optimization is currently; # only implemented for d == 2. Much of the code below is",MatchSource.WIKI,docs/4.6/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html
https://qutip.org/docs/4.6/modules/qutip/metrics.html:15025,Deployability,update,updated,15025,"e dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.full(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]). J_dat = J.data. if not sparse:; # The parameters and constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji = dnorm_problem(dim). # Load the parameters with the Choi matrix passed in.; Jr.value = sp.csr_matrix((J_dat.data.real, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(). Ji.value = sp.csr_matrix((J_dat.data.imag, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(); else:. # The parameters do not depend solely on the dimension,; # so we can not cache them efficiently.; problem = dnorm_sparse_problem(dim, J_dat). problem.solve(solver=solver, verbose=verbose). return problem.value. def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.norm(Eu, 'fro')**2 / len(Eu). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html
https://qutip.org/docs/4.6/modules/qutip/metrics.html:13855,Energy Efficiency,efficient,efficiently,13855,"nces = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A). if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.full(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]). J_dat = J.data. if not sparse:; # The parameters and constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji = dnorm_problem(dim). # Load the parameters with the Choi matrix passed in.; Jr.value = sp.csr_matrix((J_dat.data.real, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(). Ji.value = sp.csr_matrix((J_dat.data.imag, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(); else:. # The parameters do not depend solely on the dimension,; # so we can not cache them efficiently.; problem = dnorm_sparse_problem(dim, J_dat). problem.solve(solver=solver, verbose=verbose). return problem.value. def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.no",MatchSource.WIKI,docs/4.6/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html
https://qutip.org/docs/4.6/modules/qutip/metrics.html:14263,Energy Efficiency,efficient,efficiently,14263,"e dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.full(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]). J_dat = J.data. if not sparse:; # The parameters and constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji = dnorm_problem(dim). # Load the parameters with the Choi matrix passed in.; Jr.value = sp.csr_matrix((J_dat.data.real, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(). Ji.value = sp.csr_matrix((J_dat.data.imag, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(); else:. # The parameters do not depend solely on the dimension,; # so we can not cache them efficiently.; problem = dnorm_sparse_problem(dim, J_dat). problem.solve(solver=solver, verbose=verbose). return problem.value. def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.norm(Eu, 'fro')**2 / len(Eu). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html
https://qutip.org/docs/4.6/modules/qutip/metrics.html:13806,Integrability,depend,depend,13806,"nces = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A). if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.full(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]). J_dat = J.data. if not sparse:; # The parameters and constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji = dnorm_problem(dim). # Load the parameters with the Choi matrix passed in.; Jr.value = sp.csr_matrix((J_dat.data.real, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(). Ji.value = sp.csr_matrix((J_dat.data.imag, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(); else:. # The parameters do not depend solely on the dimension,; # so we can not cache them efficiently.; problem = dnorm_sparse_problem(dim, J_dat). problem.solve(solver=solver, verbose=verbose). return problem.value. def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.no",MatchSource.WIKI,docs/4.6/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html
https://qutip.org/docs/4.6/modules/qutip/metrics.html:14203,Integrability,depend,depend,14203,"e dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.full(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]). J_dat = J.data. if not sparse:; # The parameters and constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji = dnorm_problem(dim). # Load the parameters with the Choi matrix passed in.; Jr.value = sp.csr_matrix((J_dat.data.real, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(). Ji.value = sp.csr_matrix((J_dat.data.imag, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(); else:. # The parameters do not depend solely on the dimension,; # so we can not cache them efficiently.; problem = dnorm_sparse_problem(dim, J_dat). problem.solve(solver=solver, verbose=verbose). return problem.value. def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.norm(Eu, 'fro')**2 / len(Eu). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html
https://qutip.org/docs/4.6/modules/qutip/metrics.html:11924,Performance,optimiz,optimization,11924,"py: http://www.cvxpy.org/en/latest/; """"""; if cvxpy is None: # pragma: no cover; raise ImportError(""dnorm() requires CVXPY to be installed.""). # We follow the strategy of using Watrous' simpler semidefinite; # program in its primal form. This is the same strategy used,; # for instance, by both pyGSTi and SchattenNorms.jl. (By contrast,; # QETLAB uses the dual problem.). # Check if A and B are both unitaries. If so, then we can without; # loss of generality choose B to be the identity by using the; # unitary invariance of the diamond norm,; # || A - B ||_♢ = || A B⁺ - I ||_♢.; # Then, using the technique mentioned by each of Johnston and; # da Silva,; # || A B⁺ - I ||_♢ = max_{i, j} | \lambda_i(A B⁺) - \lambda_j(A B⁺) |,; # where \lambda_i(U) is the ith eigenvalue of U. if (; # There's a lot of conditions to check for this path.; not force_solve and B is not None and; # Only check if they aren't superoperators.; A.type == ""oper"" and B.type == ""oper"" and; # The difference of unitaries optimization is currently; # only implemented for d == 2. Much of the code below is more general,; # though, in anticipation of generalizing the optimization.; A.shape[0] == 2; ):; # Make an identity the same size as A and B to; # compare against.; I = qeye(A.dims[0]); # Compare to B first, so that an error is raised; # as soon as possible.; Bd = B.dag(); if (; (B * Bd - I).norm() < 1e-6 and; (A * A.dag() - I).norm() < 1e-6; ):; # Now we are on the fast path, so let's compute the; # eigenvalues, then find the diameter of the smallest circle; # containing all of them.; #; # For now, this is only implemented for dim = 2, such that; # generalizing here will allow for generalizing the optimization.; # A reasonable approach would probably be to use Welzl's algorithm; # (https://en.wikipedia.org/wiki/Smallest-circle_problem).; U = A * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Cho",MatchSource.WIKI,docs/4.6/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html
https://qutip.org/docs/4.6/modules/qutip/metrics.html:12069,Performance,optimiz,optimization,12069,"() requires CVXPY to be installed.""). # We follow the strategy of using Watrous' simpler semidefinite; # program in its primal form. This is the same strategy used,; # for instance, by both pyGSTi and SchattenNorms.jl. (By contrast,; # QETLAB uses the dual problem.). # Check if A and B are both unitaries. If so, then we can without; # loss of generality choose B to be the identity by using the; # unitary invariance of the diamond norm,; # || A - B ||_♢ = || A B⁺ - I ||_♢.; # Then, using the technique mentioned by each of Johnston and; # da Silva,; # || A B⁺ - I ||_♢ = max_{i, j} | \lambda_i(A B⁺) - \lambda_j(A B⁺) |,; # where \lambda_i(U) is the ith eigenvalue of U. if (; # There's a lot of conditions to check for this path.; not force_solve and B is not None and; # Only check if they aren't superoperators.; A.type == ""oper"" and B.type == ""oper"" and; # The difference of unitaries optimization is currently; # only implemented for d == 2. Much of the code below is more general,; # though, in anticipation of generalizing the optimization.; A.shape[0] == 2; ):; # Make an identity the same size as A and B to; # compare against.; I = qeye(A.dims[0]); # Compare to B first, so that an error is raised; # as soon as possible.; Bd = B.dag(); if (; (B * Bd - I).norm() < 1e-6 and; (A * A.dag() - I).norm() < 1e-6; ):; # Now we are on the fast path, so let's compute the; # eigenvalues, then find the diameter of the smallest circle; # containing all of them.; #; # For now, this is only implemented for dim = 2, such that; # generalizing here will allow for generalizing the optimization.; # A reasonable approach would probably be to use Welzl's algorithm; # (https://en.wikipedia.org/wiki/Smallest-circle_problem).; U = A * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A). if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the d",MatchSource.WIKI,docs/4.6/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html
https://qutip.org/docs/4.6/modules/qutip/metrics.html:12614,Performance,optimiz,optimization,12614,"ston and; # da Silva,; # || A B⁺ - I ||_♢ = max_{i, j} | \lambda_i(A B⁺) - \lambda_j(A B⁺) |,; # where \lambda_i(U) is the ith eigenvalue of U. if (; # There's a lot of conditions to check for this path.; not force_solve and B is not None and; # Only check if they aren't superoperators.; A.type == ""oper"" and B.type == ""oper"" and; # The difference of unitaries optimization is currently; # only implemented for d == 2. Much of the code below is more general,; # though, in anticipation of generalizing the optimization.; A.shape[0] == 2; ):; # Make an identity the same size as A and B to; # compare against.; I = qeye(A.dims[0]); # Compare to B first, so that an error is raised; # as soon as possible.; Bd = B.dag(); if (; (B * Bd - I).norm() < 1e-6 and; (A * A.dag() - I).norm() < 1e-6; ):; # Now we are on the fast path, so let's compute the; # eigenvalues, then find the diameter of the smallest circle; # containing all of them.; #; # For now, this is only implemented for dim = 2, such that; # generalizing here will allow for generalizing the optimization.; # A reasonable approach would probably be to use Welzl's algorithm; # (https://en.wikipedia.org/wiki/Smallest-circle_problem).; U = A * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A). if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Th",MatchSource.WIKI,docs/4.6/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html
https://qutip.org/docs/4.6/modules/qutip/metrics.html:13844,Performance,cache,cache,13844,"nces = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A). if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.full(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]). J_dat = J.data. if not sparse:; # The parameters and constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji = dnorm_problem(dim). # Load the parameters with the Choi matrix passed in.; Jr.value = sp.csr_matrix((J_dat.data.real, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(). Ji.value = sp.csr_matrix((J_dat.data.imag, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(); else:. # The parameters do not depend solely on the dimension,; # so we can not cache them efficiently.; problem = dnorm_sparse_problem(dim, J_dat). problem.solve(solver=solver, verbose=verbose). return problem.value. def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.no",MatchSource.WIKI,docs/4.6/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html
https://qutip.org/docs/4.6/modules/qutip/metrics.html:14252,Performance,cache,cache,14252,"e dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.full(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]). J_dat = J.data. if not sparse:; # The parameters and constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji = dnorm_problem(dim). # Load the parameters with the Choi matrix passed in.; Jr.value = sp.csr_matrix((J_dat.data.real, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(). Ji.value = sp.csr_matrix((J_dat.data.imag, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(); else:. # The parameters do not depend solely on the dimension,; # so we can not cache them efficiently.; problem = dnorm_sparse_problem(dim, J_dat). problem.solve(solver=solver, verbose=verbose). return problem.value. def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.norm(Eu, 'fro')**2 / len(Eu). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html
https://qutip.org/docs/4.6/modules/qutip/metrics.html:3616,Safety,avoid,avoid,3616,"port to_kraus, to_stinespring, to_choi, _super_to_superpauli, to_super; from qutip.superoperator import operator_to_vector, vector_to_operator; from qutip.operators import qeye; from qutip.semidefinite import dnorm_problem, dnorm_sparse_problem; import qutip.settings as settings. import qutip.logging_utils as logging; logger = logging.get_logger(). try:; import cvxpy; except ImportError:; cvxpy = None. [docs]def fidelity(A, B):; """"""; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> np.testing.assert_almost_equal(fidelity(x,y), 0.24104350624628332); """"""; if A.isket or A.isbra:; # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); # Check whether we have to turn B into a density operator, too.; if B.isket or B.isbra:; B = ket2dm(B); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, A); # If we made it here, both A and B are operators, so; # we have to take the sqrtm of one of them.; sqrtmA = A.sqrtm(). if sqrtmA.dims != B.dims:; raise TypeError('Density matrices do not have same dimensions.'). # We don't actually need the whole matrix here, just the trace; # of its square root, so let's just get its eigenenergies instead.; # We also truncate negative eigenvalues to avoid nan propagation;; # even for positive semidefinite matrices, small negative eigenvalues; # can be reported.; eig_vals = (sqrtmA * B * sqrtmA).eigenenergies(); return float(np.real(np.sqrt(eig_vals[eig_vals > 0]).sum())). [docs]def process_fidelity(U1, U2, normalize=True):; """"""; Calculate",MatchSource.WIKI,docs/4.6/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html
https://qutip.org/docs/4.6/modules/qutip/metrics.html:4287,Safety,avoid,avoid,4287,"at; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> np.testing.assert_almost_equal(fidelity(x,y), 0.24104350624628332); """"""; if A.isket or A.isbra:; # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); # Check whether we have to turn B into a density operator, too.; if B.isket or B.isbra:; B = ket2dm(B); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, A); # If we made it here, both A and B are operators, so; # we have to take the sqrtm of one of them.; sqrtmA = A.sqrtm(). if sqrtmA.dims != B.dims:; raise TypeError('Density matrices do not have same dimensions.'). # We don't actually need the whole matrix here, just the trace; # of its square root, so let's just get its eigenenergies instead.; # We also truncate negative eigenvalues to avoid nan propagation;; # even for positive semidefinite matrices, small negative eigenvalues; # can be reported.; eig_vals = (sqrtmA * B * sqrtmA).eigenenergies(); return float(np.real(np.sqrt(eig_vals[eig_vals > 0]).sum())). [docs]def process_fidelity(U1, U2, normalize=True):; """"""; Calculate the process fidelity given two process operators.; """"""; if normalize:; return (U1 * U2).tr() / (U1.tr() * U2.tr()); else:; return (U1 * U2).tr(). [docs]def average_gate_fidelity(oper, target=None):; """"""; Given a Qobj representing the supermatrix form of a map, returns the; average gate fidelity (pseudo-metric) of that map. Parameters; ----------; A : Qobj; Quantum object representing a superoperator.; target : Qobj; Quantum object representing the target unitary; the inverse; is applied before evaluating the fidelity. Returns; -------; fid : float; Fidelity pseudo-metric between A and the identity superoperator,; or between A and the target superunitary.; """"""; kraus_form = to_kraus(oper); d = kraus_form[0].shape[0]. if kraus_form",MatchSource.WIKI,docs/4.6/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html
https://qutip.org/docs/4.6/modules/qutip/metrics.html:9716,Safety,avoid,avoid,9716,"arameters; ----------; A : :class:`qutip.Qobj`; Density matrix or state vector.; B : :class:`qutip.Qobj`; Density matrix or state vector with same dimensions as A.; tol : float; Tolerance used by sparse eigensolver, if used. (0=Machine precision); sparse : {False, True}; Use sparse eigensolver. Returns; -------; hellinger_dist : float; Quantum Hellinger distance between A and B. Ranges from 0 to sqrt(2). Examples; --------; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(hellinger_dist(x,y), 1.3725145002591095); """"""; if A.isket or A.isbra:; sqrtmA = ket2dm(A); else:; sqrtmA = A.sqrtm(sparse=sparse, tol=tol); if B.isket or B.isbra:; sqrtmB = ket2dm(B); else:; sqrtmB = B.sqrtm(sparse=sparse, tol=tol). if sqrtmA.dims != sqrtmB.dims:; raise TypeError(""A and B do not have compatible dimensions.""). product = sqrtmA*sqrtmB; eigs = sp_eigs(product.data,; isherm=product.isherm, vecs=False, sparse=sparse, tol=tol); # np.maximum() is to avoid nan appearing sometimes due to numerical; # instabilities causing np.sum(eigs) slightly (~1e-8) larger than 1; # when hellinger_dist(A, B) is called for A=B; return np.sqrt(2.0 * np.maximum(0., (1.0 - np.real(np.sum(eigs))))). def dnorm(A, B=None, solver=""CVXOPT"", verbose=False, force_solve=False,; sparse=True):; """"""; Calculates the diamond norm of the quantum map q_oper, using; the simplified semidefinite program of [Wat12]_. The diamond norm SDP is solved by using CVXPY_. Parameters; ----------; A : Qobj; Quantum map to take the diamond norm of.; B : Qobj or None; If provided, the diamond norm of :math:`A - B` is taken instead.; solver : str; Solver to use with CVXPY. One of ""CVXOPT"" (default) or ""SCS"". The; latter tends to be significantly faster, but somewhat less accurate.; verbose : bool; If True, prints additional information about the solution.; force_solve : bool; If True, forces dnorm to solve the associated SDP, even if a special; case is known for the argument.; sparse : bool; Whether to use spars",MatchSource.WIKI,docs/4.6/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html
https://qutip.org/docs/4.6/modules/qutip/metrics.html:2891,Testability,log,logging,2891,"GLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators.; """""". __all__ = ['fidelity', 'tracedist', 'bures_dist', 'bures_angle',; 'hellinger_dist', 'hilbert_dist', 'average_gate_fidelity',; 'process_fidelity', 'unitarity', 'dnorm']. import numpy as np; from scipy import linalg as la; import scipy.sparse as sp; from qutip.sparse import sp_eigs; from qutip.states import ket2dm; from qutip.superop_reps import to_kraus, to_stinespring, to_choi, _super_to_superpauli, to_super; from qutip.superoperator import operator_to_vector, vector_to_operator; from qutip.operators import qeye; from qutip.semidefinite import dnorm_problem, dnorm_sparse_problem; import qutip.settings as settings. import qutip.logging_utils as logging; logger = logging.get_logger(). try:; import cvxpy; except ImportError:; cvxpy = None. [docs]def fidelity(A, B):; """"""; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> np.testing.assert_almost_equal(fidelity(x,y), 0.24104350624628332); """"""; if A.isket or A.isbra:; # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); # Check whether we have to turn B into a density operator, too.; if B.isket or B.isbra:; B = ket2dm(B); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, ",MatchSource.WIKI,docs/4.6/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html
https://qutip.org/docs/4.6/modules/qutip/metrics.html:2900,Testability,log,logger,2900,"GLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators.; """""". __all__ = ['fidelity', 'tracedist', 'bures_dist', 'bures_angle',; 'hellinger_dist', 'hilbert_dist', 'average_gate_fidelity',; 'process_fidelity', 'unitarity', 'dnorm']. import numpy as np; from scipy import linalg as la; import scipy.sparse as sp; from qutip.sparse import sp_eigs; from qutip.states import ket2dm; from qutip.superop_reps import to_kraus, to_stinespring, to_choi, _super_to_superpauli, to_super; from qutip.superoperator import operator_to_vector, vector_to_operator; from qutip.operators import qeye; from qutip.semidefinite import dnorm_problem, dnorm_sparse_problem; import qutip.settings as settings. import qutip.logging_utils as logging; logger = logging.get_logger(). try:; import cvxpy; except ImportError:; cvxpy = None. [docs]def fidelity(A, B):; """"""; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> np.testing.assert_almost_equal(fidelity(x,y), 0.24104350624628332); """"""; if A.isket or A.isbra:; # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); # Check whether we have to turn B into a density operator, too.; if B.isket or B.isbra:; B = ket2dm(B); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, ",MatchSource.WIKI,docs/4.6/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html
https://qutip.org/docs/4.6/modules/qutip/metrics.html:2909,Testability,log,logging,2909,"GLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators.; """""". __all__ = ['fidelity', 'tracedist', 'bures_dist', 'bures_angle',; 'hellinger_dist', 'hilbert_dist', 'average_gate_fidelity',; 'process_fidelity', 'unitarity', 'dnorm']. import numpy as np; from scipy import linalg as la; import scipy.sparse as sp; from qutip.sparse import sp_eigs; from qutip.states import ket2dm; from qutip.superop_reps import to_kraus, to_stinespring, to_choi, _super_to_superpauli, to_super; from qutip.superoperator import operator_to_vector, vector_to_operator; from qutip.operators import qeye; from qutip.semidefinite import dnorm_problem, dnorm_sparse_problem; import qutip.settings as settings. import qutip.logging_utils as logging; logger = logging.get_logger(). try:; import cvxpy; except ImportError:; cvxpy = None. [docs]def fidelity(A, B):; """"""; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> np.testing.assert_almost_equal(fidelity(x,y), 0.24104350624628332); """"""; if A.isket or A.isbra:; # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); # Check whether we have to turn B into a density operator, too.; if B.isket or B.isbra:; B = ket2dm(B); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, ",MatchSource.WIKI,docs/4.6/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html
https://qutip.org/docs/4.6/modules/qutip/metrics.html:3440,Testability,test,testing,3440,"t linalg as la; import scipy.sparse as sp; from qutip.sparse import sp_eigs; from qutip.states import ket2dm; from qutip.superop_reps import to_kraus, to_stinespring, to_choi, _super_to_superpauli, to_super; from qutip.superoperator import operator_to_vector, vector_to_operator; from qutip.operators import qeye; from qutip.semidefinite import dnorm_problem, dnorm_sparse_problem; import qutip.settings as settings. import qutip.logging_utils as logging; logger = logging.get_logger(). try:; import cvxpy; except ImportError:; cvxpy = None. [docs]def fidelity(A, B):; """"""; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> np.testing.assert_almost_equal(fidelity(x,y), 0.24104350624628332); """"""; if A.isket or A.isbra:; # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); # Check whether we have to turn B into a density operator, too.; if B.isket or B.isbra:; B = ket2dm(B); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, A); # If we made it here, both A and B are operators, so; # we have to take the sqrtm of one of them.; sqrtmA = A.sqrtm(). if sqrtmA.dims != B.dims:; raise TypeError('Density matrices do not have same dimensions.'). # We don't actually need the whole matrix here, just the trace; # of its square root, so let's just get its eigenenergies instead.; # We also truncate negative eigenvalues to avoid nan propagation;; # even for positive semidefinite matrices, small negative eigenvalues; # can be reported.; eig_vals = (sqrtmA * B * sqrtmA).eigenener",MatchSource.WIKI,docs/4.6/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html
https://qutip.org/docs/4.6/modules/qutip/metrics.html:6231,Testability,test,testing,6231,"runitary.; """"""; kraus_form = to_kraus(oper); d = kraus_form[0].shape[0]. if kraus_form[0].shape[1] != d:; return TypeError(""Average gate fidelity only implemented for square ""; ""superoperators.""). if target is None:; return (d + np.sum([np.abs(A_k.tr())**2; for A_k in kraus_form])) / (d**2 + d); else:; return (d + np.sum([np.abs((A_k * target.dag()).tr())**2; for A_k in kraus_form])) / (d**2 + d). [docs]def tracedist(A, B, sparse=False, tol=0):; """"""; Calculates the trace distance between two density matrices..; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------!=; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A.; tol : float; Tolerance used by sparse eigensolver, if used. (0=Machine precision); sparse : {False, True}; Use sparse eigensolver. Returns; -------; tracedist : float; Trace distance between A and B. Examples; --------; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(tracedist(x,y), 0.9705143161472971); """"""; if A.isket or A.isbra:; A = ket2dm(A); if B.isket or B.isbra:; B = ket2dm(B). if A.dims != B.dims:; raise TypeError(""A and B do not have same dimensions.""). diff = A - B; diff = diff.dag() * diff; vals = sp_eigs(diff.data, diff.isherm, vecs=False, sparse=sparse, tol=tol); return float(np.real(0.5 * np.sum(np.sqrt(np.abs(vals))))). [docs]def hilbert_dist(A, B):; """"""; Returns the Hilbert-Schmidt distance between two density matrices A & B. Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; dist : float; Hilbert-Schmidt distance between density matrices. Notes; -----; See V. Vedral and M. B. Plenio, Phys. Rev. A 57, 1619 (1998). """"""; if A.isket or A.isbra:; A = ket2dm(A); if B.isket or B.isbra:; B = ket2dm(B). if A.dims != B.dims:; raise TypeError('A and B do not have same dimensions.'). return ((A - B)**2).tr(). [docs]def ",MatchSource.WIKI,docs/4.6/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html
https://qutip.org/docs/4.6/modules/qutip/metrics.html:9224,Testability,test,testing,9224,"a:; A = ket2dm(A); if B.isket or B.isbra:; B = ket2dm(B). if A.dims != B.dims:; raise TypeError('A and B do not have same dimensions.'). return np.arccos(fidelity(A, B)). def hellinger_dist(A, B, sparse=False, tol=0):; """"""; Calculates the quantum Hellinger distance between two density matrices. Formula:; hellinger_dist(A, B) = sqrt(2-2*Tr(sqrt(A)*sqrt(B))). See: D. Spehner, F. Illuminati, M. Orszag, and W. Roga, ""Geometric; measures of quantum correlations with Bures and Hellinger distances""; arXiv:1611.03449. Parameters; ----------; A : :class:`qutip.Qobj`; Density matrix or state vector.; B : :class:`qutip.Qobj`; Density matrix or state vector with same dimensions as A.; tol : float; Tolerance used by sparse eigensolver, if used. (0=Machine precision); sparse : {False, True}; Use sparse eigensolver. Returns; -------; hellinger_dist : float; Quantum Hellinger distance between A and B. Ranges from 0 to sqrt(2). Examples; --------; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(hellinger_dist(x,y), 1.3725145002591095); """"""; if A.isket or A.isbra:; sqrtmA = ket2dm(A); else:; sqrtmA = A.sqrtm(sparse=sparse, tol=tol); if B.isket or B.isbra:; sqrtmB = ket2dm(B); else:; sqrtmB = B.sqrtm(sparse=sparse, tol=tol). if sqrtmA.dims != sqrtmB.dims:; raise TypeError(""A and B do not have compatible dimensions.""). product = sqrtmA*sqrtmB; eigs = sp_eigs(product.data,; isherm=product.isherm, vecs=False, sparse=sparse, tol=tol); # np.maximum() is to avoid nan appearing sometimes due to numerical; # instabilities causing np.sum(eigs) slightly (~1e-8) larger than 1; # when hellinger_dist(A, B) is called for A=B; return np.sqrt(2.0 * np.maximum(0., (1.0 - np.real(np.sum(eigs))))). def dnorm(A, B=None, solver=""CVXOPT"", verbose=False, force_solve=False,; sparse=True):; """"""; Calculates the diamond norm of the quantum map q_oper, using; the simplified semidefinite program of [Wat12]_. The diamond norm SDP is solved by using CVXPY_. Parameters; ----------; A :",MatchSource.WIKI,docs/4.6/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html
https://qutip.org/docs/4.6/modules/qutip/metrics.html:10108,Usability,simpl,simplified,10108,"-------; hellinger_dist : float; Quantum Hellinger distance between A and B. Ranges from 0 to sqrt(2). Examples; --------; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(hellinger_dist(x,y), 1.3725145002591095); """"""; if A.isket or A.isbra:; sqrtmA = ket2dm(A); else:; sqrtmA = A.sqrtm(sparse=sparse, tol=tol); if B.isket or B.isbra:; sqrtmB = ket2dm(B); else:; sqrtmB = B.sqrtm(sparse=sparse, tol=tol). if sqrtmA.dims != sqrtmB.dims:; raise TypeError(""A and B do not have compatible dimensions.""). product = sqrtmA*sqrtmB; eigs = sp_eigs(product.data,; isherm=product.isherm, vecs=False, sparse=sparse, tol=tol); # np.maximum() is to avoid nan appearing sometimes due to numerical; # instabilities causing np.sum(eigs) slightly (~1e-8) larger than 1; # when hellinger_dist(A, B) is called for A=B; return np.sqrt(2.0 * np.maximum(0., (1.0 - np.real(np.sum(eigs))))). def dnorm(A, B=None, solver=""CVXOPT"", verbose=False, force_solve=False,; sparse=True):; """"""; Calculates the diamond norm of the quantum map q_oper, using; the simplified semidefinite program of [Wat12]_. The diamond norm SDP is solved by using CVXPY_. Parameters; ----------; A : Qobj; Quantum map to take the diamond norm of.; B : Qobj or None; If provided, the diamond norm of :math:`A - B` is taken instead.; solver : str; Solver to use with CVXPY. One of ""CVXOPT"" (default) or ""SCS"". The; latter tends to be significantly faster, but somewhat less accurate.; verbose : bool; If True, prints additional information about the solution.; force_solve : bool; If True, forces dnorm to solve the associated SDP, even if a special; case is known for the argument.; sparse : bool; Whether to use sparse matrices in the convex optimisation problem.; Default True. Returns; -------; dn : float; Diamond norm of q_oper. Raises; ------; ImportError; If CVXPY cannot be imported. .. _cvxpy: http://www.cvxpy.org/en/latest/; """"""; if cvxpy is None: # pragma: no cover; raise ImportError(""dnorm() requires CVXPY t",MatchSource.WIKI,docs/4.6/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html
https://qutip.org/docs/4.6/modules/qutip/metrics.html:11112,Usability,simpl,simpler,11112,"ied semidefinite program of [Wat12]_. The diamond norm SDP is solved by using CVXPY_. Parameters; ----------; A : Qobj; Quantum map to take the diamond norm of.; B : Qobj or None; If provided, the diamond norm of :math:`A - B` is taken instead.; solver : str; Solver to use with CVXPY. One of ""CVXOPT"" (default) or ""SCS"". The; latter tends to be significantly faster, but somewhat less accurate.; verbose : bool; If True, prints additional information about the solution.; force_solve : bool; If True, forces dnorm to solve the associated SDP, even if a special; case is known for the argument.; sparse : bool; Whether to use sparse matrices in the convex optimisation problem.; Default True. Returns; -------; dn : float; Diamond norm of q_oper. Raises; ------; ImportError; If CVXPY cannot be imported. .. _cvxpy: http://www.cvxpy.org/en/latest/; """"""; if cvxpy is None: # pragma: no cover; raise ImportError(""dnorm() requires CVXPY to be installed.""). # We follow the strategy of using Watrous' simpler semidefinite; # program in its primal form. This is the same strategy used,; # for instance, by both pyGSTi and SchattenNorms.jl. (By contrast,; # QETLAB uses the dual problem.). # Check if A and B are both unitaries. If so, then we can without; # loss of generality choose B to be the identity by using the; # unitary invariance of the diamond norm,; # || A - B ||_♢ = || A B⁺ - I ||_♢.; # Then, using the technique mentioned by each of Johnston and; # da Silva,; # || A B⁺ - I ||_♢ = max_{i, j} | \lambda_i(A B⁺) - \lambda_j(A B⁺) |,; # where \lambda_i(U) is the ith eigenvalue of U. if (; # There's a lot of conditions to check for this path.; not force_solve and B is not None and; # Only check if they aren't superoperators.; A.type == ""oper"" and B.type == ""oper"" and; # The difference of unitaries optimization is currently; # only implemented for d == 2. Much of the code below is more general,; # though, in anticipation of generalizing the optimization.; A.shape[0] == 2; ):; # Make an i",MatchSource.WIKI,docs/4.6/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html
https://qutip.org/docs/4.6/modules/qutip/operators.html:8655,Availability,error,error,8655,"[[ 1. 0.]; [ 0. -1.]]. """"""; return 2 * jmat(1 / 2, 'z'). #; # DESTROY returns annihilation operator for N dimensional Hilbert space; # out = destroy(N), N is integer value & N>0; #; [docs]def destroy(N, offset=0):; '''Destruction (lowering) operator. Parameters; ----------; N : int; Dimension of Hilbert space. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Returns; -------; oper : qobj; Qobj for lowering operator. Examples; --------; >>> destroy(4) # doctest: +SKIP; Quantum object: dims = [[4], [4]], \; shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j]; [ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]]. '''; if not isinstance(N, (int, np.integer)): # raise error if N not integer; raise ValueError(""Hilbert space dimension must be integer value""); data = np.sqrt(np.arange(offset+1, N+offset, dtype=complex)); ind = np.arange(1,N, dtype=np.int32); ptr = np.arange(N+1, dtype=np.int32); ptr[-1] = N-1; return Qobj(fast_csr_matrix((data,ind,ptr),shape=(N,N)), isherm=False). #; # create returns creation operator for N dimensional Hilbert space; # out = create(N), N is integer value & N>0; #; [docs]def create(N, offset=0):; '''Creation (raising) operator. Parameters; ----------; N : int; Dimension of Hilbert space. Returns; -------; oper : qobj; Qobj for raising operator. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Examples; --------; >>> create(4) # doctest: +SKIP; Quantum object: dims = [[4], [4]], \; shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.",MatchSource.WIKI,docs/4.6/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/operators.html
https://qutip.org/docs/4.6/modules/qutip/operators.html:9860,Availability,error,error,9860,"ptr),shape=(N,N)), isherm=False). #; # create returns creation operator for N dimensional Hilbert space; # out = create(N), N is integer value & N>0; #; [docs]def create(N, offset=0):; '''Creation (raising) operator. Parameters; ----------; N : int; Dimension of Hilbert space. Returns; -------; oper : qobj; Qobj for raising operator. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Examples; --------; >>> create(4) # doctest: +SKIP; Quantum object: dims = [[4], [4]], \; shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. '''; if not isinstance(N, (int, np.integer)): # raise error if N not integer; raise ValueError(""Hilbert space dimension must be integer value""); qo = destroy(N, offset=offset) # create operator using destroy function; return qo.dag(). def _implicit_tensor_dimensions(dimensions):; """"""; Total flattened size and operator dimensions for operator creation routines; that automatically perform tensor products. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); First dimension of an operator which can create an implicit tensor; product. If the type is `int`, it is promoted first to `[dimensions]`.; From there, it should be one of the two-elements `dims` parameter of a; `qutip.Qobj` representing an `oper` or `super`, with possible tensor; products. Returns; -------; size : int; Dimension of backing matrix required to represent operator.; dimensions : list; Dimension list in the form required by ``Qobj`` creation.; """"""; if not isinstance(dimensions, list):; dimensions = [dimensions]; flat = flatten(dimensions); if not all(isinstance(x, numbers.Integral) and x >= 0 for x in flat):; raise Val",MatchSource.WIKI,docs/4.6/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/operators.html
https://qutip.org/docs/4.6/modules/qutip/operators.html:23898,Deployability,update,updated,23898,"umber basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex128); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax]. Notes; -----; .. versionadded:: 3.2. """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form; :math:`\\sum |N><N+m| + |N+m><N|`. Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event. Returns; -------; T : Qobj; Tunneling operator. Notes; -----; .. versionadded:: 3.2. """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dtype=complex); return Qobj(T, isherm=True). # Break circular dependencies by a trailing import.; # Note that we use a relative import here to deal with that; # qutip.tensor is the *function* tensor, not the module.; from qutip.tensor import tensor. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/operators.html
https://qutip.org/docs/4.6/modules/qutip/operators.html:2557,Energy Efficiency,charge,charge,2557,"ERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators.; """""". __all__ = ['jmat', 'spin_Jx', 'spin_Jy', 'spin_Jz', 'spin_Jm', 'spin_Jp',; 'spin_J_set', 'sigmap', 'sigmam', 'sigmax', 'sigmay', 'sigmaz',; 'destroy', 'create', 'qeye', 'identity', 'position', 'momentum',; 'num', 'squeeze', 'squeezing', 'displace', 'commutator',; 'qutrit_ops', 'qdiags', 'phase', 'qzero', 'enr_destroy',; 'enr_identity', 'charge', 'tunneling']. import numbers; import numpy as np; import scipy.sparse as sp; from qutip.qobj import Qobj; from qutip.fastsparse import fast_csr_matrix, fast_identity; from qutip.dimensions import flatten. #; # Spin operators; #; [docs]def jmat(j, *args):; """"""Higher-order spin operators:. Parameters; ----------; j : float; Spin of operator. args : str; Which operator to return 'x','y','z','+','-'.; If no args given, then output is ['x','y','z']. Returns; -------; jmat : qobj / ndarray; ``qobj`` for requested spin operator(s). Examples; --------; >>> jmat(1) # doctest: +SKIP; [ Quantum object: dims = [[3], [3]], \; shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0. 0.70710678 0. ]; [ 0.70710678 0. 0.70710678]; [ 0. 0.70710678 0. ]]; Quantum object: dims = [[3], [3]], \; shape = [3, 3], type = oper, isHerm = Tru",MatchSource.WIKI,docs/4.6/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/operators.html
https://qutip.org/docs/4.6/modules/qutip/operators.html:22410,Energy Efficiency,charge,charge,22410," a in a_ops]. [docs]def enr_identity(dims, excitations):; """"""; Generate the identity operator for the excitation-number restricted; state space defined by the `dims` and `exciations` arguments. See the; docstring for enr_fock for a more detailed description of these arguments. Parameters; ----------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex128); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax]. Notes; -----; .. versionadded:: 3.2. """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form; :math:`\\sum |N><N+m| + |N+m><N|`. Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event. Returns; -------; T : Qobj; Tunneling operator. Notes; -----; .. versionadded:: 3.2. """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dty",MatchSource.WIKI,docs/4.6/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/operators.html
https://qutip.org/docs/4.6/modules/qutip/operators.html:22473,Energy Efficiency,charge,charge,22473," a in a_ops]. [docs]def enr_identity(dims, excitations):; """"""; Generate the identity operator for the excitation-number restricted; state space defined by the `dims` and `exciations` arguments. See the; docstring for enr_fock for a more detailed description of these arguments. Parameters; ----------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex128); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax]. Notes; -----; .. versionadded:: 3.2. """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form; :math:`\\sum |N><N+m| + |N+m><N|`. Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event. Returns; -------; T : Qobj; Tunneling operator. Notes; -----; .. versionadded:: 3.2. """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dty",MatchSource.WIKI,docs/4.6/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/operators.html
https://qutip.org/docs/4.6/modules/qutip/operators.html:22494,Energy Efficiency,charge,charge,22494," a in a_ops]. [docs]def enr_identity(dims, excitations):; """"""; Generate the identity operator for the excitation-number restricted; state space defined by the `dims` and `exciations` arguments. See the; docstring for enr_fock for a more detailed description of these arguments. Parameters; ----------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex128); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax]. Notes; -----; .. versionadded:: 3.2. """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form; :math:`\\sum |N><N+m| + |N+m><N|`. Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event. Returns; -------; T : Qobj; Tunneling operator. Notes; -----; .. versionadded:: 3.2. """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dty",MatchSource.WIKI,docs/4.6/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/operators.html
https://qutip.org/docs/4.6/modules/qutip/operators.html:22572,Energy Efficiency,charge,charge,22572,"he excitation-number restricted; state space defined by the `dims` and `exciations` arguments. See the; docstring for enr_fock for a more detailed description of these arguments. Parameters; ----------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex128); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax]. Notes; -----; .. versionadded:: 3.2. """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form; :math:`\\sum |N><N+m| + |N+m><N|`. Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event. Returns; -------; T : Qobj; Tunneling operator. Notes; -----; .. versionadded:: 3.2. """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dtype=complex); return Qobj(T, isherm=True). # Break circular dependencies by a trailing import.; # No",MatchSource.WIKI,docs/4.6/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/operators.html
https://qutip.org/docs/4.6/modules/qutip/operators.html:22635,Energy Efficiency,charge,charge,22635," and `exciations` arguments. See the; docstring for enr_fock for a more detailed description of these arguments. Parameters; ----------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex128); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax]. Notes; -----; .. versionadded:: 3.2. """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form; :math:`\\sum |N><N+m| + |N+m><N|`. Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event. Returns; -------; T : Qobj; Tunneling operator. Notes; -----; .. versionadded:: 3.2. """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dtype=complex); return Qobj(T, isherm=True). # Break circular dependencies by a trailing import.; # Note that we use a relative import here to deal with that; # qutip.te",MatchSource.WIKI,docs/4.6/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/operators.html
https://qutip.org/docs/4.6/modules/qutip/operators.html:22708,Energy Efficiency,charge,charge,22708," a more detailed description of these arguments. Parameters; ----------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex128); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax]. Notes; -----; .. versionadded:: 3.2. """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form; :math:`\\sum |N><N+m| + |N+m><N|`. Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event. Returns; -------; T : Qobj; Tunneling operator. Notes; -----; .. versionadded:: 3.2. """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dtype=complex); return Qobj(T, isherm=True). # Break circular dependencies by a trailing import.; # Note that we use a relative import here to deal with that; # qutip.tensor is the *function* tensor, not the module.; from qutip.tenso",MatchSource.WIKI,docs/4.6/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/operators.html
https://qutip.org/docs/4.6/modules/qutip/operators.html:10159,Integrability,rout,routines,10159,"reation (raising) operator. Parameters; ----------; N : int; Dimension of Hilbert space. Returns; -------; oper : qobj; Qobj for raising operator. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Examples; --------; >>> create(4) # doctest: +SKIP; Quantum object: dims = [[4], [4]], \; shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. '''; if not isinstance(N, (int, np.integer)): # raise error if N not integer; raise ValueError(""Hilbert space dimension must be integer value""); qo = destroy(N, offset=offset) # create operator using destroy function; return qo.dag(). def _implicit_tensor_dimensions(dimensions):; """"""; Total flattened size and operator dimensions for operator creation routines; that automatically perform tensor products. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); First dimension of an operator which can create an implicit tensor; product. If the type is `int`, it is promoted first to `[dimensions]`.; From there, it should be one of the two-elements `dims` parameter of a; `qutip.Qobj` representing an `oper` or `super`, with possible tensor; products. Returns; -------; size : int; Dimension of backing matrix required to represent operator.; dimensions : list; Dimension list in the form required by ``Qobj`` creation.; """"""; if not isinstance(dimensions, list):; dimensions = [dimensions]; flat = flatten(dimensions); if not all(isinstance(x, numbers.Integral) and x >= 0 for x in flat):; raise ValueError(""All dimensions must be integers >= 0""); return np.prod(flat), [dimensions, dimensions]. [docs]def qzero(dimensions):; """"""; Zero operator. Parameters; ----------; dimensions : (int",MatchSource.WIKI,docs/4.6/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/operators.html
https://qutip.org/docs/4.6/modules/qutip/operators.html:11389,Integrability,depend,depending,11389,"pe is `int`, it is promoted first to `[dimensions]`.; From there, it should be one of the two-elements `dims` parameter of a; `qutip.Qobj` representing an `oper` or `super`, with possible tensor; products. Returns; -------; size : int; Dimension of backing matrix required to represent operator.; dimensions : list; Dimension list in the form required by ``Qobj`` creation.; """"""; if not isinstance(dimensions, list):; dimensions = [dimensions]; flat = flatten(dimensions); if not all(isinstance(x, numbers.Integral) and x >= 0 for x in flat):; raise ValueError(""All dimensions must be integers >= 0""); return np.prod(flat), [dimensions, dimensions]. [docs]def qzero(dimensions):; """"""; Zero operator. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the ``dims`` property of; the new Qobj are set to this list. This can produce either `oper` or; `super` depending on the passed `dimensions`. Returns; -------; qzero : qobj; Zero operator Qobj. """"""; size, dimensions = _implicit_tensor_dimensions(dimensions); # A sparse matrix with no data is equal to a zero matrix.; return Qobj(fast_csr_matrix(shape=(size, size), dtype=complex),; dims=dimensions, isherm=True). #; # QEYE returns identity operator for a Hilbert space with dimensions dims.; # a = qeye(N), N is integer or list of integers & all elements >= 0; #; [docs]def qeye(dimensions):; """"""; Identity operator. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the ``dims`` property of; the new Qobj are set to this list. This can produce either `oper` or; `super` depending on the passed `dimensions`. Returns; -------; oper : qobj; Identity operator Qobj. Examples; --------; >>> qeye(3) # doctest: +SKIP; Quantum object: dims = [[3], [3]], s",MatchSource.WIKI,docs/4.6/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/operators.html
https://qutip.org/docs/4.6/modules/qutip/operators.html:12207,Integrability,depend,depending,12207,"rovided as a list of ints, then the; dimension is the product over this list, but the ``dims`` property of; the new Qobj are set to this list. This can produce either `oper` or; `super` depending on the passed `dimensions`. Returns; -------; qzero : qobj; Zero operator Qobj. """"""; size, dimensions = _implicit_tensor_dimensions(dimensions); # A sparse matrix with no data is equal to a zero matrix.; return Qobj(fast_csr_matrix(shape=(size, size), dtype=complex),; dims=dimensions, isherm=True). #; # QEYE returns identity operator for a Hilbert space with dimensions dims.; # a = qeye(N), N is integer or list of integers & all elements >= 0; #; [docs]def qeye(dimensions):; """"""; Identity operator. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the ``dims`` property of; the new Qobj are set to this list. This can produce either `oper` or; `super` depending on the passed `dimensions`. Returns; -------; oper : qobj; Identity operator Qobj. Examples; --------; >>> qeye(3) # doctest: +SKIP; Quantum object: dims = [[3], [3]], shape = (3, 3), type = oper, \; isherm = True; Qobj data =; [[ 1. 0. 0.]; [ 0. 1. 0.]; [ 0. 0. 1.]]; >>> qeye([2,2]) # doctest: +SKIP; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, \; isherm = True; Qobj data =; [[1. 0. 0. 0.]; [0. 1. 0. 0.]; [0. 0. 1. 0.]; [0. 0. 0. 1.]]. """"""; size, dimensions = _implicit_tensor_dimensions(dimensions); return Qobj(fast_identity(size),; dims=dimensions, isherm=True, isunitary=True). [docs]def identity(dims):; """"""Identity operator. Alternative name to :func:`qeye`. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the ``dims`` property of; the new Qobj are set to this list. This can produce either `oper` ",MatchSource.WIKI,docs/4.6/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/operators.html
https://qutip.org/docs/4.6/modules/qutip/operators.html:13216,Integrability,depend,depending,13216,"ding on the passed `dimensions`. Returns; -------; oper : qobj; Identity operator Qobj. Examples; --------; >>> qeye(3) # doctest: +SKIP; Quantum object: dims = [[3], [3]], shape = (3, 3), type = oper, \; isherm = True; Qobj data =; [[ 1. 0. 0.]; [ 0. 1. 0.]; [ 0. 0. 1.]]; >>> qeye([2,2]) # doctest: +SKIP; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, \; isherm = True; Qobj data =; [[1. 0. 0. 0.]; [0. 1. 0. 0.]; [0. 0. 1. 0.]; [0. 0. 0. 1.]]. """"""; size, dimensions = _implicit_tensor_dimensions(dimensions); return Qobj(fast_identity(size),; dims=dimensions, isherm=True, isunitary=True). [docs]def identity(dims):; """"""Identity operator. Alternative name to :func:`qeye`. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the ``dims`` property of; the new Qobj are set to this list. This can produce either `oper` or; `super` depending on the passed `dimensions`. Returns; -------; oper : qobj; Identity operator Qobj.; """"""; return qeye(dims). [docs]def position(N, offset=0):; """"""; Position operator x=1/sqrt(2)*(a+a.dag()). Parameters; ----------; N : int; Number of Fock states in Hilbert space. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Returns; -------; oper : qobj; Position operator as Qobj.; """"""; a = destroy(N, offset=offset); return 1.0 / np.sqrt(2.0) * (a + a.dag()). [docs]def momentum(N, offset=0):; """"""; Momentum operator p=-1j/sqrt(2)*(a-a.dag()). Parameters; ----------; N : int; Number of Fock states in Hilbert space. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Returns; -------; oper : qobj; Momentum operator as Qobj.; """"""; a = destroy(N, offset=offset); return -1j / np.sqrt(2.0) * (a - a.dag()). [docs]def num(N, offset=0):; """"""Quant",MatchSource.WIKI,docs/4.6/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/operators.html
https://qutip.org/docs/4.6/modules/qutip/operators.html:23522,Integrability,depend,dependencies,23522,"umber basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex128); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax]. Notes; -----; .. versionadded:: 3.2. """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form; :math:`\\sum |N><N+m| + |N+m><N|`. Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event. Returns; -------; T : Qobj; Tunneling operator. Notes; -----; .. versionadded:: 3.2. """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dtype=complex); return Qobj(T, isherm=True). # Break circular dependencies by a trailing import.; # Note that we use a relative import here to deal with that; # qutip.tensor is the *function* tensor, not the module.; from qutip.tensor import tensor. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/operators.html
https://qutip.org/docs/4.6/modules/qutip/operators.html:10188,Performance,perform,perform,10188,"reation (raising) operator. Parameters; ----------; N : int; Dimension of Hilbert space. Returns; -------; oper : qobj; Qobj for raising operator. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Examples; --------; >>> create(4) # doctest: +SKIP; Quantum object: dims = [[4], [4]], \; shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. '''; if not isinstance(N, (int, np.integer)): # raise error if N not integer; raise ValueError(""Hilbert space dimension must be integer value""); qo = destroy(N, offset=offset) # create operator using destroy function; return qo.dag(). def _implicit_tensor_dimensions(dimensions):; """"""; Total flattened size and operator dimensions for operator creation routines; that automatically perform tensor products. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); First dimension of an operator which can create an implicit tensor; product. If the type is `int`, it is promoted first to `[dimensions]`.; From there, it should be one of the two-elements `dims` parameter of a; `qutip.Qobj` representing an `oper` or `super`, with possible tensor; products. Returns; -------; size : int; Dimension of backing matrix required to represent operator.; dimensions : list; Dimension list in the form required by ``Qobj`` creation.; """"""; if not isinstance(dimensions, list):; dimensions = [dimensions]; flat = flatten(dimensions); if not all(isinstance(x, numbers.Integral) and x >= 0 for x in flat):; raise ValueError(""All dimensions must be integers >= 0""); return np.prod(flat), [dimensions, dimensions]. [docs]def qzero(dimensions):; """"""; Zero operator. Parameters; ----------; dimensions : (int",MatchSource.WIKI,docs/4.6/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/operators.html
https://qutip.org/docs/4.6/modules/qutip/orbital.html:4834,Deployability,update,updated,4834,"Error('Invalid input ket in orbital'); sk = ket.shape; nchk = (sk[0] - 1) / 2.0; if nchk != np.floor(nchk):; raise ValueError(; 'Kets must have odd number of components in orbital'); l = int((sk[0] - 1) / 2); if l == 0:; SPlm = np.sqrt(2) * np.ones((np.size(theta), 1), dtype=complex); else:; SPlm = _sch_lpmv(l, np.cos(theta)); fac = np.sqrt((2.0 * l + 1) / (8 * np.pi)); kf = ket.full(); psi += np.sqrt(2) * fac * kf[l, 0] * np.ones((np.size(phi),; np.size(theta)),; dtype=complex) * SPlm[0]; for m in range(1, l + 1):; psi += ((-1.0) ** m * fac * kf[l - m, 0]) * \; np.array([np.exp(1.0j * 1 * phi)]).T * \; np.ones((np.size(phi), np.size(theta)),; dtype=complex) * SPlm[1]; for m in range(-l, 0):; psi = psi + (fac * kf[l - m, 0]) * \; np.array([np.exp(1.0j * 1 * phi)]).T * \; np.ones((np.size(phi), np.size(theta)), dtype=complex) * \; SPlm[abs(m)]; return psi. # Schmidt Semi-normalized Associated Legendre Functions; def _sch_lpmv(n, x):; '''; Outputs array of Schmidt Seminormalized Associated Legendre Functions; S_{n}^{m} for m<=n. Parameters; ----------; n : int; Degree of polynomial. x : float; Point at which to evaluate. Returns; -------; array of values for Legendre functions. '''; from scipy.special import lpmv; n = int(n); sch = np.array([1.0]); sch2 = np.array([(-1.0) ** m * np.sqrt(; (2.0 * factorial(n - m)) / factorial(n + m)) for m in range(1, n + 1)]); sch = np.append(sch, sch2); if isinstance(x, float) or len(x) == 1:; leg = lpmv(np.arange(0, n + 1), n, x); return np.array([sch * leg]).T; else:; for j in range(0, len(x)):; leg = lpmv(range(0, n + 1), n, x[j]); if j == 0:; out = np.array([sch * leg]).T; else:; out = np.append(out, np.array([sch * leg]).T, axis=1); return out. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/orbital.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/orbital.html
https://qutip.org/docs/4.6/modules/qutip/parallel.html:6490,Deployability,update,update,6490,"]. This function work as a drop-in replacement of :func:`qutip.parallel_map`. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list / dictionary; The optional additional argument to the ``task`` function.; task_kwargs : list / dictionary; The optional additional keyword argument to the ``task`` function.; progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for each; value in ``values``. """"""; try:; progress_bar = kwargs['progress_bar']; if progress_bar is True:; progress_bar = TextProgressBar(); except:; progress_bar = BaseProgressBar(). progress_bar.start(len(values)); results = []; for n, value in enumerate(values):; progress_bar.update(n); result = task(value, *task_args, **task_kwargs); results.append(result); progress_bar.finished(). return results. [docs]def parallel_map(task, values, task_args=tuple(), task_kwargs={}, **kwargs):; """"""; Parallel execution of a mapping of `values` to the function `task`. This; is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list / dictionary; The optional additional argument to the ``task`` function.; task_kwargs : list / dictionary; The optional additional keyword argument to the ``task`` function.; progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for; each value in ``values``. """"""",MatchSource.WIKI,docs/4.6/modules/qutip/parallel.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/parallel.html
https://qutip.org/docs/4.6/modules/qutip/parallel.html:7915,Deployability,update,update,7915,"t = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list / dictionary; The optional additional argument to the ``task`` function.; task_kwargs : list / dictionary; The optional additional keyword argument to the ``task`` function.; progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for; each value in ``values``. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs:; kw['num_cpus'] = kwargs['num_cpus']. try:; progress_bar = kwargs['progress_bar']; if progress_bar is True:; progress_bar = TextProgressBar(); except:; progress_bar = BaseProgressBar(). progress_bar.start(len(values)); nfinished = [0]. def _update_progress_bar(x):; nfinished[0] += 1; progress_bar.update(nfinished[0]). try:; pool = Pool(processes=kw['num_cpus']). async_res = [pool.apply_async(task, (value,) + task_args, task_kwargs,; _update_progress_bar); for value in values]. while not all([ar.ready() for ar in async_res]):; for ar in async_res:; ar.wait(timeout=0.1). pool.terminate(); pool.join(). except KeyboardInterrupt as e:; os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; pool.terminate(); pool.join(); raise e. progress_bar.finished(); os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; return [ar.get() for ar in async_res]. def _default_kwargs():; settings = {'num_cpus': qset.num_cpus}; return settings. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/parallel.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/parallel.html
https://qutip.org/docs/4.6/modules/qutip/parallel.html:8715,Deployability,update,updated,8715,"t = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list / dictionary; The optional additional argument to the ``task`` function.; task_kwargs : list / dictionary; The optional additional keyword argument to the ``task`` function.; progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for; each value in ``values``. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs:; kw['num_cpus'] = kwargs['num_cpus']. try:; progress_bar = kwargs['progress_bar']; if progress_bar is True:; progress_bar = TextProgressBar(); except:; progress_bar = BaseProgressBar(). progress_bar.start(len(values)); nfinished = [0]. def _update_progress_bar(x):; nfinished[0] += 1; progress_bar.update(nfinished[0]). try:; pool = Pool(processes=kw['num_cpus']). async_res = [pool.apply_async(task, (value,) + task_args, task_kwargs,; _update_progress_bar); for value in values]. while not all([ar.ready() for ar in async_res]):; for ar in async_res:; ar.wait(timeout=0.1). pool.terminate(); pool.join(). except KeyboardInterrupt as e:; os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; pool.terminate(); pool.join(); raise e. progress_bar.finished(); os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; return [ar.get() for ar in async_res]. def _default_kwargs():; settings = {'num_cpus': qset.num_cpus}; return settings. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/parallel.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/parallel.html
https://qutip.org/docs/4.6/modules/qutip/parallel.html:2974,Modifiability,variab,variable,2974,"F THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing.; """"""; __all__ = ['parfor', 'parallel_map', 'serial_map']. from scipy import array; import multiprocessing; from functools import partial; import os; import sys; import signal; import qutip.settings as qset; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. if sys.platform == 'darwin':; Pool = multiprocessing.get_context('fork').Pool; else:; Pool = multiprocessing.Pool. def _task_wrapper(args):; try:; return args[0](*args[1]); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). def _task_wrapper_with_args(args, user_args):; try:; return args[0](*args[1], **user_args); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). [docs]def parfor(func, *args, **kwargs):; """"""Executes a multi-variable function in parallel on the local machine. Parallel execution of a for-loop over function `func` for multiple input; arguments and keyword arguments. .. note::. From QuTiP 3.1, we recommend to use :func:`qutip.parallel_map`; instead of this function. Parameters; ----------; func : function_type; A function to run in parallel on the local machine. The function 'func'; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU's to use. Default uses maximum number of CPU's.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns; -------; result : list; A ``list`` with length equal to number of input param",MatchSource.WIKI,docs/4.6/modules/qutip/parallel.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/parallel.html
https://qutip.org/docs/4.6/modules/qutip/parallel.html:3419,Modifiability,variab,variables,3419,"rt sys; import signal; import qutip.settings as qset; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. if sys.platform == 'darwin':; Pool = multiprocessing.get_context('fork').Pool; else:; Pool = multiprocessing.Pool. def _task_wrapper(args):; try:; return args[0](*args[1]); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). def _task_wrapper_with_args(args, user_args):; try:; return args[0](*args[1], **user_args); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). [docs]def parfor(func, *args, **kwargs):; """"""Executes a multi-variable function in parallel on the local machine. Parallel execution of a for-loop over function `func` for multiple input; arguments and keyword arguments. .. note::. From QuTiP 3.1, we recommend to use :func:`qutip.parallel_map`; instead of this function. Parameters; ----------; func : function_type; A function to run in parallel on the local machine. The function 'func'; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU's to use. Default uses maximum number of CPU's.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns; -------; result : list; A ``list`` with length equal to number of input parameters; containing the output from `func`. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs.keys():; kw['num_cpus'] = kwargs['num_cpus']; del kwargs['num_cpus']; if len(kwargs) != 0:; task_func = partial(_task_wrapper_with_args, user_args=kwargs); else:; task_func = _task_wrapper. if kw['num_cpus'] > qset.num_cpus:; print(""Requested number of CPUs (%s) "" % kw['num_",MatchSource.WIKI,docs/4.6/modules/qutip/parallel.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/parallel.html
https://qutip.org/docs/4.6/modules/qutip/parallel.html:3479,Modifiability,variab,variables,3479,"atform == 'darwin':; Pool = multiprocessing.get_context('fork').Pool; else:; Pool = multiprocessing.Pool. def _task_wrapper(args):; try:; return args[0](*args[1]); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). def _task_wrapper_with_args(args, user_args):; try:; return args[0](*args[1], **user_args); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). [docs]def parfor(func, *args, **kwargs):; """"""Executes a multi-variable function in parallel on the local machine. Parallel execution of a for-loop over function `func` for multiple input; arguments and keyword arguments. .. note::. From QuTiP 3.1, we recommend to use :func:`qutip.parallel_map`; instead of this function. Parameters; ----------; func : function_type; A function to run in parallel on the local machine. The function 'func'; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU's to use. Default uses maximum number of CPU's.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns; -------; result : list; A ``list`` with length equal to number of input parameters; containing the output from `func`. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs.keys():; kw['num_cpus'] = kwargs['num_cpus']; del kwargs['num_cpus']; if len(kwargs) != 0:; task_func = partial(_task_wrapper_with_args, user_args=kwargs); else:; task_func = _task_wrapper. if kw['num_cpus'] > qset.num_cpus:; print(""Requested number of CPUs (%s) "" % kw['num_cpus'] +; ""is larger than physical number (%s)."" % qset.num_cpus); print(""Reduce 'num_cpus' for greater performance.""). pool = Pool",MatchSource.WIKI,docs/4.6/modules/qutip/parallel.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/parallel.html
https://qutip.org/docs/4.6/modules/qutip/parallel.html:4484,Performance,perform,performance,4484,"ltiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU's to use. Default uses maximum number of CPU's.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns; -------; result : list; A ``list`` with length equal to number of input parameters; containing the output from `func`. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs.keys():; kw['num_cpus'] = kwargs['num_cpus']; del kwargs['num_cpus']; if len(kwargs) != 0:; task_func = partial(_task_wrapper_with_args, user_args=kwargs); else:; task_func = _task_wrapper. if kw['num_cpus'] > qset.num_cpus:; print(""Requested number of CPUs (%s) "" % kw['num_cpus'] +; ""is larger than physical number (%s)."" % qset.num_cpus); print(""Reduce 'num_cpus' for greater performance.""). pool = Pool(processes=kw['num_cpus']); args = [list(arg) for arg in args]; var = [[args[j][i] for j in range(len(args))]; for i in range(len(list(args[0])))]; try:; map_args = ((func, v, os.getpid()) for v in var); par_return = list(pool.map(task_func, map_args)). pool.terminate(); pool.join(); os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; if isinstance(par_return[0], tuple):; par_return = [elem for elem in par_return]; num_elems = len(par_return[0]); dt = [type(ii) for ii in par_return[0]]; return [array([elem[ii] for elem in par_return], dtype=dt[ii]); for ii in range(num_elems)]; else:; return par_return. except KeyboardInterrupt:; os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; pool.terminate(). [docs]def serial_map(task, values, task_args=tuple(), task_kwargs={}, **kwargs):; """"""; Serial mapping function with the same call signature as parallel_map, for; easy switching between serial and parallel execution. This; is functionally equivalent to::. result = [",MatchSource.WIKI,docs/4.6/modules/qutip/parallel.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/parallel.html
https://qutip.org/docs/4.6/modules/qutip/parallel.html:8179,Safety,timeout,timeout,8179,"t = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list / dictionary; The optional additional argument to the ``task`` function.; task_kwargs : list / dictionary; The optional additional keyword argument to the ``task`` function.; progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for; each value in ``values``. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs:; kw['num_cpus'] = kwargs['num_cpus']. try:; progress_bar = kwargs['progress_bar']; if progress_bar is True:; progress_bar = TextProgressBar(); except:; progress_bar = BaseProgressBar(). progress_bar.start(len(values)); nfinished = [0]. def _update_progress_bar(x):; nfinished[0] += 1; progress_bar.update(nfinished[0]). try:; pool = Pool(processes=kw['num_cpus']). async_res = [pool.apply_async(task, (value,) + task_args, task_kwargs,; _update_progress_bar); for value in values]. while not all([ar.ready() for ar in async_res]):; for ar in async_res:; ar.wait(timeout=0.1). pool.terminate(); pool.join(). except KeyboardInterrupt as e:; os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; pool.terminate(); pool.join(); raise e. progress_bar.finished(); os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; return [ar.get() for ar in async_res]. def _default_kwargs():; settings = {'num_cpus': qset.num_cpus}; return settings. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/parallel.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/parallel.html
https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html:2425,Availability,mask,mask,2425," THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code was contributed by Jonas Neergaard-Nielsen; ###############################################################################. __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_",MatchSource.WIKI,docs/4.6/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html:2517,Availability,mask,mask,2517," THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code was contributed by Jonas Neergaard-Nielsen; ###############################################################################. __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_",MatchSource.WIKI,docs/4.6/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html:2659,Availability,mask,mask,2659,"OCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code was contributed by Jonas Neergaard-Nielsen; ###############################################################################. __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; p",MatchSource.WIKI,docs/4.6/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html:2758,Availability,mask,mask,2758,"; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code was contributed by Jonas Neergaard-Nielsen; ###############################################################################. __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rh",MatchSource.WIKI,docs/4.6/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html:2955,Availability,mask,mask,2955," THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code was contributed by Jonas Neergaard-Nielsen; ###############################################################################. __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Impleme",MatchSource.WIKI,docs/4.6/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html:2982,Availability,mask,mask,2982," THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code was contributed by Jonas Neergaard-Nielsen; ###############################################################################. __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Impleme",MatchSource.WIKI,docs/4.6/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html:3336,Availability,mask,mask,3336,"e_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[",MatchSource.WIKI,docs/4.6/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html:3360,Availability,mask,mask,3360,"e_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[",MatchSource.WIKI,docs/4.6/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html:3429,Availability,mask,mask,3429,"ask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, ps",MatchSource.WIKI,docs/4.6/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html:3480,Availability,mask,mask,3480,"ask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, ps",MatchSource.WIKI,docs/4.6/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html:3521,Availability,mask,mask,3521,"ray/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.",MatchSource.WIKI,docs/4.6/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html:3626,Availability,mask,mask,3626,"o.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference",MatchSource.WIKI,docs/4.6/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html:3720,Availability,mask,mask,3720,"ments in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. I",MatchSource.WIKI,docs/4.6/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html:3769,Availability,mask,mask,3769,"ments in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. I",MatchSource.WIKI,docs/4.6/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html:3976,Availability,mask,mask,3976,"lects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[",MatchSource.WIKI,docs/4.6/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html:4410,Availability,mask,mask,4410,"; else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. ",MatchSource.WIKI,docs/4.6/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html:4485,Availability,mask,mask,4485,"artial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built w",MatchSource.WIKI,docs/4.6/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html:4633,Availability,mask,mask,4633,"lementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html:5096,Availability,mask,mask,5096,"lementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html:5171,Availability,mask,mask,5171,"lementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html:5452,Deployability,update,updated,5452,"lementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html:4724,Performance,perform,performs,4724,"lementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html:4797,Testability,test,testing,4797,"lementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.6/modules/qutip/piqs.html:2652,Deployability,integrat,integrate,2652,", PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""Permutational Invariant Quantum Solver (PIQS). This module calculates the Liouvillian for the dynamics of ensembles of; identical two-level systems (TLS) in the presence of local and collective; processes by exploiting permutational symmetry and using the Dicke basis.; It also allows to characterize nonlinear functions of the density matrix.; """""". # Authors: Nathan Shammah, Shahnawaz Ahmed; # Contact: nathan.shammah@gmail.com, shahnawaz.ahmed95@gmail.com. from math import factorial; from decimal import Decimal. import numpy as np; from scipy.integrate import odeint; from scipy.linalg import eigvalsh; from scipy.special import entr; from scipy.sparse import dok_matrix, block_diag, lil_matrix; from qutip.solver import Options, Result; from qutip import (; Qobj,; spre,; spost,; tensor,; identity,; ket2dm,; ); from qutip import sigmax, sigmay, sigmaz, sigmap, sigmam; from qutip.cy.piqs import Dicke as _Dicke; from qutip.cy.piqs import (; jmm1_dictionary,; _num_dicke_states,; _num_dicke_ladders,; get_blocks,; j_min,; j_vals,; ). __all__ = [; ""num_dicke_states"",; ""num_dicke_ladders"",; ""num_tls"",; ""isdiagonal"",; ""dicke_blocks"",; ""dicke_blocks_full"",; ""dicke_function_trace"",; ""purity_dicke"",; ""entropy_vn_dicke"",; ""Dicke"",; ""state_degeneracy"",; ""m_degeneracy"",; ""energy_degeneracy"",; ""ap"",; ""am"",; ""spin_algebra"",; ""jspin"",; ""collapse_uncoupled"",; ""dicke_basis"",; ""dicke"",; ""excited"",; ""superradiant"",; ""css"",; ""ghz"",; ""ground"",; ""identity_uncoupled"",; ""block_matrix"",; ""tau_column"",; ""Pim"",; ]. def _ensure_int(x):; """"""; Ensure that a floating-point valu",MatchSource.WIKI,docs/4.6/modules/qutip/piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/piqs.html
https://qutip.org/docs/4.6/modules/qutip/piqs.html:13909,Deployability,integrat,integrate,13909,"tip.Qobj`.; """"""; cythonized_dicke = _Dicke(; int(self.N),; float(self.emission),; float(self.dephasing),; float(self.pumping),; float(self.collective_emission),; float(self.collective_dephasing),; float(self.collective_pumping),; ); return cythonized_dicke.lindbladian(). [docs] def liouvillian(self):; """"""Build the total Liouvillian using the Dicke basis. Returns; -------; liouv : :class:`qutip.Qobj`; The Liouvillian matrix for the system.; """"""; lindblad = self.lindbladian(); if self.hamiltonian is None:; liouv = lindblad. else:; hamiltonian = self.hamiltonian; hamiltonian_superoperator = -1j * spre(hamiltonian) + 1j * spost(; hamiltonian; ); liouv = lindblad + hamiltonian_superoperator; return liouv. [docs] def pisolve(self, initial_state, tlist, options=None):; """"""; Solve for diagonal Hamiltonians and initial states faster. Parameters; ==========; initial_state : :class:`qutip.Qobj`; An initial state specified as a density matrix of; `qutip.Qbj` type. tlist: ndarray; A 1D numpy array of list of timesteps to integrate. options : :class:`qutip.solver.Options`; The options for the solver. Returns; =======; result: list; A dictionary of the type `qutip.solver.Result` which holds the; results of the evolution.; """"""; if isdiagonal(initial_state) == False:; msg = ""`pisolve` requires a diagonal initial density matrix. ""; msg += ""In general construct the Liouvillian using ""; msg += ""`piqs.liouvillian` and use qutip.mesolve.""; raise ValueError(msg). if self.hamiltonian and isdiagonal(self.hamiltonian) == False:; msg = ""`pisolve` should only be used for diagonal Hamiltonians. ""; msg += ""Construct the Liouvillian using `piqs.liouvillian` and""; msg += "" use `qutip.mesolve`.""; raise ValueError(msg). if initial_state.full().shape != self.dshape:; msg = ""Initial density matrix should be diagonal.""; raise ValueError(msg). pim = Pim(; self.N,; self.emission,; self.dephasing,; self.pumping,; self.collective_emission,; self.collective_pumping,; self.collective_dephasing,; ); result = ",MatchSource.WIKI,docs/4.6/modules/qutip/piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/piqs.html
https://qutip.org/docs/4.6/modules/qutip/piqs.html:47136,Deployability,update,updated,47136," den = 2 * j * (2 * j + 1); t3 = yL * (num / den); return t3. [docs] def tau4(self, j, m):; """"""; Calculate coefficient matrix element relative to (j-1, m+1, m+1).; """"""; yL = self.emission; N = float(self.N); num = (j - m + 1) * (j - m + 2) * (N / 2 - j); den = 2 * (j + 1) * (2 * j + 1); t4 = yL * (num / den); return t4. [docs] def tau5(self, j, m):; """"""; Calculate coefficient matrix element relative to (j+1, m, m).; """"""; yD = self.dephasing; N = float(self.N); num = (j - m) * (j + m) * (j + 1 + N / 2); den = 2 * j * (2 * j + 1); t5 = yD * (num / den); return t5. [docs] def tau6(self, j, m):; """"""; Calculate coefficient matrix element relative to (j-1, m, m).; """"""; yD = self.dephasing; N = float(self.N); num = (j - m + 1) * (j + m + 1) * (N / 2 - j); den = 2 * (j + 1) * (2 * j + 1); t6 = yD * (num / den); return t6. [docs] def tau7(self, j, m):; """"""; Calculate coefficient matrix element relative to (j+1, m-1, m-1).; """"""; yP = self.pumping; N = float(self.N); num = (j - m - 1) * (j - m) * (j + 1 + N / 2); den = 2 * j * (2 * j + 1); t7 = yP * (float(num) / den); return t7. [docs] def tau8(self, j, m):; """"""; Calculate coefficient matrix element relative to (j, m-1, m-1).; """"""; yP = self.pumping; yCP = self.collective_pumping; N = float(self.N). num = (1 + N / 2) * (j - m) * (j + m + 1); den = 2 * j * (j + 1); pump = yP * (float(num) / den); collective_pump = yCP * (j - m) * (j + m + 1); t8 = pump + collective_pump; return t8. [docs] def tau9(self, j, m):; """"""; Calculate coefficient matrix element relative to (j-1, m-1, m-1).; """"""; yP = self.pumping; N = float(self.N); num = (j + m + 1) * (j + m + 2) * (N / 2 - j); den = 2 * (j + 1) * (2 * j + 1); t9 = yP * (float(num) / den); return t9. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/piqs.html
https://qutip.org/docs/4.6/modules/qutip/piqs.html:16200,Energy Efficiency,energy,energy,16200,"""""; ce = self.collective_emission; cd = self.collective_dephasing; cp = self.collective_pumping; c_ops_list = collapse_uncoupled(; N=self.N,; emission=self.emission,; dephasing=self.dephasing,; pumping=self.pumping,; collective_emission=ce,; collective_dephasing=cd,; collective_pumping=cp,; ); return c_ops_list. [docs] def coefficient_matrix(self):; """"""Build coefficient matrix for ODE for a diagonal problem. Returns; -------; M: ndarray; The matrix M of the coefficients for the ODE dp/dt = Mp.; p is the vector of the diagonal matrix elements; of the density matrix rho in the Dicke basis.; """"""; diagonal_system = Pim(; N=self.N,; emission=self.emission,; dephasing=self.dephasing,; pumping=self.pumping,; collective_emission=self.collective_emission,; collective_dephasing=self.collective_dephasing,; collective_pumping=self.collective_pumping,; ); coef_matrix = diagonal_system.coefficient_matrix(); return coef_matrix. # Utility functions for properties of the Dicke space; [docs]def energy_degeneracy(N, m):; """"""Calculate the number of Dicke states with same energy. The use of the `Decimals` class allows to explore N > 1000,; unlike the built-in function `scipy.special.binom`. Parameters; ----------; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns; -------; degeneracy: int; The energy degeneracy; """"""; numerator = Decimal(factorial(N)); d1 = Decimal(factorial(_ensure_int(N / 2 + m))); d2 = Decimal(factorial(_ensure_int(N / 2 - m))); degeneracy = numerator / (d1 * d2); return int(degeneracy). [docs]def state_degeneracy(N, j):; r""""""Calculate the degeneracy of the Dicke state. Each state :math:`\lvert j, m\rangle` includes D(N,j) irreducible; representations :math:`\lvert j, m, \alpha\rangle`. Uses Decimals to calculate higher numerator and denominators numbers. Parameters; ----------; N: int; The number of two-level systems. j: float; Total spin eigenvalue (cooperativity). Returns; -",MatchSource.WIKI,docs/4.6/modules/qutip/piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/piqs.html
https://qutip.org/docs/4.6/modules/qutip/piqs.html:16472,Energy Efficiency,energy,energy,16472,"coefficient_matrix(self):; """"""Build coefficient matrix for ODE for a diagonal problem. Returns; -------; M: ndarray; The matrix M of the coefficients for the ODE dp/dt = Mp.; p is the vector of the diagonal matrix elements; of the density matrix rho in the Dicke basis.; """"""; diagonal_system = Pim(; N=self.N,; emission=self.emission,; dephasing=self.dephasing,; pumping=self.pumping,; collective_emission=self.collective_emission,; collective_dephasing=self.collective_dephasing,; collective_pumping=self.collective_pumping,; ); coef_matrix = diagonal_system.coefficient_matrix(); return coef_matrix. # Utility functions for properties of the Dicke space; [docs]def energy_degeneracy(N, m):; """"""Calculate the number of Dicke states with same energy. The use of the `Decimals` class allows to explore N > 1000,; unlike the built-in function `scipy.special.binom`. Parameters; ----------; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns; -------; degeneracy: int; The energy degeneracy; """"""; numerator = Decimal(factorial(N)); d1 = Decimal(factorial(_ensure_int(N / 2 + m))); d2 = Decimal(factorial(_ensure_int(N / 2 - m))); degeneracy = numerator / (d1 * d2); return int(degeneracy). [docs]def state_degeneracy(N, j):; r""""""Calculate the degeneracy of the Dicke state. Each state :math:`\lvert j, m\rangle` includes D(N,j) irreducible; representations :math:`\lvert j, m, \alpha\rangle`. Uses Decimals to calculate higher numerator and denominators numbers. Parameters; ----------; N: int; The number of two-level systems. j: float; Total spin eigenvalue (cooperativity). Returns; -------; degeneracy: int; The state degeneracy.; """"""; if j < 0:; raise ValueError(""j value should be >= 0""); numerator = Decimal(factorial(N)) * Decimal(2 * j + 1); denominator_1 = Decimal(factorial(_ensure_int(N / 2 + j + 1))); denominator_2 = Decimal(factorial(_ensure_int(N / 2 - j))); degeneracy = numerator / (denominator",MatchSource.WIKI,docs/4.6/modules/qutip/piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/piqs.html
https://qutip.org/docs/4.6/modules/qutip/piqs.html:16519,Energy Efficiency,energy,energy,16519,"for the ODE dp/dt = Mp.; p is the vector of the diagonal matrix elements; of the density matrix rho in the Dicke basis.; """"""; diagonal_system = Pim(; N=self.N,; emission=self.emission,; dephasing=self.dephasing,; pumping=self.pumping,; collective_emission=self.collective_emission,; collective_dephasing=self.collective_dephasing,; collective_pumping=self.collective_pumping,; ); coef_matrix = diagonal_system.coefficient_matrix(); return coef_matrix. # Utility functions for properties of the Dicke space; [docs]def energy_degeneracy(N, m):; """"""Calculate the number of Dicke states with same energy. The use of the `Decimals` class allows to explore N > 1000,; unlike the built-in function `scipy.special.binom`. Parameters; ----------; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns; -------; degeneracy: int; The energy degeneracy; """"""; numerator = Decimal(factorial(N)); d1 = Decimal(factorial(_ensure_int(N / 2 + m))); d2 = Decimal(factorial(_ensure_int(N / 2 - m))); degeneracy = numerator / (d1 * d2); return int(degeneracy). [docs]def state_degeneracy(N, j):; r""""""Calculate the degeneracy of the Dicke state. Each state :math:`\lvert j, m\rangle` includes D(N,j) irreducible; representations :math:`\lvert j, m, \alpha\rangle`. Uses Decimals to calculate higher numerator and denominators numbers. Parameters; ----------; N: int; The number of two-level systems. j: float; Total spin eigenvalue (cooperativity). Returns; -------; degeneracy: int; The state degeneracy.; """"""; if j < 0:; raise ValueError(""j value should be >= 0""); numerator = Decimal(factorial(N)) * Decimal(2 * j + 1); denominator_1 = Decimal(factorial(_ensure_int(N / 2 + j + 1))); denominator_2 = Decimal(factorial(_ensure_int(N / 2 - j))); degeneracy = numerator / (denominator_1 * denominator_2); degeneracy = int(np.round(float(degeneracy))); return degeneracy. [docs]def m_degeneracy(N, m):; r""""""Calculate the number of Dic",MatchSource.WIKI,docs/4.6/modules/qutip/piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/piqs.html
https://qutip.org/docs/4.6/modules/qutip/piqs.html:17655,Energy Efficiency,energy,energy,17655,"nsure_int(N / 2 + m))); d2 = Decimal(factorial(_ensure_int(N / 2 - m))); degeneracy = numerator / (d1 * d2); return int(degeneracy). [docs]def state_degeneracy(N, j):; r""""""Calculate the degeneracy of the Dicke state. Each state :math:`\lvert j, m\rangle` includes D(N,j) irreducible; representations :math:`\lvert j, m, \alpha\rangle`. Uses Decimals to calculate higher numerator and denominators numbers. Parameters; ----------; N: int; The number of two-level systems. j: float; Total spin eigenvalue (cooperativity). Returns; -------; degeneracy: int; The state degeneracy.; """"""; if j < 0:; raise ValueError(""j value should be >= 0""); numerator = Decimal(factorial(N)) * Decimal(2 * j + 1); denominator_1 = Decimal(factorial(_ensure_int(N / 2 + j + 1))); denominator_2 = Decimal(factorial(_ensure_int(N / 2 - j))); degeneracy = numerator / (denominator_1 * denominator_2); degeneracy = int(np.round(float(degeneracy))); return degeneracy. [docs]def m_degeneracy(N, m):; r""""""Calculate the number of Dicke states :math:`\lvert j, m\rangle` with; same energy. Parameters; ----------; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue (proportional to the total; energy). Returns; -------; degeneracy: int; The m-degeneracy.; """"""; jvals = j_vals(N); maxj = np.max(jvals); if m < -maxj:; e = ""m value is incorrect for this N.""; e += "" Minimum m value can be {}"".format(-maxj); raise ValueError(e); degeneracy = N / 2 + 1 - abs(m); return int(degeneracy). [docs]def ap(j, m):; r""""""; Calculate the coefficient ``ap`` by applying :math:`J_+\lvert j,m\rangle`. The action of ap is given by:; :math:`J_{+}\lvert j, m\rangle = A_{+}(j, m) \lvert j, m+1\rangle`. Parameters; ----------; j, m: float; The value for j and m in the dicke basis :math:`\lvert j, m\rangle`. Returns; -------; a_plus: float; The value of :math:`a_{+}`.; """"""; a_plus = np.sqrt((j - m) * (j + m + 1)); return a_plus. [docs]def am(j, m):; r""""""Calculate the operator ``am`` used later. The actio",MatchSource.WIKI,docs/4.6/modules/qutip/piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/piqs.html
https://qutip.org/docs/4.6/modules/qutip/piqs.html:17806,Energy Efficiency,energy,energy,17806," r""""""Calculate the degeneracy of the Dicke state. Each state :math:`\lvert j, m\rangle` includes D(N,j) irreducible; representations :math:`\lvert j, m, \alpha\rangle`. Uses Decimals to calculate higher numerator and denominators numbers. Parameters; ----------; N: int; The number of two-level systems. j: float; Total spin eigenvalue (cooperativity). Returns; -------; degeneracy: int; The state degeneracy.; """"""; if j < 0:; raise ValueError(""j value should be >= 0""); numerator = Decimal(factorial(N)) * Decimal(2 * j + 1); denominator_1 = Decimal(factorial(_ensure_int(N / 2 + j + 1))); denominator_2 = Decimal(factorial(_ensure_int(N / 2 - j))); degeneracy = numerator / (denominator_1 * denominator_2); degeneracy = int(np.round(float(degeneracy))); return degeneracy. [docs]def m_degeneracy(N, m):; r""""""Calculate the number of Dicke states :math:`\lvert j, m\rangle` with; same energy. Parameters; ----------; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue (proportional to the total; energy). Returns; -------; degeneracy: int; The m-degeneracy.; """"""; jvals = j_vals(N); maxj = np.max(jvals); if m < -maxj:; e = ""m value is incorrect for this N.""; e += "" Minimum m value can be {}"".format(-maxj); raise ValueError(e); degeneracy = N / 2 + 1 - abs(m); return int(degeneracy). [docs]def ap(j, m):; r""""""; Calculate the coefficient ``ap`` by applying :math:`J_+\lvert j,m\rangle`. The action of ap is given by:; :math:`J_{+}\lvert j, m\rangle = A_{+}(j, m) \lvert j, m+1\rangle`. Parameters; ----------; j, m: float; The value for j and m in the dicke basis :math:`\lvert j, m\rangle`. Returns; -------; a_plus: float; The value of :math:`a_{+}`.; """"""; a_plus = np.sqrt((j - m) * (j + m + 1)); return a_plus. [docs]def am(j, m):; r""""""Calculate the operator ``am`` used later. The action of ``ap`` is given by:; :math:`J_{-}\lvert j,m\rangle = A_{-}(jm)\lvert j,m-1\rangle`. Parameters; ----------; j: float; The value for j. m: float; The value for m. R",MatchSource.WIKI,docs/4.6/modules/qutip/piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/piqs.html
https://qutip.org/docs/4.6/modules/qutip/piqs.html:24936,Energy Efficiency,reduce,reduce,24936,"2) Pauli matrices. Notes; -----; The collapse operator list can be given to `qutip.mesolve`.; Notice that the operators are placed in a Hilbert space of; dimension :math:`2^N`. Thus the method is suitable only for; small N (of the order of 10). Parameters; ----------; N: int; The number of two-level systems. emission: float; Incoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: float; Local dephasing coefficient.; default: 0.0. pumping: float; Incoherent pumping coefficient.; default: 0.0. collective_emission: float; Collective (superradiant) emmission coefficient.; default: 0.0. collective_pumping: float; Collective pumping coefficient.; default: 0.0. collective_dephasing: float; Collective dephasing coefficient.; default: 0.0. Returns; -------; c_ops: list; The list of collapse operators as `qutip.Qobj` for the system.; """"""; N = int(N). if N > 10:; msg = ""N > 10. dim(H) = 2^N. ""; msg += ""Better use `piqs.lindbladian` to reduce Hilbert space ""; msg += ""dimension and exploit permutational symmetry.""; raise Warning(msg). [sx, sy, sz] = spin_algebra(N); sp, sm = spin_algebra(N, ""+""), spin_algebra(N, ""-""); [jx, jy, jz] = jspin(N, basis=""uncoupled""); jp, jm = (; jspin(N, ""+"", basis=""uncoupled""),; jspin(N, ""-"", basis=""uncoupled""),; ). c_ops = []. if emission != 0:; for i in range(0, N):; c_ops.append(np.sqrt(emission) * sm[i]). if dephasing != 0:; for i in range(0, N):; c_ops.append(np.sqrt(dephasing) * sz[i]). if pumping != 0:; for i in range(0, N):; c_ops.append(np.sqrt(pumping) * sp[i]). if collective_emission != 0:; c_ops.append(np.sqrt(collective_emission) * jm). if collective_dephasing != 0:; c_ops.append(np.sqrt(collective_dephasing) * jz). if collective_pumping != 0:; c_ops.append(np.sqrt(collective_pumping) * jp). return c_ops. # State definitions in the Dicke basis with an option for basis transformation; [docs]def dicke_basis(N, jmm1=None):; r""""""; Initialize the density matrix of a Dicke state for several (j, m, m1). This funct",MatchSource.WIKI,docs/4.6/modules/qutip/piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/piqs.html
https://qutip.org/docs/4.6/modules/qutip/piqs.html:2652,Integrability,integrat,integrate,2652,", PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""Permutational Invariant Quantum Solver (PIQS). This module calculates the Liouvillian for the dynamics of ensembles of; identical two-level systems (TLS) in the presence of local and collective; processes by exploiting permutational symmetry and using the Dicke basis.; It also allows to characterize nonlinear functions of the density matrix.; """""". # Authors: Nathan Shammah, Shahnawaz Ahmed; # Contact: nathan.shammah@gmail.com, shahnawaz.ahmed95@gmail.com. from math import factorial; from decimal import Decimal. import numpy as np; from scipy.integrate import odeint; from scipy.linalg import eigvalsh; from scipy.special import entr; from scipy.sparse import dok_matrix, block_diag, lil_matrix; from qutip.solver import Options, Result; from qutip import (; Qobj,; spre,; spost,; tensor,; identity,; ket2dm,; ); from qutip import sigmax, sigmay, sigmaz, sigmap, sigmam; from qutip.cy.piqs import Dicke as _Dicke; from qutip.cy.piqs import (; jmm1_dictionary,; _num_dicke_states,; _num_dicke_ladders,; get_blocks,; j_min,; j_vals,; ). __all__ = [; ""num_dicke_states"",; ""num_dicke_ladders"",; ""num_tls"",; ""isdiagonal"",; ""dicke_blocks"",; ""dicke_blocks_full"",; ""dicke_function_trace"",; ""purity_dicke"",; ""entropy_vn_dicke"",; ""Dicke"",; ""state_degeneracy"",; ""m_degeneracy"",; ""energy_degeneracy"",; ""ap"",; ""am"",; ""spin_algebra"",; ""jspin"",; ""collapse_uncoupled"",; ""dicke_basis"",; ""dicke"",; ""excited"",; ""superradiant"",; ""css"",; ""ghz"",; ""ground"",; ""identity_uncoupled"",; ""block_matrix"",; ""tau_column"",; ""Pim"",; ]. def _ensure_int(x):; """"""; Ensure that a floating-point valu",MatchSource.WIKI,docs/4.6/modules/qutip/piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/piqs.html
https://qutip.org/docs/4.6/modules/qutip/piqs.html:5013,Integrability,depend,depending,5013,"tems. Returns; -------; nds: int; The number of Dicke states.; """"""; return _num_dicke_states(N). [docs]def num_dicke_ladders(N):; """"""Calculate the total number of ladders in the Dicke space. For a collection of N two-level systems it counts how many different; ""j"" exist or the number of blocks in the block-diagonal matrix. Parameters; ----------; N: int; The number of two-level systems. Returns; -------; Nj: int; The number of Dicke ladders.; """"""; return _num_dicke_ladders(N). [docs]def num_tls(nds):; """"""Calculate the number of two-level systems. Parameters; ----------; nds: int; The number of Dicke states. Returns; -------; N: int; The number of two-level systems.; """"""; if np.sqrt(nds).is_integer():; # N is even; N = 2 * (np.sqrt(nds) - 1); else:; # N is odd; N = 2 * (np.sqrt(nds + 1 / 4) - 1); return int(N). [docs]def isdiagonal(mat):; """"""; Check if the input matrix is diagonal. Parameters; ==========; mat: ndarray/Qobj; A 2D numpy array. Returns; =======; diag: bool; True/False depending on whether the input matrix is diagonal.; """"""; if isinstance(mat, Qobj):; mat = mat.full(). return np.all(mat == np.diag(np.diagonal(mat))). # nonlinear functions of the density matrix; [docs]def dicke_blocks(rho):; """"""Create the list of blocks for block-diagonal density matrix in the Dicke basis. Parameters; ----------; rho : :class:`qutip.Qobj`; A 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns; -------; square_blocks: list of np.array; Give back the blocks list. """"""; shape_dimension = rho.shape[0]; N = num_tls(shape_dimension); ladders = num_dicke_ladders(N); # create a list with the sizes of the blocks, in order; blocks_dimensions = int(N / 2 + 1 - 0.5 * (N % 2)); blocks_list = [; (2 * (i + 1 * (N % 2)) + 1 * ((N + 1) % 2)); for i in range(blocks_dimensions); ]; blocks_list = np.flip(blocks_list, 0); # create a list with each block matrix as element; square_blocks = []; block_position = 0; f",MatchSource.WIKI,docs/4.6/modules/qutip/piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/piqs.html
https://qutip.org/docs/4.6/modules/qutip/piqs.html:13909,Integrability,integrat,integrate,13909,"tip.Qobj`.; """"""; cythonized_dicke = _Dicke(; int(self.N),; float(self.emission),; float(self.dephasing),; float(self.pumping),; float(self.collective_emission),; float(self.collective_dephasing),; float(self.collective_pumping),; ); return cythonized_dicke.lindbladian(). [docs] def liouvillian(self):; """"""Build the total Liouvillian using the Dicke basis. Returns; -------; liouv : :class:`qutip.Qobj`; The Liouvillian matrix for the system.; """"""; lindblad = self.lindbladian(); if self.hamiltonian is None:; liouv = lindblad. else:; hamiltonian = self.hamiltonian; hamiltonian_superoperator = -1j * spre(hamiltonian) + 1j * spost(; hamiltonian; ); liouv = lindblad + hamiltonian_superoperator; return liouv. [docs] def pisolve(self, initial_state, tlist, options=None):; """"""; Solve for diagonal Hamiltonians and initial states faster. Parameters; ==========; initial_state : :class:`qutip.Qobj`; An initial state specified as a density matrix of; `qutip.Qbj` type. tlist: ndarray; A 1D numpy array of list of timesteps to integrate. options : :class:`qutip.solver.Options`; The options for the solver. Returns; =======; result: list; A dictionary of the type `qutip.solver.Result` which holds the; results of the evolution.; """"""; if isdiagonal(initial_state) == False:; msg = ""`pisolve` requires a diagonal initial density matrix. ""; msg += ""In general construct the Liouvillian using ""; msg += ""`piqs.liouvillian` and use qutip.mesolve.""; raise ValueError(msg). if self.hamiltonian and isdiagonal(self.hamiltonian) == False:; msg = ""`pisolve` should only be used for diagonal Hamiltonians. ""; msg += ""Construct the Liouvillian using `piqs.liouvillian` and""; msg += "" use `qutip.mesolve`.""; raise ValueError(msg). if initial_state.full().shape != self.dshape:; msg = ""Initial density matrix should be diagonal.""; raise ValueError(msg). pim = Pim(; self.N,; self.emission,; self.dephasing,; self.pumping,; self.collective_emission,; self.collective_pumping,; self.collective_dephasing,; ); result = ",MatchSource.WIKI,docs/4.6/modules/qutip/piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/piqs.html
https://qutip.org/docs/4.6/modules/qutip/piqs.html:38382,Modifiability,evolve,evolves,38382,"ariant matrix; # ============================================================================; [docs]def tau_column(tau, k, j):; """"""; Determine the column index for the non-zero elements of the matrix for a; particular row `k` and the value of `j` from the Dicke space. Parameters; ----------; tau: str; The tau function to check for this `k` and `j`. k: int; The row of the matrix M for which the non zero elements have; to be calculated. j: float; The value of `j` for this row.; """"""; # In the notes, we indexed from k = 1, here we do it from k = 0; k = k + 1; mapping = {; ""tau3"": k - (2 * j + 3),; ""tau2"": k - 1,; ""tau4"": k + (2 * j - 1),; ""tau5"": k - (2 * j + 2),; ""tau1"": k,; ""tau6"": k + (2 * j),; ""tau7"": k - (2 * j + 1),; ""tau8"": k + 1,; ""tau9"": k + (2 * j + 1),; }; # we need to decrement k again as indexing is from 0; return int(mapping[tau] - 1). [docs]class Pim(object):; """"""; The Permutation Invariant Matrix class. Initialize the class with the parameters for generating a Permutation; Invariant matrix which evolves a given diagonal initial state `p` as:. dp/dt = Mp. Parameters; ----------; N: int; The number of two-level systems. emission: float; Incoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: float; Local dephasing coefficient.; default: 0.0. pumping: float; Incoherent pumping coefficient.; default: 0.0. collective_emission: float; Collective (superradiant) emmission coefficient.; default: 0.0. collective_pumping: float; Collective pumping coefficient.; default: 0.0. collective_dephasing: float; Collective dephasing coefficient.; default: 0.0. Attributes; ----------; N: int; The number of two-level systems. emission: float; Incoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: float; Local dephasing coefficient.; default: 0.0. pumping: float; Incoherent pumping coefficient.; default: 0.0. collective_emission: float; Collective (superradiant) emmission coefficient.; default: 0.0. collective_d",MatchSource.WIKI,docs/4.6/modules/qutip/piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/piqs.html
https://qutip.org/docs/4.6/modules/qutip/piqs.html:42977,Usability,simpl,simple,42977,"ulate_j_m(self, dicke_row, dicke_col):; """"""; Get the value of j and m for the particular Dicke space element. Parameters; ----------; dicke_row, dicke_col: int; The row and column from the Dicke space matrix. Returns; -------; j, m: float; The j and m values.; """"""; N = self.N; j = N / 2 - dicke_col; m = N / 2 - dicke_row; return (j, m). [docs] def calculate_k(self, dicke_row, dicke_col):; """"""; Get k value from the current row and column element in the Dicke space. Parameters; ----------; dicke_row, dicke_col: int; The row and column from the Dicke space matrix.; Returns; -------; k: int; The row index for the matrix M for given Dicke space; element.; """"""; N = self.N; if dicke_row == 0:; k = dicke_col; else:; k = int(; ((dicke_col) / 2) * (2 * (N + 1) - 2 * (dicke_col - 1)); + (dicke_row - (dicke_col)); ); return k. [docs] def coefficient_matrix(self):; """"""; Generate the matrix M governing the dynamics for diagonal cases. If the initial density matrix and the Hamiltonian is diagonal, the; evolution of the system is given by the simple ODE: dp/dt = Mp.; """"""; N = self.N; nds = num_dicke_states(N); rows = self.N + 1; cols = 0. sparse_M = lil_matrix((nds, nds), dtype=float); if (self.N % 2) == 0:; cols = int(self.N / 2 + 1); else:; cols = int(self.N / 2 + 1 / 2); for (dicke_row, dicke_col) in np.ndindex(rows, cols):; if self.isdicke(dicke_row, dicke_col):; k = int(self.calculate_k(dicke_row, dicke_col)); row = {}; taus = self.tau_valid(dicke_row, dicke_col); for tau in taus:; j, m = self.calculate_j_m(dicke_row, dicke_col); current_col = tau_column(tau, k, j); sparse_M[k, int(current_col)] = taus[tau]; return sparse_M.tocsr(). [docs] def solve(self, rho0, tlist, options=None):; """"""; Solve the ODE for the evolution of diagonal states and Hamiltonians.; """"""; if options is None:; options = Options(); output = Result(); output.solver = ""pisolve""; output.times = tlist; output.states = []; output.states.append(Qobj(rho0)); rhs_generate = lambda y, tt, M: M.dot(y); rho0_flat = ",MatchSource.WIKI,docs/4.6/modules/qutip/piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/piqs.html
https://qutip.org/docs/4.6/modules/qutip/propagator.html:8115,Deployability,update,update,8115,"s_bar, num_cpus=num_cpus). u = np.zeros([N, N, len(tlist)], dtype=complex); for n in range(N):; for k, t in enumerate(tlist):; u[:, n, k] = mat2vec(output[n].states[k].full()).T; else:; rho0 = qeye(H0.dims[0]); output = mesolve(; H, rho0, tlist, args=args, options=options,; _safe_mode=False); return output.states[-1] if len(tlist) == 2 else output.states. else:; # calculate the propagator for the vector representation of the; # density matrix (a superoperator propagator); unitary_mode = 'single'; N = H0.shape[0]; dims = [H0.dims, H0.dims]. u = np.zeros([N * N, N * N, len(tlist)], dtype=complex). if parallel:; output = parallel_map(_parallel_mesolve, range(N * N),; task_args=(; N, H, tlist, c_op_list, args, options),; task_kwargs={""dims"": H0.dims},; progress_bar=progress_bar, num_cpus=num_cpus); for n in range(N * N):; for k, t in enumerate(tlist):; u[:, n, k] = mat2vec(output[n].states[k].full()).T; else:; progress_bar.start(N * N); for n in range(N * N):; progress_bar.update(n); col_idx, row_idx = np.unravel_index(n, (N, N)); rho0 = projection(N, row_idx, col_idx); rho0.dims = H0.dims; output = mesolve(; H, rho0, tlist, c_ops=c_op_list, args=args,; options=options, _safe_mode=False); for k, t in enumerate(tlist):; u[:, n, k] = mat2vec(output.states[k].full()).T; progress_bar.finished(). if len(tlist) == 2:; data = u[-1] if unitary_mode == 'batch' else u[:, :, 1]; return Qobj(data, dims=dims). out = np.empty((len(tlist),), dtype=object); if unitary_mode == 'batch':; out[:] = [Qobj(u[k], dims=dims) for k in range(len(tlist))]; else:; out[:] = [Qobj(u[:, :, k], dims=dims) for k in range(len(tlist))]; return out. def _get_min_and_index(lst):; """"""; Private function for obtaining min and max indicies.; """"""; minval, minidx = lst[0], 0; for i, v in enumerate(lst[1:]):; if v < minval:; minval, minidx = v, i + 1; return minval, minidx. [docs]def propagator_steadystate(U):; """"""Find the steady state for successive applications of the propagator; :math:`U`. Parameters; ---------",MatchSource.WIKI,docs/4.6/modules/qutip/propagator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/propagator.html
https://qutip.org/docs/4.6/modules/qutip/propagator.html:10237,Deployability,update,updated,10237," k, t in enumerate(tlist):; u[:, n, k] = mat2vec(output.states[k].full()).T; progress_bar.finished(). if len(tlist) == 2:; data = u[-1] if unitary_mode == 'batch' else u[:, :, 1]; return Qobj(data, dims=dims). out = np.empty((len(tlist),), dtype=object); if unitary_mode == 'batch':; out[:] = [Qobj(u[k], dims=dims) for k in range(len(tlist))]; else:; out[:] = [Qobj(u[:, :, k], dims=dims) for k in range(len(tlist))]; return out. def _get_min_and_index(lst):; """"""; Private function for obtaining min and max indicies.; """"""; minval, minidx = lst[0], 0; for i, v in enumerate(lst[1:]):; if v < minval:; minval, minidx = v, i + 1; return minval, minidx. [docs]def propagator_steadystate(U):; """"""Find the steady state for successive applications of the propagator; :math:`U`. Parameters; ----------; U : qobj; Operator representing the propagator. Returns; -------; a : qobj; Instance representing the steady-state density matrix. """""". evals, evecs = la.eig(U.full()). shifted_vals = np.abs(evals - 1.0); ev_idx = np.argmin(shifted_vals); ev_min = shifted_vals[ev_idx]; evecs = evecs.T; rho = Qobj(vec2mat(evecs[ev_idx]), dims=U.dims[0]); rho = rho * (1.0 / rho.tr()); rho = 0.5 * (rho + rho.dag()) # make sure rho is herm; rho.isherm = True; return rho. def _parallel_sesolve(n, N, H, tlist, args, options):; psi0 = basis(N, n); output = sesolve(H, psi0, tlist, [], args, options, _safe_mode=False); return output. def _parallel_mesolve(n, N, H, tlist, c_op_list, args, options, dims=None):; col_idx, row_idx = np.unravel_index(n, (N, N)); rho0 = projection(N, row_idx, col_idx); rho0.dims = dims; output = mesolve(; H, rho0, tlist, c_ops=c_op_list, args=args, options=options,; _safe_mode=False); return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/propagator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/propagator.html
https://qutip.org/docs/4.6/modules/qutip/propagator.html:3492,Integrability,depend,dependent,3492,"eroperator import (vec2mat, mat2vec,; vector_to_operator, operator_to_vector); from qutip.sparse import sp_reshape; from qutip.cy.sparse_utils import unit_row_norm; from qutip.mesolve import mesolve; from qutip.sesolve import sesolve; from qutip.states import basis, projection; from qutip.solver import Options, _solver_safety_check, config; from qutip.parallel import parallel_map, _default_kwargs; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. [docs]def propagator(H, t, c_op_list=[], args={}, options=None,; unitary_mode='batch', parallel=False,; progress_bar=None, _safe_mode=True,; **kwargs):; r""""""; Calculate the propagator U(t) for the density matrix or wave function such; that :math:`\psi(t) = U(t)\psi(0)` or; :math:`\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)`; where :math:`\rho_{\mathrm vec}` is the vector representation of the; density matrix. Parameters; ----------; H : qobj or list; Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in :func:`qutip.mesolve`). t : float or array-like; Time or list of times for which to evaluate the propagator. c_op_list : list; List of qobj collapse operators. args : list/array/dictionary; Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the ODE solver. unitary_mode = str ('batch', 'single'); Solve all basis vectors simulaneously ('batch') or individually; ('single'). parallel : bool {False, True}; Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns; -------; a : qobj; Instance representing the propagator :math:`U(t)`. """"",MatchSource.WIKI,docs/4.6/modules/qutip/propagator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/propagator.html
https://qutip.org/docs/4.6/modules/qutip/propagator.html:3767,Integrability,depend,dependent,3767,"_safety_check, config; from qutip.parallel import parallel_map, _default_kwargs; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. [docs]def propagator(H, t, c_op_list=[], args={}, options=None,; unitary_mode='batch', parallel=False,; progress_bar=None, _safe_mode=True,; **kwargs):; r""""""; Calculate the propagator U(t) for the density matrix or wave function such; that :math:`\psi(t) = U(t)\psi(0)` or; :math:`\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)`; where :math:`\rho_{\mathrm vec}` is the vector representation of the; density matrix. Parameters; ----------; H : qobj or list; Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in :func:`qutip.mesolve`). t : float or array-like; Time or list of times for which to evaluate the propagator. c_op_list : list; List of qobj collapse operators. args : list/array/dictionary; Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the ODE solver. unitary_mode = str ('batch', 'single'); Solve all basis vectors simulaneously ('batch') or individually; ('single'). parallel : bool {False, True}; Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns; -------; a : qobj; Instance representing the propagator :math:`U(t)`. """"""; kw = _default_kwargs(); if 'num_cpus' in kwargs:; num_cpus = kwargs['num_cpus']; else:; num_cpus = kw['num_cpus']. if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). if options is None:; options = Options(); options.rhs_reuse = True; rhs_clear()",MatchSource.WIKI,docs/4.6/modules/qutip/propagator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/propagator.html
https://qutip.org/docs/4.6/modules/qutip/propagator.html:2769,Modifiability,config,config,2769,"RRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['propagator', 'propagator_steadystate']. import types; import numpy as np; import scipy.linalg as la; import functools; import scipy.sparse as sp; from qutip.qobj import Qobj; from qutip.tensor import tensor; from qutip.operators import qeye; from qutip.rhs_generate import (rhs_generate, rhs_clear, _td_format_check); from qutip.superoperator import (vec2mat, mat2vec,; vector_to_operator, operator_to_vector); from qutip.sparse import sp_reshape; from qutip.cy.sparse_utils import unit_row_norm; from qutip.mesolve import mesolve; from qutip.sesolve import sesolve; from qutip.states import basis, projection; from qutip.solver import Options, _solver_safety_check, config; from qutip.parallel import parallel_map, _default_kwargs; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. [docs]def propagator(H, t, c_op_list=[], args={}, options=None,; unitary_mode='batch', parallel=False,; progress_bar=None, _safe_mode=True,; **kwargs):; r""""""; Calculate the propagator U(t) for the density matrix or wave function such; that :math:`\psi(t) = U(t)\psi(0)` or; :math:`\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)`; where :math:`\rho_{\mathrm vec}` is the vector representation of the; density matrix. Parameters; ----------; H : qobj or list; Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in :func:`qutip.mesolve`). t : float or array-like; Time or list of times for which to evaluate the propagator. c_op_list : list; List of qobj collapse operators. args : list/array/dictionary; Parameters to callback function",MatchSource.WIKI,docs/4.6/modules/qutip/propagator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/propagator.html
https://qutip.org/docs/4.6/modules/qutip/propagator.html:4280,Usability,progress bar,progress bar,4280,"sity matrix. Parameters; ----------; H : qobj or list; Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in :func:`qutip.mesolve`). t : float or array-like; Time or list of times for which to evaluate the propagator. c_op_list : list; List of qobj collapse operators. args : list/array/dictionary; Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the ODE solver. unitary_mode = str ('batch', 'single'); Solve all basis vectors simulaneously ('batch') or individually; ('single'). parallel : bool {False, True}; Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns; -------; a : qobj; Instance representing the propagator :math:`U(t)`. """"""; kw = _default_kwargs(); if 'num_cpus' in kwargs:; num_cpus = kwargs['num_cpus']; else:; num_cpus = kw['num_cpus']. if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). if options is None:; options = Options(); options.rhs_reuse = True; rhs_clear(). if isinstance(t, (int, float, np.integer, np.floating)):; tlist = [0, t]; else:; tlist = t. if _safe_mode:; _solver_safety_check(H, None, c_ops=c_op_list, e_ops=[], args=args). td_type = _td_format_check(H, c_op_list, solver='me'). if isinstance(H, (types.FunctionType, types.BuiltinFunctionType,; functools.partial)):; H0 = H(0.0, args); if unitary_mode == 'batch':; # batch don't work with function Hamiltonian; unitary_mode = 'single'; elif isinstance(H, list):; H0 = H[0][0] if isinstance(H[0], list) else H[0]; else:; H0 = H. if len(c_op_list) == 0",MatchSource.WIKI,docs/4.6/modules/qutip/propagator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/propagator.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:16040,Availability,mask,mask,16040,"er). def __rsub__(self, other):; """"""; SUBTRACTION with Qobj on RIGHT [ ex. 4-Qobj ]; """"""; return (-self) + other. def __mul__(self, other):; """"""; MULTIPLICATION with Qobj on LEFT [ ex. Qobj*4 ]; """"""; self._isunitary = None. if isinstance(other, Qobj):; if self.dims[1] == other.dims[0]:; out = Qobj(); out.data = self.data * other.data; dims = [self.dims[0], other.dims[1]]; out.dims = dims; if settings.auto_tidyup:; out.tidyup(); if (settings.auto_tidyup_dims; and not isinstance(dims[0][0], list); and not isinstance(dims[1][0], list)):; # If neither left or right is a superoperator,; # we should implicitly partial trace over; # matching dimensions of 1.; # Using izip_longest allows for the left and right dims; # to have uneven length (non-square Qobjs).; # We use None as padding so that it doesn't match anything,; # and will never cause a partial trace on the other side.; mask = [l == r == 1; for l, r in zip_longest(dims[0], dims[1],; fillvalue=None)]; # To ensure that there are still any dimensions left, we; # use max() to add a dimensions list of [1] if all matching; # dims are traced out of that side.; out.dims = [max([1],; [dim for dim, m in zip(dims[0], mask); if not m]),; max([1],; [dim for dim, m in zip(dims[1], mask); if not m])]. else:; out.dims = dims. out._isherm = None. if self.superrep and other.superrep:; if self.superrep != other.superrep:; msg = (""Multiplying superoperators with different "" +; ""representations""); warnings.warn(msg). out.superrep = self.superrep. return out. elif np.prod(self.shape) == 1:; out = Qobj(other); out.data *= self.data[0, 0]; out.superrep = other.superrep; return out.tidyup() if settings.auto_tidyup else out. elif np.prod(other.shape) == 1:; out = Qobj(self); out.data *= other.data[0, 0]; out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. elif self.shape[1] == 1 and other.shape[0] == 1:; out = Qobj(); out.data = self.data * other.data; out.dims = [self.dims[0], other.dims[1]]; return out.tidyu",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:16332,Availability,mask,mask,16332,"4 ]; """"""; self._isunitary = None. if isinstance(other, Qobj):; if self.dims[1] == other.dims[0]:; out = Qobj(); out.data = self.data * other.data; dims = [self.dims[0], other.dims[1]]; out.dims = dims; if settings.auto_tidyup:; out.tidyup(); if (settings.auto_tidyup_dims; and not isinstance(dims[0][0], list); and not isinstance(dims[1][0], list)):; # If neither left or right is a superoperator,; # we should implicitly partial trace over; # matching dimensions of 1.; # Using izip_longest allows for the left and right dims; # to have uneven length (non-square Qobjs).; # We use None as padding so that it doesn't match anything,; # and will never cause a partial trace on the other side.; mask = [l == r == 1; for l, r in zip_longest(dims[0], dims[1],; fillvalue=None)]; # To ensure that there are still any dimensions left, we; # use max() to add a dimensions list of [1] if all matching; # dims are traced out of that side.; out.dims = [max([1],; [dim for dim, m in zip(dims[0], mask); if not m]),; max([1],; [dim for dim, m in zip(dims[1], mask); if not m])]. else:; out.dims = dims. out._isherm = None. if self.superrep and other.superrep:; if self.superrep != other.superrep:; msg = (""Multiplying superoperators with different "" +; ""representations""); warnings.warn(msg). out.superrep = self.superrep. return out. elif np.prod(self.shape) == 1:; out = Qobj(other); out.data *= self.data[0, 0]; out.superrep = other.superrep; return out.tidyup() if settings.auto_tidyup else out. elif np.prod(other.shape) == 1:; out = Qobj(self); out.data *= other.data[0, 0]; out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. elif self.shape[1] == 1 and other.shape[0] == 1:; out = Qobj(); out.data = self.data * other.data; out.dims = [self.dims[0], other.dims[1]]; return out.tidyup() if settings.auto_tidyup else out. else:; raise TypeError(""Incompatible Qobj shapes""). elif isinstance(other, np.ndarray):; if other.dtype == 'object':; out = np.empty(other.shape, dtype=o",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:16394,Availability,mask,mask,16394,"4 ]; """"""; self._isunitary = None. if isinstance(other, Qobj):; if self.dims[1] == other.dims[0]:; out = Qobj(); out.data = self.data * other.data; dims = [self.dims[0], other.dims[1]]; out.dims = dims; if settings.auto_tidyup:; out.tidyup(); if (settings.auto_tidyup_dims; and not isinstance(dims[0][0], list); and not isinstance(dims[1][0], list)):; # If neither left or right is a superoperator,; # we should implicitly partial trace over; # matching dimensions of 1.; # Using izip_longest allows for the left and right dims; # to have uneven length (non-square Qobjs).; # We use None as padding so that it doesn't match anything,; # and will never cause a partial trace on the other side.; mask = [l == r == 1; for l, r in zip_longest(dims[0], dims[1],; fillvalue=None)]; # To ensure that there are still any dimensions left, we; # use max() to add a dimensions list of [1] if all matching; # dims are traced out of that side.; out.dims = [max([1],; [dim for dim, m in zip(dims[0], mask); if not m]),; max([1],; [dim for dim, m in zip(dims[1], mask); if not m])]. else:; out.dims = dims. out._isherm = None. if self.superrep and other.superrep:; if self.superrep != other.superrep:; msg = (""Multiplying superoperators with different "" +; ""representations""); warnings.warn(msg). out.superrep = self.superrep. return out. elif np.prod(self.shape) == 1:; out = Qobj(other); out.data *= self.data[0, 0]; out.superrep = other.superrep; return out.tidyup() if settings.auto_tidyup else out. elif np.prod(other.shape) == 1:; out = Qobj(self); out.data *= other.data[0, 0]; out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. elif self.shape[1] == 1 and other.shape[0] == 1:; out = Qobj(); out.data = self.data * other.data; out.dims = [self.dims[0], other.dims[1]]; return out.tidyup() if settings.auto_tidyup else out. else:; raise TypeError(""Incompatible Qobj shapes""). elif isinstance(other, np.ndarray):; if other.dtype == 'object':; out = np.empty(other.shape, dtype=o",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:21579,Availability,error,errors,21579,"rators and super-operators (square matrices).""). if m is not None:; raise NotImplementedError(""modulo is not implemented for Qobj""). try:; data = self.data ** n; except (TypeError, ValueError):; raise ValueError('Invalid choice of exponent.'); out = Qobj(data, dims=self.dims); out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. def __abs__(self):; return abs(self.data). def __str__(self):; s = """"; t = self.type; shape = self.shape; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; ) + ""\n""); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t + ""\n""); s += ""Qobj data =\n"". if shape[0] > 10000 or shape[1] > 10000:; # if the system is huge, don't attempt to convert to a; # dense matrix and then to string, because it is pointless; # and is likely going to produce memory errors. Instead print the; # sparse data string representation; s += str(self.data). elif all(np.imag(self.data.data) == 0):; s += str(np.real(self.full())). else:; s += str(self.full()). return s. def __repr__(self):; # give complete information on Qobj without print statement in; # command-line we cant realistically serialize a Qobj into a string,; # so we simply return the informal __str__ representation instead.); return self.__str__(). def __call__(self, other):; """"""; Acts this Qobj on another Qobj either by left-multiplication,; or by vectorization and devectorization, as; appropriate.; """"""; if not isinstance(other, Qobj):; raise TypeError(""Only defined for quantum objects.""). if self.type == ""super"":; if other.type == ""ket"":; other = qutip.states.ket2dm(other). if other.type == ""oper"":; return qutip.superoperator.vector_to_operator(; self * qutip.superoperator.operator_to_vector(other",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:27345,Availability,toler,tolerance,27345,"merate_flat(J.dims); J_dual = tensor.tensor_swap(J, *(; list(zip(tensor_idxs[0][1], tensor_idxs[0][0])) +; list(zip(tensor_idxs[1][1], tensor_idxs[1][0])); )).trans(); J_dual.superrep = 'choi'; return J_dual. [docs] def conj(self):; """"""Conjugate operator of quantum object.; """"""; out = Qobj(); out.data = self.data.conj(); out.dims = [self.dims[0], self.dims[1]]; return out. [docs] def norm(self, norm=None, sparse=False, tol=0, maxiter=100000):; """"""Norm of a quantum object. Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the `norm` and; argument. Parameters; ----------; norm : str; Which norm to use for ket/bra vectors: L2 'l2', max norm 'max',; or for operators: trace 'tr', Frobius 'fro', one 'one', or max; 'max'. sparse : bool; Use sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tol : float; Tolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used); for trace norm. Returns; -------; norm : float; The requested norm of the operator or state quantum object. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if self.type in ['oper', 'super']:; if norm is None or norm == 'tr':; _op = self.data * zcsr_adjoint(self.data); vals = sp_eigs(_op, True, vecs=False,; sparse=sparse, tol=tol, maxiter=maxiter); return np.sum(np.sqrt(np.abs(vals))); elif norm == 'fro':; return sp_fro_norm(self.data); elif norm == 'one':; return sp_one_norm(self.data); elif norm == 'max':; return sp_max_norm(self.data); else:; raise ValueError(; ""For matrices, norm must be 'tr', 'fro', 'one', or 'max'.""); else:; if norm is None or norm == 'l2':; return sp_L2_norm(self.data); elif norm == 'max':; return sp_max_norm(self.data); else:; raise ValueError(""For vectors, norm mu",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:30679,Availability,avail,available,30679,"t) or Fortran ordering.; squeeze : bool {False, True}; Squeeze output array. Returns; -------; data : array; Array of complex data from quantum objects `data` attribute.; """"""; if squeeze:; return self.data.toarray(order=order).squeeze(); else:; return self.data.toarray(order=order). def __array__(self, *arg, **kwarg):; """"""Numpy array from Qobj; For compatibility with np.array; """"""; return self.full(). [docs] def diag(self):; """"""Diagonal elements of quantum object. Returns; -------; diags : array; Returns array of ``real`` values if operators is Hermitian,; otherwise ``complex`` values are returned. """"""; out = self.data.diagonal(); if np.any(np.imag(out) > settings.atol) or not self.isherm:; return out; else:; return np.real(out). [docs] def expm(self, method='dense'):; """"""Matrix exponential of quantum operator. Input operator must be square. Parameters; ----------; method : str {'dense', 'sparse'}; Use set method to use to calculate the matrix exponentiation. The; available choices includes 'dense' and 'sparse'. Since the; exponential of a matrix is nearly always dense, method='dense'; is set as default.s. Returns; -------; oper : :class:`qutip.Qobj`; Exponentiated quantum operator. Raises; ------; TypeError; Quantum operator is not square. """"""; if self.dims[0][0] != self.dims[1][0]:; raise TypeError('Invalid operand for matrix exponential'). if method == 'dense':; F = sp_expm(self.data, sparse=False). elif method == 'sparse':; F = sp_expm(self.data, sparse=True). else:; raise ValueError(""method must be 'dense' or 'sparse'.""). out = Qobj(F, dims=self.dims); return out.tidyup() if settings.auto_tidyup else out. [docs] def check_herm(self):; """"""Check if the quantum object is hermitian. Returns; -------; isherm : bool; Returns the new value of isherm property.; """"""; self._isherm = None; return self.isherm. [docs] def sqrtm(self, sparse=False, tol=0, maxiter=100000):; """"""Sqrt of a quantum operator. Operator must be square. Parameters; ----------; sparse : bool; Use spar",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:36176,Availability,toler,tolerance,36176,"rder in the output. Returns; -------; oper : :class:`qutip.Qobj`; Quantum object representing partial trace with selected components; remaining. Notes; -----; This function is identical to the :func:`qutip.qobj.ptrace` function; that has been deprecated. """"""; if sparse is None:; if self.isket:; sparse = False; elif (self.data.nnz / (self.shape[0] * self.shape[1])) >= 0.1:; sparse = False; if sparse:; q = Qobj(); q.data, q.dims, _ = _ptrace(self, sel); return q.tidyup() if settings.auto_tidyup else q; else:; return _ptrace_dense(self, sel). [docs] def permute(self, order):; """"""Permutes a composite quantum object. Parameters; ----------; order : list/array; List specifying new tensor order. Returns; -------; P : :class:`qutip.Qobj`; Permuted quantum object. """"""; q = Qobj(); q.data, q.dims = _permute(self, order); q.data.sort_indices(); return q. [docs] def tidyup(self, atol=settings.auto_tidyup_atol):; """"""Removes small elements from the quantum object. Parameters; ----------; atol : float; Absolute tolerance used by tidyup. Default is set; via qutip global settings parameters. Returns; -------; oper : :class:`qutip.Qobj`; Quantum object with small elements removed. """"""; if self.data.nnz:; # This does the tidyup and returns True if; # The sparse data needs to be shortened; if use_openmp() and self.data.nnz > 500:; if omp_tidyup(self.data.data, atol, self.data.nnz,; settings.num_cpus):; self.data.eliminate_zeros(); else:; if cy_tidyup(self.data.data, atol, self.data.nnz):; self.data.eliminate_zeros(); return self; else:; return self. [docs] def transform(self, inpt, inverse=False, sparse=True):; """"""Basis transform defined by input array. Input array can be a ``matrix`` defining the transformation,; or a ``list`` of kets that defines the new basis. Parameters; ----------; inpt : array_like; A ``matrix`` or ``list`` of kets defining the transformation.; inverse : bool; Whether to return inverse transformation.; sparse : bool; Use sparse matrices when possible. Can be slowe",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:43228,Availability,toler,tolerance,43228,"qutip.states.ket2dm(self).dag() * other).tr(); else:; err = ""Can only calculate overlap for state vector Qobjs""; raise TypeError(err). elif self.isoper:; if other.isket or other.isbra:; return (self.dag() * qutip.states.ket2dm(other)).tr(); elif other.isoper:; return (self.dag() * other).tr(); else:; err = ""Can only calculate overlap for state vector Qobjs""; raise TypeError(err); raise TypeError(""Can only calculate overlap for state vector Qobjs""). [docs] def eigenstates(self, sparse=False, sort='low', eigvals=0,; tol=0, maxiter=100000, phase_fix=None):; """"""Eigenstates and eigenenergies. Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues (and vectors) 'low' to high, or 'high' to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). phase_fix : int, None; If not None, set the phase of each kets so that ket[phase_fix,0]; is real positive. Returns; -------; eigvals : array; Array of eigenvalues for operator. eigvecs : array; Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; evals, evecs = sp_eigs(self.data, self.isherm, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol,; maxiter=maxiter); if self.type == 'super':; new_dims = [self.dims[0], [1]]; new_type = 'operator-ket'; else:; new_dims = [self.dims[0], [1] * len(self.dims[0])]; new_type = 'ket'; ekets = np.empty((len(evecs),), dtype=object); ekets[:] = [Qobj(vec, dims=new_dims, type=new_type) for vec in evecs]; norms = np.array([ket.norm() for ket",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:44979,Availability,toler,tolerance,44979," = 'operator-ket'; else:; new_dims = [self.dims[0], [1] * len(self.dims[0])]; new_type = 'ket'; ekets = np.empty((len(evecs),), dtype=object); ekets[:] = [Qobj(vec, dims=new_dims, type=new_type) for vec in evecs]; norms = np.array([ket.norm() for ket in ekets]); if phase_fix is None:; phase = np.array([1] * len(ekets)); else:; phase = np.array([np.abs(ket[phase_fix, 0]) / ket[phase_fix, 0]; if ket[phase_fix, 0] else 1; for ket in ekets]); return evals, ekets / norms * phase. [docs] def eigenenergies(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort eigenvalues 'low' to high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : ",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:45770,Availability,toler,tolerance,45770," high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`qutip.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; tol = 1e-15 if tol == 0 else tol; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Ret",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:60965,Availability,toler,tolerance,60965,"is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isoperbra else False. [docs]def isoper(Q):; """"""Determines if given quantum object is a operator. Parameters; ----------; Q : :class:`qutip.Qobj`; Quantum object. Returns; -------; isoper : bool; True if Qobj is operator, False otherwise. Examples; --------; >>> a = destroy(5); >>> isoper(a); True. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isoper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isoper else False. [docs]def issuper(Q):; """"""Determines if given quantum object is a super-operator. Parameters; ----------; Q : :class:`qutip.Qobj`; Quantum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. [docs]def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : :class:`qutip.Qobj`; Qobj one; B : :class:`qutip.Qobj`; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. [docs]def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : :class:`qutip.Qobj`; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:22770,Deployability,update,update,22770,"# give complete information on Qobj without print statement in; # command-line we cant realistically serialize a Qobj into a string,; # so we simply return the informal __str__ representation instead.); return self.__str__(). def __call__(self, other):; """"""; Acts this Qobj on another Qobj either by left-multiplication,; or by vectorization and devectorization, as; appropriate.; """"""; if not isinstance(other, Qobj):; raise TypeError(""Only defined for quantum objects.""). if self.type == ""super"":; if other.type == ""ket"":; other = qutip.states.ket2dm(other). if other.type == ""oper"":; return qutip.superoperator.vector_to_operator(; self * qutip.superoperator.operator_to_vector(other); ); else:; raise TypeError(""Can only act super on oper or ket.""). elif self.type == ""oper"":; if other.type == ""ket"":; return self * other; else:; raise TypeError(""Can only act oper on ket.""). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). def _repr_latex_(self):; """"""; Generate a LaTeX representation of the Qobj instance. Can be used for; formatted output in ipython notebook.; """"""; t = self.type; shape = self.shape; s = r''; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; )); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t). M, N = self.data.shape. s += r'\begin{equation*}\left(\begin{array}{*{11}c}'. def _format_float(value):; if value == 0.0:; return ""0.0""; elif abs(value) > 1000.0 or abs(value) < 0.001:; return (""%.3e",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:23001,Deployability,update,update,23001,"self.__str__(). def __call__(self, other):; """"""; Acts this Qobj on another Qobj either by left-multiplication,; or by vectorization and devectorization, as; appropriate.; """"""; if not isinstance(other, Qobj):; raise TypeError(""Only defined for quantum objects.""). if self.type == ""super"":; if other.type == ""ket"":; other = qutip.states.ket2dm(other). if other.type == ""oper"":; return qutip.superoperator.vector_to_operator(; self * qutip.superoperator.operator_to_vector(other); ); else:; raise TypeError(""Can only act super on oper or ket.""). elif self.type == ""oper"":; if other.type == ""ket"":; return self * other; else:; raise TypeError(""Can only act oper on ket.""). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). def _repr_latex_(self):; """"""; Generate a LaTeX representation of the Qobj instance. Can be used for; formatted output in ipython notebook.; """"""; t = self.type; shape = self.shape; s = r''; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; )); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t). M, N = self.data.shape. s += r'\begin{equation*}\left(\begin{array}{*{11}c}'. def _format_float(value):; if value == 0.0:; return ""0.0""; elif abs(value) > 1000.0 or abs(value) < 0.001:; return (""%.3e"" % value).replace(""e"", r""\times10^{"") + ""}""; elif abs(value - int(value)) < 0.001:; return ""%.1f"" % value; else:; return ""%.3f"" % value. def _format_element(m, n, d):; s = "" & "" if n > 0 else """"; if type(d) ==",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:62546,Deployability,update,updated,62546,"f Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. [docs]def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : :class:`qutip.Qobj`; Qobj one; B : :class:`qutip.Qobj`; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. [docs]def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : :class:`qutip.Qobj`; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isherm else False. # TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.; from qutip.eseries import eseries; import qutip.superop_reps as sr; import qutip.tensor as tensor; import qutip.operators as ops; import qutip.metrics as mts; import qutip.states; import qutip.superoperator. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:20333,Energy Efficiency,power,powers,20333,"t.dims = self.dims; if settings.auto_tidyup:; out.tidyup(); if isinstance(other, complex):; out._isherm = out.isherm; else:; out._isherm = self._isherm. out.superrep = self.superrep. return out. else:; raise TypeError(""Incompatible object for division""). def __neg__(self):; """"""; NEGATION operation.; """"""; out = Qobj(); out.data = -self.data; out.dims = self.dims; out.superrep = self.superrep; if settings.auto_tidyup:; out.tidyup(); out._isherm = self._isherm; out._isunitary = self._isunitary; return out. def __getitem__(self, ind):; """"""; GET qobj elements.; """"""; out = self.data[ind]; if sp.issparse(out):; return out.toarray(); else:; return out. def __eq__(self, other):; """"""; EQUALITY operator.; """"""; if (isinstance(other, Qobj) and; self.dims == other.dims and; not np.any(np.abs((self.data - other.data).data) >; settings.atol)):; return True; else:; return False. def __ne__(self, other):; """"""; INEQUALITY operator.; """"""; return not (self == other). def __pow__(self, n, m=None): # calculates powers of Qobj; """"""; POWER operation.; """"""; if self.shape[0] != self.shape[1]:; raise Exception(""Raising a qobj to some power works only for "" +; ""operators and super-operators (square matrices).""). if m is not None:; raise NotImplementedError(""modulo is not implemented for Qobj""). try:; data = self.data ** n; except (TypeError, ValueError):; raise ValueError('Invalid choice of exponent.'); out = Qobj(data, dims=self.dims); out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. def __abs__(self):; return abs(self.data). def __str__(self):; s = """"; t = self.type; shape = self.shape; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; ) + ""\n""); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape)",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:20453,Energy Efficiency,power,power,20453," = self._isherm. out.superrep = self.superrep. return out. else:; raise TypeError(""Incompatible object for division""). def __neg__(self):; """"""; NEGATION operation.; """"""; out = Qobj(); out.data = -self.data; out.dims = self.dims; out.superrep = self.superrep; if settings.auto_tidyup:; out.tidyup(); out._isherm = self._isherm; out._isunitary = self._isunitary; return out. def __getitem__(self, ind):; """"""; GET qobj elements.; """"""; out = self.data[ind]; if sp.issparse(out):; return out.toarray(); else:; return out. def __eq__(self, other):; """"""; EQUALITY operator.; """"""; if (isinstance(other, Qobj) and; self.dims == other.dims and; not np.any(np.abs((self.data - other.data).data) >; settings.atol)):; return True; else:; return False. def __ne__(self, other):; """"""; INEQUALITY operator.; """"""; return not (self == other). def __pow__(self, n, m=None): # calculates powers of Qobj; """"""; POWER operation.; """"""; if self.shape[0] != self.shape[1]:; raise Exception(""Raising a qobj to some power works only for "" +; ""operators and super-operators (square matrices).""). if m is not None:; raise NotImplementedError(""modulo is not implemented for Qobj""). try:; data = self.data ** n; except (TypeError, ValueError):; raise ValueError('Invalid choice of exponent.'); out = Qobj(data, dims=self.dims); out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. def __abs__(self):; return abs(self.data). def __str__(self):; s = """"; t = self.type; shape = self.shape; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; ) + ""\n""); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t + ""\n""); s += ""Qobj data =\n"". if shape[0] > 10000 or shape[1] > 10000:; # if the system is huge, don't attempt to ",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:40391,Energy Efficiency,efficient,efficient,40391,"; eigvals = eigvals[idx_nonzero]; eigstates = eigstates[idx_nonzero]. if method == 'clip':; eigvals[eigvals < 0] = 0; elif method == 'sgs':; eigvals = eigvals[::-1]; eigstates = eigstates[::-1]. acc = 0.0; dim = self.shape[0]; n_eigs = len(eigvals). for idx in reversed(range(n_eigs)):; if eigvals[idx] + acc / (idx + 1) >= 0:; break; else:; acc += eigvals[idx]; eigvals[idx] = 0.0. eigvals[:idx+1] += acc / (idx + 1). return sum([; val * qutip.states.ket2dm(state); for val, state in zip(eigvals, eigstates); ], Qobj(np.zeros(self.shape), dims=self.dims); ).unit(). [docs] def matrix_element(self, bra, ket):; """"""Calculates a matrix element. Gives the matrix element for the quantum object sandwiched between a; `bra` and `ket` vector. Parameters; -----------; bra : :class:`qutip.Qobj`; Quantum object of type 'bra' or 'ket'. ket : :class:`qutip.Qobj`; Quantum object of type 'ket'. Returns; -------; elem : complex; Complex valued matrix element. Notes; -----; It is slightly more computationally efficient to use a ket; vector for the 'bra' input.; """"""; if not self.isoper:; raise TypeError(""Can only get matrix elements for an operator.""). else:; if bra.isbra and ket.isket:; return zcsr_mat_elem(self.data, bra.data, ket.data, 1). elif bra.isket and ket.isket:; return zcsr_mat_elem(self.data, bra.data, ket.data, 0); else:; err = ""Can only calculate matrix elements for bra""; err += "" and ket vectors.""; raise TypeError(err). [docs] def overlap(self, other):; """"""Overlap between two state vectors or two operators. Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap; when one of the Qobj is an operator/density matrix. Parameters; -----------; other : :class:`qutip.Qobj`; Quantum object for a state vector of type 'ket', 'bra' or density; matrix. Returns; -------; overlap : complex; Complex valued overlap. Raises; ------; TypeError; Can only calculate overlap between a bra, ket and density matrix; q",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:41473,Energy Efficiency,efficient,efficient,41473,"ix elements for an operator.""). else:; if bra.isbra and ket.isket:; return zcsr_mat_elem(self.data, bra.data, ket.data, 1). elif bra.isket and ket.isket:; return zcsr_mat_elem(self.data, bra.data, ket.data, 0); else:; err = ""Can only calculate matrix elements for bra""; err += "" and ket vectors.""; raise TypeError(err). [docs] def overlap(self, other):; """"""Overlap between two state vectors or two operators. Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap; when one of the Qobj is an operator/density matrix. Parameters; -----------; other : :class:`qutip.Qobj`; Quantum object for a state vector of type 'ket', 'bra' or density; matrix. Returns; -------; overlap : complex; Complex valued overlap. Raises; ------; TypeError; Can only calculate overlap between a bra, ket and density matrix; quantum objects. Notes; -----; Since QuTiP mainly deals with ket vectors, the most efficient inner; product call is the ket-ket version that computes the product; <self|other> with both vectors expressed as kets.; """""". if isinstance(other, Qobj):. if self.isbra:; if other.isket:; return zcsr_inner(self.data, other.data, 1); elif other.isbra:; # Since we deal mainly with ket vectors, the bra-bra combo; # is not common, and not optimized.; return zcsr_inner(self.data, other.dag().data, 1); elif other.isoper:; return (qutip.states.ket2dm(self).dag() * other).tr(); else:; err = ""Can only calculate overlap for state vector Qobjs""; raise TypeError(err). elif self.isket:; if other.isbra:; return zcsr_inner(other.data, self.data, 1); elif other.isket:; return zcsr_inner(self.data, other.data, 0); elif other.isoper:; return (qutip.states.ket2dm(self).dag() * other).tr(); else:; err = ""Can only calculate overlap for state vector Qobjs""; raise TypeError(err). elif self.isoper:; if other.isket or other.isbra:; return (self.dag() * qutip.states.ket2dm(other)).tr(); elif other.isoper:; return (self.dag() * othe",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:52914,Integrability,depend,dependent,52914,"ngs.atol; ); ); else:; return False. @property; def isunitary(self):; if self._isunitary is not None:; # used previously computed value; return self._isunitary. self._isunitary = self.check_isunitary(). return self._isunitary. @isunitary.setter; def isunitary(self, isunitary):; self._isunitary = isunitary. @property; def type(self):; if not self._type:; self._type = type_from_dims(self.dims). return self._type. @property; def shape(self):; if self.data.shape == (1, 1):; return tuple([np.prod(self.dims[0]), np.prod(self.dims[1])]); else:; return tuple(self.data.shape). @property; def isbra(self):; return self.type == 'bra'. @property; def isket(self):; return self.type == 'ket'. @property; def isoperbra(self):; return self.type == 'operator-bra'. @property; def isoperket(self):; return self.type == 'operator-ket'. @property; def isoper(self):; return self.type == 'oper'. @property; def issuper(self):; return self.type == 'super'. [docs] @staticmethod; def evaluate(qobj_list, t, args):; """"""Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : :class:`qutip.Qobj`; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isins",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:53253,Integrability,depend,dependent,53253,"f type(self):; if not self._type:; self._type = type_from_dims(self.dims). return self._type. @property; def shape(self):; if self.data.shape == (1, 1):; return tuple([np.prod(self.dims[0]), np.prod(self.dims[1])]); else:; return tuple(self.data.shape). @property; def isbra(self):; return self.type == 'bra'. @property; def isket(self):; return self.type == 'ket'. @property; def isoperbra(self):; return self.type == 'operator-bra'. @property; def isoperket(self):; return self.type == 'operator-ket'. @property; def isoper(self):; return self.type == 'oper'. @property; def issuper(self):; return self.type == 'super'. [docs] @staticmethod; def evaluate(qobj_list, t, args):; """"""Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : :class:`qutip.Qobj`; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format ",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:53330,Integrability,depend,dependent,53330,"erty; def shape(self):; if self.data.shape == (1, 1):; return tuple([np.prod(self.dims[0]), np.prod(self.dims[1])]); else:; return tuple(self.data.shape). @property; def isbra(self):; return self.type == 'bra'. @property; def isket(self):; return self.type == 'ket'. @property; def isoperbra(self):; return self.type == 'operator-bra'. @property; def isoperket(self):; return self.type == 'operator-ket'. @property; def isoper(self):; return self.type == 'oper'. @property; def issuper(self):; return self.type == 'super'. [docs] @staticmethod; def evaluate(qobj_list, t, args):; """"""Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : :class:`qutip.Qobj`; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # ----------------------------------------",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:53441,Integrability,depend,dependent,53441,".prod(self.dims[1])]); else:; return tuple(self.data.shape). @property; def isbra(self):; return self.type == 'bra'. @property; def isket(self):; return self.type == 'ket'. @property; def isoperbra(self):; return self.type == 'operator-bra'. @property; def isoperket(self):; return self.type == 'operator-ket'. @property; def isoper(self):; return self.type == 'oper'. @property; def issuper(self):; return self.type == 'super'. [docs] @staticmethod; def evaluate(qobj_list, t, args):; """"""Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : :class:`qutip.Qobj`; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum ob",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:54058,Integrability,depend,dependent,54058,"args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : :class:`qutip.Qobj`; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; [docs]def qobj_list_evaluate(qobj_list, t, args):; """"""; Deprecated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:54152,Integrability,depend,dependent,54152,"args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : :class:`qutip.Qobj`; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; [docs]def qobj_list_evaluate(qobj_list, t, args):; """"""; Deprecated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:54242,Integrability,depend,dependent,54242,"args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : :class:`qutip.Qobj`; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; [docs]def qobj_list_evaluate(qobj_list, t, args):; """"""; Deprecated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:54389,Integrability,depend,dependent,54389,"ith parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : :class:`qutip.Qobj`; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; [docs]def qobj_list_evaluate(qobj_list, t, args):; """"""; Deprecated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests used to determine the type of quantum objects, and some; # functions for increased compatibility with quantum optics toolbox.; #; [docs]def dag(A):; """"""Adjont operator (dagger) of a quantum object. Parameters; ----------; A : :class:`qutip.Qobj`; Input quantum object. Returns; -------; oper : :class:`qutip.Qobj`; Adjoint of input operator",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:54488,Integrability,depend,dependent,54488,"ith parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : :class:`qutip.Qobj`; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; [docs]def qobj_list_evaluate(qobj_list, t, args):; """"""; Deprecated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests used to determine the type of quantum objects, and some; # functions for increased compatibility with quantum optics toolbox.; #; [docs]def dag(A):; """"""Adjont operator (dagger) of a quantum object. Parameters; ----------; A : :class:`qutip.Qobj`; Input quantum object. Returns; -------; oper : :class:`qutip.Qobj`; Adjoint of input operator",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:62135,Integrability,depend,dependencies,62135,"f Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. [docs]def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : :class:`qutip.Qobj`; Qobj one; B : :class:`qutip.Qobj`; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. [docs]def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : :class:`qutip.Qobj`; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isherm else False. # TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.; from qutip.eseries import eseries; import qutip.superop_reps as sr; import qutip.tensor as tensor; import qutip.operators as ops; import qutip.metrics as mts; import qutip.states; import qutip.superoperator. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:7434,Performance,perform,performing,7434,"; Dual channel of quantum object representing a CP map.; eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object.; eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object.; expm(); Matrix exponential of quantum object.; full(order='C'); Returns dense array of quantum object `data` attribute.; groundstate(sparse=False, tol=0, maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum; object.; inv(); Return a Qobj corresponding to the matrix inverse of the operator.; matrix_element(bra, ket); Returns the matrix element of operator between `bra` and `ket` vectors.; norm(norm='tr', sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator.; permute(order); Returns composite qobj with indices reordered.; proj(); Computes the projector for a ket or bra vector.; ptrace(sel); Returns quantum object for selected dimensions after performing; partial trace.; sinm(); Sine of quantum object.; sqrtm(); Matrix square root of quantum object.; tidyup(atol=1e-12); Removes small elements from quantum object.; tr(); Trace of quantum object.; trans(); Transpose of quantum object.; transform(inpt, inverse=False); Performs a basis transformation defined by `inpt` matrix.; trunc_neg(method='clip'); Removes negative eigenvalues and returns a new Qobj that is; a valid density operator.; unit(norm='tr', sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. """"""; __array_priority__ = 100 # sets Qobj priority above numpy arrays; # Disable ufuncs from acting directly on Qobj. This is necessary because we; # define __array__.; __array_ufunc__ = None. def __init__(self, inpt=None, dims=None, shape=None,; type=None, isherm=None, copy=True,; fast=False, superrep=None, isunitary=None):; """"""; Qobj constructor.; """"""; self._isherm = isherm; self._type = type; self.superrep = superrep; self._isunitary",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:12144,Performance,cache,cache,12144,"= 'super':; # Type is not super, i.e. dims not explicitly passed, but oper-like; # shape.; if dims is None and self.shape[0] == self.shape[1]:; sub_shape = np.sqrt(self.shape[0]); # check if root of shape is int; if (sub_shape % 1) != 0:; raise Exception('Invalid shape for a super operator.'); else:; sub_shape = int(sub_shape); self.dims = [[[sub_shape], [sub_shape]]]*2. if superrep:; self.superrep = superrep; else:; if self.type == 'super' and self.superrep is None:; self.superrep = 'super'. # While the obvious check would be != that would fail valid; # use cases such as enr_fock and other enr_ functions.; # This does leave open the possibility of data still being; # misused such as Qobj(complex[n**2][1], dims = [[n],[n]]); if (self._data.shape[0] > np.prod(np.hstack(self.dims[0])) or; self._data.shape[1] > np.prod(np.hstack(self.dims[1]))) and \; self.type != 'super':. raise ValueError(f""Qobj has smaller dims {self.dims} "" +; f""than underlying shape {self._data.shape}""). # clear type cache; self._type = None. [docs] def copy(self):; """"""Create identical copy""""""; return Qobj(inpt=self). def get_data(self):; return self._data. # Here we perfrom a check of the csr matrix type during setting of Q.data; def set_data(self, data):; if not isinstance(data, fast_csr_matrix):; raise TypeError('Qobj data must be in fast_csr format.'); else:; self._data = data; data = property(get_data, set_data). def __add__(self, other):; """"""; ADDITION with Qobj on LEFT [ ex. Qobj+4 ]; """"""; self._isunitary = None. if isinstance(other, eseries):; return other.__radd__(self). if not isinstance(other, Qobj):; if isinstance(other, (int, float, complex, np.integer, np.floating,; np.complexfloating, np.ndarray, list, tuple)) \; or sp.issparse(other):; other = Qobj(other); else:; return NotImplemented. if np.prod(other.shape) == 1 and np.prod(self.shape) != 1:; # case for scalar quantum object; dat = other.data[0, 0]; if dat == 0:; return self. out = Qobj(). if self.type in ['oper', 'super']:; out.",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:22896,Performance,load,loading,22896,"tically serialize a Qobj into a string,; # so we simply return the informal __str__ representation instead.); return self.__str__(). def __call__(self, other):; """"""; Acts this Qobj on another Qobj either by left-multiplication,; or by vectorization and devectorization, as; appropriate.; """"""; if not isinstance(other, Qobj):; raise TypeError(""Only defined for quantum objects.""). if self.type == ""super"":; if other.type == ""ket"":; other = qutip.states.ket2dm(other). if other.type == ""oper"":; return qutip.superoperator.vector_to_operator(; self * qutip.superoperator.operator_to_vector(other); ); else:; raise TypeError(""Can only act super on oper or ket.""). elif self.type == ""oper"":; if other.type == ""ket"":; return self * other; else:; raise TypeError(""Can only act oper on ket.""). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). def _repr_latex_(self):; """"""; Generate a LaTeX representation of the Qobj instance. Can be used for; formatted output in ipython notebook.; """"""; t = self.type; shape = self.shape; s = r''; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; )); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t). M, N = self.data.shape. s += r'\begin{equation*}\left(\begin{array}{*{11}c}'. def _format_float(value):; if value == 0.0:; return ""0.0""; elif abs(value) > 1000.0 or abs(value) < 0.001:; return (""%.3e"" % value).replace(""e"", r""\times10^{"") + ""}""; elif abs(value - int(value)) < 0.001:; return ""%",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:27415,Performance,perform,performed,27415,"tensor_idxs[0][0])) +; list(zip(tensor_idxs[1][1], tensor_idxs[1][0])); )).trans(); J_dual.superrep = 'choi'; return J_dual. [docs] def conj(self):; """"""Conjugate operator of quantum object.; """"""; out = Qobj(); out.data = self.data.conj(); out.dims = [self.dims[0], self.dims[1]]; return out. [docs] def norm(self, norm=None, sparse=False, tol=0, maxiter=100000):; """"""Norm of a quantum object. Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the `norm` and; argument. Parameters; ----------; norm : str; Which norm to use for ket/bra vectors: L2 'l2', max norm 'max',; or for operators: trace 'tr', Frobius 'fro', one 'one', or max; 'max'. sparse : bool; Use sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tol : float; Tolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used); for trace norm. Returns; -------; norm : float; The requested norm of the operator or state quantum object. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if self.type in ['oper', 'super']:; if norm is None or norm == 'tr':; _op = self.data * zcsr_adjoint(self.data); vals = sp_eigs(_op, True, vecs=False,; sparse=sparse, tol=tol, maxiter=maxiter); return np.sum(np.sqrt(np.abs(vals))); elif norm == 'fro':; return sp_fro_norm(self.data); elif norm == 'one':; return sp_one_norm(self.data); elif norm == 'max':; return sp_max_norm(self.data); else:; raise ValueError(; ""For matrices, norm must be 'tr', 'fro', 'one', or 'max'.""); else:; if norm is None or norm == 'l2':; return sp_L2_norm(self.data); elif norm == 'max':; return sp_max_norm(self.data); else:; raise ValueError(""For vectors, norm must be 'l2', or 'max'.""). [docs] def proj(self):; """"""Form the projector from a given",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:34419,Performance,perform,performed,34419,"e:; raise TypeError('Invalid operand for matrix square root'). [docs] def inv(self, sparse=False):; """"""Matrix inverse of a quantum operator. Operator must be square. Returns; -------; oper : :class:`qutip.Qobj`; Matrix inverse of operator. Raises; ------; TypeError; Quantum object is not square.; """"""; if self.shape[0] != self.shape[1]:; raise TypeError('Invalid operand for matrix inverse'); if sparse:; inv_mat = sp.linalg.inv(sp.csc_matrix(self.data)); else:; inv_mat = np.linalg.inv(self.full()); return Qobj(inv_mat, dims=self.dims[::-1]). [docs] def unit(self, inplace=False,; norm=None, sparse=False,; tol=0, maxiter=100000):; """"""Operator or state normalized to unity. Uses norm from Qobj.norm(). Parameters; ----------; inplace : bool; Do an in-place normalization; norm : str; Requested norm for states / operators.; sparse : bool; Use sparse eigensolver for trace norm. Does not affect other norms.; tol : float; Tolerance used by sparse eigensolver.; maxiter : int; Number of maximum iterations performed by sparse eigensolver. Returns; -------; oper : :class:`qutip.Qobj`; Normalized quantum object if not in-place,; else None. """"""; if inplace:; nrm = self.norm(norm=norm, sparse=sparse,; tol=tol, maxiter=maxiter). self.data /= nrm; elif not inplace:; out = self / self.norm(norm=norm, sparse=sparse,; tol=tol, maxiter=maxiter); if settings.auto_tidyup:; return out.tidyup(); else:; return out; else:; raise Exception('inplace kwarg must be bool.'). [docs] def ptrace(self, sel, sparse=None):; """"""Partial trace of the quantum object. Parameters; ----------; sel : int/list; An ``int`` or ``list`` of components to keep after partial trace.; The order is unimportant; no transposition will be done and the; spaces will remain in the same order in the output. Returns; -------; oper : :class:`qutip.Qobj`; Quantum object representing partial trace with selected components; remaining. Notes; -----; This function is identical to the :func:`qutip.qobj.ptrace` function; that has been depre",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:41820,Performance,optimiz,optimized,41820,"+= "" and ket vectors.""; raise TypeError(err). [docs] def overlap(self, other):; """"""Overlap between two state vectors or two operators. Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap; when one of the Qobj is an operator/density matrix. Parameters; -----------; other : :class:`qutip.Qobj`; Quantum object for a state vector of type 'ket', 'bra' or density; matrix. Returns; -------; overlap : complex; Complex valued overlap. Raises; ------; TypeError; Can only calculate overlap between a bra, ket and density matrix; quantum objects. Notes; -----; Since QuTiP mainly deals with ket vectors, the most efficient inner; product call is the ket-ket version that computes the product; <self|other> with both vectors expressed as kets.; """""". if isinstance(other, Qobj):. if self.isbra:; if other.isket:; return zcsr_inner(self.data, other.data, 1); elif other.isbra:; # Since we deal mainly with ket vectors, the bra-bra combo; # is not common, and not optimized.; return zcsr_inner(self.data, other.dag().data, 1); elif other.isoper:; return (qutip.states.ket2dm(self).dag() * other).tr(); else:; err = ""Can only calculate overlap for state vector Qobjs""; raise TypeError(err). elif self.isket:; if other.isbra:; return zcsr_inner(other.data, self.data, 1); elif other.isket:; return zcsr_inner(self.data, other.data, 0); elif other.isoper:; return (qutip.states.ket2dm(self).dag() * other).tr(); else:; err = ""Can only calculate overlap for state vector Qobjs""; raise TypeError(err). elif self.isoper:; if other.isket or other.isbra:; return (self.dag() * qutip.states.ket2dm(other)).tr(); elif other.isoper:; return (self.dag() * other).tr(); else:; err = ""Can only calculate overlap for state vector Qobjs""; raise TypeError(err); raise TypeError(""Can only calculate overlap for state vector Qobjs""). [docs] def eigenstates(self, sparse=False, sort='low', eigvals=0,; tol=0, maxiter=100000, phase_fix=None):; ",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:43298,Performance,perform,performed,43298,"ate overlap for state vector Qobjs""; raise TypeError(err). elif self.isoper:; if other.isket or other.isbra:; return (self.dag() * qutip.states.ket2dm(other)).tr(); elif other.isoper:; return (self.dag() * other).tr(); else:; err = ""Can only calculate overlap for state vector Qobjs""; raise TypeError(err); raise TypeError(""Can only calculate overlap for state vector Qobjs""). [docs] def eigenstates(self, sparse=False, sort='low', eigvals=0,; tol=0, maxiter=100000, phase_fix=None):; """"""Eigenstates and eigenenergies. Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues (and vectors) 'low' to high, or 'high' to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). phase_fix : int, None; If not None, set the phase of each kets so that ket[phase_fix,0]; is real positive. Returns; -------; eigvals : array; Array of eigenvalues for operator. eigvecs : array; Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; evals, evecs = sp_eigs(self.data, self.isherm, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol,; maxiter=maxiter); if self.type == 'super':; new_dims = [self.dims[0], [1]]; new_type = 'operator-ket'; else:; new_dims = [self.dims[0], [1] * len(self.dims[0])]; new_type = 'ket'; ekets = np.empty((len(evecs),), dtype=object); ekets[:] = [Qobj(vec, dims=new_dims, type=new_type) for vec in evecs]; norms = np.array([ket.norm() for ket in ekets]); if phase_fix is None:; phase = np.array([1] * len(ekets)); els",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:45050,Performance,perform,performed,45050,"; new_type = 'ket'; ekets = np.empty((len(evecs),), dtype=object); ekets[:] = [Qobj(vec, dims=new_dims, type=new_type) for vec in evecs]; norms = np.array([ket.norm() for ket in ekets]); if phase_fix is None:; phase = np.array([1] * len(ekets)); else:; phase = np.array([np.abs(ket[phase_fix, 0]) / ket[phase_fix, 0]; if ket[phase_fix, 0] else 1; for ket in ekets]); return evals, ekets / norms * phase. [docs] def eigenenergies(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort eigenvalues 'low' to high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:45841,Performance,perform,performed,45841,"fault is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`qutip.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; tol = 1e-15 if tol == 0 else tol; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : :class:`qutip.Qobj`; Transpose of input operator. """""";",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:49345,Performance,cache,cached,49345,"normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns; -------; q : :class:`qutip.Qobj`; A new instance of :class:`qutip.Qobj` that contains only the states; corresponding to indices that are **not** in `state_inds`. Notes; -----; Experimental. """"""; keep_indices = np.array([s not in states_inds; for s in range(self.shape[0])]).nonzero()[0]. return self.extract_states(keep_indices, normalize=normalize). [docs] def dnorm(self, B=None):; """"""Calculates the diamond norm, or the diamond distance to another; operator. Parameters; ----------; B : :class:`qutip.Qobj` or None; If B is not None, the diamond distance d(A, B) = dnorm(A - B); between this operator and B is returned instead of the diamond; norm. Returns; -------; d : float; Either the diamond norm of this operator, or the diamond distance; from this operator to B. """"""; return mts.dnorm(self, B). @property; def ishp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = sr.to_choi(self); return J.isherm; except TypeError:; return False; else:; return False. @property; def iscp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = (; self; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.superrep in ('choi', 'chi'); else sr.to_choi(self); ); # If J isn't hermitian, then that could indicate either; # that J is not normal, or is normal,; # but has complex eigenvalues.; # In either case, it makes no sense to then demand that the; # eigenvalues be non-negative.; if not J.isherm:; return False; eigs = J.eigenenergies(); return all(eigs >= -settings.atol); except TypeError:; return False; else:; return False. @property; def istp(self):; import qutip.superop_reps as sr; if self.type in [""super"", ""oper""]:",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:49570,Performance,cache,cached,49570,"hat contains only the states; corresponding to indices that are **not** in `state_inds`. Notes; -----; Experimental. """"""; keep_indices = np.array([s not in states_inds; for s in range(self.shape[0])]).nonzero()[0]. return self.extract_states(keep_indices, normalize=normalize). [docs] def dnorm(self, B=None):; """"""Calculates the diamond norm, or the diamond distance to another; operator. Parameters; ----------; B : :class:`qutip.Qobj` or None; If B is not None, the diamond distance d(A, B) = dnorm(A - B); between this operator and B is returned instead of the diamond; norm. Returns; -------; d : float; Either the diamond norm of this operator, or the diamond distance; from this operator to B. """"""; return mts.dnorm(self, B). @property; def ishp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = sr.to_choi(self); return J.isherm; except TypeError:; return False; else:; return False. @property; def iscp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = (; self; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.superrep in ('choi', 'chi'); else sr.to_choi(self); ); # If J isn't hermitian, then that could indicate either; # that J is not normal, or is normal,; # but has complex eigenvalues.; # In either case, it makes no sense to then demand that the; # eigenvalues be non-negative.; if not J.isherm:; return False; eigs = J.eigenenergies(); return all(eigs >= -settings.atol); except TypeError:; return False; else:; return False. @property; def istp(self):; import qutip.superop_reps as sr; if self.type in [""super"", ""oper""]:; try:; # Normalize to a super of type choi or chi.; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.type == ""super"" a",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:45478,Safety,safe,safe,45478,"s(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort eigenvalues 'low' to high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`qutip.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; tol = 1e-15 if tol == 0 else tol; if (grndval[1]-grndval[0]) <= 10*tol:",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:45880,Safety,safe,safe,45880,"er (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`qutip.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; tol = 1e-15 if tol == 0 else tol; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : :class:`qutip.Qobj`; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dim",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:46247,Safety,safe,safe,46247,"mand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`qutip.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; tol = 1e-15 if tol == 0 else tol; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : :class:`qutip.Qobj`; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dims[1], self.dims[0]]; return out. [docs] def extract_states(self, states_inds, normalize=False):; """"""Qobj with states in state_inds only. Parameters; ----------; states_inds : list of integer; The states that should be kept. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matr",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:46395,Safety,safe,safe,46395,"roundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`qutip.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; tol = 1e-15 if tol == 0 else tol; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : :class:`qutip.Qobj`; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dims[1], self.dims[0]]; return out. [docs] def extract_states(self, states_inds, normalize=False):; """"""Qobj with states in state_inds only. Parameters; ----------; states_inds : list of integer; The states that should be kept. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:62120,Safety,avoid,avoid,62120,"f Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. [docs]def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : :class:`qutip.Qobj`; Qobj one; B : :class:`qutip.Qobj`; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. [docs]def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : :class:`qutip.Qobj`; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isherm else False. # TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.; from qutip.eseries import eseries; import qutip.superop_reps as sr; import qutip.tensor as tensor; import qutip.operators as ops; import qutip.metrics as mts; import qutip.states; import qutip.superoperator. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:2734,Testability,log,log,2734," OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""The Quantum Object (Qobj) class, for representing quantum states and; operators, and related functions.; """""". __all__ = ['Qobj', 'qobj_list_evaluate', 'ptrace', 'dag', 'isequal',; 'issuper', 'isoper', 'isoperket', 'isoperbra', 'isket', 'isbra',; 'isherm', 'shape', 'dims']. import warnings; import types; import numbers. try:; import builtins; except ImportError:; import __builtin__ as builtins. # import math functions from numpy.math: required for td string evaluation; from numpy import (arccos, arccosh, arcsin, arcsinh, arctan, arctan2, arctanh,; ceil, copysign, cos, cosh, degrees, e, exp, expm1, fabs,; floor, fmod, frexp, hypot, isinf, isnan, ldexp, log, log10,; log1p, modf, pi, radians, sin, sinh, sqrt, tan, tanh). import numpy as np; import scipy.sparse as sp; import qutip.settings as settings; from qutip import __version__; from qutip.fastsparse import fast_csr_matrix, fast_identity; from qutip.cy.ptrace import _ptrace; from qutip.permute import _permute; from qutip.sparse import (; sp_eigs, sp_expm, sp_fro_norm, sp_max_norm, sp_one_norm, sp_L2_norm,; ); from qutip.dimensions import (; type_from_dims, enumerate_flat, collapse_dims_super,; ); from qutip.cy.spmath import (; zcsr_transpose, zcsr_adjoint, zcsr_isherm, zcsr_trace, zcsr_proj,; zcsr_inner,; ); from qutip.cy.spmatfuncs import zcsr_mat_elem; from qutip.cy.sparse_utils import cy_tidyup; import sys; if sys.version_info.major >= 3:; from itertools import zip_longest; elif sys.version_info.major < 3:; from itertools import izip_longest; zip_longest = izip_longest. # OPENMP stuff; from qutip.cy.o",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:49670,Testability,test,test,49670,"t in states_inds; for s in range(self.shape[0])]).nonzero()[0]. return self.extract_states(keep_indices, normalize=normalize). [docs] def dnorm(self, B=None):; """"""Calculates the diamond norm, or the diamond distance to another; operator. Parameters; ----------; B : :class:`qutip.Qobj` or None; If B is not None, the diamond distance d(A, B) = dnorm(A - B); between this operator and B is returned instead of the diamond; norm. Returns; -------; d : float; Either the diamond norm of this operator, or the diamond distance; from this operator to B. """"""; return mts.dnorm(self, B). @property; def ishp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = sr.to_choi(self); return J.isherm; except TypeError:; return False; else:; return False. @property; def iscp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = (; self; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.superrep in ('choi', 'chi'); else sr.to_choi(self); ); # If J isn't hermitian, then that could indicate either; # that J is not normal, or is normal,; # but has complex eigenvalues.; # In either case, it makes no sense to then demand that the; # eigenvalues be non-negative.; if not J.isherm:; return False; eigs = J.eigenenergies(); return all(eigs >= -settings.atol); except TypeError:; return False; else:; return False. @property; def istp(self):; import qutip.superop_reps as sr; if self.type in [""super"", ""oper""]:; try:; # Normalize to a super of type choi or chi.; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.type == ""super"" and self.superrep in ('choi', 'chi'):; qobj = self; else:; qobj = sr.to_choi(self). # Possibly collapse dims.; if any(; len(index) > 1; for super_index",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:50397,Testability,test,test,50397,"m; except TypeError:; return False; else:; return False. @property; def iscp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = (; self; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.superrep in ('choi', 'chi'); else sr.to_choi(self); ); # If J isn't hermitian, then that could indicate either; # that J is not normal, or is normal,; # but has complex eigenvalues.; # In either case, it makes no sense to then demand that the; # eigenvalues be non-negative.; if not J.isherm:; return False; eigs = J.eigenenergies(); return all(eigs >= -settings.atol); except TypeError:; return False; else:; return False. @property; def istp(self):; import qutip.superop_reps as sr; if self.type in [""super"", ""oper""]:; try:; # Normalize to a super of type choi or chi.; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.type == ""super"" and self.superrep in ('choi', 'chi'):; qobj = self; else:; qobj = sr.to_choi(self). # Possibly collapse dims.; if any(; len(index) > 1; for super_index in qobj.dims for index in super_index; ):; qobj = Qobj(qobj, dims=collapse_dims_super(qobj.dims)); else:; qobj = qobj. # We use the condition from John Watrous' lecture notes,; # Tr_1(J(Phi)) = identity_2.; tr_oper = qobj.ptrace([0]); ident = ops.identity(tr_oper.shape[0]); return isequal(tr_oper, ident); except TypeError:; return False; else:; return False. @property; def iscptp(self):; from qutip.superop_reps import to_choi; if self.type == ""super"" or self.type == ""oper"":; reps = ('choi', 'chi'); q_oper = to_choi(self) if self.superrep not in reps else self; return q_oper.iscp and q_oper.istp; else:; return False. @property; def isherm(self):; if self._isherm is not None:; # used previously computed value; return self._isherm. self._ishe",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:54569,Testability,test,test,54569,"sinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; [docs]def qobj_list_evaluate(qobj_list, t, args):; """"""; Deprecated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests used to determine the type of quantum objects, and some; # functions for increased compatibility with quantum optics toolbox.; #; [docs]def dag(A):; """"""Adjont operator (dagger) of a quantum object. Parameters; ----------; A : :class:`qutip.Qobj`; Input quantum object. Returns; -------; oper : :class:`qutip.Qobj`; Adjoint of input operator. Notes; -----; This function is for legacy compatibility only. It is recommended to use; the ``dag()`` Qobj method. """"""; if not isinstance(A, Qobj):; raise TypeError(""Input is not a quantum object""). return A",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:55044,Testability,test,tests,55044,"dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; [docs]def qobj_list_evaluate(qobj_list, t, args):; """"""; Deprecated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests used to determine the type of quantum objects, and some; # functions for increased compatibility with quantum optics toolbox.; #; [docs]def dag(A):; """"""Adjont operator (dagger) of a quantum object. Parameters; ----------; A : :class:`qutip.Qobj`; Input quantum object. Returns; -------; oper : :class:`qutip.Qobj`; Adjoint of input operator. Notes; -----; This function is for legacy compatibility only. It is recommended to use; the ``dag()`` Qobj method. """"""; if not isinstance(A, Qobj):; raise TypeError(""Input is not a quantum object""). return A.dag(). [docs]def ptrace(Q, sel):; """"""Partial trace of the Qobj with selected components remaining. Parameters; ----------; Q : :class:`qutip.Qobj`; Composite quantum object.; sel : int/list; An ``int`` or ``list`` of components to keep after partial trace. Returns; -------; oper : :class:`qutip.Qobj`; Quantum object representing partial trace with selected components; remaining. Notes; -----; This function is for legacy compatibility only. It is recommen",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:12133,Usability,clear,clear,12133,"= 'super':; # Type is not super, i.e. dims not explicitly passed, but oper-like; # shape.; if dims is None and self.shape[0] == self.shape[1]:; sub_shape = np.sqrt(self.shape[0]); # check if root of shape is int; if (sub_shape % 1) != 0:; raise Exception('Invalid shape for a super operator.'); else:; sub_shape = int(sub_shape); self.dims = [[[sub_shape], [sub_shape]]]*2. if superrep:; self.superrep = superrep; else:; if self.type == 'super' and self.superrep is None:; self.superrep = 'super'. # While the obvious check would be != that would fail valid; # use cases such as enr_fock and other enr_ functions.; # This does leave open the possibility of data still being; # misused such as Qobj(complex[n**2][1], dims = [[n],[n]]); if (self._data.shape[0] > np.prod(np.hstack(self.dims[0])) or; self._data.shape[1] > np.prod(np.hstack(self.dims[1]))) and \; self.type != 'super':. raise ValueError(f""Qobj has smaller dims {self.dims} "" +; f""than underlying shape {self._data.shape}""). # clear type cache; self._type = None. [docs] def copy(self):; """"""Create identical copy""""""; return Qobj(inpt=self). def get_data(self):; return self._data. # Here we perfrom a check of the csr matrix type during setting of Q.data; def set_data(self, data):; if not isinstance(data, fast_csr_matrix):; raise TypeError('Qobj data must be in fast_csr format.'); else:; self._data = data; data = property(get_data, set_data). def __add__(self, other):; """"""; ADDITION with Qobj on LEFT [ ex. Qobj+4 ]; """"""; self._isunitary = None. if isinstance(other, eseries):; return other.__radd__(self). if not isinstance(other, Qobj):; if isinstance(other, (int, float, complex, np.integer, np.floating,; np.complexfloating, np.ndarray, list, tuple)) \; or sp.issparse(other):; other = Qobj(other); else:; return NotImplemented. if np.prod(other.shape) == 1 and np.prod(self.shape) != 1:; # case for scalar quantum object; dat = other.data[0, 0]; if dat == 0:; return self. out = Qobj(). if self.type in ['oper', 'super']:; out.",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:21940,Usability,simpl,simply,21940," def __str__(self):; s = """"; t = self.type; shape = self.shape; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; ) + ""\n""); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t + ""\n""); s += ""Qobj data =\n"". if shape[0] > 10000 or shape[1] > 10000:; # if the system is huge, don't attempt to convert to a; # dense matrix and then to string, because it is pointless; # and is likely going to produce memory errors. Instead print the; # sparse data string representation; s += str(self.data). elif all(np.imag(self.data.data) == 0):; s += str(np.real(self.full())). else:; s += str(self.full()). return s. def __repr__(self):; # give complete information on Qobj without print statement in; # command-line we cant realistically serialize a Qobj into a string,; # so we simply return the informal __str__ representation instead.); return self.__str__(). def __call__(self, other):; """"""; Acts this Qobj on another Qobj either by left-multiplication,; or by vectorization and devectorization, as; appropriate.; """"""; if not isinstance(other, Qobj):; raise TypeError(""Only defined for quantum objects.""). if self.type == ""super"":; if other.type == ""ket"":; other = qutip.states.ket2dm(other). if other.type == ""oper"":; return qutip.superoperator.vector_to_operator(; self * qutip.superoperator.operator_to_vector(other); ); else:; raise TypeError(""Can only act super on oper or ket.""). elif self.type == ""oper"":; if other.type == ""ket"":; return self * other; else:; raise TypeError(""Can only act oper on ket.""). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happ",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobj.html:38768,Usability,simpl,simply,38768,"lse:; raise TypeError('Invalid operand for basis transformation'). # transform data; if inverse:; if self.isket:; data = (S.conj().T) * self.data; elif self.isbra:; data = self.data.dot(S); else:; if sparse:; data = (S.conj().T) * self.data * S; else:; data = (S.conj().T).dot(self.data.dot(S)); else:; if self.isket:; data = S * self.data; elif self.isbra:; data = self.data.dot(S.conj().T); else:; if sparse:; data = S * self.data * (S.conj().T); else:; data = S.dot(self.data.dot(S.conj().T)). out = Qobj(data, dims=self.dims); out._isherm = self._isherm; out.superrep = self.superrep. if settings.auto_tidyup:; return out.tidyup(); else:; return out. [docs] def trunc_neg(self, method=""clip""):; """"""Truncates negative eigenvalues and renormalizes. Returns a new Qobj by removing the negative eigenvalues; of this instance, then renormalizing to obtain a valid density; operator. Parameters; ----------; method : str; Algorithm to use to remove negative eigenvalues. ""clip""; simply discards negative eigenvalues, then renormalizes.; ""sgs"" uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns; -------; oper : :class:`qutip.Qobj`; A valid density operator. """"""; if not self.isherm:; raise ValueError(""Must be a Hermitian operator to remove negative ""; ""eigenvalues.""). if method not in ('clip', 'sgs'):; raise ValueError(""Method {} not recognized."".format(method)). eigvals, eigstates = self.eigenstates(); if all([eigval >= 0 for eigval in eigvals]):; # All positive, so just renormalize.; return self.unit(); idx_nonzero = eigvals != 0; eigvals = eigvals[idx_nonzero]; eigstates = eigstates[idx_nonzero]. if method == 'clip':; eigvals[eigvals < 0] = 0; elif method == 'sgs':; eigvals = eigvals[::-1]; eigstates = eigstates[::-1]. acc = 0.0; dim = self.shape[0]; n_eigs = len(eigvals). for idx in reversed(range(n_eigs)):; if eigvals[idx] + acc / (idx + 1) >= 0:; break; else:; acc += eigvals[idx]; eigvals[idx] = 0.0. eigvals[:idx+1] +=",MatchSource.WIKI,docs/4.6/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:9586,Availability,avail,available,9586,"r the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; ``args = {""_step_func_coeff"": True}``. Examples of array-format usage are:. .. code-block:: python. tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; ``QobjEvo`` that contains different ``tlist`` values, however. **Passing arguments**. ``args`` is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string. There are some ""magic"" names that can be specified, whose objects will be; overwritten when used within :func:`.sesolve`, :func:`.mesolve` and; :func:`.mcsolve`. This allows access to the solvers' internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. - ``""state""``: the current state as a :class:`~Qobj`; - ``""state_vec""``: the current state as a column-stacked 1D ``np.ndarray``; - ``""state_mat""``: the current state as a 2D ``np.ndarray``; - ``""expect_op_<n>""``: the current expectation value of the element; ``e_ops[n]``, which is an argument to the solvers. Replace ``<n>`` with; an integer literal, e.g. ``""expect_op_0""``. This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; - ``""collapse""``: (:func:`.mcsolve` only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; ``(time: float, which: int)``, where ``time`` is the time this collapse; happened, and ``which`` is an integer indexing the ``c_ops`` argument to; :func:`.mcsolve`. Parameters; ----------; Q_object : list, :class:`~Qobj` or :class:`~QobjEvo`; The time-dependent description of the quantum object. This is of the; same format as the first pa",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:4378,Deployability,update,update,4378,"""sinh"": np.sinh,; ""cosh"": np.cosh,; ""tanh"": np.tanh,; ""asinh"": np.arcsinh,; ""acosh"": np.arccosh,; ""atanh"": np.arctanh,; ""exp"": np.exp,; ""log"": np.log,; ""log10"": np.log10,; ""erf"": scipy.special.erf,; ""zerf"": scipy.special.erf,; ""sqrt"": np.sqrt,; ""real"": np.real,; ""imag"": np.imag,; ""conj"": np.conj,; ""abs"": np.abs,; ""norm"": lambda x: np.abs(x)**2,; ""arg"": np.angle,; ""proj"": proj,; ""np"": np,; ""spe"": scipy.special}. class _file_list:; """"""; Contain temp a list .pyx to clean; """"""; def __init__(self):; self.files = []. def add(self, file_):; self.files += [file_ + "".pyx""]. def clean(self):; to_del = []; for i, file_ in enumerate(self.files):; try:; os.remove(file_); to_del.append(i); except Exception:; if not os.path.isfile(file_):; to_del.append(i). for i in to_del[::-1]:; del self.files[i]. def __del__(self):; self.clean(). coeff_files = _file_list(). class _StrWrapper:; def __init__(self, code):; self.code = ""_out = "" + code. def __call__(self, t, args={}):; env = {""t"": t}; env.update(args); exec(self.code, str_env, env); return env[""_out""]. class _CubicSplineWrapper:; # Using scipy's CubicSpline since Qutip's one; # only accept linearly distributed tlist; def __init__(self, tlist, coeff, args=None):; self.coeff = coeff; self.tlist = tlist; try:; use_step_func = args[""_step_func_coeff""]; except KeyError:; use_step_func = 0; if use_step_func:; self.func = interp1d(; self.tlist, self.coeff, kind=""previous"",; bounds_error=False, fill_value=0.); else:; self.func = CubicSpline(self.tlist, self.coeff). def __call__(self, t, args={}):; return self.func([t])[0]. class _StateAsArgs:; # old with state (f(t, psi, args)) to new (args[""state""] = psi); def __init__(self, coeff_func):; self.coeff_func = coeff_func. def __call__(self, t, args={}):; return self.coeff_func(t, args[""_state_vec""], args). # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%; class StateArgs:; """"""Object to indicate to use the state in args outside solver.; args[key] = StateArgs(type, op); """"""; def __init__(self, type=",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:9482,Deployability,update,updated,9482,"mes of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; ``args = {""_step_func_coeff"": True}``. Examples of array-format usage are:. .. code-block:: python. tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; ``QobjEvo`` that contains different ``tlist`` values, however. **Passing arguments**. ``args`` is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string. There are some ""magic"" names that can be specified, whose objects will be; overwritten when used within :func:`.sesolve`, :func:`.mesolve` and; :func:`.mcsolve`. This allows access to the solvers' internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. - ``""state""``: the current state as a :class:`~Qobj`; - ``""state_vec""``: the current state as a column-stacked 1D ``np.ndarray``; - ``""state_mat""``: the current state as a 2D ``np.ndarray``; - ``""expect_op_<n>""``: the current expectation value of the element; ``e_ops[n]``, which is an argument to the solvers. Replace ``<n>`` with; an integer literal, e.g. ``""expect_op_0""``. This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; - ``""collapse""``: (:func:`.mcsolve` only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; ``(time: float, which: int)``, where ``time`` is the time this collapse; happened, and ``which`` is an integer indexing the ``c_ops`` argument to; :func:`.mcsolve`. Parameters; ----------; Q_object : list, :class:`~",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:19010,Deployability,update,update,19010,"sinstance(self.args[key], StateArgs):; self.dynamics_args += [(key, *self.args[key]())]; self.args[key] = 0. def _check_old_with_state(self):; add_vec = False; for op in self.ops:; if op.type == ""func"":; try:; op.get_coeff(0., self.args); except TypeError as e:; nfunc = _StateAsArgs(self.coeff); op = EvoElement((op.qobj, nfunc, nfunc, ""func"")); add_vec = True; if add_vec:; self.dynamics_args += [(""_state_vec"", ""vec"", None)]. def __del__(self):; for file_ in self.coeff_files:; try:; os.remove(file_); except:; pass. def __call__(self, t, data=False, state=None, args={}):; """"""; Return a single :obj:`~Qobj` at the given time ``t``.; """"""; try:; t = float(t); except Exception as e:; raise TypeError(""Time must be a real scalar."") from e. if state is not None:; self._dynamics_args_update(t, state). if args:; if not isinstance(args, dict):; raise TypeError(""The new args must be in a dict""); old_args = self.args.copy(); old_compiled = self.compiled; self.compiled = False; self.args.update(args); op_t = self.__call__(t, data=data); self.args = old_args; self.compiled = old_compiled; elif self.const:; if data:; op_t = self.cte.data.copy(); else:; op_t = self.cte.copy(); elif self.compiled and self.compiled.split()[0] != ""dense"":; op_t = self.compiled_qobjevo.call(t, data); elif data:; op_t = self.cte.data.copy(); for part in self.ops:; op_t += part.qobj.data * part.get_coeff(t, self.args); else:; op_t = self.cte.copy(); for part in self.ops:; op_t += part.qobj * part.get_coeff(t, self.args). return op_t. def _dynamics_args_update(self, t, state):; if isinstance(state, Qobj):; for name, what, op in self.dynamics_args:; if what == ""vec"":; self.args[name] = state.full().ravel(""F""); elif what == ""mat"":; self.args[name] = state.full(); elif what == ""Qobj"":; self.args[name] = state; elif what == ""expect"":; self.args[name] = op.expect(t, state). elif isinstance(state, np.ndarray) and state.ndim == 1:; s1 = self.cte.shape[1]; for name, what, op in self.dynamics_args:; if what == ""vec"":",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:23003,Deployability,update,update,23003,"inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). [docs] def arguments(self, new_args):; """"""; Update the scoped variables that were passed as ``args`` to new values.; """"""; if not isinstance(new_args, dict):; raise TypeError(""The new args must be in a dict""); # remove dynamics_args that are to be refreshed; self.dynamics_args = [dargs for dargs in self.dynamics_args; if dargs[0] not in new_args]; self.args.update(new_args); self._args_checks(); if self.compiled and self.compiled.split()[2] != ""cte"":; if isinstance(self.coeff_get, StrCoeff):; self.coeff_get.set_args(self.args); self.coeff_get._set_dyn_args(self.dynamics_args); elif isinstance(self.coeff_get, _UnitedFuncCaller):; self.coeff_get.set_args(self.args, self.dynamics_args). def solver_set_args(self, new_args, state, e_ops):; self.dynamics_args = []; self.args.update(new_args); self._args_checks(); for i, dargs in enumerate(self.dynamics_args):; if dargs[1] == ""expect"" and isinstance(dargs[2], int):; self.dynamics_args[i] = (dargs[0], ""expect"",; QobjEvo(e_ops[dargs[2]])); if self.compiled:; self.dynamics_args[i][2].compile(); self._dynamics_args_update(0., state); if self.compiled and self.compiled.split()[2] != ""cte"":; if isinstance(self.coeff_get, StrCoeff):; self.coeff_get.set_args(self.args); self.coeff_get._set_dyn_args(self.dynamics_args); elif isinstance(self.coeff_get, _UnitedFuncCaller):; self.coeff_get.set_args(self.args, self.dyna",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:23423,Deployability,update,update,23423,"ickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). [docs] def arguments(self, new_args):; """"""; Update the scoped variables that were passed as ``args`` to new values.; """"""; if not isinstance(new_args, dict):; raise TypeError(""The new args must be in a dict""); # remove dynamics_args that are to be refreshed; self.dynamics_args = [dargs for dargs in self.dynamics_args; if dargs[0] not in new_args]; self.args.update(new_args); self._args_checks(); if self.compiled and self.compiled.split()[2] != ""cte"":; if isinstance(self.coeff_get, StrCoeff):; self.coeff_get.set_args(self.args); self.coeff_get._set_dyn_args(self.dynamics_args); elif isinstance(self.coeff_get, _UnitedFuncCaller):; self.coeff_get.set_args(self.args, self.dynamics_args). def solver_set_args(self, new_args, state, e_ops):; self.dynamics_args = []; self.args.update(new_args); self._args_checks(); for i, dargs in enumerate(self.dynamics_args):; if dargs[1] == ""expect"" and isinstance(dargs[2], int):; self.dynamics_args[i] = (dargs[0], ""expect"",; QobjEvo(e_ops[dargs[2]])); if self.compiled:; self.dynamics_args[i][2].compile(); self._dynamics_args_update(0., state); if self.compiled and self.compiled.split()[2] != ""cte"":; if isinstance(self.coeff_get, StrCoeff):; self.coeff_get.set_args(self.args); self.coeff_get._set_dyn_args(self.dynamics_args); elif isinstance(self.coeff_get, _UnitedFuncCaller):; self.coeff_get.set_args(self.args, self.dynamics_args). [docs] def to_list(self):; """"""; Return this operator in the list-like form used to initialised it, like; can be passed to :func:`~mesolve`.; """"""; list_qobj = []; if not self.dummy_cte:; list_qobj.append(self.cte); for op in self.ops:; list_qobj.append([op.qobj, op.coeff]); return list_qobj. # Math function; def __add__(self, other):; res = self.copy(); res += other; return res. def __radd__(self, other):;",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:24785,Deployability,update,update,24785," isinstance(self.coeff_get, StrCoeff):; self.coeff_get.set_args(self.args); self.coeff_get._set_dyn_args(self.dynamics_args); elif isinstance(self.coeff_get, _UnitedFuncCaller):; self.coeff_get.set_args(self.args, self.dynamics_args). [docs] def to_list(self):; """"""; Return this operator in the list-like form used to initialised it, like; can be passed to :func:`~mesolve`.; """"""; list_qobj = []; if not self.dummy_cte:; list_qobj.append(self.cte); for op in self.ops:; list_qobj.append([op.qobj, op.coeff]); return list_qobj. # Math function; def __add__(self, other):; res = self.copy(); res += other; return res. def __radd__(self, other):; res = self.copy(); res += other; return res. def __iadd__(self, other):; if isinstance(other, QobjEvo):; self.cte += other.cte; l = len(self.ops); for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)); l += 1; self.args.update(**other.args); self.dynamics_args += other.dynamics_args; self.const = self.const and other.const; self.dummy_cte = self.dummy_cte and other.dummy_cte; if self.type != other.type:; if self.type in [""func"", ""mixed_callable""] or \; other.type in [""func"", ""mixed_callable""]:; self.type = ""mixed_callable""; else:; self.type = ""mixed_compilable""; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None. if self.tlist is None:; self.tlist = other.tlist; else:; if other.tlist is None:; pass; elif len(other.tlist) != len(self.tlist) or \; other.tlist[-1] != self.tlist[-1]:; raise ValueError(""Time lists are not compatible""); else:; self.cte += other; self.dummy_cte = False. self.num_obj = (len(self.ops) if self.dummy_cte else len(self.ops) + 1); self._reset_type(); return self. def __sub__(self, other):; res = self.copy(); res -= other; return res. def __rsub__(self, other):; res = -self.copy(); res += other; return res. def __isub__(self, other):; self += (-other); return self. def",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:26889,Deployability,update,update,26889," self.copy(); if isinstance(other, Qobj):; res.cte = other * res.cte; for op in res.ops:; op.qobj = other * op.qobj; return res; else:; res *= other; return res. def __imul__(self, other):; if isinstance(other, Qobj) or isinstance(other, Number):; self.cte *= other; for op in self.ops:; op.qobj *= other; return self; if isinstance(other, QobjEvo):; if other.const:; self.cte *= other.cte; for op in self.ops:; op.qobj *= other.cte; elif self.const:; cte = self.cte.copy(); self = other.copy(); self.cte = cte * self.cte; for op in self.ops:; op.qobj = cte*op.qobj; else:; cte = self.cte.copy(); self.cte *= other.cte; new_terms = []; old_ops = self.ops; if not other.dummy_cte:; for op in old_ops:; new_terms.append(self._ops_mul_cte(op, other.cte, ""R"")); if not self.dummy_cte:; for op in other.ops:; new_terms.append(self._ops_mul_cte(op, cte, ""L"")). for op_left in old_ops:; for op_right in other.ops:; new_terms.append(self._ops_mul_(op_left,; op_right)); self.ops = new_terms; self.args.update(other.args); self.dynamics_args += other.dynamics_args; self.dummy_cte = self.dummy_cte and other.dummy_cte; self.num_obj = (len(self.ops) if; self.dummy_cte else len(self.ops) + 1); self._reset_type(); return self; return NotImplemented. def __div__(self, other):; if isinstance(other, (int, float, complex,; np.integer, np.floating, np.complexfloating)):; res = self.copy(); res *= other**(-1); return res; return NotImplemented. def __idiv__(self, other):; if isinstance(other, (int, float, complex,; np.integer, np.floating, np.complexfloating)):; self *= other**(-1); return self; return NotImplemented. def __truediv__(self, other):; return self.__div__(other). def __neg__(self):; res = self.copy(); res.cte = -res.cte; for op in res.ops:; op.qobj = -op.qobj; return res. def _ops_mul_(self, opL, opR):; new_f = _Prod(opL.get_coeff, opR.get_coeff); new_op = [opL.qobj*opR.qobj, new_f, None, 0]; if opL.type == opR.type and opL.type == ""string"":; new_op[2] = ""("" + opL.coeff + "") * ("" + opR.coe",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:37807,Deployability,update,update,37807,"coeff)**2; new_op[1] = _CubicSplineWrapper(; self.tlist, new_op[2], args=self.args); elif op.type == ""spline"":; new_op[1] = _Norm2(op.get_coeff); new_op[2] = new_op[1]; new_op[3] = ""func""; self.type = ""mixed_callable""; new_ops.append(EvoElement.make(new_op)); self.ops = new_ops; return self. def _f_conj(self):; self.compiled = """"; new_ops = []; for op in self.ops:; new_op = [op.qobj, None, None, op.type]; if op.type == ""func"":; new_op[1] = _Conj(op.get_coeff); new_op[2] = new_op[1]; elif op.type == ""string"":; new_op[2] = ""conj("" + op.coeff + "")""; new_op[1] = _StrWrapper(new_op[2]); elif op.type == ""array"":; new_op[2] = np.conj(op.coeff); new_op[1] = _CubicSplineWrapper(; self.tlist, new_op[2], args=self.args); elif op.type == ""spline"":; new_op[1] = _Conj(op.get_coeff); new_op[2] = new_op[1]; new_op[3] = ""func""; self.type = ""mixed_callable""; new_ops.append(EvoElement.make(new_op)); self.ops = new_ops; return self. def _shift(self):; self.compiled = """"; self.args.update({""_t0"": 0}); new_ops = []; for op in self.ops:; new_op = [op.qobj, None, None, op.type]; if op.type == ""func"":; new_op[1] = _Shift(op.get_coeff); new_op[2] = new_op[1]; elif op.type == ""string"":; new_op[2] = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", "" "" + op.coeff + "" ""); new_op[1] = _StrWrapper(new_op[2]); elif op.type == ""array"":; new_op[2] = _Shift(op.get_coeff); new_op[1] = new_op[2]; new_op[3] = ""func""; self.type = ""mixed_callable""; elif op.type == ""spline"":; new_op[1] = _Shift(op.get_coeff); new_op[2] = new_op[1]; new_op[3] = ""func""; self.type = ""mixed_callable""; new_ops.append(EvoElement.make(new_op)); self.ops = new_ops; return self. [docs] def expect(self, t, state, herm=False):; """"""; Calculate the expectation value of this operator on the given; (time-independent) state at a particular time. This is more efficient than ``expect(QobjEvo(t), state)``. Parameters; ----------; t : float; The time to evaluate this operator at. state : Qobj or np.ndarray; The state to take the expectat",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:51097,Deployability,update,update,51097," dynamics_args, cte):; self.funclist = funclist; self.args = args; self.dynamics_args = dynamics_args; self.dims = cte.dims; self.shape = cte.shape. def set_args(self, args, dynamics_args):; self.args = args; self.dynamics_args = dynamics_args. def dyn_args(self, t, state, shape):; # 1d array are to F ordered; mat = state.reshape(shape, order=""F""); for name, what, op in self.dynamics_args:; if what == ""vec"":; self.args[name] = state; elif what == ""mat"":; self.args[name] = mat; elif what == ""Qobj"":; if self.shape[1] == shape[1]: # oper; self.args[name] = Qobj(mat, dims=self.dims); elif shape[1] == 1: # ket; self.args[name] = Qobj(mat, dims=[self.dims[1],[1]]); else: # rho; self.args[name] = Qobj(mat, dims=self.dims[1]); elif what == ""expect"":; if shape[1] == op.cte.shape[1]: # same shape as object; self.args[name] = op.mul_mat(t, mat).trace(); else:; self.args[name] = op.expect(t, state). def __call__(self, t, args={}):; if args:; now_args = self.args.copy(); now_args.update(args); else:; now_args = self.args; out = []; for func in self.funclist:; out.append(func(t, now_args)); return out. def get_args(self):; return self.args. class _Norm2():; def __init__(self, f):; self.func = f. def __call__(self, t, args):; return self.func(t, args)*np.conj(self.func(t, args)). class _Shift():; def __init__(self, f):; self.func = f. def __call__(self, t, args):; return np.conj(self.func(t + args[""_t0""], args)). class _Conj():; def __init__(self, f):; self.func = f. def __call__(self, t, args):; return np.conj(self.func(t, args)). class _Prod():; def __init__(self, f, g):; self.func_1 = f; self.func_2 = g. def __call__(self, t, args):; return self.func_1(t, args)*self.func_2(t, args). class _Add():; def __init__(self, fs):; self.funcs = fs. def __call__(self, t, args):; return np.sum([f(t, args) for f in self.funcs]). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, a",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:52139,Deployability,update,updated,52139,"self.shape = cte.shape. def set_args(self, args, dynamics_args):; self.args = args; self.dynamics_args = dynamics_args. def dyn_args(self, t, state, shape):; # 1d array are to F ordered; mat = state.reshape(shape, order=""F""); for name, what, op in self.dynamics_args:; if what == ""vec"":; self.args[name] = state; elif what == ""mat"":; self.args[name] = mat; elif what == ""Qobj"":; if self.shape[1] == shape[1]: # oper; self.args[name] = Qobj(mat, dims=self.dims); elif shape[1] == 1: # ket; self.args[name] = Qobj(mat, dims=[self.dims[1],[1]]); else: # rho; self.args[name] = Qobj(mat, dims=self.dims[1]); elif what == ""expect"":; if shape[1] == op.cte.shape[1]: # same shape as object; self.args[name] = op.mul_mat(t, mat).trace(); else:; self.args[name] = op.expect(t, state). def __call__(self, t, args={}):; if args:; now_args = self.args.copy(); now_args.update(args); else:; now_args = self.args; out = []; for func in self.funclist:; out.append(func(t, now_args)); return out. def get_args(self):; return self.args. class _Norm2():; def __init__(self, f):; self.func = f. def __call__(self, t, args):; return self.func(t, args)*np.conj(self.func(t, args)). class _Shift():; def __init__(self, f):; self.func = f. def __call__(self, t, args):; return np.conj(self.func(t + args[""_t0""], args)). class _Conj():; def __init__(self, f):; self.func = f. def __call__(self, t, args):; return np.conj(self.func(t, args)). class _Prod():; def __init__(self, f, g):; self.func_1 = f; self.func_2 = g. def __call__(self, t, args):; return self.func_1(t, args)*self.func_2(t, args). class _Add():; def __init__(self, fs):; self.funcs = fs. def __call__(self, t, args):; return np.sum([f(t, args) for f in self.funcs]). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:31928,Energy Efficiency,reduce,reduce,31928," ""("" + self.ops[_set[0]].coeff + "")""; for i in _set[1:]:; new_str += "" + ("" + self.ops[i].coeff + "")""; new_op[1] = _StrWrapper(new_str); new_op[2] = new_str; new_ops.append(EvoElement.make(new_op)). elif self.ops[_set[0]].type == ""array"":; new_op = [self.ops[_set[0]].qobj, None, None, ""array""]; new_array = (self.ops[_set[0]].coeff).copy(); for i in _set[1:]:; new_array += self.ops[i].coeff; new_op[2] = new_array; new_op[1] = _CubicSplineWrapper(; self.tlist, new_array, args=self.args); new_ops.append(EvoElement.make(new_op)). self.ops = new_ops. def _compress_merge_func(self, fsets):; new_ops = []; for _set in fsets:; base = self.ops[_set[0]]; new_op = [None, base.get_coeff, base.coeff, base.type]; if len(_set) == 1:; new_op[0] = base.qobj; else:; new_op[0] = base.qobj.copy(); for i in _set[1:]:; new_op[0] += self.ops[i].qobj; new_ops.append(EvoElement.make(new_op)); self.ops = new_ops. [docs] def compress(self):; """"""; Merge together elements that share the same time-dependence, to reduce; the number of matrix multiplications and additions that need to be done; to evaluate this object. Modifies the object inplace.; """"""; self.tidyup(); sets, fsets = self._compress_make_set(); N_sets = len(sets); N_fsets = len(fsets); num_ops = len(self.ops). if N_sets < num_ops and N_fsets < num_ops:; # Both could be better; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; if N_sets < N_fsets:; self._compress_merge_qobj(sets); else:; self._compress_merge_func(fsets); sets, fsets = self._compress_make_set(); N_sets = len(sets); N_fsets = len(fsets); num_ops = len(self.ops). if N_sets < num_ops:; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self._compress_merge_qobj(sets); elif N_fsets < num_ops:; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self._compress_merge_func(fsets); self._reset_type(). def _reset_type(self):; op_type_count = [0, 0, 0, 0]; for op in self.ops:; if op.type == ""func"":; op_type_count[0] ",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:38654,Energy Efficiency,efficient,efficient,38654,"xed_callable""; new_ops.append(EvoElement.make(new_op)); self.ops = new_ops; return self. def _shift(self):; self.compiled = """"; self.args.update({""_t0"": 0}); new_ops = []; for op in self.ops:; new_op = [op.qobj, None, None, op.type]; if op.type == ""func"":; new_op[1] = _Shift(op.get_coeff); new_op[2] = new_op[1]; elif op.type == ""string"":; new_op[2] = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", "" "" + op.coeff + "" ""); new_op[1] = _StrWrapper(new_op[2]); elif op.type == ""array"":; new_op[2] = _Shift(op.get_coeff); new_op[1] = new_op[2]; new_op[3] = ""func""; self.type = ""mixed_callable""; elif op.type == ""spline"":; new_op[1] = _Shift(op.get_coeff); new_op[2] = new_op[1]; new_op[3] = ""func""; self.type = ""mixed_callable""; new_ops.append(EvoElement.make(new_op)); self.ops = new_ops; return self. [docs] def expect(self, t, state, herm=False):; """"""; Calculate the expectation value of this operator on the given; (time-independent) state at a particular time. This is more efficient than ``expect(QobjEvo(t), state)``. Parameters; ----------; t : float; The time to evaluate this operator at. state : Qobj or np.ndarray; The state to take the expectation value around. herm : bool, default False; Whether this operator and the state are both Hermitian. If True,; only the real part of the result will be returned. See Also; --------; expect : General-purpose expectation values.; """"""; if not isinstance(t, (int, float)):; raise TypeError(""Time must be a real scalar""); if isinstance(state, Qobj):; if self.cte.dims[1] == state.dims[0]:; vec = state.full().ravel(""F""); elif self.cte.dims[1] == state.dims:; vec = state.full().ravel(""F""); else:; raise ValueError(""Dimensions do not fit""); elif isinstance(state, np.ndarray):; vec = state.ravel(""F""); else:; raise TypeError(""The vector must be an array or Qobj""). if vec.shape[0] == self.cte.shape[1]:; if self.compiled:; exp = self.compiled_qobjevo.expect(t, vec); elif self.cte.issuper:; self._dynamics_args_update(t, state); exp = cy_expec",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:2089,Integrability,depend,dependent,2089,"names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""Time-dependent Quantum Object (Qobj) class.; """"""; __all__ = ['QobjEvo']. from qutip.qobj import Qobj; import qutip.settings as qset; from qutip.interpolate import Cubic_Spline; from scipy.interpolate import CubicSpline, interp1d; from functools import partial; from types import FunctionType, BuiltinFunctionType; import numpy as np; from numbers import Number; from qutip.qobjevo_codegen import (_compile_str_single, _compiled_coeffs,; _compiled_coeffs_python); from qutip.cy.spmatfuncs import (cy_expect_rho_vec, cy_expect_psi,; spmv); from qutip.cy.cqobjevo import (CQobjCte, CQobjCteDense, CQobjEvoTd,; CQobjEvoTdMatched, CQobjEvoTdDense); from qutip.cy.cqobjevo_factor import (InterCoeffT, InterCoeffCte,; InterpolateCoeff, StrCoeff,; StepCoeffCte, StepCoeffT); import sys; import scipy; import os; from re import sub. if qset.has_openmp:; from qutip.cy.openmp.cqobjevo_omp import (CQobjCteOmp, CQobjEvoTdOmp,; CQobjEvoTdMatchedOmp). safePickle = [False]; if sys.platform ==",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:5549,Integrability,depend,dependent,5549,"f.tlist = tlist; try:; use_step_func = args[""_step_func_coeff""]; except KeyError:; use_step_func = 0; if use_step_func:; self.func = interp1d(; self.tlist, self.coeff, kind=""previous"",; bounds_error=False, fill_value=0.); else:; self.func = CubicSpline(self.tlist, self.coeff). def __call__(self, t, args={}):; return self.func([t])[0]. class _StateAsArgs:; # old with state (f(t, psi, args)) to new (args[""state""] = psi); def __init__(self, coeff_func):; self.coeff_func = coeff_func. def __call__(self, t, args={}):; return self.coeff_func(t, args[""_state_vec""], args). # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%; class StateArgs:; """"""Object to indicate to use the state in args outside solver.; args[key] = StateArgs(type, op); """"""; def __init__(self, type=""Qobj"", op=None):; self.dyn_args = (type, op). def __call__(self):; return self.dyn_args. # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%; # object for each time dependent element of the QobjEvo; # qobj : the Qobj of element ([*Qobj*, f]); # get_coeff : a callable that take (t, args) and return the coeff at that t; # coeff : The coeff as a string, array or function as provided by the user.; # type : flag for the type of coeff; class EvoElement:; """"""; Internal type used to represent the time-dependent parts of a; :class:`~QobjEvo`. Availables ""types"" are. 1. function; 2. string; 3. ``np.ndarray``; 4. :class:`.Cubic_Spline`; """""". def __init__(self, qobj, get_coeff, coeff, type):; self.qobj = qobj; self.get_coeff = get_coeff; self.coeff = coeff; self.type = type. @classmethod; def make(cls, list_):; return cls(*list_). def __getitem__(self, i):; if i == 0:; return self.qobj; if i == 1:; return self.get_coeff; if i == 2:; return self.coeff; if i == 3:; return self.type. [docs]class QobjEvo:; """"""; A class for representing time-dependent quantum objects, such as quantum; operators and states. Basic math operations are defined:. - ``+``, ``-`` : :class:`~QobjEvo`, :class:`~Qobj`, scalars.; - ``*``: :class:`~Qobj`, C number; - ``/",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:5883,Integrability,depend,dependent,5883,"else:; self.func = CubicSpline(self.tlist, self.coeff). def __call__(self, t, args={}):; return self.func([t])[0]. class _StateAsArgs:; # old with state (f(t, psi, args)) to new (args[""state""] = psi); def __init__(self, coeff_func):; self.coeff_func = coeff_func. def __call__(self, t, args={}):; return self.coeff_func(t, args[""_state_vec""], args). # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%; class StateArgs:; """"""Object to indicate to use the state in args outside solver.; args[key] = StateArgs(type, op); """"""; def __init__(self, type=""Qobj"", op=None):; self.dyn_args = (type, op). def __call__(self):; return self.dyn_args. # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%; # object for each time dependent element of the QobjEvo; # qobj : the Qobj of element ([*Qobj*, f]); # get_coeff : a callable that take (t, args) and return the coeff at that t; # coeff : The coeff as a string, array or function as provided by the user.; # type : flag for the type of coeff; class EvoElement:; """"""; Internal type used to represent the time-dependent parts of a; :class:`~QobjEvo`. Availables ""types"" are. 1. function; 2. string; 3. ``np.ndarray``; 4. :class:`.Cubic_Spline`; """""". def __init__(self, qobj, get_coeff, coeff, type):; self.qobj = qobj; self.get_coeff = get_coeff; self.coeff = coeff; self.type = type. @classmethod; def make(cls, list_):; return cls(*list_). def __getitem__(self, i):; if i == 0:; return self.qobj; if i == 1:; return self.get_coeff; if i == 2:; return self.coeff; if i == 3:; return self.type. [docs]class QobjEvo:; """"""; A class for representing time-dependent quantum objects, such as quantum; operators and states. Basic math operations are defined:. - ``+``, ``-`` : :class:`~QobjEvo`, :class:`~Qobj`, scalars.; - ``*``: :class:`~Qobj`, C number; - ``/`` : C number. This object is constructed by passing a list of :obj:`~Qobj` instances,; each of which *may* have an associated scalar time dependence. The list is; summed to produce the final result. In other words, if an ",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:6425,Integrability,depend,dependent,6425,"pe, op). def __call__(self):; return self.dyn_args. # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%; # object for each time dependent element of the QobjEvo; # qobj : the Qobj of element ([*Qobj*, f]); # get_coeff : a callable that take (t, args) and return the coeff at that t; # coeff : The coeff as a string, array or function as provided by the user.; # type : flag for the type of coeff; class EvoElement:; """"""; Internal type used to represent the time-dependent parts of a; :class:`~QobjEvo`. Availables ""types"" are. 1. function; 2. string; 3. ``np.ndarray``; 4. :class:`.Cubic_Spline`; """""". def __init__(self, qobj, get_coeff, coeff, type):; self.qobj = qobj; self.get_coeff = get_coeff; self.coeff = coeff; self.type = type. @classmethod; def make(cls, list_):; return cls(*list_). def __getitem__(self, i):; if i == 0:; return self.qobj; if i == 1:; return self.get_coeff; if i == 2:; return self.coeff; if i == 3:; return self.type. [docs]class QobjEvo:; """"""; A class for representing time-dependent quantum objects, such as quantum; operators and states. Basic math operations are defined:. - ``+``, ``-`` : :class:`~QobjEvo`, :class:`~Qobj`, scalars.; - ``*``: :class:`~Qobj`, C number; - ``/`` : C number. This object is constructed by passing a list of :obj:`~Qobj` instances,; each of which *may* have an associated scalar time dependence. The list is; summed to produce the final result. In other words, if an instance of this; class is :math:`Q(t)`, then it is constructed from a set of constant; :obj:`~Qobj` :math:`\\{Q_k\\}` and time-dependent scalars :math:`f_k(t)` by. .. math::. Q(t) = \\sum_k f_k(t) Q_k. If a scalar :math:`f_k(t)` is not passed with a given :obj:`~Qobj`, then; that term is assumed to be constant. The next section contains more detail; on the allowed forms of the constants, and gives several examples for how; to build instances of this class. **Time-dependence formats**. There are three major formats for specifying a time-dependent scalar:. - Python functio",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:6768,Integrability,depend,dependence,6768," : The coeff as a string, array or function as provided by the user.; # type : flag for the type of coeff; class EvoElement:; """"""; Internal type used to represent the time-dependent parts of a; :class:`~QobjEvo`. Availables ""types"" are. 1. function; 2. string; 3. ``np.ndarray``; 4. :class:`.Cubic_Spline`; """""". def __init__(self, qobj, get_coeff, coeff, type):; self.qobj = qobj; self.get_coeff = get_coeff; self.coeff = coeff; self.type = type. @classmethod; def make(cls, list_):; return cls(*list_). def __getitem__(self, i):; if i == 0:; return self.qobj; if i == 1:; return self.get_coeff; if i == 2:; return self.coeff; if i == 3:; return self.type. [docs]class QobjEvo:; """"""; A class for representing time-dependent quantum objects, such as quantum; operators and states. Basic math operations are defined:. - ``+``, ``-`` : :class:`~QobjEvo`, :class:`~Qobj`, scalars.; - ``*``: :class:`~Qobj`, C number; - ``/`` : C number. This object is constructed by passing a list of :obj:`~Qobj` instances,; each of which *may* have an associated scalar time dependence. The list is; summed to produce the final result. In other words, if an instance of this; class is :math:`Q(t)`, then it is constructed from a set of constant; :obj:`~Qobj` :math:`\\{Q_k\\}` and time-dependent scalars :math:`f_k(t)` by. .. math::. Q(t) = \\sum_k f_k(t) Q_k. If a scalar :math:`f_k(t)` is not passed with a given :obj:`~Qobj`, then; that term is assumed to be constant. The next section contains more detail; on the allowed forms of the constants, and gives several examples for how; to build instances of this class. **Time-dependence formats**. There are three major formats for specifying a time-dependent scalar:. - Python function; - string; - array. For function format, the function signature must be; ``f(t: float, args: dict) -> complex``, for example. .. code-block:: python. def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, ",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:6979,Integrability,depend,dependent,6979,"`. Availables ""types"" are. 1. function; 2. string; 3. ``np.ndarray``; 4. :class:`.Cubic_Spline`; """""". def __init__(self, qobj, get_coeff, coeff, type):; self.qobj = qobj; self.get_coeff = get_coeff; self.coeff = coeff; self.type = type. @classmethod; def make(cls, list_):; return cls(*list_). def __getitem__(self, i):; if i == 0:; return self.qobj; if i == 1:; return self.get_coeff; if i == 2:; return self.coeff; if i == 3:; return self.type. [docs]class QobjEvo:; """"""; A class for representing time-dependent quantum objects, such as quantum; operators and states. Basic math operations are defined:. - ``+``, ``-`` : :class:`~QobjEvo`, :class:`~Qobj`, scalars.; - ``*``: :class:`~Qobj`, C number; - ``/`` : C number. This object is constructed by passing a list of :obj:`~Qobj` instances,; each of which *may* have an associated scalar time dependence. The list is; summed to produce the final result. In other words, if an instance of this; class is :math:`Q(t)`, then it is constructed from a set of constant; :obj:`~Qobj` :math:`\\{Q_k\\}` and time-dependent scalars :math:`f_k(t)` by. .. math::. Q(t) = \\sum_k f_k(t) Q_k. If a scalar :math:`f_k(t)` is not passed with a given :obj:`~Qobj`, then; that term is assumed to be constant. The next section contains more detail; on the allowed forms of the constants, and gives several examples for how; to build instances of this class. **Time-dependence formats**. There are three major formats for specifying a time-dependent scalar:. - Python function; - string; - array. For function format, the function signature must be; ``f(t: float, args: dict) -> complex``, for example. .. code-block:: python. def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. .. code-block::. pi exp log log",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:7320,Integrability,depend,dependence,7320,"self.coeff; if i == 3:; return self.type. [docs]class QobjEvo:; """"""; A class for representing time-dependent quantum objects, such as quantum; operators and states. Basic math operations are defined:. - ``+``, ``-`` : :class:`~QobjEvo`, :class:`~Qobj`, scalars.; - ``*``: :class:`~Qobj`, C number; - ``/`` : C number. This object is constructed by passing a list of :obj:`~Qobj` instances,; each of which *may* have an associated scalar time dependence. The list is; summed to produce the final result. In other words, if an instance of this; class is :math:`Q(t)`, then it is constructed from a set of constant; :obj:`~Qobj` :math:`\\{Q_k\\}` and time-dependent scalars :math:`f_k(t)` by. .. math::. Q(t) = \\sum_k f_k(t) Q_k. If a scalar :math:`f_k(t)` is not passed with a given :obj:`~Qobj`, then; that term is assumed to be constant. The next section contains more detail; on the allowed forms of the constants, and gives several examples for how; to build instances of this class. **Time-dependence formats**. There are three major formats for specifying a time-dependent scalar:. - Python function; - string; - array. For function format, the function signature must be; ``f(t: float, args: dict) -> complex``, for example. .. code-block:: python. def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. .. code-block::. pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:. .. code-block:: python. H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype ``np.float64`` or; ``np.complex128``. A list of times (``np.",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:7394,Integrability,depend,dependent,7394,"ass QobjEvo:; """"""; A class for representing time-dependent quantum objects, such as quantum; operators and states. Basic math operations are defined:. - ``+``, ``-`` : :class:`~QobjEvo`, :class:`~Qobj`, scalars.; - ``*``: :class:`~Qobj`, C number; - ``/`` : C number. This object is constructed by passing a list of :obj:`~Qobj` instances,; each of which *may* have an associated scalar time dependence. The list is; summed to produce the final result. In other words, if an instance of this; class is :math:`Q(t)`, then it is constructed from a set of constant; :obj:`~Qobj` :math:`\\{Q_k\\}` and time-dependent scalars :math:`f_k(t)` by. .. math::. Q(t) = \\sum_k f_k(t) Q_k. If a scalar :math:`f_k(t)` is not passed with a given :obj:`~Qobj`, then; that term is assumed to be constant. The next section contains more detail; on the allowed forms of the constants, and gives several examples for how; to build instances of this class. **Time-dependence formats**. There are three major formats for specifying a time-dependent scalar:. - Python function; - string; - array. For function format, the function signature must be; ``f(t: float, args: dict) -> complex``, for example. .. code-block:: python. def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. .. code-block::. pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:. .. code-block:: python. H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype ``np.float64`` or; ``np.complex128``. A list of times (``np.float64``) at which the; coeffients must be given ",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:10025,Integrability,depend,depending,10025," **Passing arguments**. ``args`` is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string. There are some ""magic"" names that can be specified, whose objects will be; overwritten when used within :func:`.sesolve`, :func:`.mesolve` and; :func:`.mcsolve`. This allows access to the solvers' internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. - ``""state""``: the current state as a :class:`~Qobj`; - ``""state_vec""``: the current state as a column-stacked 1D ``np.ndarray``; - ``""state_mat""``: the current state as a 2D ``np.ndarray``; - ``""expect_op_<n>""``: the current expectation value of the element; ``e_ops[n]``, which is an argument to the solvers. Replace ``<n>`` with; an integer literal, e.g. ``""expect_op_0""``. This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; - ``""collapse""``: (:func:`.mcsolve` only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; ``(time: float, which: int)``, where ``time`` is the time this collapse; happened, and ``which`` is an integer indexing the ``c_ops`` argument to; :func:`.mcsolve`. Parameters; ----------; Q_object : list, :class:`~Qobj` or :class:`~QobjEvo`; The time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of ``[Qobj, time_dependence]`` pairs that are; summed to make the whole object. The ``time_dependence`` can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the ``Qobj`` instead; of the 2-element list. args : dict, optional; Mapping of ``{str: object}``, discussed in greater detail above. The; strings can be",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:10497,Integrability,depend,dependent,10497,"ey are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. - ``""state""``: the current state as a :class:`~Qobj`; - ``""state_vec""``: the current state as a column-stacked 1D ``np.ndarray``; - ``""state_mat""``: the current state as a 2D ``np.ndarray``; - ``""expect_op_<n>""``: the current expectation value of the element; ``e_ops[n]``, which is an argument to the solvers. Replace ``<n>`` with; an integer literal, e.g. ``""expect_op_0""``. This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; - ``""collapse""``: (:func:`.mcsolve` only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; ``(time: float, which: int)``, where ``time`` is the time this collapse; happened, and ``which`` is an integer indexing the ``c_ops`` argument to; :func:`.mcsolve`. Parameters; ----------; Q_object : list, :class:`~Qobj` or :class:`~QobjEvo`; The time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of ``[Qobj, time_dependence]`` pairs that are; summed to make the whole object. The ``time_dependence`` can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the ``Qobj`` instead; of the 2-element list. args : dict, optional; Mapping of ``{str: object}``, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the ""magic""; names used to access solver internals. tlist : array_like, optional; List of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in ``Q_object`` is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween wi",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:10847,Integrability,depend,dependence,10847,"n]``, which is an argument to the solvers. Replace ``<n>`` with; an integer literal, e.g. ``""expect_op_0""``. This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; - ``""collapse""``: (:func:`.mcsolve` only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; ``(time: float, which: int)``, where ``time`` is the time this collapse; happened, and ``which`` is an integer indexing the ``c_ops`` argument to; :func:`.mcsolve`. Parameters; ----------; Q_object : list, :class:`~Qobj` or :class:`~QobjEvo`; The time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of ``[Qobj, time_dependence]`` pairs that are; summed to make the whole object. The ``time_dependence`` can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the ``Qobj`` instead; of the 2-element list. args : dict, optional; Mapping of ``{str: object}``, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the ""magic""; names used to access solver internals. tlist : array_like, optional; List of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in ``Q_object`` is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes; ----------; cte : :class:`~Qobj`; Constant part of the QobjEvo. ops : list of :class:`.EvoElement`; Internal representation of the time-dependence structure of the; elements. args : dict; The current value of the ``args`` dictionary passed into the; constructor. dynamics_args : list; Names of the dynamic arguments that the solvers will generate. These; are the m",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:11339,Integrability,depend,dependences,11339,"an integer indexing the ``c_ops`` argument to; :func:`.mcsolve`. Parameters; ----------; Q_object : list, :class:`~Qobj` or :class:`~QobjEvo`; The time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of ``[Qobj, time_dependence]`` pairs that are; summed to make the whole object. The ``time_dependence`` can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the ``Qobj`` instead; of the 2-element list. args : dict, optional; Mapping of ``{str: object}``, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the ""magic""; names used to access solver internals. tlist : array_like, optional; List of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in ``Q_object`` is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes; ----------; cte : :class:`~Qobj`; Constant part of the QobjEvo. ops : list of :class:`.EvoElement`; Internal representation of the time-dependence structure of the; elements. args : dict; The current value of the ``args`` dictionary passed into the; constructor. dynamics_args : list; Names of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the ``args`` parameter. tlist : array_like; List of times at which the numpy-array coefficients are applied. compiled : str; A string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevo : ``CQobjCte`` or ``CQobjEvoTd``; Cython version of the QobjEvo. coeff_get : callable; Object called to obtain a list of all the coefficients at a particular; time. coeff_files : list; Runtime creat",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:11643,Integrability,depend,dependence,11643,"is a list of ``[Qobj, time_dependence]`` pairs that are; summed to make the whole object. The ``time_dependence`` can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the ``Qobj`` instead; of the 2-element list. args : dict, optional; Mapping of ``{str: object}``, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the ""magic""; names used to access solver internals. tlist : array_like, optional; List of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in ``Q_object`` is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes; ----------; cte : :class:`~Qobj`; Constant part of the QobjEvo. ops : list of :class:`.EvoElement`; Internal representation of the time-dependence structure of the; elements. args : dict; The current value of the ``args`` dictionary passed into the; constructor. dynamics_args : list; Names of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the ``args`` parameter. tlist : array_like; List of times at which the numpy-array coefficients are applied. compiled : str; A string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevo : ``CQobjCte`` or ``CQobjEvoTd``; Cython version of the QobjEvo. coeff_get : callable; Object called to obtain a list of all the coefficients at a particular; time. coeff_files : list; Runtime created files to delete with the instance. dummy_cte : bool; Is self.cte an empty Qobj. const : bool; Indicates if quantum object is constant. type : {""cte"", ""string"", ""func"", ""array"", ""spline"", ""mixed_callable"", \; ""mixed_compilable""}; Information about the type of coefficients used in the entire",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:13767,Integrability,depend,dependent,13767,"le : bool; Flag to not share pointers between thread.; """""". def __init__(self, Q_object=[], args={}, copy=True,; tlist=None, state0=None, e_ops=[]):; if isinstance(Q_object, QobjEvo):; if copy:; self._inplace_copy(Q_object); else:; self.__dict__ = Q_object.__dict__; if args:; self.arguments(args); for i, dargs in enumerate(self.dynamics_args):; e_int = dargs[1] == ""expect"" and isinstance(dargs[2], int); if e_ops and e_int:; self.dynamics_args[i] = (dargs[0], ""expect"",; e_ops[dargs[2]]); if state0 is not None:; self._dynamics_args_update(0., state0); return. self.const = False; self.dummy_cte = False; self.args = args.copy(); self.dynamics_args = []; self.cte = None; self.tlist = np.asarray(tlist) if tlist is not None else None; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.type = ""none""; self.omp = 0; self.coeff_files = []; self.use_cython = use_cython[0]; self.safePickle = safePickle[0]. # Attempt to determine if a 2-element list is a single, time-dependent; # operator, or a list with 2 possibly time-dependent elements.; if isinstance(Q_object, list) and len(Q_object) == 2:; try:; # Test if parsing succeeds on this as a single element.; self._td_op_type(Q_object); Q_object = [Q_object]; except (TypeError, ValueError):; pass. op_type = self._td_format_check(Q_object); self.ops = []. if isinstance(op_type, int):; if op_type == 0:; self.cte = Q_object; self.const = True; self.type = ""cte""; elif op_type == 1:; raise TypeError(""The Qobj must not already be a function""); elif op_type == -1:; pass; else:; op_type_count = [0, 0, 0, 0]; for type_, op in zip(op_type, Q_object):; if type_ == 0:; if self.cte is None:; self.cte = op; else:; self.cte += op; elif type_ == 1:; op_type_count[0] += 1; self.ops.append(EvoElement(op[0], op[1], op[1], ""func"")); elif type_ == 2:; op_type_count[1] += 1; self.ops.append(EvoElement(op[0], _StrWrapper(op[1]),; op[1], ""string"")); elif type_ == 3:; op_type_count[2] += 1; self.ops.append(EvoElement(; op[0],; _Cub",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:13821,Integrability,depend,dependent,13821,"le : bool; Flag to not share pointers between thread.; """""". def __init__(self, Q_object=[], args={}, copy=True,; tlist=None, state0=None, e_ops=[]):; if isinstance(Q_object, QobjEvo):; if copy:; self._inplace_copy(Q_object); else:; self.__dict__ = Q_object.__dict__; if args:; self.arguments(args); for i, dargs in enumerate(self.dynamics_args):; e_int = dargs[1] == ""expect"" and isinstance(dargs[2], int); if e_ops and e_int:; self.dynamics_args[i] = (dargs[0], ""expect"",; e_ops[dargs[2]]); if state0 is not None:; self._dynamics_args_update(0., state0); return. self.const = False; self.dummy_cte = False; self.args = args.copy(); self.dynamics_args = []; self.cte = None; self.tlist = np.asarray(tlist) if tlist is not None else None; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.type = ""none""; self.omp = 0; self.coeff_files = []; self.use_cython = use_cython[0]; self.safePickle = safePickle[0]. # Attempt to determine if a 2-element list is a single, time-dependent; # operator, or a list with 2 possibly time-dependent elements.; if isinstance(Q_object, list) and len(Q_object) == 2:; try:; # Test if parsing succeeds on this as a single element.; self._td_op_type(Q_object); Q_object = [Q_object]; except (TypeError, ValueError):; pass. op_type = self._td_format_check(Q_object); self.ops = []. if isinstance(op_type, int):; if op_type == 0:; self.cte = Q_object; self.const = True; self.type = ""cte""; elif op_type == 1:; raise TypeError(""The Qobj must not already be a function""); elif op_type == -1:; pass; else:; op_type_count = [0, 0, 0, 0]; for type_, op in zip(op_type, Q_object):; if type_ == 0:; if self.cte is None:; self.cte = op; else:; self.cte += op; elif type_ == 1:; op_type_count[0] += 1; self.ops.append(EvoElement(op[0], op[1], op[1], ""func"")); elif type_ == 2:; op_type_count[1] += 1; self.ops.append(EvoElement(op[0], _StrWrapper(op[1]),; op[1], ""string"")); elif type_ == 3:; op_type_count[2] += 1; self.ops.append(EvoElement(; op[0],; _Cub",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:31913,Integrability,depend,dependence,31913," ""("" + self.ops[_set[0]].coeff + "")""; for i in _set[1:]:; new_str += "" + ("" + self.ops[i].coeff + "")""; new_op[1] = _StrWrapper(new_str); new_op[2] = new_str; new_ops.append(EvoElement.make(new_op)). elif self.ops[_set[0]].type == ""array"":; new_op = [self.ops[_set[0]].qobj, None, None, ""array""]; new_array = (self.ops[_set[0]].coeff).copy(); for i in _set[1:]:; new_array += self.ops[i].coeff; new_op[2] = new_array; new_op[1] = _CubicSplineWrapper(; self.tlist, new_array, args=self.args); new_ops.append(EvoElement.make(new_op)). self.ops = new_ops. def _compress_merge_func(self, fsets):; new_ops = []; for _set in fsets:; base = self.ops[_set[0]]; new_op = [None, base.get_coeff, base.coeff, base.type]; if len(_set) == 1:; new_op[0] = base.qobj; else:; new_op[0] = base.qobj.copy(); for i in _set[1:]:; new_op[0] += self.ops[i].qobj; new_ops.append(EvoElement.make(new_op)); self.ops = new_ops. [docs] def compress(self):; """"""; Merge together elements that share the same time-dependence, to reduce; the number of matrix multiplications and additions that need to be done; to evaluate this object. Modifies the object inplace.; """"""; self.tidyup(); sets, fsets = self._compress_make_set(); N_sets = len(sets); N_fsets = len(fsets); num_ops = len(self.ops). if N_sets < num_ops and N_fsets < num_ops:; # Both could be better; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; if N_sets < N_fsets:; self._compress_merge_qobj(sets); else:; self._compress_merge_func(fsets); sets, fsets = self._compress_make_set(); N_sets = len(sets); N_fsets = len(fsets); num_ops = len(self.ops). if N_sets < num_ops:; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self._compress_merge_qobj(sets); elif N_fsets < num_ops:; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self._compress_merge_func(fsets); self._reset_type(). def _reset_type(self):; op_type_count = [0, 0, 0, 0]; for op in self.ops:; if op.type == ""func"":; op_type_count[0] ",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:34019,Integrability,depend,dependent,34019," += 1; elif op.type == ""array"":; op_type_count[2] += 1; elif op.type == ""spline"":; op_type_count[3] += 1. nops = sum(op_type_count); if not self.ops and self.dummy_cte is False:; self.type = ""cte""; elif op_type_count[0] == nops:; self.type = ""func""; elif op_type_count[1] == nops:; self.type = ""string""; elif op_type_count[2] == nops:; self.type = ""array""; elif op_type_count[3] == nops:; self.type = ""spline""; elif op_type_count[0]:; self.type = ""mixed_callable""; else:; self.type = ""mixed_compilable"". self.num_obj = (len(self.ops) if self.dummy_cte else len(self.ops) + 1). [docs] def permute(self, order):; """"""; Permute the tensor structure of the underlying matrices into a new; format. See Also; --------; Qobj.permute : the same operation on constant quantum objects.; """"""; res = self.copy(); res.cte = res.cte.permute(order); for op in res.ops:; op.qobj = op.qobj.permute(order); return res. [docs] def apply(self, function, *args, **kw_args):; """"""; Apply the linear function ``function`` to every ``Qobj`` included in; this time-dependent object, and return a new ``QobjEvo`` with the; result. Any additional arguments or keyword arguments will be appended to every; function call.; """"""; self.compiled = """"; res = self.copy(); cte_res = function(res.cte, *args, **kw_args); if not isinstance(cte_res, Qobj):; raise TypeError(""The function must return a Qobj""); res.cte = cte_res; for op in res.ops:; op.qobj = function(op.qobj, *args, **kw_args); return res. [docs] def apply_decorator(self, function, *args,; str_mod=None, inplace_np=False, **kw_args):; """"""; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result. Any additional arguments and keyword arguments will be appended to the; function calls. Parameters; ----------; function : callable; ``(time_dependence, *args, **kwargs) -> time_dependence``. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arg",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:34589,Integrability,depend,dependent,34589,"cs] def permute(self, order):; """"""; Permute the tensor structure of the underlying matrices into a new; format. See Also; --------; Qobj.permute : the same operation on constant quantum objects.; """"""; res = self.copy(); res.cte = res.cte.permute(order); for op in res.ops:; op.qobj = op.qobj.permute(order); return res. [docs] def apply(self, function, *args, **kw_args):; """"""; Apply the linear function ``function`` to every ``Qobj`` included in; this time-dependent object, and return a new ``QobjEvo`` with the; result. Any additional arguments or keyword arguments will be appended to every; function call.; """"""; self.compiled = """"; res = self.copy(); cte_res = function(res.cte, *args, **kw_args); if not isinstance(cte_res, Qobj):; raise TypeError(""The function must return a Qobj""); res.cte = cte_res; for op in res.ops:; op.qobj = function(op.qobj, *args, **kw_args); return res. [docs] def apply_decorator(self, function, *args,; str_mod=None, inplace_np=False, **kw_args):; """"""; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result. Any additional arguments and keyword arguments will be appended to the; function calls. Parameters; ----------; function : callable; ``(time_dependence, *args, **kwargs) -> time_dependence``. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_mod : list; A 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string ``x`` will; become ``str_mod[0] + x + str_mod[1]``. inplace_np : bool, default False; Whether this function should modify Numpy arrays inplace, or be; used like a regular decorator. Some decorators create incorrect; arrays as some transformations ``f'(t) = f(g(t))`` create a; mismatch between the array and the associated time list.; """"""; res = self.copy(); for op in res.ops:; op.get_coeff = fun",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:34889,Integrability,depend,dependent,34889," function, *args, **kw_args):; """"""; Apply the linear function ``function`` to every ``Qobj`` included in; this time-dependent object, and return a new ``QobjEvo`` with the; result. Any additional arguments or keyword arguments will be appended to every; function call.; """"""; self.compiled = """"; res = self.copy(); cte_res = function(res.cte, *args, **kw_args); if not isinstance(cte_res, Qobj):; raise TypeError(""The function must return a Qobj""); res.cte = cte_res; for op in res.ops:; op.qobj = function(op.qobj, *args, **kw_args); return res. [docs] def apply_decorator(self, function, *args,; str_mod=None, inplace_np=False, **kw_args):; """"""; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result. Any additional arguments and keyword arguments will be appended to the; function calls. Parameters; ----------; function : callable; ``(time_dependence, *args, **kwargs) -> time_dependence``. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_mod : list; A 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string ``x`` will; become ``str_mod[0] + x + str_mod[1]``. inplace_np : bool, default False; Whether this function should modify Numpy arrays inplace, or be; used like a regular decorator. Some decorators create incorrect; arrays as some transformations ``f'(t) = f(g(t))`` create a; mismatch between the array and the associated time list.; """"""; res = self.copy(); for op in res.ops:; op.get_coeff = function(op.get_coeff, *args, **kw_args); if op.type == [""func"", ""spline""]:; op.coeff = op.get_coeff; op.type = ""func""; elif op.type == ""string"":; if str_mod is None:; op.coeff = op.get_coeff; op.type = ""func""; else:; op.coeff = str_mod[0] + op.coeff + str_mod[1]; elif op.type == ""array"":; if inplace_np:; # keep the original function, change t",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:35095,Integrability,wrap,wrap,35095,"esult. Any additional arguments or keyword arguments will be appended to every; function call.; """"""; self.compiled = """"; res = self.copy(); cte_res = function(res.cte, *args, **kw_args); if not isinstance(cte_res, Qobj):; raise TypeError(""The function must return a Qobj""); res.cte = cte_res; for op in res.ops:; op.qobj = function(op.qobj, *args, **kw_args); return res. [docs] def apply_decorator(self, function, *args,; str_mod=None, inplace_np=False, **kw_args):; """"""; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result. Any additional arguments and keyword arguments will be appended to the; function calls. Parameters; ----------; function : callable; ``(time_dependence, *args, **kwargs) -> time_dependence``. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_mod : list; A 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string ``x`` will; become ``str_mod[0] + x + str_mod[1]``. inplace_np : bool, default False; Whether this function should modify Numpy arrays inplace, or be; used like a regular decorator. Some decorators create incorrect; arrays as some transformations ``f'(t) = f(g(t))`` create a; mismatch between the array and the associated time list.; """"""; res = self.copy(); for op in res.ops:; op.get_coeff = function(op.get_coeff, *args, **kw_args); if op.type == [""func"", ""spline""]:; op.coeff = op.get_coeff; op.type = ""func""; elif op.type == ""string"":; if str_mod is None:; op.coeff = op.get_coeff; op.type = ""func""; else:; op.coeff = str_mod[0] + op.coeff + str_mod[1]; elif op.type == ""array"":; if inplace_np:; # keep the original function, change the array; def f(a):; return a; ff = function(f, *args, **kw_args); for i, v in enumerate(op.coeff):; op.coeff[i] = ff(v); op.get_coeff = _CubicSplineWrapper(; self.tlist, op.",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:35117,Integrability,depend,dependences,35117,"esult. Any additional arguments or keyword arguments will be appended to every; function call.; """"""; self.compiled = """"; res = self.copy(); cte_res = function(res.cte, *args, **kw_args); if not isinstance(cte_res, Qobj):; raise TypeError(""The function must return a Qobj""); res.cte = cte_res; for op in res.ops:; op.qobj = function(op.qobj, *args, **kw_args); return res. [docs] def apply_decorator(self, function, *args,; str_mod=None, inplace_np=False, **kw_args):; """"""; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result. Any additional arguments and keyword arguments will be appended to the; function calls. Parameters; ----------; function : callable; ``(time_dependence, *args, **kwargs) -> time_dependence``. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_mod : list; A 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string ``x`` will; become ``str_mod[0] + x + str_mod[1]``. inplace_np : bool, default False; Whether this function should modify Numpy arrays inplace, or be; used like a regular decorator. Some decorators create incorrect; arrays as some transformations ``f'(t) = f(g(t))`` create a; mismatch between the array and the associated time list.; """"""; res = self.copy(); for op in res.ops:; op.get_coeff = function(op.get_coeff, *args, **kw_args); if op.type == [""func"", ""spline""]:; op.coeff = op.get_coeff; op.type = ""func""; elif op.type == ""string"":; if str_mod is None:; op.coeff = op.get_coeff; op.type = ""func""; else:; op.coeff = str_mod[0] + op.coeff + str_mod[1]; elif op.type == ""array"":; if inplace_np:; # keep the original function, change the array; def f(a):; return a; ff = function(f, *args, **kw_args); for i, v in enumerate(op.coeff):; op.coeff[i] = ff(v); op.get_coeff = _CubicSplineWrapper(; self.tlist, op.",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:35147,Integrability,depend,dependence,35147," """"""; self.compiled = """"; res = self.copy(); cte_res = function(res.cte, *args, **kw_args); if not isinstance(cte_res, Qobj):; raise TypeError(""The function must return a Qobj""); res.cte = cte_res; for op in res.ops:; op.qobj = function(op.qobj, *args, **kw_args); return res. [docs] def apply_decorator(self, function, *args,; str_mod=None, inplace_np=False, **kw_args):; """"""; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result. Any additional arguments and keyword arguments will be appended to the; function calls. Parameters; ----------; function : callable; ``(time_dependence, *args, **kwargs) -> time_dependence``. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_mod : list; A 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string ``x`` will; become ``str_mod[0] + x + str_mod[1]``. inplace_np : bool, default False; Whether this function should modify Numpy arrays inplace, or be; used like a regular decorator. Some decorators create incorrect; arrays as some transformations ``f'(t) = f(g(t))`` create a; mismatch between the array and the associated time list.; """"""; res = self.copy(); for op in res.ops:; op.get_coeff = function(op.get_coeff, *args, **kw_args); if op.type == [""func"", ""spline""]:; op.coeff = op.get_coeff; op.type = ""func""; elif op.type == ""string"":; if str_mod is None:; op.coeff = op.get_coeff; op.type = ""func""; else:; op.coeff = str_mod[0] + op.coeff + str_mod[1]; elif op.type == ""array"":; if inplace_np:; # keep the original function, change the array; def f(a):; return a; ff = function(f, *args, **kw_args); for i, v in enumerate(op.coeff):; op.coeff[i] = ff(v); op.get_coeff = _CubicSplineWrapper(; self.tlist, op.coeff, args=self.args); else:; op.coeff = op.get_coeff; op.type = ""func""; if self.type == ""stri",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:48430,Integrability,depend,dependence,48430,"s. coeff_files.clean(); if code:; return Code. def _get_coeff(self, t):; out = []; for part in self.ops:; out.append(part.get_coeff(t, self.args)); return out. def __getstate__(self):; _dict_ = {key: self.__dict__[key]; for key in self.__dict__ if key != ""compiled_qobjevo""}; if self.compiled:; return (_dict_, self.compiled_qobjevo.__getstate__()); else:; return (_dict_,). def __setstate__(self, state):; self.__dict__ = state[0]; self.compiled_qobjevo = None; if self.compiled:; mat_type, threading, td = self.compiled.split(); if mat_type == ""csr"":; if self.safePickle:; # __getstate__ and __setstate__ of compiled_qobjevo pass pointers; # In 'safe' mod, these pointers are not used.; if td == ""cte"":; if threading == ""single"":; self.compiled_qobjevo = CQobjCte(); self.compiled_qobjevo.set_data(self.cte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteOmp(); self.compiled_qobjevo.set_data(self.cte); self.compiled_qobjevo.set_threads(self.omp); else:; # time dependence is pyfunc or cyfactor; if threading == ""single"":; self.compiled_qobjevo = CQobjEvoTd(); self.compiled_qobjevo.set_data(self.cte, self.ops); elif threading == ""omp"":; self.compiled_qobjevo = CQobjEvoTdOmp(); self.compiled_qobjevo.set_data(self.cte, self.ops); self.compiled_qobjevo.set_threads(self.omp). if td == ""pyfunc"":; self.compiled_qobjevo.set_factor(func=self.coeff_get); elif td == ""cyfactor"":; self.compiled_qobjevo.set_factor(obj=self.coeff_get); else:; if td == ""cte"":; if threading == ""single"":; self.compiled_qobjevo = CQobjCte.__new__(CQobjCte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteOmp.__new__(CQobjCteOmp); self.compiled_qobjevo.set_threads(self.omp); else:; # time dependence is pyfunc or cyfactor; if threading == ""single"":; self.compiled_qobjevo = CQobjEvoTd.__new__(CQobjEvoTd); elif threading == ""omp"":; self.compiled_qobjevo = CQobjEvoTdOmp.__new__(CQobjEvoTdOmp); self.compiled_qobjevo.set_threads(self.omp); self.compiled_qobjevo.__setstate__(state[1]). elif mat_type",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:49144,Integrability,depend,dependence,49144,"ding == ""single"":; self.compiled_qobjevo = CQobjCte(); self.compiled_qobjevo.set_data(self.cte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteOmp(); self.compiled_qobjevo.set_data(self.cte); self.compiled_qobjevo.set_threads(self.omp); else:; # time dependence is pyfunc or cyfactor; if threading == ""single"":; self.compiled_qobjevo = CQobjEvoTd(); self.compiled_qobjevo.set_data(self.cte, self.ops); elif threading == ""omp"":; self.compiled_qobjevo = CQobjEvoTdOmp(); self.compiled_qobjevo.set_data(self.cte, self.ops); self.compiled_qobjevo.set_threads(self.omp). if td == ""pyfunc"":; self.compiled_qobjevo.set_factor(func=self.coeff_get); elif td == ""cyfactor"":; self.compiled_qobjevo.set_factor(obj=self.coeff_get); else:; if td == ""cte"":; if threading == ""single"":; self.compiled_qobjevo = CQobjCte.__new__(CQobjCte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteOmp.__new__(CQobjCteOmp); self.compiled_qobjevo.set_threads(self.omp); else:; # time dependence is pyfunc or cyfactor; if threading == ""single"":; self.compiled_qobjevo = CQobjEvoTd.__new__(CQobjEvoTd); elif threading == ""omp"":; self.compiled_qobjevo = CQobjEvoTdOmp.__new__(CQobjEvoTdOmp); self.compiled_qobjevo.set_threads(self.omp); self.compiled_qobjevo.__setstate__(state[1]). elif mat_type == ""dense"":; if td == ""cte"":; self.compiled_qobjevo = \; CQobjCteDense.__new__(CQobjCteDense); else:; CQobjEvoTdDense.__new__(CQobjEvoTdDense); self.compiled_qobjevo.__setstate__(state[1]). elif mat_type == ""matched"":; if threading == ""single"":; self.compiled_qobjevo = \; CQobjEvoTdMatched.__new__(CQobjEvoTdMatched); elif threading == ""omp"":; self.compiled_qobjevo = \; CQobjEvoTdMatchedOmp.__new__(CQobjEvoTdMatchedOmp); self.compiled_qobjevo.set_threads(self.omp); self.compiled_qobjevo.__setstate__(state[1]). # Function defined inside another function cannot be pickled,; # Using class instead; class _UnitedFuncCaller:; def __init__(self, funclist, args, dynamics_args, cte):; self.funclist = funclist; sel",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:22706,Modifiability,variab,variables,22706,"; new.coeff_get = None; new.coeff_files = []; new.use_cython = self.use_cython; new.safePickle = self.safePickle. for op in self.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; new.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). return new. def _inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). [docs] def arguments(self, new_args):; """"""; Update the scoped variables that were passed as ``args`` to new values.; """"""; if not isinstance(new_args, dict):; raise TypeError(""The new args must be in a dict""); # remove dynamics_args that are to be refreshed; self.dynamics_args = [dargs for dargs in self.dynamics_args; if dargs[0] not in new_args]; self.args.update(new_args); self._args_checks(); if self.compiled and self.compiled.split()[2] != ""cte"":; if isinstance(self.coeff_get, StrCoeff):; self.coeff_get.set_args(self.args); self.coeff_get._set_dyn_args(self.dynamics_args); elif isinstance(self.coeff_get, _UnitedFuncCaller):; self.coeff_get.set_args(self.args, self.dynamics_args). def solver_set_args(self, new_args, state, e_ops):; self.dynamics_args = []; self.args.update(new_args); self._args_checks(); for i, dargs in enumerate(self.dynamics_args):; if dargs[1] == ""expect"" and isinstance(dargs[2], int):; self.dynamics_args[i] = (dargs[0], ""expect"",; QobjEvo(e_ops[dargs[2]])); if self.compiled:; self.dynamics_args[i][2].compile(); self._d",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:3023,Safety,safe,safePickle,3023,"##########################################; """"""Time-dependent Quantum Object (Qobj) class.; """"""; __all__ = ['QobjEvo']. from qutip.qobj import Qobj; import qutip.settings as qset; from qutip.interpolate import Cubic_Spline; from scipy.interpolate import CubicSpline, interp1d; from functools import partial; from types import FunctionType, BuiltinFunctionType; import numpy as np; from numbers import Number; from qutip.qobjevo_codegen import (_compile_str_single, _compiled_coeffs,; _compiled_coeffs_python); from qutip.cy.spmatfuncs import (cy_expect_rho_vec, cy_expect_psi,; spmv); from qutip.cy.cqobjevo import (CQobjCte, CQobjCteDense, CQobjEvoTd,; CQobjEvoTdMatched, CQobjEvoTdDense); from qutip.cy.cqobjevo_factor import (InterCoeffT, InterCoeffCte,; InterpolateCoeff, StrCoeff,; StepCoeffCte, StepCoeffT); import sys; import scipy; import os; from re import sub. if qset.has_openmp:; from qutip.cy.openmp.cqobjevo_omp import (CQobjCteOmp, CQobjEvoTdOmp,; CQobjEvoTdMatchedOmp). safePickle = [False]; if sys.platform == 'win32':; safePickle[0] = True. try:; import cython; use_cython = [True]; except:; use_cython = [False]. def proj(x):; if np.isfinite(x):; return (x); else:; return np.inf + 0j * np.imag(x). str_env = {; ""sin"": np.sin,; ""cos"": np.cos,; ""tan"": np.tan,; ""asin"": np.arcsin,; ""acos"": np.arccos,; ""atan"": np.arctan,; ""pi"": np.pi,; ""sinh"": np.sinh,; ""cosh"": np.cosh,; ""tanh"": np.tanh,; ""asinh"": np.arcsinh,; ""acosh"": np.arccosh,; ""atanh"": np.arctanh,; ""exp"": np.exp,; ""log"": np.log,; ""log10"": np.log10,; ""erf"": scipy.special.erf,; ""zerf"": scipy.special.erf,; ""sqrt"": np.sqrt,; ""real"": np.real,; ""imag"": np.imag,; ""conj"": np.conj,; ""abs"": np.abs,; ""norm"": lambda x: np.abs(x)**2,; ""arg"": np.angle,; ""proj"": proj,; ""np"": np,; ""spe"": scipy.special}. class _file_list:; """"""; Contain temp a list .pyx to clean; """"""; def __init__(self):; self.files = []. def add(self, file_):; self.files += [file_ + "".pyx""]. def clean(self):; to_del = []; for i, file_ in enumerate(self.files):; try:",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:3074,Safety,safe,safePickle,3074,"######; """"""Time-dependent Quantum Object (Qobj) class.; """"""; __all__ = ['QobjEvo']. from qutip.qobj import Qobj; import qutip.settings as qset; from qutip.interpolate import Cubic_Spline; from scipy.interpolate import CubicSpline, interp1d; from functools import partial; from types import FunctionType, BuiltinFunctionType; import numpy as np; from numbers import Number; from qutip.qobjevo_codegen import (_compile_str_single, _compiled_coeffs,; _compiled_coeffs_python); from qutip.cy.spmatfuncs import (cy_expect_rho_vec, cy_expect_psi,; spmv); from qutip.cy.cqobjevo import (CQobjCte, CQobjCteDense, CQobjEvoTd,; CQobjEvoTdMatched, CQobjEvoTdDense); from qutip.cy.cqobjevo_factor import (InterCoeffT, InterCoeffCte,; InterpolateCoeff, StrCoeff,; StepCoeffCte, StepCoeffT); import sys; import scipy; import os; from re import sub. if qset.has_openmp:; from qutip.cy.openmp.cqobjevo_omp import (CQobjCteOmp, CQobjEvoTdOmp,; CQobjEvoTdMatchedOmp). safePickle = [False]; if sys.platform == 'win32':; safePickle[0] = True. try:; import cython; use_cython = [True]; except:; use_cython = [False]. def proj(x):; if np.isfinite(x):; return (x); else:; return np.inf + 0j * np.imag(x). str_env = {; ""sin"": np.sin,; ""cos"": np.cos,; ""tan"": np.tan,; ""asin"": np.arcsin,; ""acos"": np.arccos,; ""atan"": np.arctan,; ""pi"": np.pi,; ""sinh"": np.sinh,; ""cosh"": np.cosh,; ""tanh"": np.tanh,; ""asinh"": np.arcsinh,; ""acosh"": np.arccosh,; ""atanh"": np.arctanh,; ""exp"": np.exp,; ""log"": np.log,; ""log10"": np.log10,; ""erf"": scipy.special.erf,; ""zerf"": scipy.special.erf,; ""sqrt"": np.sqrt,; ""real"": np.real,; ""imag"": np.imag,; ""conj"": np.conj,; ""abs"": np.abs,; ""norm"": lambda x: np.abs(x)**2,; ""arg"": np.angle,; ""proj"": proj,; ""np"": np,; ""spe"": scipy.special}. class _file_list:; """"""; Contain temp a list .pyx to clean; """"""; def __init__(self):; self.files = []. def add(self, file_):; self.files += [file_ + "".pyx""]. def clean(self):; to_del = []; for i, file_ in enumerate(self.files):; try:; os.remove(file_); to_del.append(i);",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:12764,Safety,safe,safePickle,12764,"mes of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the ``args`` parameter. tlist : array_like; List of times at which the numpy-array coefficients are applied. compiled : str; A string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevo : ``CQobjCte`` or ``CQobjEvoTd``; Cython version of the QobjEvo. coeff_get : callable; Object called to obtain a list of all the coefficients at a particular; time. coeff_files : list; Runtime created files to delete with the instance. dummy_cte : bool; Is self.cte an empty Qobj. const : bool; Indicates if quantum object is constant. type : {""cte"", ""string"", ""func"", ""array"", ""spline"", ""mixed_callable"", \; ""mixed_compilable""}; Information about the type of coefficients used in the entire object. num_obj : int; Number of :obj:`~Qobj` in the QobjEvo. use_cython : bool; Flag to compile string to Cython or Python. safePickle : bool; Flag to not share pointers between thread.; """""". def __init__(self, Q_object=[], args={}, copy=True,; tlist=None, state0=None, e_ops=[]):; if isinstance(Q_object, QobjEvo):; if copy:; self._inplace_copy(Q_object); else:; self.__dict__ = Q_object.__dict__; if args:; self.arguments(args); for i, dargs in enumerate(self.dynamics_args):; e_int = dargs[1] == ""expect"" and isinstance(dargs[2], int); if e_ops and e_int:; self.dynamics_args[i] = (dargs[0], ""expect"",; e_ops[dargs[2]]); if state0 is not None:; self._dynamics_args_update(0., state0); return. self.const = False; self.dummy_cte = False; self.args = args.copy(); self.dynamics_args = []; self.cte = None; self.tlist = np.asarray(tlist) if tlist is not None else None; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.type = ""none""; self.omp = 0; self.coeff_files = []; self.use_cython = use_cython[0]; self.safePickle = safePickle[0]. # Attempt to determine if a 2-element list is a single, time-dependent; # operator, or a",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:13678,Safety,safe,safePickle,13678," QobjEvo. use_cython : bool; Flag to compile string to Cython or Python. safePickle : bool; Flag to not share pointers between thread.; """""". def __init__(self, Q_object=[], args={}, copy=True,; tlist=None, state0=None, e_ops=[]):; if isinstance(Q_object, QobjEvo):; if copy:; self._inplace_copy(Q_object); else:; self.__dict__ = Q_object.__dict__; if args:; self.arguments(args); for i, dargs in enumerate(self.dynamics_args):; e_int = dargs[1] == ""expect"" and isinstance(dargs[2], int); if e_ops and e_int:; self.dynamics_args[i] = (dargs[0], ""expect"",; e_ops[dargs[2]]); if state0 is not None:; self._dynamics_args_update(0., state0); return. self.const = False; self.dummy_cte = False; self.args = args.copy(); self.dynamics_args = []; self.cte = None; self.tlist = np.asarray(tlist) if tlist is not None else None; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.type = ""none""; self.omp = 0; self.coeff_files = []; self.use_cython = use_cython[0]; self.safePickle = safePickle[0]. # Attempt to determine if a 2-element list is a single, time-dependent; # operator, or a list with 2 possibly time-dependent elements.; if isinstance(Q_object, list) and len(Q_object) == 2:; try:; # Test if parsing succeeds on this as a single element.; self._td_op_type(Q_object); Q_object = [Q_object]; except (TypeError, ValueError):; pass. op_type = self._td_format_check(Q_object); self.ops = []. if isinstance(op_type, int):; if op_type == 0:; self.cte = Q_object; self.const = True; self.type = ""cte""; elif op_type == 1:; raise TypeError(""The Qobj must not already be a function""); elif op_type == -1:; pass; else:; op_type_count = [0, 0, 0, 0]; for type_, op in zip(op_type, Q_object):; if type_ == 0:; if self.cte is None:; self.cte = op; else:; self.cte += op; elif type_ == 1:; op_type_count[0] += 1; self.ops.append(EvoElement(op[0], op[1], op[1], ""func"")); elif type_ == 2:; op_type_count[1] += 1; self.ops.append(EvoElement(op[0], _StrWrapper(op[1]),; op[1], ""string"")); e",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:13691,Safety,safe,safePickle,13691," QobjEvo. use_cython : bool; Flag to compile string to Cython or Python. safePickle : bool; Flag to not share pointers between thread.; """""". def __init__(self, Q_object=[], args={}, copy=True,; tlist=None, state0=None, e_ops=[]):; if isinstance(Q_object, QobjEvo):; if copy:; self._inplace_copy(Q_object); else:; self.__dict__ = Q_object.__dict__; if args:; self.arguments(args); for i, dargs in enumerate(self.dynamics_args):; e_int = dargs[1] == ""expect"" and isinstance(dargs[2], int); if e_ops and e_int:; self.dynamics_args[i] = (dargs[0], ""expect"",; e_ops[dargs[2]]); if state0 is not None:; self._dynamics_args_update(0., state0); return. self.const = False; self.dummy_cte = False; self.args = args.copy(); self.dynamics_args = []; self.cte = None; self.tlist = np.asarray(tlist) if tlist is not None else None; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.type = ""none""; self.omp = 0; self.coeff_files = []; self.use_cython = use_cython[0]; self.safePickle = safePickle[0]. # Attempt to determine if a 2-element list is a single, time-dependent; # operator, or a list with 2 possibly time-dependent elements.; if isinstance(Q_object, list) and len(Q_object) == 2:; try:; # Test if parsing succeeds on this as a single element.; self._td_op_type(Q_object); Q_object = [Q_object]; except (TypeError, ValueError):; pass. op_type = self._td_format_check(Q_object); self.ops = []. if isinstance(op_type, int):; if op_type == 0:; self.cte = Q_object; self.const = True; self.type = ""cte""; elif op_type == 1:; raise TypeError(""The Qobj must not already be a function""); elif op_type == -1:; pass; else:; op_type_count = [0, 0, 0, 0]; for type_, op in zip(op_type, Q_object):; if type_ == 0:; if self.cte is None:; self.cte = op; else:; self.cte += op; elif type_ == 1:; op_type_count[0] += 1; self.ops.append(EvoElement(op[0], op[1], op[1], ""func"")); elif type_ == 2:; op_type_count[1] += 1; self.ops.append(EvoElement(op[0], _StrWrapper(op[1]),; op[1], ""string"")); e",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:21785,Safety,safe,safePickle,21785,", np.ndarray) and state.ndim == 2:; s1 = self.cte.shape[1]; new_l = int(np.sqrt(s1)); for name, what, op in self.dynamics_args:; if what == ""vec"":; self.args[name] = state.ravel(""F""); elif what == ""mat"":; self.args[name] = state; elif what == ""expect"":; self.args[name] = op.expect(t, state); elif state.shape[1] == 1:; self.args[name] = Qobj(state, dims=[self.cte.dims[1],[1]]); elif state.shape[1] == s1:; self.args[name] = Qobj(state, dims=self.cte.dims); else:; self.args[name] = Qobj(state). else:; raise TypeError(""state must be a Qobj or np.ndarray""). [docs] def copy(self):; """"""Return a copy of this object.""""""; new = QobjEvo(self.cte.copy()); new.const = self.const; new.args = self.args.copy(); new.dynamics_args = self.dynamics_args.copy(); new.tlist = self.tlist; new.dummy_cte = self.dummy_cte; new.num_obj = self.num_obj; new.type = self.type; new.compiled = False; new.compiled_qobjevo = None; new.coeff_get = None; new.coeff_files = []; new.use_cython = self.use_cython; new.safePickle = self.safePickle. for op in self.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; new.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). return new. def _inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). [docs] def arguments(self, new_args):; """"""; Update the scoped variables that were passed as ``args`` to new values.; """"""; if not isinstance(new_args, ",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:21803,Safety,safe,safePickle,21803,"and state.ndim == 2:; s1 = self.cte.shape[1]; new_l = int(np.sqrt(s1)); for name, what, op in self.dynamics_args:; if what == ""vec"":; self.args[name] = state.ravel(""F""); elif what == ""mat"":; self.args[name] = state; elif what == ""expect"":; self.args[name] = op.expect(t, state); elif state.shape[1] == 1:; self.args[name] = Qobj(state, dims=[self.cte.dims[1],[1]]); elif state.shape[1] == s1:; self.args[name] = Qobj(state, dims=self.cte.dims); else:; self.args[name] = Qobj(state). else:; raise TypeError(""state must be a Qobj or np.ndarray""). [docs] def copy(self):; """"""Return a copy of this object.""""""; new = QobjEvo(self.cte.copy()); new.const = self.const; new.args = self.args.copy(); new.dynamics_args = self.dynamics_args.copy(); new.tlist = self.tlist; new.dummy_cte = self.dummy_cte; new.num_obj = self.num_obj; new.type = self.type; new.compiled = False; new.compiled_qobjevo = None; new.coeff_get = None; new.coeff_files = []; new.use_cython = self.use_cython; new.safePickle = self.safePickle. for op in self.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; new.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). return new. def _inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). [docs] def arguments(self, new_args):; """"""; Update the scoped variables that were passed as ``args`` to new values.; """"""; if not isinstance(new_args, dict):; raise T",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:22429,Safety,safe,safePickle,22429,"opy()); new.const = self.const; new.args = self.args.copy(); new.dynamics_args = self.dynamics_args.copy(); new.tlist = self.tlist; new.dummy_cte = self.dummy_cte; new.num_obj = self.num_obj; new.type = self.type; new.compiled = False; new.compiled_qobjevo = None; new.coeff_get = None; new.coeff_files = []; new.use_cython = self.use_cython; new.safePickle = self.safePickle. for op in self.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; new.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). return new. def _inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). [docs] def arguments(self, new_args):; """"""; Update the scoped variables that were passed as ``args`` to new values.; """"""; if not isinstance(new_args, dict):; raise TypeError(""The new args must be in a dict""); # remove dynamics_args that are to be refreshed; self.dynamics_args = [dargs for dargs in self.dynamics_args; if dargs[0] not in new_args]; self.args.update(new_args); self._args_checks(); if self.compiled and self.compiled.split()[2] != ""cte"":; if isinstance(self.coeff_get, StrCoeff):; self.coeff_get.set_args(self.args); self.coeff_get._set_dyn_args(self.dynamics_args); elif isinstance(self.coeff_get, _UnitedFuncCaller):; self.coeff_get.set_args(self.args, self.dynamics_args). def solver_set_args(self, new_args, state, e_ops):; self.dynamics_args = []; self.args.update(new_args)",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:22448,Safety,safe,safePickle,22448,"st = self.const; new.args = self.args.copy(); new.dynamics_args = self.dynamics_args.copy(); new.tlist = self.tlist; new.dummy_cte = self.dummy_cte; new.num_obj = self.num_obj; new.type = self.type; new.compiled = False; new.compiled_qobjevo = None; new.coeff_get = None; new.coeff_files = []; new.use_cython = self.use_cython; new.safePickle = self.safePickle. for op in self.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; new.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). return new. def _inplace_copy(self, other):; self.cte = other.cte; self.const = other.const; self.args = other.args.copy(); self.dynamics_args = other.dynamics_args; self.tlist = other.tlist; self.dummy_cte = other.dummy_cte; self.num_obj = other.num_obj; self.type = other.type; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.ops = []; self.coeff_files = []; self.use_cython = other.use_cython; self.safePickle = other.safePickle. for op in other.ops:; if op.type == ""array"":; new_coeff = op.coeff.copy(); else:; new_coeff = op.coeff; self.ops.append(EvoElement(op.qobj.copy(), op.get_coeff,; new_coeff, op.type)). [docs] def arguments(self, new_args):; """"""; Update the scoped variables that were passed as ``args`` to new values.; """"""; if not isinstance(new_args, dict):; raise TypeError(""The new args must be in a dict""); # remove dynamics_args that are to be refreshed; self.dynamics_args = [dargs for dargs in self.dynamics_args; if dargs[0] not in new_args]; self.args.update(new_args); self._args_checks(); if self.compiled and self.compiled.split()[2] != ""cte"":; if isinstance(self.coeff_get, StrCoeff):; self.coeff_get.set_args(self.args); self.coeff_get._set_dyn_args(self.dynamics_args); elif isinstance(self.coeff_get, _UnitedFuncCaller):; self.coeff_get.set_args(self.args, self.dynamics_args). def solver_set_args(self, new_args, state, e_ops):; self.dynamics_args = []; self.args.update(new_args); self._args_ch",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:48015,Safety,safe,safePickle,48015,"et = StepCoeffT(; self.ops, None, self.tlist); else:; self.coeff_get = InterCoeffT(; self.ops, None, self.tlist); self.compiled += ""cyfactor""; self.compiled_qobjevo.set_factor(obj=self.coeff_get). elif self.type == ""spline"":; self.coeff_get = InterpolateCoeff(self.ops, None, None); self.compiled += ""cyfactor""; self.compiled_qobjevo.set_factor(obj=self.coeff_get). else:; pass. coeff_files.clean(); if code:; return Code. def _get_coeff(self, t):; out = []; for part in self.ops:; out.append(part.get_coeff(t, self.args)); return out. def __getstate__(self):; _dict_ = {key: self.__dict__[key]; for key in self.__dict__ if key != ""compiled_qobjevo""}; if self.compiled:; return (_dict_, self.compiled_qobjevo.__getstate__()); else:; return (_dict_,). def __setstate__(self, state):; self.__dict__ = state[0]; self.compiled_qobjevo = None; if self.compiled:; mat_type, threading, td = self.compiled.split(); if mat_type == ""csr"":; if self.safePickle:; # __getstate__ and __setstate__ of compiled_qobjevo pass pointers; # In 'safe' mod, these pointers are not used.; if td == ""cte"":; if threading == ""single"":; self.compiled_qobjevo = CQobjCte(); self.compiled_qobjevo.set_data(self.cte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteOmp(); self.compiled_qobjevo.set_data(self.cte); self.compiled_qobjevo.set_threads(self.omp); else:; # time dependence is pyfunc or cyfactor; if threading == ""single"":; self.compiled_qobjevo = CQobjEvoTd(); self.compiled_qobjevo.set_data(self.cte, self.ops); elif threading == ""omp"":; self.compiled_qobjevo = CQobjEvoTdOmp(); self.compiled_qobjevo.set_data(self.cte, self.ops); self.compiled_qobjevo.set_threads(self.omp). if td == ""pyfunc"":; self.compiled_qobjevo.set_factor(func=self.coeff_get); elif td == ""cyfactor"":; self.compiled_qobjevo.set_factor(obj=self.coeff_get); else:; if td == ""cte"":; if threading == ""single"":; self.compiled_qobjevo = CQobjCte.__new__(CQobjCte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteOmp.__new__(CQobjCt",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:48101,Safety,safe,safe,48101,"et = StepCoeffT(; self.ops, None, self.tlist); else:; self.coeff_get = InterCoeffT(; self.ops, None, self.tlist); self.compiled += ""cyfactor""; self.compiled_qobjevo.set_factor(obj=self.coeff_get). elif self.type == ""spline"":; self.coeff_get = InterpolateCoeff(self.ops, None, None); self.compiled += ""cyfactor""; self.compiled_qobjevo.set_factor(obj=self.coeff_get). else:; pass. coeff_files.clean(); if code:; return Code. def _get_coeff(self, t):; out = []; for part in self.ops:; out.append(part.get_coeff(t, self.args)); return out. def __getstate__(self):; _dict_ = {key: self.__dict__[key]; for key in self.__dict__ if key != ""compiled_qobjevo""}; if self.compiled:; return (_dict_, self.compiled_qobjevo.__getstate__()); else:; return (_dict_,). def __setstate__(self, state):; self.__dict__ = state[0]; self.compiled_qobjevo = None; if self.compiled:; mat_type, threading, td = self.compiled.split(); if mat_type == ""csr"":; if self.safePickle:; # __getstate__ and __setstate__ of compiled_qobjevo pass pointers; # In 'safe' mod, these pointers are not used.; if td == ""cte"":; if threading == ""single"":; self.compiled_qobjevo = CQobjCte(); self.compiled_qobjevo.set_data(self.cte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteOmp(); self.compiled_qobjevo.set_data(self.cte); self.compiled_qobjevo.set_threads(self.omp); else:; # time dependence is pyfunc or cyfactor; if threading == ""single"":; self.compiled_qobjevo = CQobjEvoTd(); self.compiled_qobjevo.set_data(self.cte, self.ops); elif threading == ""omp"":; self.compiled_qobjevo = CQobjEvoTdOmp(); self.compiled_qobjevo.set_data(self.cte, self.ops); self.compiled_qobjevo.set_threads(self.omp). if td == ""pyfunc"":; self.compiled_qobjevo.set_factor(func=self.coeff_get); elif td == ""cyfactor"":; self.compiled_qobjevo.set_factor(obj=self.coeff_get); else:; if td == ""cte"":; if threading == ""single"":; self.compiled_qobjevo = CQobjCte.__new__(CQobjCte); elif threading == ""omp"":; self.compiled_qobjevo = CQobjCteOmp.__new__(CQobjCt",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:9428,Security,access,access,9428,"mes of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; ``args = {""_step_func_coeff"": True}``. Examples of array-format usage are:. .. code-block:: python. tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; ``QobjEvo`` that contains different ``tlist`` values, however. **Passing arguments**. ``args`` is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string. There are some ""magic"" names that can be specified, whose objects will be; overwritten when used within :func:`.sesolve`, :func:`.mesolve` and; :func:`.mcsolve`. This allows access to the solvers' internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. - ``""state""``: the current state as a :class:`~Qobj`; - ``""state_vec""``: the current state as a column-stacked 1D ``np.ndarray``; - ``""state_mat""``: the current state as a 2D ``np.ndarray``; - ``""expect_op_<n>""``: the current expectation value of the element; ``e_ops[n]``, which is an argument to the solvers. Replace ``<n>`` with; an integer literal, e.g. ``""expect_op_0""``. This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; - ``""collapse""``: (:func:`.mcsolve` only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; ``(time: float, which: int)``, where ``time`` is the time this collapse; happened, and ``which`` is an integer indexing the ``c_ops`` argument to; :func:`.mcsolve`. Parameters; ----------; Q_object : list, :class:`~",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:11180,Security,access,access,11180,"apses that have; occurred during the evolution. Each element of the list is a 2-tuple; ``(time: float, which: int)``, where ``time`` is the time this collapse; happened, and ``which`` is an integer indexing the ``c_ops`` argument to; :func:`.mcsolve`. Parameters; ----------; Q_object : list, :class:`~Qobj` or :class:`~QobjEvo`; The time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of ``[Qobj, time_dependence]`` pairs that are; summed to make the whole object. The ``time_dependence`` can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the ``Qobj`` instead; of the 2-element list. args : dict, optional; Mapping of ``{str: object}``, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the ""magic""; names used to access solver internals. tlist : array_like, optional; List of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in ``Q_object`` is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes; ----------; cte : :class:`~Qobj`; Constant part of the QobjEvo. ops : list of :class:`.EvoElement`; Internal representation of the time-dependence structure of the; elements. args : dict; The current value of the ``args`` dictionary passed into the; constructor. dynamics_args : list; Names of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the ``args`` parameter. tlist : array_like; List of times at which the numpy-array coefficients are applied. compiled : str; A string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevo : ``CQobjCt",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:3527,Testability,log,log,3527,"ed_coeffs_python); from qutip.cy.spmatfuncs import (cy_expect_rho_vec, cy_expect_psi,; spmv); from qutip.cy.cqobjevo import (CQobjCte, CQobjCteDense, CQobjEvoTd,; CQobjEvoTdMatched, CQobjEvoTdDense); from qutip.cy.cqobjevo_factor import (InterCoeffT, InterCoeffCte,; InterpolateCoeff, StrCoeff,; StepCoeffCte, StepCoeffT); import sys; import scipy; import os; from re import sub. if qset.has_openmp:; from qutip.cy.openmp.cqobjevo_omp import (CQobjCteOmp, CQobjEvoTdOmp,; CQobjEvoTdMatchedOmp). safePickle = [False]; if sys.platform == 'win32':; safePickle[0] = True. try:; import cython; use_cython = [True]; except:; use_cython = [False]. def proj(x):; if np.isfinite(x):; return (x); else:; return np.inf + 0j * np.imag(x). str_env = {; ""sin"": np.sin,; ""cos"": np.cos,; ""tan"": np.tan,; ""asin"": np.arcsin,; ""acos"": np.arccos,; ""atan"": np.arctan,; ""pi"": np.pi,; ""sinh"": np.sinh,; ""cosh"": np.cosh,; ""tanh"": np.tanh,; ""asinh"": np.arcsinh,; ""acosh"": np.arccosh,; ""atanh"": np.arctanh,; ""exp"": np.exp,; ""log"": np.log,; ""log10"": np.log10,; ""erf"": scipy.special.erf,; ""zerf"": scipy.special.erf,; ""sqrt"": np.sqrt,; ""real"": np.real,; ""imag"": np.imag,; ""conj"": np.conj,; ""abs"": np.abs,; ""norm"": lambda x: np.abs(x)**2,; ""arg"": np.angle,; ""proj"": proj,; ""np"": np,; ""spe"": scipy.special}. class _file_list:; """"""; Contain temp a list .pyx to clean; """"""; def __init__(self):; self.files = []. def add(self, file_):; self.files += [file_ + "".pyx""]. def clean(self):; to_del = []; for i, file_ in enumerate(self.files):; try:; os.remove(file_); to_del.append(i); except Exception:; if not os.path.isfile(file_):; to_del.append(i). for i in to_del[::-1]:; del self.files[i]. def __del__(self):; self.clean(). coeff_files = _file_list(). class _StrWrapper:; def __init__(self, code):; self.code = ""_out = "" + code. def __call__(self, t, args={}):; env = {""t"": t}; env.update(args); exec(self.code, str_env, env); return env[""_out""]. class _CubicSplineWrapper:; # Using scipy's CubicSpline since Qutip's one; # only acc",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:3536,Testability,log,log,3536,"; from qutip.cy.spmatfuncs import (cy_expect_rho_vec, cy_expect_psi,; spmv); from qutip.cy.cqobjevo import (CQobjCte, CQobjCteDense, CQobjEvoTd,; CQobjEvoTdMatched, CQobjEvoTdDense); from qutip.cy.cqobjevo_factor import (InterCoeffT, InterCoeffCte,; InterpolateCoeff, StrCoeff,; StepCoeffCte, StepCoeffT); import sys; import scipy; import os; from re import sub. if qset.has_openmp:; from qutip.cy.openmp.cqobjevo_omp import (CQobjCteOmp, CQobjEvoTdOmp,; CQobjEvoTdMatchedOmp). safePickle = [False]; if sys.platform == 'win32':; safePickle[0] = True. try:; import cython; use_cython = [True]; except:; use_cython = [False]. def proj(x):; if np.isfinite(x):; return (x); else:; return np.inf + 0j * np.imag(x). str_env = {; ""sin"": np.sin,; ""cos"": np.cos,; ""tan"": np.tan,; ""asin"": np.arcsin,; ""acos"": np.arccos,; ""atan"": np.arctan,; ""pi"": np.pi,; ""sinh"": np.sinh,; ""cosh"": np.cosh,; ""tanh"": np.tanh,; ""asinh"": np.arcsinh,; ""acosh"": np.arccosh,; ""atanh"": np.arctanh,; ""exp"": np.exp,; ""log"": np.log,; ""log10"": np.log10,; ""erf"": scipy.special.erf,; ""zerf"": scipy.special.erf,; ""sqrt"": np.sqrt,; ""real"": np.real,; ""imag"": np.imag,; ""conj"": np.conj,; ""abs"": np.abs,; ""norm"": lambda x: np.abs(x)**2,; ""arg"": np.angle,; ""proj"": proj,; ""np"": np,; ""spe"": scipy.special}. class _file_list:; """"""; Contain temp a list .pyx to clean; """"""; def __init__(self):; self.files = []. def add(self, file_):; self.files += [file_ + "".pyx""]. def clean(self):; to_del = []; for i, file_ in enumerate(self.files):; try:; os.remove(file_); to_del.append(i); except Exception:; if not os.path.isfile(file_):; to_del.append(i). for i in to_del[::-1]:; del self.files[i]. def __del__(self):; self.clean(). coeff_files = _file_list(). class _StrWrapper:; def __init__(self, code):; self.code = ""_out = "" + code. def __call__(self, t, args={}):; env = {""t"": t}; env.update(args); exec(self.code, str_env, env); return env[""_out""]. class _CubicSplineWrapper:; # Using scipy's CubicSpline since Qutip's one; # only accept linearly dist",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:7915,Testability,log,log,7915,"dependent scalars :math:`f_k(t)` by. .. math::. Q(t) = \\sum_k f_k(t) Q_k. If a scalar :math:`f_k(t)` is not passed with a given :obj:`~Qobj`, then; that term is assumed to be constant. The next section contains more detail; on the allowed forms of the constants, and gives several examples for how; to build instances of this class. **Time-dependence formats**. There are three major formats for specifying a time-dependent scalar:. - Python function; - string; - array. For function format, the function signature must be; ``f(t: float, args: dict) -> complex``, for example. .. code-block:: python. def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. .. code-block::. pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:. .. code-block:: python. H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype ``np.float64`` or; ``np.complex128``. A list of times (``np.float64``) at which the; coeffients must be given as ``tlist``. The coeffients array must have the; same length as the tlist. The times of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; ``args = {""_step_func_coeff"": True}``. Examples of array-format usage are:. .. code-block:: python. tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; ``Qob",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:8802,Testability,log,logspace,8802," code; resulting in a complex. The following symbols are defined:. .. code-block::. pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:. .. code-block:: python. H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype ``np.float64`` or; ``np.complex128``. A list of times (``np.float64``) at which the; coeffients must be given as ``tlist``. The coeffients array must have the; same length as the tlist. The times of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; ``args = {""_step_func_coeff"": True}``. Examples of array-format usage are:. .. code-block:: python. tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; ``QobjEvo`` that contains different ``tlist`` values, however. **Passing arguments**. ``args`` is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string. There are some ""magic"" names that can be specified, whose objects will be; overwritten when used within :func:`.sesolve`, :func:`.mesolve` and; :func:`.mcsolve`. This allows access to the solvers' internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. - ``""state""``: the current state as a :class:`~Qobj`; - ``""state_vec""``: the current state as a column-stacked 1D ``np.ndarray``; - ``""state_mat""``: the current state as a 2D ``np.ndarray``; - ``""expect_op_<n>""``: the curre",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:15396,Testability,test,test,15396,"f.cte is None:; self.cte = op; else:; self.cte += op; elif type_ == 1:; op_type_count[0] += 1; self.ops.append(EvoElement(op[0], op[1], op[1], ""func"")); elif type_ == 2:; op_type_count[1] += 1; self.ops.append(EvoElement(op[0], _StrWrapper(op[1]),; op[1], ""string"")); elif type_ == 3:; op_type_count[2] += 1; self.ops.append(EvoElement(; op[0],; _CubicSplineWrapper(tlist, op[1], args=self.args),; op[1].copy(), ""array"")); elif type_ == 4:; op_type_count[3] += 1; self.ops.append(EvoElement(op[0], op[1], op[1], ""spline"")). nops = sum(op_type_count); if all([op_t == 0 for op_t in op_type]):; self.type = ""cte""; elif op_type_count[0] == nops:; self.type = ""func""; elif op_type_count[1] == nops:; self.type = ""string""; elif op_type_count[2] == nops:; self.type = ""array""; elif op_type_count[3] == nops:; self.type = ""spline""; elif op_type_count[0]:; self.type = ""mixed_callable""; else:; self.type = ""mixed_compilable"". try:; if not self.cte:; self.cte = self.ops[0].qobj; # test is all qobj are compatible (shape, dims); for op in self.ops[1:]:; self.cte += op.qobj; self.cte *= 0.; self.dummy_cte = True; else:; cte_copy = self.cte.copy(); # test is all qobj are compatible (shape, dims); for op in self.ops:; cte_copy += op.qobj; except Exception as e:; raise TypeError(""Qobj not compatible."") from e. if not self.ops:; self.const = True; self.num_obj = (len(self.ops) if self.dummy_cte else len(self.ops) + 1); self._args_checks(); if e_ops:; for i, dargs in enumerate(self.dynamics_args):; if dargs[1] == ""expect"" and isinstance(dargs[2], int):; self.dynamics_args[i] = (dargs[0], ""expect"",; QobjEvo(e_ops[dargs[2]])); if state0 is not None:; self._dynamics_args_update(0., state0). def _td_format_check(self, Q_object):; if isinstance(Q_object, Qobj):; return 0; if isinstance(Q_object, (FunctionType, BuiltinFunctionType, partial)):; return 1; if isinstance(Q_object, list):; return [self._td_op_type(element) for element in Q_object] or -1; raise TypeError(""Incorrect Q_object specification""). ",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:15565,Testability,test,test,15565,":; op_type_count[1] += 1; self.ops.append(EvoElement(op[0], _StrWrapper(op[1]),; op[1], ""string"")); elif type_ == 3:; op_type_count[2] += 1; self.ops.append(EvoElement(; op[0],; _CubicSplineWrapper(tlist, op[1], args=self.args),; op[1].copy(), ""array"")); elif type_ == 4:; op_type_count[3] += 1; self.ops.append(EvoElement(op[0], op[1], op[1], ""spline"")). nops = sum(op_type_count); if all([op_t == 0 for op_t in op_type]):; self.type = ""cte""; elif op_type_count[0] == nops:; self.type = ""func""; elif op_type_count[1] == nops:; self.type = ""string""; elif op_type_count[2] == nops:; self.type = ""array""; elif op_type_count[3] == nops:; self.type = ""spline""; elif op_type_count[0]:; self.type = ""mixed_callable""; else:; self.type = ""mixed_compilable"". try:; if not self.cte:; self.cte = self.ops[0].qobj; # test is all qobj are compatible (shape, dims); for op in self.ops[1:]:; self.cte += op.qobj; self.cte *= 0.; self.dummy_cte = True; else:; cte_copy = self.cte.copy(); # test is all qobj are compatible (shape, dims); for op in self.ops:; cte_copy += op.qobj; except Exception as e:; raise TypeError(""Qobj not compatible."") from e. if not self.ops:; self.const = True; self.num_obj = (len(self.ops) if self.dummy_cte else len(self.ops) + 1); self._args_checks(); if e_ops:; for i, dargs in enumerate(self.dynamics_args):; if dargs[1] == ""expect"" and isinstance(dargs[2], int):; self.dynamics_args[i] = (dargs[0], ""expect"",; QobjEvo(e_ops[dargs[2]])); if state0 is not None:; self._dynamics_args_update(0., state0). def _td_format_check(self, Q_object):; if isinstance(Q_object, Qobj):; return 0; if isinstance(Q_object, (FunctionType, BuiltinFunctionType, partial)):; return 1; if isinstance(Q_object, list):; return [self._td_op_type(element) for element in Q_object] or -1; raise TypeError(""Incorrect Q_object specification""). def _td_op_type(self, element):; if isinstance(element, Qobj):; return 0; try:; op, td = element; except (TypeError, ValueError) as exc:; raise TypeError(""Incorrect Q_o",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:8082,Usability,simpl,simple,8082," not passed with a given :obj:`~Qobj`, then; that term is assumed to be constant. The next section contains more detail; on the allowed forms of the constants, and gives several examples for how; to build instances of this class. **Time-dependence formats**. There are three major formats for specifying a time-dependent scalar:. - Python function; - string; - array. For function format, the function signature must be; ``f(t: float, args: dict) -> complex``, for example. .. code-block:: python. def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. .. code-block::. pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:. .. code-block:: python. H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype ``np.float64`` or; ``np.complex128``. A list of times (``np.float64``) at which the; coeffients must be given as ``tlist``. The coeffients array must have the; same length as the tlist. The times of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; ``args = {""_step_func_coeff"": True}``. Examples of array-format usage are:. .. code-block:: python. tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; ``QobjEvo`` that contains different ``tlist`` values, however. **Passing arguments**. ``args`` is a dict of ",MatchSource.WIKI,docs/4.6/modules/qutip/qobjevo.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html
https://qutip.org/docs/4.6/modules/qutip/random_objects.html:12156,Availability,error,error,12156,"d dims is None:; raise ValueError('Specify either the number of rows of state vector'; '(N) or dimensions of quantum object (dims)'); if N and dims:; _check_dims(dims, N, 1); elif dims:; N = np.prod(dims[0]); _check_dims(dims, N, 1); else:; dims = [[N], [1]]; psi = rand_unitary_haar(N, seed=seed) * basis(N, 0); psi.dims = dims; return psi. [docs]def rand_dm(N, density=0.75, pure=False, dims=None, seed=None):; r""""""Creates a random NxN density matrix. Parameters; ----------; N : int, ndarray, list; If int, then shape of output operator. If list/ndarray then eigenvalues; of generated density matrix.; density : float; Density between [0,1] of output density matrix.; dims : list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]].; seed : int; Seed for the random number generator. Returns; -------; oper : qobj; NxN density matrix quantum operator. Notes; -----; For small density matrices., choosing a low density will result in an error; as no diagonal elements will be generated such that :math:`Tr(\rho)=1`. """"""; if isinstance(N, (np.ndarray, list)):; if np.abs(np.sum(N)-1.0) > 1e-15:; raise ValueError('Eigenvalues of a density matrix '; 'must sum to one.'); H = sp.diags(N, 0, dtype=complex, format='csr'); N = len(N); if dims:; _check_dims(dims, N, N); nvals = N**2*density; H = rand_jacobi_rotation(H, seed=seed); while H.nnz < 0.95*nvals:; H = rand_jacobi_rotation(H); H.sort_indices(); elif isinstance(N, (int, np.int32, np.int64)):; if dims:; _check_dims(dims, N, N); if pure:; dm_density = np.sqrt(density); psi = rand_ket(N, dm_density, seed=seed); H = psi * psi.dag(); H.data.sort_indices(); else:; non_zero = 0; tries = 0; while non_zero == 0 and tries < 10:; H = rand_herm(N, density, seed=seed); H = H.dag() * H; non_zero = H.tr(); tries += 1; if tries >= 10:; raise ValueError(; ""Requested density is too low to generate density matrix.""); H = H / H.tr(); H.data.sort_indices(); else:; raise TypeError('Input N must be an integer or",MatchSource.WIKI,docs/4.6/modules/qutip/random_objects.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/random_objects.html
https://qutip.org/docs/4.6/modules/qutip/random_objects.html:20794,Deployability,update,updated,20794,"None):; """"""Generates a random stochastic matrix. Parameters; ----------; N : int; Dimension of matrix.; density : float; Density between [0,1] of output density matrix.; kind : str (Default = 'left'); Generate 'left' or 'right' stochastic matrix.; dims : list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns; -------; oper : qobj; Quantum operator form of stochastic matrix.; """"""; if seed is not None:; np.random.seed(seed=seed); if dims:; _check_dims(dims, N, N); num_elems = max([int(np.ceil(N*(N+1)*density)/2), N]); data = np.random.rand(num_elems); # Ensure an element on every row and column; row_idx = np.hstack([np.random.permutation(N),; np.random.choice(N, num_elems-N)]); col_idx = np.hstack([np.random.permutation(N),; np.random.choice(N, num_elems-N)]); M = sp.coo_matrix((data, (row_idx, col_idx)),; dtype=float, shape=(N, N)).tocsr(); M = 0.5 * (M + M.conj().transpose()); num_rows = M.indptr.shape[0]-1; for row in range(num_rows):; row_start = M.indptr[row]; row_end = M.indptr[row+1]; row_sum = np.sum(M.data[row_start:row_end]); M.data[row_start:row_end] /= row_sum; if kind == 'left':; M = M.transpose(); return Qobj(M, dims=dims, shape=(N, N)). def _check_dims(dims, N1, N2):; if len(dims) != 2:; raise Exception(""Qobj dimensions must be list of length 2.""); if (not isinstance(dims[0], list)) or (not isinstance(dims[1], list)):; raise TypeError(; ""Qobj dimension components must be lists. i.e. dims=[[N],[N]]""); if np.prod(dims[0]) != N1 or np.prod(dims[1]) != N2:; raise ValueError(""Qobj dimensions must match matrix shape.""); if len(dims[0]) != len(dims[1]):; raise TypeError(""Qobj dimension components must have same length.""). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/random_objects.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/random_objects.html
https://qutip.org/docs/4.6/modules/qutip/random_objects.html:17754,Safety,avoid,avoid,17754,": list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[[N],[N]], [[N],[N]]]. Returns; -------; rho : Qobj; A superoperator acting on vectorized dim × dim density operators,; sampled from the BCSZ distribution.; """"""; if dims is not None:; # TODO: check!; pass; else:; dims = [[[N], [N]], [[N], [N]]]. if rank is None:; rank = N**2; if rank > N**2:; raise ValueError(""Rank cannot exceed superoperator dimension.""). # We use mainly dense matrices here for speed in low; # dimensions. In the future, it would likely be better to switch off; # between sparse and dense matrices as the dimension grows. # We start with a Ginibre uniform matrix X of the appropriate rank,; # and use it to construct a positive semidefinite matrix X X⁺.; X = randnz((N**2, rank), norm='ginibre', seed=seed). # Precompute X X⁺, as we'll need it in two different places.; XXdag = np.dot(X, X.T.conj()). if enforce_tp:; # We do the partial trace over the first index by using dense reshape; # operations, so that we can avoid bouncing to a sparse representation; # and back.; Y = np.einsum('ijik->jk', XXdag.reshape((N, N, N, N))). # Now we have the matrix 𝟙 ⊗ Y^{-1/2}, which we can find by doing; # the square root and the inverse separately. As a possible; # improvement, iterative methods exist to find inverse square root; # matrices directly, as this is important in statistics.; Z = np.kron(; np.eye(N),; la.sqrtm(la.inv(Y)); ). # Finally, we dot everything together and pack it into a Qobj,; # marking the dimensions as that of a type=super (that is,; # with left and right compound indices, each representing; # left and right indices on the underlying Hilbert space).; D = Qobj(np.dot(Z, np.dot(XXdag, Z))); else:; D = N * Qobj(XXdag / np.trace(XXdag)). D.dims = [; # Left dims; [[N], [N]],; # Right dims; [[N], [N]]; ]. # Since [BCSZ08] gives a row-stacking Choi matrix, but QuTiP; # expects a column-stacking Choi matrix, we must permute the indices.; D = D.permute([[1], [0]])",MatchSource.WIKI,docs/4.6/modules/qutip/random_objects.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/random_objects.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:3886,Availability,error,error,3886,"e # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperat",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:8688,Deployability,install,installed,8688,"r k in range(len(c_ops)):; if isinstance(c_ops[k], Qobj):; c_const.append(k); elif isinstance(c_ops[k], list):; if len(c_ops[k]) != 2:; raise TypeError(; ""Incorrect collapse operator specification.""); else:; if isinstance(c_ops[k][1], (FunctionType,; BuiltinFunctionType, partial)):; c_func.append(k); elif isinstance(c_ops[k][1], str):; c_str.append(k); elif isinstance(c_ops[k][1], Cubic_Spline):; c_obj.append(k); elif hasattr(c_ops[k][1], '__call__'):; c_func.append(k); elif isinstance(c_ops[k][1], np.ndarray):; c_str.append(k); elif isinstance(c_ops[k][1], tuple):; c_str.append(k); else:; raise TypeError(; ""Incorrect collapse operator specification""); else:; raise TypeError(""Incorrect collapse operator specification""). #; # if n_str == 0 and n_func == 0:; # # no time-dependence at all; #; if ((len(h_str) > 0 and len(h_func) > 0) or; (len(c_str) > 0 and len(c_func) > 0)):; raise TypeError(; ""Cannot mix string and function type time-dependence formats""). # check to see if Cython is installed and version is high enough.; if len(h_str) > 0 or len(c_str) > 0:; pass; #try:; # import Cython; #except:; # raise Exception(; # ""Unable to load Cython. Use Python function format.""); #else:; # if Cython.__version__ < '0.21':; # raise Exception(""Cython version (%s) is too old. Upgrade to"" +; # "" version 0.21+"" % Cython.__version__). # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; c_str += c_obj; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj. #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)). elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; ",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:11670,Deployability,update,update,11670,"dence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):; c_ops_new = c_ops; else:; for ck in c_ops:; if isinstance(ck, list) and isinstance(ck[1], np.ndarray):; c_op, c_td = ck; td_array_name = ""_td_array_%d"" % n; c_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = c_td; c_ops_new.append([c_op, c_td_str]); n += 1; else:; c_ops_new.append(ck). if not args_new:; args_new = args; elif isinstance(args, dict):; args_new.update(args); else:; raise ValueError(""Time-dependent array format requires args to "" +; ""be a dictionary""). return H_new, c_ops_new, args_new. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:12002,Deployability,update,updated,12002,"dence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):; c_ops_new = c_ops; else:; for ck in c_ops:; if isinstance(ck, list) and isinstance(ck[1], np.ndarray):; c_op, c_td = ck; td_array_name = ""_td_array_%d"" % n; c_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = c_td; c_ops_new.append([c_op, c_td_str]); n += 1; else:; c_ops_new.append(ck). if not args_new:; args_new = args; elif isinstance(args, dict):; args_new.update(args); else:; raise ValueError(""Time-dependent array format requires args to "" +; ""be a dictionary""). return H_new, c_ops_new, args_new. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:2522,Integrability,depend,dependent,2522,"T; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of co",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:2665,Integrability,depend,dependent,2665,"T OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name o",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:3559,Integrability,depend,dependent,3559," ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator"").",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:4275,Integrability,depend,dependence,4275," name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). else:; raise TypeError(msg + ""expected string format""). # loop over all collapse operators; for c_spec in c_ops:; if isinstance(c_spec, Qobj):; c = c_spec. if not isinstance(c, Qobj):; raise TypeError(msg + ""expected Qobj""). if c.isoper:; c",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:6674,Integrability,depend,dependent,6674,"()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append(k); elif hasattr(H_k[1], '__call__'):; h_obj.append(k); elif isinstance(H_k[1], np.ndarray):; h_str.append(k); else:; raise TypeError(""Incorrect hamiltonian specification""); else:; raise TypeError(""Incorrect hamiltonian specification""). # the the whole thing again for c_ops; c_const = []; c_func = []; c_str = []; ",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:8471,Integrability,depend,dependence,8471,"t hamiltonian specification""). # the the whole thing again for c_ops; c_const = []; c_func = []; c_str = []; c_obj = []; if isinstance(c_ops, list):; for k in range(len(c_ops)):; if isinstance(c_ops[k], Qobj):; c_const.append(k); elif isinstance(c_ops[k], list):; if len(c_ops[k]) != 2:; raise TypeError(; ""Incorrect collapse operator specification.""); else:; if isinstance(c_ops[k][1], (FunctionType,; BuiltinFunctionType, partial)):; c_func.append(k); elif isinstance(c_ops[k][1], str):; c_str.append(k); elif isinstance(c_ops[k][1], Cubic_Spline):; c_obj.append(k); elif hasattr(c_ops[k][1], '__call__'):; c_func.append(k); elif isinstance(c_ops[k][1], np.ndarray):; c_str.append(k); elif isinstance(c_ops[k][1], tuple):; c_str.append(k); else:; raise TypeError(; ""Incorrect collapse operator specification""); else:; raise TypeError(""Incorrect collapse operator specification""). #; # if n_str == 0 and n_func == 0:; # # no time-dependence at all; #; if ((len(h_str) > 0 and len(h_func) > 0) or; (len(c_str) > 0 and len(c_func) > 0)):; raise TypeError(; ""Cannot mix string and function type time-dependence formats""). # check to see if Cython is installed and version is high enough.; if len(h_str) > 0 or len(c_str) > 0:; pass; #try:; # import Cython; #except:; # raise Exception(; # ""Unable to load Cython. Use Python function format.""); #else:; # if Cython.__version__ < '0.21':; # raise Exception(""Cython version (%s) is too old. Upgrade to"" +; # "" version 0.21+"" % Cython.__version__). # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; c_str += c_obj; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj. #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str)",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:8638,Integrability,depend,dependence,8638,"t hamiltonian specification""). # the the whole thing again for c_ops; c_const = []; c_func = []; c_str = []; c_obj = []; if isinstance(c_ops, list):; for k in range(len(c_ops)):; if isinstance(c_ops[k], Qobj):; c_const.append(k); elif isinstance(c_ops[k], list):; if len(c_ops[k]) != 2:; raise TypeError(; ""Incorrect collapse operator specification.""); else:; if isinstance(c_ops[k][1], (FunctionType,; BuiltinFunctionType, partial)):; c_func.append(k); elif isinstance(c_ops[k][1], str):; c_str.append(k); elif isinstance(c_ops[k][1], Cubic_Spline):; c_obj.append(k); elif hasattr(c_ops[k][1], '__call__'):; c_func.append(k); elif isinstance(c_ops[k][1], np.ndarray):; c_str.append(k); elif isinstance(c_ops[k][1], tuple):; c_str.append(k); else:; raise TypeError(; ""Incorrect collapse operator specification""); else:; raise TypeError(""Incorrect collapse operator specification""). #; # if n_str == 0 and n_func == 0:; # # no time-dependence at all; #; if ((len(h_str) > 0 and len(h_func) > 0) or; (len(c_str) > 0 and len(c_func) > 0)):; raise TypeError(; ""Cannot mix string and function type time-dependence formats""). # check to see if Cython is installed and version is high enough.; if len(h_str) > 0 or len(c_str) > 0:; pass; #try:; # import Cython; #except:; # raise Exception(; # ""Unable to load Cython. Use Python function format.""); #else:; # if Cython.__version__ < '0.21':; # raise Exception(""Cython version (%s) is too old. Upgrade to"" +; # "" version 0.21+"" % Cython.__version__). # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; c_str += c_obj; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj. #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str)",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:9048,Integrability,depend,dependence,9048,"[k][1], np.ndarray):; c_str.append(k); elif isinstance(c_ops[k][1], tuple):; c_str.append(k); else:; raise TypeError(; ""Incorrect collapse operator specification""); else:; raise TypeError(""Incorrect collapse operator specification""). #; # if n_str == 0 and n_func == 0:; # # no time-dependence at all; #; if ((len(h_str) > 0 and len(h_func) > 0) or; (len(c_str) > 0 and len(c_func) > 0)):; raise TypeError(; ""Cannot mix string and function type time-dependence formats""). # check to see if Cython is installed and version is high enough.; if len(h_str) > 0 or len(c_str) > 0:; pass; #try:; # import Cython; #except:; # raise Exception(; # ""Unable to load Cython. Use Python function format.""); #else:; # if Cython.__version__ < '0.21':; # raise Exception(""Cython version (%s) is too old. Upgrade to"" +; # "" version 0.21+"" % Cython.__version__). # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; c_str += c_obj; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj. #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)). elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str)",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:9910,Integrability,depend,dependent,9910," version 0.21+"" % Cython.__version__). # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; c_str += c_obj; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj. #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)). elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:10098,Integrability,depend,dependence,10098," version 0.21+"" % Cython.__version__). # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; c_str += c_obj; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj. #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)). elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:10298,Integrability,depend,dependence,10298,"ects; c_str += c_obj; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj. #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)). elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:10511,Integrability,depend,dependence,10511,"en(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)). elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):; c_ops_new = c_ops; else:; for ck in c_ops:; if isinstance(ck, list) and isinstance(ck[1], np.ndarray):; c_op, c_td = ck; td_array_name = ""_td_array_%d"" % n; c_td_str = '(0 if (t > %f) else %s[int(round(%d",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:10677,Integrability,depend,dependence,10677," #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):; c_ops_new = c_ops; else:; for ck in c_ops:; if isinstance(ck, list) and isinstance(ck[1], np.ndarray):; c_op, c_td = ck; td_array_name = ""_td_array_%d"" % n; c_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = c_td; c_ops_new.append([c_op, c_td_str]); n += 1; else:; c_ops_new.append(ck). if not args_new:; args_new = args; elif isinstance(args, dict):; args_new.update(args); else:; ",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:10713,Integrability,depend,dependence,10713," #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):; c_ops_new = c_ops; else:; for ck in c_ops:; if isinstance(ck, list) and isinstance(ck[1], np.ndarray):; c_op, c_td = ck; td_array_name = ""_td_array_%d"" % n; c_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = c_td; c_ops_new.append([c_op, c_td_str]); n += 1; else:; c_ops_new.append(ck). if not args_new:; args_new = args; elif isinstance(args, dict):; args_new.update(args); else:; ",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:11714,Integrability,depend,dependent,11714,"dence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):; c_ops_new = c_ops; else:; for ck in c_ops:; if isinstance(ck, list) and isinstance(ck[1], np.ndarray):; c_op, c_td = ck; td_array_name = ""_td_array_%d"" % n; c_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = c_td; c_ops_new.append([c_op, c_td_str]); n += 1; else:; c_ops_new.append(ck). if not args_new:; args_new = args; elif isinstance(args, dict):; args_new.update(args); else:; raise ValueError(""Time-dependent array format requires args to "" +; ""be a dictionary""). return H_new, c_ops_new, args_new. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:2324,Modifiability,config,config,2324,"PLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions ne",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:2638,Modifiability,config,config,2638,"QUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. option",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:2696,Modifiability,config,config,2696,"T OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name o",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:2753,Modifiability,config,config,2753,"SS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be au",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:2816,Modifiability,config,config,2816,"TY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function ",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:2883,Modifiability,config,config,2883,"GLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an ",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:2922,Modifiability,variab,variables,2922," OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.option",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:2956,Modifiability,config,config,2956," OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.option",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:3898,Modifiability,config,config,3898," None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices)",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:3914,Modifiability,config,config,3914,"tring of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:3950,Modifiability,config,config,3950,"solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_co",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:3979,Modifiability,config,config,3979," None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lob",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:4026,Modifiability,config,config,4026,"code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). ",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:6342,Modifiability,config,config,6342," * spre(cdc) \; - 0.5 * spost(cdc); elif c.issuper:; Lconst += c; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if not isinstance(c, Qobj):; raise TypeError(msg + ""expected Qobj""). if c.isoper:; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):;",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:6349,Modifiability,config,config,6349," * spre(cdc) \; - 0.5 * spost(cdc); elif c.issuper:; Lconst += c; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if not isinstance(c, Qobj):; raise TypeError(msg + ""expected Qobj""). if c.isoper:; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):;",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:6372,Modifiability,config,config,6372,"; Lconst += c; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if not isinstance(c, Qobj):; raise TypeError(msg + ""expected Qobj""). if c.isoper:; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append(k); elif hasattr(H_k[1], '__call__'):",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:6422,Modifiability,config,config,6422," + ""expected operator or superoperator""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if not isinstance(c, Qobj):; raise TypeError(msg + ""expected Qobj""). if c.isoper:; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append(k); elif hasattr(H_k[1], '__call__'):; h_obj.append(k); elif isinstance(H_k[1],",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:6508,Modifiability,config,config,6508,"c_spec[1]. if not isinstance(c, Qobj):; raise TypeError(msg + ""expected Qobj""). if c.isoper:; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append(k); elif hasattr(H_k[1], '__call__'):; h_obj.append(k); elif isinstance(H_k[1], np.ndarray):; h_str.append(k); else:; raise TypeError(""Incorrect hamiltonian specification""); els",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:6568,Modifiability,config,config,6568,"sg + ""expected Qobj""). if c.isoper:; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append(k); elif hasattr(H_k[1], '__call__'):; h_obj.append(k); elif isinstance(H_k[1], np.ndarray):; h_str.append(k); else:; raise TypeError(""Incorrect hamiltonian specification""); else:; raise TypeError(""Incorrect hamiltonian specification""",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:8838,Performance,load,load,8838,"_ops[k], list):; if len(c_ops[k]) != 2:; raise TypeError(; ""Incorrect collapse operator specification.""); else:; if isinstance(c_ops[k][1], (FunctionType,; BuiltinFunctionType, partial)):; c_func.append(k); elif isinstance(c_ops[k][1], str):; c_str.append(k); elif isinstance(c_ops[k][1], Cubic_Spline):; c_obj.append(k); elif hasattr(c_ops[k][1], '__call__'):; c_func.append(k); elif isinstance(c_ops[k][1], np.ndarray):; c_str.append(k); elif isinstance(c_ops[k][1], tuple):; c_str.append(k); else:; raise TypeError(; ""Incorrect collapse operator specification""); else:; raise TypeError(""Incorrect collapse operator specification""). #; # if n_str == 0 and n_func == 0:; # # no time-dependence at all; #; if ((len(h_str) > 0 and len(h_func) > 0) or; (len(c_str) > 0 and len(c_func) > 0)):; raise TypeError(; ""Cannot mix string and function type time-dependence formats""). # check to see if Cython is installed and version is high enough.; if len(h_str) > 0 or len(c_str) > 0:; pass; #try:; # import Cython; #except:; # raise Exception(; # ""Unable to load Cython. Use Python function format.""); #else:; # if Cython.__version__ < '0.21':; # raise Exception(""Cython version (%s) is too old. Upgrade to"" +; # "" version 0.21+"" % Cython.__version__). # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; c_str += c_obj; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj. #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)). elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; el",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:2612,Usability,clear,clears,2612,"QUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. option",MatchSource.WIKI,docs/4.6/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.6/modules/qutip/scattering.html:2277,Deployability,configurat,configuration,2277," SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; Photon scattering in quantum optical systems. This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875).; """"""; # Author: Ben Bartlett; # Contact: benbartlett@stanford.edu. import numpy as np; from itertools import product, combinations_with_replacement; from qutip import propagator, Options, basis, tensor, zero_ket, Qobj. __all__ = ['temporal_basis_vector',; 'temporal_scattered_state',; 'scattering_probability']. class Evolver:; """"""; A caching class which takes a Hamiltonian and a list of times to calculate; and memoize propagators for the system between any two times as demanded. Parameters; ----------; H : :class: qutip.Qobj or list; System-waveguide(s) Hamiltonian or effective Hamiltonian in `Qobj` or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is",MatchSource.WIKI,docs/4.6/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/scattering.html
https://qutip.org/docs/4.6/modules/qutip/scattering.html:11159,Deployability,integrat,integrated,11159,"]; else:; raise TypeError(""Hamiltonian must be Qobj or list-callback format""); else:; Heff = H. evolver = Evolver(Heff, tlist). all_emission_indices = combinations_with_replacement(range(T), n_emissions). if system_zero_state is None:; system_zero_state = psi0. # Compute <omega_tau> for all combinations of tau; for emission_indices in all_emission_indices:; # Consider unique partitionings of emission times into waveguides; partition = tuple(set(set_partition(emission_indices, W))); # Consider all possible partitionings of time bins by waveguide; for indices in partition:; taus = [[tlist[i] for i in wg_indices] for wg_indices in indices]; omega = photon_scattering_operator(evolver, c_ops, taus); phi_n_amp = system_zero_state.dag() * omega * psi0; # Add scatter amplitude times temporal basis to overall state; phi_n += phi_n_amp * temporal_basis_vector(indices, T). return phi_n. [docs]def scattering_probability(H, psi0, n_emissions, c_ops, tlist,; system_zero_state=None,; construct_effective_hamiltonian=True):; """"""; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters; ----------; H : :class: qutip.Qobj or list; System-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and; `c_ops`.; psi0 : :class: qutip.Qobj; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`.; n_emissions : int; Number of photons emitted by the system (into any combination of; waveguides).; c_ops : list; List of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`.; tlist : array_like; List of times for :math:`\\tau_i`. tlist should contain 0 and exceed; the pulse duration / temporal region of interest; tlist need not be; linearly spaced.; system_zer",MatchSource.WIKI,docs/4.6/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/scattering.html
https://qutip.org/docs/4.6/modules/qutip/scattering.html:13357,Deployability,integrat,integrate,13357," c_ops : list; List of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`.; tlist : array_like; List of times for :math:`\\tau_i`. tlist should contain 0 and exceed; the pulse duration / temporal region of interest; tlist need not be; linearly spaced.; system_zero_state : :class: qutip.Qobj; State representing zero excitations in the system. Defaults to; `basis(systemDims, 0)`.; construct_effective_hamiltonian : bool; Whether an effective Hamiltonian should be constructed from H and c_ops:; :math:`H_{eff} = H - \\frac{i}{2} \\sum_n \\sigma_n^\\dagger \\sigma_n`; Default: True. Returns; -------; scattering_prob : float; The probability of scattering n photons from the system over the time; range specified.; """"""; phi_n = temporal_scattered_state(H, psi0, n_emissions, c_ops, tlist,; system_zero_state,; construct_effective_hamiltonian); T = len(tlist); W = len(c_ops). # Compute <omega_tau> for all combinations of tau; all_emission_indices = combinations_with_replacement(range(T), n_emissions); probs = np.zeros([T] * n_emissions). # Project scattered state onto temporal basis; for emit_indices in all_emission_indices:; # Consider unique emission time partitionings; partition = tuple(set(set_partition(emit_indices, W))); # wg_indices_list = list(set_partition(indices, W)); for wg_indices in partition:; projector = temporal_basis_vector(wg_indices, T); amplitude = (projector.dag() * phi_n).full().item(); probs[emit_indices] += np.real(amplitude.conjugate() * amplitude). # Iteratively integrate to obtain single value; while probs.shape != ():; probs = np.trapz(probs, x = tlist); return np.abs(probs). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/scattering.html
https://qutip.org/docs/4.6/modules/qutip/scattering.html:13663,Deployability,update,updated,13663," c_ops : list; List of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`.; tlist : array_like; List of times for :math:`\\tau_i`. tlist should contain 0 and exceed; the pulse duration / temporal region of interest; tlist need not be; linearly spaced.; system_zero_state : :class: qutip.Qobj; State representing zero excitations in the system. Defaults to; `basis(systemDims, 0)`.; construct_effective_hamiltonian : bool; Whether an effective Hamiltonian should be constructed from H and c_ops:; :math:`H_{eff} = H - \\frac{i}{2} \\sum_n \\sigma_n^\\dagger \\sigma_n`; Default: True. Returns; -------; scattering_prob : float; The probability of scattering n photons from the system over the time; range specified.; """"""; phi_n = temporal_scattered_state(H, psi0, n_emissions, c_ops, tlist,; system_zero_state,; construct_effective_hamiltonian); T = len(tlist); W = len(c_ops). # Compute <omega_tau> for all combinations of tau; all_emission_indices = combinations_with_replacement(range(T), n_emissions); probs = np.zeros([T] * n_emissions). # Project scattered state onto temporal basis; for emit_indices in all_emission_indices:; # Consider unique emission time partitionings; partition = tuple(set(set_partition(emit_indices, W))); # wg_indices_list = list(set_partition(indices, W)); for wg_indices in partition:; projector = temporal_basis_vector(wg_indices, T); amplitude = (projector.dag() * phi_n).full().item(); probs[emit_indices] += np.real(amplitude.conjugate() * amplitude). # Iteratively integrate to obtain single value; while probs.shape != ():; probs = np.trapz(probs, x = tlist); return np.abs(probs). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/scattering.html
https://qutip.org/docs/4.6/modules/qutip/scattering.html:3507,Integrability,depend,dependent,3507,"stems (2017, arXiv:1710.02875).; """"""; # Author: Ben Bartlett; # Contact: benbartlett@stanford.edu. import numpy as np; from itertools import product, combinations_with_replacement; from qutip import propagator, Options, basis, tensor, zero_ket, Qobj. __all__ = ['temporal_basis_vector',; 'temporal_scattered_state',; 'scattering_probability']. class Evolver:; """"""; A caching class which takes a Hamiltonian and a list of times to calculate; and memoize propagators for the system between any two times as demanded. Parameters; ----------; H : :class: qutip.Qobj or list; System-waveguide(s) Hamiltonian or effective Hamiltonian in `Qobj` or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and c_ops.; times : list-like; List of times to evaluate propagators over.; options : :class: qutip.Options; Solver options to use when computing propagators. Attributes; ----------; H : :class: qutip.Qobj or list; System-waveguide(s) Hamiltonian, may be time-dependent.; tlist : list-like; List of times to evaluate propagators over.; propagators : (dict of float: (dict of float: :class: qutip.Qobj)); Dictionary of dictionaries of propagator objects with keys of; evaluation times, e.g. propagators[t2][t1] returns U[t2,t1].; """"""; def __init__(self, H, tlist, options=None):; self.H = H; self.tlist = tlist; if options is None:; self.options = Options(nsteps=10000, normalize_output=False); else:; self.options = options; # Make a blank nested dictionary to store propagators; self.propagators = dict.fromkeys(tlist); for t in tlist:; self.propagators[t] = dict.fromkeys(tlist). def prop(self, tf, ti):; """"""Compute U[t2,t1] where t2 > t1 or return the cached operator. Parameters; ----------; tf : float; Final time to compute the propagator U[tf, ti].; ti : float; Initial time to compute the propagator U[tf,ti]. Returns; -------; propagator : :class: qutip.Qobj; The propagation operator.; """"""; left, right = np.searchsorted(self.",MatchSource.WIKI,docs/4.6/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/scattering.html
https://qutip.org/docs/4.6/modules/qutip/scattering.html:5746,Integrability,wrap,wrapped,5746,"e #807); return self.propagators[t2][t1]. def set_partition(collection, num_sets):; """"""; Enumerate all ways of partitioning collection into num_sets different lists,; e.g. list(set_partition([1,2], 2)) = [[[1, 2], []], [[1], [2]], [[2], [1]],; [[], [1, 2]]]. Parameters; ----------; collection : iterable; Collection to generate a set partition of.; num_sets : int; Number of sets to partition collection into. Returns; -------; partition : iterable; The partitioning of collection into num_sets sets.; """"""; for partitioning in product(range(num_sets), repeat=len(collection)):; partition = [[] for _ in range(num_sets)]; for i, set_index in enumerate(partitioning):; partition[set_index].append(collection[i]); yield tuple(tuple(indices) for indices in partition). def photon_scattering_operator(evolver, c_ops, taus_list):; """"""; Compute the scattering operator for a system emitting into multiple; waveguides. Parameters; ----------; evolver : :class: qutip.scattering.Evolver; Evolver-wrapped Hamiltonian describing the system.; c_ops : list; list of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`; taus_list : list-like; List of (list of emission times) for each waveguide. Returns; -------; omega : :class: qutip.Qobj; The temporal scattering operator with dimensionality equal to the; system state.; """"""; omega = 1. # Extract the full list of taus; taus = [(0.0, -1)] # temporal ""ground state"" for arbitrary waveguide; for i, tau_wg in enumerate(taus_list):; for tau in tau_wg:; taus.append((tau, i)); taus.sort(key = lambda tup: tup[0]) # sort taus by time. # Compute Prod Ueff(tq, tq-1); for i in range(1, len(taus)):; tq, q = taus[i]; tprev, _ = taus[i - 1]; omega = c_ops[q] * evolver.prop(tq, tprev) * omega. # Add the <0|Uff(TP, tm)|0> term; tmax = evolver.tlist[-1]; taumax, _ = taus[-1]; # if taus[-1] < tmax:; omega = evolver.prop(tmax, taumax) * omega. return omega. [docs]def temporal_basi",MatchSource.WIKI,docs/4.6/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/scattering.html
https://qutip.org/docs/4.6/modules/qutip/scattering.html:11159,Integrability,integrat,integrated,11159,"]; else:; raise TypeError(""Hamiltonian must be Qobj or list-callback format""); else:; Heff = H. evolver = Evolver(Heff, tlist). all_emission_indices = combinations_with_replacement(range(T), n_emissions). if system_zero_state is None:; system_zero_state = psi0. # Compute <omega_tau> for all combinations of tau; for emission_indices in all_emission_indices:; # Consider unique partitionings of emission times into waveguides; partition = tuple(set(set_partition(emission_indices, W))); # Consider all possible partitionings of time bins by waveguide; for indices in partition:; taus = [[tlist[i] for i in wg_indices] for wg_indices in indices]; omega = photon_scattering_operator(evolver, c_ops, taus); phi_n_amp = system_zero_state.dag() * omega * psi0; # Add scatter amplitude times temporal basis to overall state; phi_n += phi_n_amp * temporal_basis_vector(indices, T). return phi_n. [docs]def scattering_probability(H, psi0, n_emissions, c_ops, tlist,; system_zero_state=None,; construct_effective_hamiltonian=True):; """"""; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters; ----------; H : :class: qutip.Qobj or list; System-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and; `c_ops`.; psi0 : :class: qutip.Qobj; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`.; n_emissions : int; Number of photons emitted by the system (into any combination of; waveguides).; c_ops : list; List of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`.; tlist : array_like; List of times for :math:`\\tau_i`. tlist should contain 0 and exceed; the pulse duration / temporal region of interest; tlist need not be; linearly spaced.; system_zer",MatchSource.WIKI,docs/4.6/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/scattering.html
https://qutip.org/docs/4.6/modules/qutip/scattering.html:13357,Integrability,integrat,integrate,13357," c_ops : list; List of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`.; tlist : array_like; List of times for :math:`\\tau_i`. tlist should contain 0 and exceed; the pulse duration / temporal region of interest; tlist need not be; linearly spaced.; system_zero_state : :class: qutip.Qobj; State representing zero excitations in the system. Defaults to; `basis(systemDims, 0)`.; construct_effective_hamiltonian : bool; Whether an effective Hamiltonian should be constructed from H and c_ops:; :math:`H_{eff} = H - \\frac{i}{2} \\sum_n \\sigma_n^\\dagger \\sigma_n`; Default: True. Returns; -------; scattering_prob : float; The probability of scattering n photons from the system over the time; range specified.; """"""; phi_n = temporal_scattered_state(H, psi0, n_emissions, c_ops, tlist,; system_zero_state,; construct_effective_hamiltonian); T = len(tlist); W = len(c_ops). # Compute <omega_tau> for all combinations of tau; all_emission_indices = combinations_with_replacement(range(T), n_emissions); probs = np.zeros([T] * n_emissions). # Project scattered state onto temporal basis; for emit_indices in all_emission_indices:; # Consider unique emission time partitionings; partition = tuple(set(set_partition(emit_indices, W))); # wg_indices_list = list(set_partition(indices, W)); for wg_indices in partition:; projector = temporal_basis_vector(wg_indices, T); amplitude = (projector.dag() * phi_n).full().item(); probs[emit_indices] += np.real(amplitude.conjugate() * amplitude). # Iteratively integrate to obtain single value; while probs.shape != ():; probs = np.trapz(probs, x = tlist); return np.abs(probs). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/scattering.html
https://qutip.org/docs/4.6/modules/qutip/scattering.html:2277,Modifiability,config,configuration,2277," SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; Photon scattering in quantum optical systems. This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875).; """"""; # Author: Ben Bartlett; # Contact: benbartlett@stanford.edu. import numpy as np; from itertools import product, combinations_with_replacement; from qutip import propagator, Options, basis, tensor, zero_ket, Qobj. __all__ = ['temporal_basis_vector',; 'temporal_scattered_state',; 'scattering_probability']. class Evolver:; """"""; A caching class which takes a Hamiltonian and a list of times to calculate; and memoize propagators for the system between any two times as demanded. Parameters; ----------; H : :class: qutip.Qobj or list; System-waveguide(s) Hamiltonian or effective Hamiltonian in `Qobj` or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is",MatchSource.WIKI,docs/4.6/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/scattering.html
https://qutip.org/docs/4.6/modules/qutip/scattering.html:5555,Modifiability,evolve,evolver,5555,"; self.propagators[t2][t1] = propagator(self.H, [t1, t2],; options=self.options,; unitary_mode='single'); # Something is still broken about batch unitary mode (see #807); return self.propagators[t2][t1]. def set_partition(collection, num_sets):; """"""; Enumerate all ways of partitioning collection into num_sets different lists,; e.g. list(set_partition([1,2], 2)) = [[[1, 2], []], [[1], [2]], [[2], [1]],; [[], [1, 2]]]. Parameters; ----------; collection : iterable; Collection to generate a set partition of.; num_sets : int; Number of sets to partition collection into. Returns; -------; partition : iterable; The partitioning of collection into num_sets sets.; """"""; for partitioning in product(range(num_sets), repeat=len(collection)):; partition = [[] for _ in range(num_sets)]; for i, set_index in enumerate(partitioning):; partition[set_index].append(collection[i]); yield tuple(tuple(indices) for indices in partition). def photon_scattering_operator(evolver, c_ops, taus_list):; """"""; Compute the scattering operator for a system emitting into multiple; waveguides. Parameters; ----------; evolver : :class: qutip.scattering.Evolver; Evolver-wrapped Hamiltonian describing the system.; c_ops : list; list of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`; taus_list : list-like; List of (list of emission times) for each waveguide. Returns; -------; omega : :class: qutip.Qobj; The temporal scattering operator with dimensionality equal to the; system state.; """"""; omega = 1. # Extract the full list of taus; taus = [(0.0, -1)] # temporal ""ground state"" for arbitrary waveguide; for i, tau_wg in enumerate(taus_list):; for tau in tau_wg:; taus.append((tau, i)); taus.sort(key = lambda tup: tup[0]) # sort taus by time. # Compute Prod Ueff(tq, tq-1); for i in range(1, len(taus)):; tq, q = taus[i]; tprev, _ = taus[i - 1]; omega = c_ops[q] * evolver.prop(tq, tprev) * omega. # Add the <0|Uff(TP, tm",MatchSource.WIKI,docs/4.6/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/scattering.html
https://qutip.org/docs/4.6/modules/qutip/scattering.html:5694,Modifiability,evolve,evolver,5694,"ingle'); # Something is still broken about batch unitary mode (see #807); return self.propagators[t2][t1]. def set_partition(collection, num_sets):; """"""; Enumerate all ways of partitioning collection into num_sets different lists,; e.g. list(set_partition([1,2], 2)) = [[[1, 2], []], [[1], [2]], [[2], [1]],; [[], [1, 2]]]. Parameters; ----------; collection : iterable; Collection to generate a set partition of.; num_sets : int; Number of sets to partition collection into. Returns; -------; partition : iterable; The partitioning of collection into num_sets sets.; """"""; for partitioning in product(range(num_sets), repeat=len(collection)):; partition = [[] for _ in range(num_sets)]; for i, set_index in enumerate(partitioning):; partition[set_index].append(collection[i]); yield tuple(tuple(indices) for indices in partition). def photon_scattering_operator(evolver, c_ops, taus_list):; """"""; Compute the scattering operator for a system emitting into multiple; waveguides. Parameters; ----------; evolver : :class: qutip.scattering.Evolver; Evolver-wrapped Hamiltonian describing the system.; c_ops : list; list of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`; taus_list : list-like; List of (list of emission times) for each waveguide. Returns; -------; omega : :class: qutip.Qobj; The temporal scattering operator with dimensionality equal to the; system state.; """"""; omega = 1. # Extract the full list of taus; taus = [(0.0, -1)] # temporal ""ground state"" for arbitrary waveguide; for i, tau_wg in enumerate(taus_list):; for tau in tau_wg:; taus.append((tau, i)); taus.sort(key = lambda tup: tup[0]) # sort taus by time. # Compute Prod Ueff(tq, tq-1); for i in range(1, len(taus)):; tq, q = taus[i]; tprev, _ = taus[i - 1]; omega = c_ops[q] * evolver.prop(tq, tprev) * omega. # Add the <0|Uff(TP, tm)|0> term; tmax = evolver.tlist[-1]; taumax, _ = taus[-1]; # if taus[-1] < tmax:; omega = evolver.",MatchSource.WIKI,docs/4.6/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/scattering.html
https://qutip.org/docs/4.6/modules/qutip/scattering.html:6540,Modifiability,evolve,evolver,6540,"tuple(indices) for indices in partition). def photon_scattering_operator(evolver, c_ops, taus_list):; """"""; Compute the scattering operator for a system emitting into multiple; waveguides. Parameters; ----------; evolver : :class: qutip.scattering.Evolver; Evolver-wrapped Hamiltonian describing the system.; c_ops : list; list of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`; taus_list : list-like; List of (list of emission times) for each waveguide. Returns; -------; omega : :class: qutip.Qobj; The temporal scattering operator with dimensionality equal to the; system state.; """"""; omega = 1. # Extract the full list of taus; taus = [(0.0, -1)] # temporal ""ground state"" for arbitrary waveguide; for i, tau_wg in enumerate(taus_list):; for tau in tau_wg:; taus.append((tau, i)); taus.sort(key = lambda tup: tup[0]) # sort taus by time. # Compute Prod Ueff(tq, tq-1); for i in range(1, len(taus)):; tq, q = taus[i]; tprev, _ = taus[i - 1]; omega = c_ops[q] * evolver.prop(tq, tprev) * omega. # Add the <0|Uff(TP, tm)|0> term; tmax = evolver.tlist[-1]; taumax, _ = taus[-1]; # if taus[-1] < tmax:; omega = evolver.prop(tmax, taumax) * omega. return omega. [docs]def temporal_basis_vector(waveguide_emission_indices, n_time_bins):; """"""; Generate a temporal basis vector for emissions at specified time bins into; specified waveguides. Parameters; ----------; waveguide_emission_indices : list or tuple; List of indices where photon emission occurs for each waveguide,; e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4, t2_wg4, t3_wg4]].; n_time_bins : int; Number of time bins; the range over which each index can vary. Returns; -------; temporal_basis_vector : :class: qutip.Qobj; A basis vector representing photon scattering at the specified indices.; If there are W waveguides, T times, and N photon emissions, then the; basis vector has dimensionality (W*T)^N.; """"""; # Cast waveguide_emission_indices t",MatchSource.WIKI,docs/4.6/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/scattering.html
https://qutip.org/docs/4.6/modules/qutip/scattering.html:6614,Modifiability,evolve,evolver,6614,"the scattering operator for a system emitting into multiple; waveguides. Parameters; ----------; evolver : :class: qutip.scattering.Evolver; Evolver-wrapped Hamiltonian describing the system.; c_ops : list; list of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`; taus_list : list-like; List of (list of emission times) for each waveguide. Returns; -------; omega : :class: qutip.Qobj; The temporal scattering operator with dimensionality equal to the; system state.; """"""; omega = 1. # Extract the full list of taus; taus = [(0.0, -1)] # temporal ""ground state"" for arbitrary waveguide; for i, tau_wg in enumerate(taus_list):; for tau in tau_wg:; taus.append((tau, i)); taus.sort(key = lambda tup: tup[0]) # sort taus by time. # Compute Prod Ueff(tq, tq-1); for i in range(1, len(taus)):; tq, q = taus[i]; tprev, _ = taus[i - 1]; omega = c_ops[q] * evolver.prop(tq, tprev) * omega. # Add the <0|Uff(TP, tm)|0> term; tmax = evolver.tlist[-1]; taumax, _ = taus[-1]; # if taus[-1] < tmax:; omega = evolver.prop(tmax, taumax) * omega. return omega. [docs]def temporal_basis_vector(waveguide_emission_indices, n_time_bins):; """"""; Generate a temporal basis vector for emissions at specified time bins into; specified waveguides. Parameters; ----------; waveguide_emission_indices : list or tuple; List of indices where photon emission occurs for each waveguide,; e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4, t2_wg4, t3_wg4]].; n_time_bins : int; Number of time bins; the range over which each index can vary. Returns; -------; temporal_basis_vector : :class: qutip.Qobj; A basis vector representing photon scattering at the specified indices.; If there are W waveguides, T times, and N photon emissions, then the; basis vector has dimensionality (W*T)^N.; """"""; # Cast waveguide_emission_indices to list for mutability; waveguide_emission_indices = [list(i) for i in waveguide_emission_indices]. # Calculate tot",MatchSource.WIKI,docs/4.6/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/scattering.html
https://qutip.org/docs/4.6/modules/qutip/scattering.html:6686,Modifiability,evolve,evolver,6686,"waveguides. Parameters; ----------; evolver : :class: qutip.scattering.Evolver; Evolver-wrapped Hamiltonian describing the system.; c_ops : list; list of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`; taus_list : list-like; List of (list of emission times) for each waveguide. Returns; -------; omega : :class: qutip.Qobj; The temporal scattering operator with dimensionality equal to the; system state.; """"""; omega = 1. # Extract the full list of taus; taus = [(0.0, -1)] # temporal ""ground state"" for arbitrary waveguide; for i, tau_wg in enumerate(taus_list):; for tau in tau_wg:; taus.append((tau, i)); taus.sort(key = lambda tup: tup[0]) # sort taus by time. # Compute Prod Ueff(tq, tq-1); for i in range(1, len(taus)):; tq, q = taus[i]; tprev, _ = taus[i - 1]; omega = c_ops[q] * evolver.prop(tq, tprev) * omega. # Add the <0|Uff(TP, tm)|0> term; tmax = evolver.tlist[-1]; taumax, _ = taus[-1]; # if taus[-1] < tmax:; omega = evolver.prop(tmax, taumax) * omega. return omega. [docs]def temporal_basis_vector(waveguide_emission_indices, n_time_bins):; """"""; Generate a temporal basis vector for emissions at specified time bins into; specified waveguides. Parameters; ----------; waveguide_emission_indices : list or tuple; List of indices where photon emission occurs for each waveguide,; e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4, t2_wg4, t3_wg4]].; n_time_bins : int; Number of time bins; the range over which each index can vary. Returns; -------; temporal_basis_vector : :class: qutip.Qobj; A basis vector representing photon scattering at the specified indices.; If there are W waveguides, T times, and N photon emissions, then the; basis vector has dimensionality (W*T)^N.; """"""; # Cast waveguide_emission_indices to list for mutability; waveguide_emission_indices = [list(i) for i in waveguide_emission_indices]. # Calculate total number of waveguides; W = len(waveguide_emission_indices).",MatchSource.WIKI,docs/4.6/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/scattering.html
https://qutip.org/docs/4.6/modules/qutip/scattering.html:10214,Modifiability,evolve,evolver,10214,"h:`\\psi(t_0)`; construct_effective_hamiltonian : bool; Whether an effective Hamiltonian should be constructed from H and c_ops:; :math:`H_{eff} = H - \\frac{i}{2} \\sum_n \\sigma_n^\\dagger \\sigma_n`; Default: True. Returns; -------; phi_n : :class: qutip.Qobj; The scattered bath state projected onto the temporal basis given by; tlist. If there are W waveguides, T times, and N photon emissions, then; the state is a tensor product state with dimensionality T^(W*N).; """"""; T = len(tlist); W = len(c_ops). if n_emissions == 0:; phi_n = zero_ket(W * T); else:; phi_n = tensor([zero_ket(W * T)] * n_emissions). if construct_effective_hamiltonian:; # Construct an effective Hamiltonian from system hamiltonian and c_ops; if isinstance(H, Qobj):; Heff = H - 1j / 2 * sum([op.dag() * op for op in c_ops]); elif isinstance(H, list):; Heff = H + [-1j / 2 * sum([op.dag() * op for op in c_ops])]; else:; raise TypeError(""Hamiltonian must be Qobj or list-callback format""); else:; Heff = H. evolver = Evolver(Heff, tlist). all_emission_indices = combinations_with_replacement(range(T), n_emissions). if system_zero_state is None:; system_zero_state = psi0. # Compute <omega_tau> for all combinations of tau; for emission_indices in all_emission_indices:; # Consider unique partitionings of emission times into waveguides; partition = tuple(set(set_partition(emission_indices, W))); # Consider all possible partitionings of time bins by waveguide; for indices in partition:; taus = [[tlist[i] for i in wg_indices] for wg_indices in indices]; omega = photon_scattering_operator(evolver, c_ops, taus); phi_n_amp = system_zero_state.dag() * omega * psi0; # Add scatter amplitude times temporal basis to overall state; phi_n += phi_n_amp * temporal_basis_vector(indices, T). return phi_n. [docs]def scattering_probability(H, psi0, n_emissions, c_ops, tlist,; system_zero_state=None,; construct_effective_hamiltonian=True):; """"""; Compute the integrated probability of scattering n photons in an arbitrary; system",MatchSource.WIKI,docs/4.6/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/scattering.html
https://qutip.org/docs/4.6/modules/qutip/scattering.html:10799,Modifiability,evolve,evolver,10799,"on emissions, then; the state is a tensor product state with dimensionality T^(W*N).; """"""; T = len(tlist); W = len(c_ops). if n_emissions == 0:; phi_n = zero_ket(W * T); else:; phi_n = tensor([zero_ket(W * T)] * n_emissions). if construct_effective_hamiltonian:; # Construct an effective Hamiltonian from system hamiltonian and c_ops; if isinstance(H, Qobj):; Heff = H - 1j / 2 * sum([op.dag() * op for op in c_ops]); elif isinstance(H, list):; Heff = H + [-1j / 2 * sum([op.dag() * op for op in c_ops])]; else:; raise TypeError(""Hamiltonian must be Qobj or list-callback format""); else:; Heff = H. evolver = Evolver(Heff, tlist). all_emission_indices = combinations_with_replacement(range(T), n_emissions). if system_zero_state is None:; system_zero_state = psi0. # Compute <omega_tau> for all combinations of tau; for emission_indices in all_emission_indices:; # Consider unique partitionings of emission times into waveguides; partition = tuple(set(set_partition(emission_indices, W))); # Consider all possible partitionings of time bins by waveguide; for indices in partition:; taus = [[tlist[i] for i in wg_indices] for wg_indices in indices]; omega = photon_scattering_operator(evolver, c_ops, taus); phi_n_amp = system_zero_state.dag() * omega * psi0; # Add scatter amplitude times temporal basis to overall state; phi_n += phi_n_amp * temporal_basis_vector(indices, T). return phi_n. [docs]def scattering_probability(H, psi0, n_emissions, c_ops, tlist,; system_zero_state=None,; construct_effective_hamiltonian=True):; """"""; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters; ----------; H : :class: qutip.Qobj or list; System-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and; `c_ops`.; psi0 : :class: qutip.Qobj; Initial state density matrix :math:`",MatchSource.WIKI,docs/4.6/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/scattering.html
https://qutip.org/docs/4.6/modules/qutip/scattering.html:4202,Performance,cache,cached,4202,"ltonian is not; specified, an effective Hamiltonian is constructed from H and c_ops.; times : list-like; List of times to evaluate propagators over.; options : :class: qutip.Options; Solver options to use when computing propagators. Attributes; ----------; H : :class: qutip.Qobj or list; System-waveguide(s) Hamiltonian, may be time-dependent.; tlist : list-like; List of times to evaluate propagators over.; propagators : (dict of float: (dict of float: :class: qutip.Qobj)); Dictionary of dictionaries of propagator objects with keys of; evaluation times, e.g. propagators[t2][t1] returns U[t2,t1].; """"""; def __init__(self, H, tlist, options=None):; self.H = H; self.tlist = tlist; if options is None:; self.options = Options(nsteps=10000, normalize_output=False); else:; self.options = options; # Make a blank nested dictionary to store propagators; self.propagators = dict.fromkeys(tlist); for t in tlist:; self.propagators[t] = dict.fromkeys(tlist). def prop(self, tf, ti):; """"""Compute U[t2,t1] where t2 > t1 or return the cached operator. Parameters; ----------; tf : float; Final time to compute the propagator U[tf, ti].; ti : float; Initial time to compute the propagator U[tf,ti]. Returns; -------; propagator : :class: qutip.Qobj; The propagation operator.; """"""; left, right = np.searchsorted(self.tlist, [ti, tf], side='left'); t1, t2 = self.tlist[left], self.tlist[right]; if self.propagators[t2][t1] is None:; self.propagators[t2][t1] = propagator(self.H, [t1, t2],; options=self.options,; unitary_mode='single'); # Something is still broken about batch unitary mode (see #807); return self.propagators[t2][t1]. def set_partition(collection, num_sets):; """"""; Enumerate all ways of partitioning collection into num_sets different lists,; e.g. list(set_partition([1,2], 2)) = [[[1, 2], []], [[1], [2]], [[2], [1]],; [[], [1, 2]]]. Parameters; ----------; collection : iterable; Collection to generate a set partition of.; num_sets : int; Number of sets to partition collection into. Retu",MatchSource.WIKI,docs/4.6/modules/qutip/scattering.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/scattering.html
https://qutip.org/docs/4.6/modules/qutip/sesolve.html:11200,Availability,error,error,11200," op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); if oper_evo:; for e in e_ops:; if e.dims[1] != psi0.dims[0]:; raise TypeError(f""e_ops dims ({e.dims}) are not compatible""; f"" with the state's ({psi0.dims})""); else:; e_ops_data.append(e.dag().data); else:; for e in e_ops:; if e.dims[1] != psi0.dims[0]:; raise TypeError(f""e_ops dims ({e.dims}) are not compatible""; f"" with the state's ({psi0.dims})""); else:; e_ops_data.append(e.data); else:; raise TypeError(""Expectation parameter must be a list or a function""). if opt.store_states:; output.states = []. if oper_evo:; def get_curr_state_data(r):; return vec2mat(r.y); else:; def get_curr_state_data(r):; return r.y. #; # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""); # get the current state / oper data if needed; if opt.store_states or opt.normalize_output or n_expt_op > 0 or expt_callback:; cdata = get_curr_state_data(r). if opt.normalize_output:; # normalize per column; if oper_evo:; cdata /= la_norm(cdata, axis=0); #cdata *= norm_dim_factor / la_norm(cdata); r.set_initial_value(cdata.ravel('F'), r.t); else:; #cdata /= la_norm(cdata); norm = normalize_inplace(cdata); if norm > 1e-12:; # only reset the solver if state changed; r.set_initial_value(cdata, r.t); else:; r._y = cdata. if opt.store_states:; if oper_evo:; fdata = dense2D_to_fastcsr_fmode(cdata, size, size); output.states.append(Qobj(fdata, dims=dims)); else:; fdata = dense1D_to_fastcsr_ket(cdata); output.states.append(Qobj(fdata, dims=dims, fast='mc')). if expt_callback:; # use callback method; output.expect.append(e_ops(t, Qobj(cdata, dims=dims))). if oper_evo:; for m in range(n_expt_op):; output.expe",MatchSource.WIKI,docs/4.6/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/sesolve.html
https://qutip.org/docs/4.6/modules/qutip/sesolve.html:2240,Deployability,integrat,integrate,2240,"IGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the unitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; import numpy as np; import scipy.integrate; from scipy.linalg import norm as la_norm; from qutip.cy.stochastic import normalize_inplace; import qutip.settings as qset; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.cy.spconvert import dense1D_to_fastcsr_ket, dense2D_to_fastcsr_fmode; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.solver import Result, Options, config, solver_safe, SolverSystem; from qutip.superoperator import vec2mat; from qutip.ui.progressbar import (BaseProgressBar, TextProgressBar); from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. [docs]def sesolve(H, psi0, tlist, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian. Evolve the state vector (``psi0``) using a given Hamiltonian (``H``), by; integrating the set of ordinary differential equations that define the; system. Altern",MatchSource.WIKI,docs/4.6/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/sesolve.html
https://qutip.org/docs/4.6/modules/qutip/sesolve.html:3165,Deployability,integrat,integrating,3165,"= ['sesolve']. import os; import types; import numpy as np; import scipy.integrate; from scipy.linalg import norm as la_norm; from qutip.cy.stochastic import normalize_inplace; import qutip.settings as qset; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.cy.spconvert import dense1D_to_fastcsr_ket, dense2D_to_fastcsr_fmode; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.solver import Result, Options, config, solver_safe, SolverSystem; from qutip.superoperator import vec2mat; from qutip.ui.progressbar import (BaseProgressBar, TextProgressBar); from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. [docs]def sesolve(H, psi0, tlist, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian. Evolve the state vector (``psi0``) using a given Hamiltonian (``H``), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If ``e_ops`` is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. ``e_ops`` cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters; ----------. H : :class:`~Qobj`, :class:`~QobjEvo`, list, or callable; System Hamiltonian as a :obj:`~Qobj , list of :obj:`Qobj` and; coefficient, :obj:`~QObjEvo`, or a callback function for time-dependent; Hamiltonians. List format and options can be found in QobjEvo's; description. psi0 : :class:`~Qobj`; Initial state vector (ket) or initial unitary operator ``psi0 = U``. tlist : array_like of float; ",MatchSource.WIKI,docs/4.6/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/sesolve.html
https://qutip.org/docs/4.6/modules/qutip/sesolve.html:9626,Deployability,integrat,integrate,9626,"eturn (H * ym).ravel(""F""). # -----------------------------------------------------------------------------; # Solve an ODE for func.; # Calculate the required expectation values or invoke callback; # function at each time step.; def _generic_ode_solve(func, ode_args, psi0, tlist, e_ops, opt,; progress_bar, dims=None):; """"""; Internal function for solving ODEs.; """"""; # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%; # This function is made similar to mesolve's one for futur merging in a; # solver class; # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%. # prepare output array; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if psi0.isunitary:; initial_vector = psi0.full().ravel('F'); oper_evo = True; size = psi0.shape[0]; # oper_n = dims[0][0]; # norm_dim_factor = np.sqrt(oper_n); elif psi0.isket:; initial_vector = psi0.full().ravel(); oper_evo = False; # norm_dim_factor = 1.0. r = scipy.integrate.ode(func); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); if ode_args:; r.set_f_params(*ode_args); r.set_initial_value(initial_vector, tlist[0]). e_ops_data = []; output.expect = []; if callable(e_ops):; n_expt_op = 0; expt_callback = True; output.num_expect = 1; elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False; output.num_expect = n_expt_op; if n_expt_op == 0:; # fallback on storing states; opt.store_states = True; else:; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); if oper_evo:; for e in e_ops:; if e.dims[1] != psi0.dims[0]:; raise TypeError(f""e_ops dims ({e.dims}) are not compatible""; f"" with the state's ({psi0.dims})""); else:; e_ops_data.append(e.dag().data); else:; for e in e_ops:; if e.dims[1] != psi0.dims[0]:; raise",MatchSource.WIKI,docs/4.6/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/sesolve.html
https://qutip.org/docs/4.6/modules/qutip/sesolve.html:11128,Deployability,update,update,11128,"_expt_op; if n_expt_op == 0:; # fallback on storing states; opt.store_states = True; else:; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); if oper_evo:; for e in e_ops:; if e.dims[1] != psi0.dims[0]:; raise TypeError(f""e_ops dims ({e.dims}) are not compatible""; f"" with the state's ({psi0.dims})""); else:; e_ops_data.append(e.dag().data); else:; for e in e_ops:; if e.dims[1] != psi0.dims[0]:; raise TypeError(f""e_ops dims ({e.dims}) are not compatible""; f"" with the state's ({psi0.dims})""); else:; e_ops_data.append(e.data); else:; raise TypeError(""Expectation parameter must be a list or a function""). if opt.store_states:; output.states = []. if oper_evo:; def get_curr_state_data(r):; return vec2mat(r.y); else:; def get_curr_state_data(r):; return r.y. #; # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""); # get the current state / oper data if needed; if opt.store_states or opt.normalize_output or n_expt_op > 0 or expt_callback:; cdata = get_curr_state_data(r). if opt.normalize_output:; # normalize per column; if oper_evo:; cdata /= la_norm(cdata, axis=0); #cdata *= norm_dim_factor / la_norm(cdata); r.set_initial_value(cdata.ravel('F'), r.t); else:; #cdata /= la_norm(cdata); norm = normalize_inplace(cdata); if norm > 1e-12:; # only reset the solver if state changed; r.set_initial_value(cdata, r.t); else:; r._y = cdata. if opt.store_states:; if oper_evo:; fdata = dense2D_to_fastcsr_fmode(cdata, size, size); output.states.append(Qobj(fdata, dims=dims)); else:; fdata = dense1D_to_fastcsr_ket(cdata); output.states.append(Qobj(fdata, dims=dims, fast='mc')). if expt_callback:; # use callback method; output.expect.",MatchSource.WIKI,docs/4.6/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/sesolve.html
https://qutip.org/docs/4.6/modules/qutip/sesolve.html:11188,Deployability,integrat,integration,11188," op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); if oper_evo:; for e in e_ops:; if e.dims[1] != psi0.dims[0]:; raise TypeError(f""e_ops dims ({e.dims}) are not compatible""; f"" with the state's ({psi0.dims})""); else:; e_ops_data.append(e.dag().data); else:; for e in e_ops:; if e.dims[1] != psi0.dims[0]:; raise TypeError(f""e_ops dims ({e.dims}) are not compatible""; f"" with the state's ({psi0.dims})""); else:; e_ops_data.append(e.data); else:; raise TypeError(""Expectation parameter must be a list or a function""). if opt.store_states:; output.states = []. if oper_evo:; def get_curr_state_data(r):; return vec2mat(r.y); else:; def get_curr_state_data(r):; return r.y. #; # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""); # get the current state / oper data if needed; if opt.store_states or opt.normalize_output or n_expt_op > 0 or expt_callback:; cdata = get_curr_state_data(r). if opt.normalize_output:; # normalize per column; if oper_evo:; cdata /= la_norm(cdata, axis=0); #cdata *= norm_dim_factor / la_norm(cdata); r.set_initial_value(cdata.ravel('F'), r.t); else:; #cdata /= la_norm(cdata); norm = normalize_inplace(cdata); if norm > 1e-12:; # only reset the solver if state changed; r.set_initial_value(cdata, r.t); else:; r._y = cdata. if opt.store_states:; if oper_evo:; fdata = dense2D_to_fastcsr_fmode(cdata, size, size); output.states.append(Qobj(fdata, dims=dims)); else:; fdata = dense1D_to_fastcsr_ket(cdata); output.states.append(Qobj(fdata, dims=dims, fast='mc')). if expt_callback:; # use callback method; output.expect.append(e_ops(t, Qobj(cdata, dims=dims))). if oper_evo:; for m in range(n_expt_op):; output.expe",MatchSource.WIKI,docs/4.6/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/sesolve.html
https://qutip.org/docs/4.6/modules/qutip/sesolve.html:12427,Deployability,integrat,integrate,12427," # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""); # get the current state / oper data if needed; if opt.store_states or opt.normalize_output or n_expt_op > 0 or expt_callback:; cdata = get_curr_state_data(r). if opt.normalize_output:; # normalize per column; if oper_evo:; cdata /= la_norm(cdata, axis=0); #cdata *= norm_dim_factor / la_norm(cdata); r.set_initial_value(cdata.ravel('F'), r.t); else:; #cdata /= la_norm(cdata); norm = normalize_inplace(cdata); if norm > 1e-12:; # only reset the solver if state changed; r.set_initial_value(cdata, r.t); else:; r._y = cdata. if opt.store_states:; if oper_evo:; fdata = dense2D_to_fastcsr_fmode(cdata, size, size); output.states.append(Qobj(fdata, dims=dims)); else:; fdata = dense1D_to_fastcsr_ket(cdata); output.states.append(Qobj(fdata, dims=dims, fast='mc')). if expt_callback:; # use callback method; output.expect.append(e_ops(t, Qobj(cdata, dims=dims))). if oper_evo:; for m in range(n_expt_op):; output.expect[m][t_idx] = (e_ops_data[m] * cdata).trace(); else:; for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops_data[m], cdata,; e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if opt.store_final_state:; cdata = get_curr_state_data(r); if opt.normalize_output:; cdata /= la_norm(cdata, axis=0); # cdata *= norm_dim_factor / la_norm(cdata); output.final_state = Qobj(cdata, dims=dims). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/sesolve.html
https://qutip.org/docs/4.6/modules/qutip/sesolve.html:12891,Deployability,update,updated,12891," # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""); # get the current state / oper data if needed; if opt.store_states or opt.normalize_output or n_expt_op > 0 or expt_callback:; cdata = get_curr_state_data(r). if opt.normalize_output:; # normalize per column; if oper_evo:; cdata /= la_norm(cdata, axis=0); #cdata *= norm_dim_factor / la_norm(cdata); r.set_initial_value(cdata.ravel('F'), r.t); else:; #cdata /= la_norm(cdata); norm = normalize_inplace(cdata); if norm > 1e-12:; # only reset the solver if state changed; r.set_initial_value(cdata, r.t); else:; r._y = cdata. if opt.store_states:; if oper_evo:; fdata = dense2D_to_fastcsr_fmode(cdata, size, size); output.states.append(Qobj(fdata, dims=dims)); else:; fdata = dense1D_to_fastcsr_ket(cdata); output.states.append(Qobj(fdata, dims=dims, fast='mc')). if expt_callback:; # use callback method; output.expect.append(e_ops(t, Qobj(cdata, dims=dims))). if oper_evo:; for m in range(n_expt_op):; output.expect[m][t_idx] = (e_ops_data[m] * cdata).trace(); else:; for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops_data[m], cdata,; e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if opt.store_final_state:; cdata = get_curr_state_data(r); if opt.normalize_output:; cdata /= la_norm(cdata, axis=0); # cdata *= norm_dim_factor / la_norm(cdata); output.final_state = Qobj(cdata, dims=dims). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/sesolve.html
https://qutip.org/docs/4.6/modules/qutip/sesolve.html:2240,Integrability,integrat,integrate,2240,"IGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the unitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; import numpy as np; import scipy.integrate; from scipy.linalg import norm as la_norm; from qutip.cy.stochastic import normalize_inplace; import qutip.settings as qset; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.cy.spconvert import dense1D_to_fastcsr_ket, dense2D_to_fastcsr_fmode; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.solver import Result, Options, config, solver_safe, SolverSystem; from qutip.superoperator import vec2mat; from qutip.ui.progressbar import (BaseProgressBar, TextProgressBar); from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. [docs]def sesolve(H, psi0, tlist, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian. Evolve the state vector (``psi0``) using a given Hamiltonian (``H``), by; integrating the set of ordinary differential equations that define the; system. Altern",MatchSource.WIKI,docs/4.6/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/sesolve.html
https://qutip.org/docs/4.6/modules/qutip/sesolve.html:3165,Integrability,integrat,integrating,3165,"= ['sesolve']. import os; import types; import numpy as np; import scipy.integrate; from scipy.linalg import norm as la_norm; from qutip.cy.stochastic import normalize_inplace; import qutip.settings as qset; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.cy.spconvert import dense1D_to_fastcsr_ket, dense2D_to_fastcsr_fmode; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.solver import Result, Options, config, solver_safe, SolverSystem; from qutip.superoperator import vec2mat; from qutip.ui.progressbar import (BaseProgressBar, TextProgressBar); from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. [docs]def sesolve(H, psi0, tlist, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian. Evolve the state vector (``psi0``) using a given Hamiltonian (``H``), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If ``e_ops`` is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. ``e_ops`` cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters; ----------. H : :class:`~Qobj`, :class:`~QobjEvo`, list, or callable; System Hamiltonian as a :obj:`~Qobj , list of :obj:`Qobj` and; coefficient, :obj:`~QObjEvo`, or a callback function for time-dependent; Hamiltonians. List format and options can be found in QobjEvo's; description. psi0 : :class:`~Qobj`; Initial state vector (ket) or initial unitary operator ``psi0 = U``. tlist : array_like of float; ",MatchSource.WIKI,docs/4.6/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/sesolve.html
https://qutip.org/docs/4.6/modules/qutip/sesolve.html:3957,Integrability,depend,dependent,3957,"ents. [docs]def sesolve(H, psi0, tlist, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian. Evolve the state vector (``psi0``) using a given Hamiltonian (``H``), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If ``e_ops`` is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. ``e_ops`` cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters; ----------. H : :class:`~Qobj`, :class:`~QobjEvo`, list, or callable; System Hamiltonian as a :obj:`~Qobj , list of :obj:`Qobj` and; coefficient, :obj:`~QObjEvo`, or a callback function for time-dependent; Hamiltonians. List format and options can be found in QobjEvo's; description. psi0 : :class:`~Qobj`; Initial state vector (ket) or initial unitary operator ``psi0 = U``. tlist : array_like of float; List of times for :math:`t`. e_ops : list of :class:`~Qobj` or callback function, optional; Single operator or list of operators for which to evaluate expectation; values. For operator evolution, the overlap is computed: ::. (e_ops[i].dag() * op(t)).tr(). args : dict, optional; Dictionary of scope parameters for time-dependent Hamiltonians. options : :obj:`~solver.Options`, optional; Options for the ODE solver. progress_bar : :obj:`~BaseProgressBar`, optional; Optional instance of :obj:`~BaseProgressBar`, or a subclass thereof,; for showing the progress of the simulation. Returns; -------. output: :class:`~solver.Result`; An instance of the class :class:`~solver.Result`, which contains either; an arra",MatchSource.WIKI,docs/4.6/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/sesolve.html
https://qutip.org/docs/4.6/modules/qutip/sesolve.html:4486,Integrability,depend,dependent,4486,"lied operators; (``e_ops``). If ``e_ops`` is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. ``e_ops`` cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters; ----------. H : :class:`~Qobj`, :class:`~QobjEvo`, list, or callable; System Hamiltonian as a :obj:`~Qobj , list of :obj:`Qobj` and; coefficient, :obj:`~QObjEvo`, or a callback function for time-dependent; Hamiltonians. List format and options can be found in QobjEvo's; description. psi0 : :class:`~Qobj`; Initial state vector (ket) or initial unitary operator ``psi0 = U``. tlist : array_like of float; List of times for :math:`t`. e_ops : list of :class:`~Qobj` or callback function, optional; Single operator or list of operators for which to evaluate expectation; values. For operator evolution, the overlap is computed: ::. (e_ops[i].dag() * op(t)).tr(). args : dict, optional; Dictionary of scope parameters for time-dependent Hamiltonians. options : :obj:`~solver.Options`, optional; Options for the ODE solver. progress_bar : :obj:`~BaseProgressBar`, optional; Optional instance of :obj:`~BaseProgressBar`, or a subclass thereof,; for showing the progress of the simulation. Returns; -------. output: :class:`~solver.Result`; An instance of the class :class:`~solver.Result`, which contains either; an array of expectation values for the times specified by ``tlist``, or; an array or state vectors corresponding to the times in ``tlist`` (if; ``e_ops`` is an empty list), or nothing if a callback function was; given inplace of operators for which to calculate the expectation; values.; """"""; if e_ops is None:; e_ops = []; if isinstance(e_ops, Qobj):; e_ops = [e_ops]; elif isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. if progress_bar is None:; progress_bar = BaseProgressBar(); if progress_bar is True:; progress_bar = TextProgres",MatchSource.WIKI,docs/4.6/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/sesolve.html
https://qutip.org/docs/4.6/modules/qutip/sesolve.html:6593,Integrability,depend,dependent,6593,"). if options is None:; options = Options(); if options.rhs_reuse and not isinstance(H, SolverSystem):; # TODO: deprecate when going to class based solver.; if ""sesolve"" in solver_safe:; H = solver_safe[""sesolve""]. if args is None:; args = {}. check_use_openmp(options). if isinstance(H, SolverSystem):; ss = H; elif isinstance(H, (list, Qobj, QobjEvo)):; ss = _sesolve_QobjEvo(H, tlist, args, options); elif callable(H):; ss = _sesolve_func_td(H, args, options); else:; raise Exception(""Invalid H type""). func, ode_args = ss.makefunc(ss, psi0, args, e_ops, options). if _safe_mode:; v = psi0.full().ravel('F'); func(0., v, *ode_args) + v. res = _generic_ode_solve(func, ode_args, psi0, tlist, e_ops, options,; progress_bar, dims=psi0.dims); if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; res.SolverSystem = ss; return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_QobjEvo(H, tlist, args, opt):; """"""; Prepare the system for the solver, H can be an QobjEvo.; """"""; H_td = -1.0j * QobjEvo(H, args, tlist=tlist); if opt.rhs_with_state:; H_td._check_old_with_state(); nthread = opt.openmp_threads if opt.use_openmp else 0; H_td.compile(omp=nthread). ss = SolverSystem(); ss.H = H_td; ss.makefunc = _qobjevo_set; solver_safe[""sesolve""] = ss; return ss. def _qobjevo_set(HS, psi, args, e_ops, opt):; """"""; From the system, get the ode function and args; """"""; H_td = HS.H; H_td.solver_set_args(args, psi, e_ops); if psi.isunitary:; func = H_td.compiled_qobjevo.ode_mul_mat_f_vec; elif psi.isket:; func = H_td.compiled_qobjevo.mul_vec; else:; raise TypeError(""The unitary solver requires psi0 to be""; "" a ket as initial state""; "" or a unitary as initial operator.""); return func, (). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolut",MatchSource.WIKI,docs/4.6/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/sesolve.html
https://qutip.org/docs/4.6/modules/qutip/sesolve.html:7654,Integrability,depend,dependent,7654,"-; # A time-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_QobjEvo(H, tlist, args, opt):; """"""; Prepare the system for the solver, H can be an QobjEvo.; """"""; H_td = -1.0j * QobjEvo(H, args, tlist=tlist); if opt.rhs_with_state:; H_td._check_old_with_state(); nthread = opt.openmp_threads if opt.use_openmp else 0; H_td.compile(omp=nthread). ss = SolverSystem(); ss.H = H_td; ss.makefunc = _qobjevo_set; solver_safe[""sesolve""] = ss; return ss. def _qobjevo_set(HS, psi, args, e_ops, opt):; """"""; From the system, get the ode function and args; """"""; H_td = HS.H; H_td.solver_set_args(args, psi, e_ops); if psi.isunitary:; func = H_td.compiled_qobjevo.ode_mul_mat_f_vec; elif psi.isket:; func = H_td.compiled_qobjevo.mul_vec; else:; raise TypeError(""The unitary solver requires psi0 to be""; "" a ket as initial state""; "" or a unitary as initial operator.""); return func, (). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians.; #; def _sesolve_func_td(H_func, args, opt):; """"""; Prepare the system for the solver, H is a function.; """"""; ss = SolverSystem(); ss.H = H_func; ss.makefunc = _Hfunc_set; solver_safe[""sesolve""] = ss; return ss. def _Hfunc_set(HS, psi, args, e_ops, opt):; """"""; From the system, get the ode function and args; """"""; H_func = HS.H; if psi.isunitary:; if not opt.rhs_with_state:; func = _ode_oper_func_td; else:; func = _ode_oper_func_td_with_state; else:; if not opt.rhs_with_state:; func = cy_ode_psi_func_td; else:; func = cy_ode_psi_func_td_with_state. return func, (H_func, args). # -----------------------------------------------------------------------------; # evaluate dU(t)/dt according to the schrodinger equation; #; def _ode_oper_func_td(t, y, H_func, args):; H = H_func(t, args).data * -1j; ym = vec2mat(y); return (H * ym).ravel(""F""). def _ode_oper_func_td_with_state(t, y, H_func, args):; H = ",MatchSource.WIKI,docs/4.6/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/sesolve.html
https://qutip.org/docs/4.6/modules/qutip/sesolve.html:9626,Integrability,integrat,integrate,9626,"eturn (H * ym).ravel(""F""). # -----------------------------------------------------------------------------; # Solve an ODE for func.; # Calculate the required expectation values or invoke callback; # function at each time step.; def _generic_ode_solve(func, ode_args, psi0, tlist, e_ops, opt,; progress_bar, dims=None):; """"""; Internal function for solving ODEs.; """"""; # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%; # This function is made similar to mesolve's one for futur merging in a; # solver class; # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%. # prepare output array; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if psi0.isunitary:; initial_vector = psi0.full().ravel('F'); oper_evo = True; size = psi0.shape[0]; # oper_n = dims[0][0]; # norm_dim_factor = np.sqrt(oper_n); elif psi0.isket:; initial_vector = psi0.full().ravel(); oper_evo = False; # norm_dim_factor = 1.0. r = scipy.integrate.ode(func); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); if ode_args:; r.set_f_params(*ode_args); r.set_initial_value(initial_vector, tlist[0]). e_ops_data = []; output.expect = []; if callable(e_ops):; n_expt_op = 0; expt_callback = True; output.num_expect = 1; elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False; output.num_expect = n_expt_op; if n_expt_op == 0:; # fallback on storing states; opt.store_states = True; else:; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); if oper_evo:; for e in e_ops:; if e.dims[1] != psi0.dims[0]:; raise TypeError(f""e_ops dims ({e.dims}) are not compatible""; f"" with the state's ({psi0.dims})""); else:; e_ops_data.append(e.dag().data); else:; for e in e_ops:; if e.dims[1] != psi0.dims[0]:; raise",MatchSource.WIKI,docs/4.6/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/sesolve.html
https://qutip.org/docs/4.6/modules/qutip/sesolve.html:11188,Integrability,integrat,integration,11188," op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); if oper_evo:; for e in e_ops:; if e.dims[1] != psi0.dims[0]:; raise TypeError(f""e_ops dims ({e.dims}) are not compatible""; f"" with the state's ({psi0.dims})""); else:; e_ops_data.append(e.dag().data); else:; for e in e_ops:; if e.dims[1] != psi0.dims[0]:; raise TypeError(f""e_ops dims ({e.dims}) are not compatible""; f"" with the state's ({psi0.dims})""); else:; e_ops_data.append(e.data); else:; raise TypeError(""Expectation parameter must be a list or a function""). if opt.store_states:; output.states = []. if oper_evo:; def get_curr_state_data(r):; return vec2mat(r.y); else:; def get_curr_state_data(r):; return r.y. #; # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""); # get the current state / oper data if needed; if opt.store_states or opt.normalize_output or n_expt_op > 0 or expt_callback:; cdata = get_curr_state_data(r). if opt.normalize_output:; # normalize per column; if oper_evo:; cdata /= la_norm(cdata, axis=0); #cdata *= norm_dim_factor / la_norm(cdata); r.set_initial_value(cdata.ravel('F'), r.t); else:; #cdata /= la_norm(cdata); norm = normalize_inplace(cdata); if norm > 1e-12:; # only reset the solver if state changed; r.set_initial_value(cdata, r.t); else:; r._y = cdata. if opt.store_states:; if oper_evo:; fdata = dense2D_to_fastcsr_fmode(cdata, size, size); output.states.append(Qobj(fdata, dims=dims)); else:; fdata = dense1D_to_fastcsr_ket(cdata); output.states.append(Qobj(fdata, dims=dims, fast='mc')). if expt_callback:; # use callback method; output.expect.append(e_ops(t, Qobj(cdata, dims=dims))). if oper_evo:; for m in range(n_expt_op):; output.expe",MatchSource.WIKI,docs/4.6/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/sesolve.html
https://qutip.org/docs/4.6/modules/qutip/sesolve.html:12427,Integrability,integrat,integrate,12427," # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""); # get the current state / oper data if needed; if opt.store_states or opt.normalize_output or n_expt_op > 0 or expt_callback:; cdata = get_curr_state_data(r). if opt.normalize_output:; # normalize per column; if oper_evo:; cdata /= la_norm(cdata, axis=0); #cdata *= norm_dim_factor / la_norm(cdata); r.set_initial_value(cdata.ravel('F'), r.t); else:; #cdata /= la_norm(cdata); norm = normalize_inplace(cdata); if norm > 1e-12:; # only reset the solver if state changed; r.set_initial_value(cdata, r.t); else:; r._y = cdata. if opt.store_states:; if oper_evo:; fdata = dense2D_to_fastcsr_fmode(cdata, size, size); output.states.append(Qobj(fdata, dims=dims)); else:; fdata = dense1D_to_fastcsr_ket(cdata); output.states.append(Qobj(fdata, dims=dims, fast='mc')). if expt_callback:; # use callback method; output.expect.append(e_ops(t, Qobj(cdata, dims=dims))). if oper_evo:; for m in range(n_expt_op):; output.expect[m][t_idx] = (e_ops_data[m] * cdata).trace(); else:; for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops_data[m], cdata,; e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if opt.store_final_state:; cdata = get_curr_state_data(r); if opt.normalize_output:; cdata /= la_norm(cdata, axis=0); # cdata *= norm_dim_factor / la_norm(cdata); output.final_state = Qobj(cdata, dims=dims). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/sesolve.html
https://qutip.org/docs/4.6/modules/qutip/sesolve.html:2663,Modifiability,config,config,2663,"STITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the unitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; import numpy as np; import scipy.integrate; from scipy.linalg import norm as la_norm; from qutip.cy.stochastic import normalize_inplace; import qutip.settings as qset; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.cy.spconvert import dense1D_to_fastcsr_ket, dense2D_to_fastcsr_fmode; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.solver import Result, Options, config, solver_safe, SolverSystem; from qutip.superoperator import vec2mat; from qutip.ui.progressbar import (BaseProgressBar, TextProgressBar); from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. [docs]def sesolve(H, psi0, tlist, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian. Evolve the state vector (``psi0``) using a given Hamiltonian (``H``), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If ``e_ops`` is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. ``e_ops`` ",MatchSource.WIKI,docs/4.6/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/sesolve.html
https://qutip.org/docs/4.6/modules/qutip/sesolve.html:3259,Modifiability,evolve,evolve,3259,"_norm; from qutip.cy.stochastic import normalize_inplace; import qutip.settings as qset; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.cy.spconvert import dense1D_to_fastcsr_ket, dense2D_to_fastcsr_fmode; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.solver import Result, Options, config, solver_safe, SolverSystem; from qutip.superoperator import vec2mat; from qutip.ui.progressbar import (BaseProgressBar, TextProgressBar); from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. [docs]def sesolve(H, psi0, tlist, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian. Evolve the state vector (``psi0``) using a given Hamiltonian (``H``), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If ``e_ops`` is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. ``e_ops`` cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters; ----------. H : :class:`~Qobj`, :class:`~QobjEvo`, list, or callable; System Hamiltonian as a :obj:`~Qobj , list of :obj:`Qobj` and; coefficient, :obj:`~QObjEvo`, or a callback function for time-dependent; Hamiltonians. List format and options can be found in QobjEvo's; description. psi0 : :class:`~Qobj`; Initial state vector (ket) or initial unitary operator ``psi0 = U``. tlist : array_like of float; List of times for :math:`t`. e_ops : list of :class:`~Qobj` or callback function, optional; Single operator or list of o",MatchSource.WIKI,docs/4.6/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/sesolve.html
https://qutip.org/docs/4.6/modules/qutip/simdiag.html:5563,Deployability,update,updated,5563,"t to; ``False`` and operators are not commuting, the eigenvectors returned; will often be eigenvectors of only the first operator. Returns; --------; eigs : tuple; Tuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. """"""; if not ops:; raise ValueError(""No input matrices.""); N = ops[0].shape[0]; num_ops = len(ops) if safe_mode else 0; for jj in range(num_ops):; A = ops[jj]; shape = A.shape; if shape[0] != shape[1]:; raise TypeError('Matricies must be square.'); if shape[0] != N:; raise TypeError('All matrices. must be the same shape'); if not A.isherm:; raise TypeError('Matricies must be Hermitian'); for kk in range(jj):; B = ops[kk]; if (A * B - B * A).norm() / (A * B).norm() > tol:; raise TypeError('Matricies must commute.'). eigvals, eigvecs = la.eigh(ops[0].full()); perm = np.argsort(eigvals); eigvecs = eigvecs[:, perm]; eigvals = eigvals[perm]. k = 0; while k < N:; # find degenerate eigenvalues, get indicies of degenerate eigvals; ttol = max(tol, tol * abs(eigvals[k])); inds, = np.where(abs(eigvals - eigvals[k]) < ttol); if len(inds) > 1: # if at least 2 eigvals are degenerate; eigvecs[:, inds] = _degen(tol, eigvecs[:, inds], ops, 1); k = inds[-1] + 1. for k in range(N):; eigvecs[:, k] = eigvecs[:, k] / la.norm(eigvecs[:, k]). kets_out = [; Qobj(eigvecs[:, j],; dims=[ops[0].dims[0], [1]], shape=[ops[0].shape[0], 1]); for j in range(N); ]; eigvals_out = np.zeros((len(ops), N), dtype=np.float64); if not evals:; return kets_out; else:; for kk in range(len(ops)):; for j in range(N):; eigvals_out[kk, j] = ops[kk].matrix_element(kets_out[j],; kets_out[j]).real; return eigvals_out, kets_out. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/simdiag.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/simdiag.html
https://qutip.org/docs/4.6/modules/qutip/simdiag.html:3541,Safety,detect,detecting,3541,", k]); / (1 - np.abs(dot)**2)**0.5). subspace = vecs.conj().T @ ops[i].data @ vecs; eigvals, eigvecs = la.eig(subspace). perm = np.argsort(eigvals); eigvals = eigvals[perm]. vecs_new = vecs @ eigvecs[:, perm]; for k in range(len(eigvals)):; vecs_new[:, k] = vecs_new[:, k] / la.norm(vecs_new[:, k]). k = 0; while k < len(eigvals):; ttol = max(tol, tol * abs(eigvals[k])); inds, = np.where(abs(eigvals - eigvals[k]) < ttol); if len(inds) > 1: # if at least 2 eigvals are degenerate; vecs_new[:, inds] = _degen(tol, vecs_new[:, inds], ops, i+1); k = inds[-1] + 1; return vecs_new. [docs]def simdiag(ops, evals: bool = True, *,; tol: float = 1e-14, safe_mode: bool = True):; """"""Simultaneous diagonalization of commuting Hermitian matrices. Parameters; ----------; ops : list/array; ``list`` or ``array`` of qobjs representing commuting Hermitian; operators. evals : bool [True]; Whether to return the eigenvalues for each ops and eigenvectors or just; the eigenvectors. tol : float [1e-14]; Tolerance for detecting degenerate eigenstates. safe_mode : bool [True]; Whether to check that all ops are Hermitian and commuting. If set to; ``False`` and operators are not commuting, the eigenvectors returned; will often be eigenvectors of only the first operator. Returns; --------; eigs : tuple; Tuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. """"""; if not ops:; raise ValueError(""No input matrices.""); N = ops[0].shape[0]; num_ops = len(ops) if safe_mode else 0; for jj in range(num_ops):; A = ops[jj]; shape = A.shape; if shape[0] != shape[1]:; raise TypeError('Matricies must be square.'); if shape[0] != N:; raise TypeError('All matrices. must be the same shape'); if not A.isherm:; raise TypeError('Matricies must be Hermitian'); for kk in range(jj):; B = ops[kk]; if (A * B - B * A).norm() / (A * B).norm() > tol:; raise TypeError('Matricies must commute.'). eigvals, eigvecs = la.eigh(ops[0].full()); p",MatchSource.WIKI,docs/4.6/modules/qutip/simdiag.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/simdiag.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:5249,Availability,toler,tolerance,5249,"d_qobjevo.expect(t, state). def finish(self):; if self.isfunc:; result = self.raw_out; else:; result = []; for ii in range(self.e_num):; if self.e_ops_isherm[ii]:; result.append(np.real(self.raw_out[ii, :])); else:; result.append(self.raw_out[ii, :]); if self.e_ops_dict:; result = {e: result[n]; for n, e in enumerate(self.e_ops_dict.keys())}; return result. def __eq__(self, other):; if isinstance(other, ExpectOps):; other = other.raw_e_ops; return self.raw_e_ops == other. def __ne__(self, other):; return not (self == other). def __bool__(self):; return bool(self.e_num). [docs]class Options():; """"""; Class of options for evolution solvers such as :func:`qutip.mesolve` and; :func:`qutip.mcsolve`. Options can be specified either as arguments to the; constructor::. opts = Options(order=10, ...). or by changing the class attributes after creation::. opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes; ----------. atol : float {1e-8}; Absolute tolerance.; rtol : float {1e-6}; Relative tolerance.; method : str {'adams','bdf'}; Integration method.; order : int {12}; Order of integrator (<=12 'adams', <=5 'bdf'); nsteps : int {2500}; Max. number of internal steps/call.; first_step : float {0}; Size of initial step (0 = automatic).; min_step : float {0}; Minimum step size (0 = automatic).; max_step : float {0}; Maximum step size (0 = automatic); tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms.; num_cpus : int; Number of cpus used by mcsolver (default = # of cpus).; norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve.; norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve.; average_states : bool {False}; Average states values over trajectories in stochastic solvers.; average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers.; mc_corr_eps : float {1e-10}; Arbitrarily small v",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:5291,Availability,toler,tolerance,5291,"f):; if self.isfunc:; result = self.raw_out; else:; result = []; for ii in range(self.e_num):; if self.e_ops_isherm[ii]:; result.append(np.real(self.raw_out[ii, :])); else:; result.append(self.raw_out[ii, :]); if self.e_ops_dict:; result = {e: result[n]; for n, e in enumerate(self.e_ops_dict.keys())}; return result. def __eq__(self, other):; if isinstance(other, ExpectOps):; other = other.raw_e_ops; return self.raw_e_ops == other. def __ne__(self, other):; return not (self == other). def __bool__(self):; return bool(self.e_num). [docs]class Options():; """"""; Class of options for evolution solvers such as :func:`qutip.mesolve` and; :func:`qutip.mcsolve`. Options can be specified either as arguments to the; constructor::. opts = Options(order=10, ...). or by changing the class attributes after creation::. opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes; ----------. atol : float {1e-8}; Absolute tolerance.; rtol : float {1e-6}; Relative tolerance.; method : str {'adams','bdf'}; Integration method.; order : int {12}; Order of integrator (<=12 'adams', <=5 'bdf'); nsteps : int {2500}; Max. number of internal steps/call.; first_step : float {0}; Size of initial step (0 = automatic).; min_step : float {0}; Minimum step size (0 = automatic).; max_step : float {0}; Maximum step size (0 = automatic); tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms.; num_cpus : int; Number of cpus used by mcsolver (default = # of cpus).; norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve.; norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve.; average_states : bool {False}; Average states values over trajectories in stochastic solvers.; average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers.; mc_corr_eps : float {1e-10}; Arbitrarily small value for eliminating any divide-by-zero e",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:6279,Availability,error,errors,6279,"rtol : float {1e-6}; Relative tolerance.; method : str {'adams','bdf'}; Integration method.; order : int {12}; Order of integrator (<=12 'adams', <=5 'bdf'); nsteps : int {2500}; Max. number of internal steps/call.; first_step : float {0}; Size of initial step (0 = automatic).; min_step : float {0}; Minimum step size (0 = automatic).; max_step : float {0}; Maximum step size (0 = automatic); tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms.; num_cpus : int; Number of cpus used by mcsolver (default = # of cpus).; norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve.; norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve.; average_states : bool {False}; Average states values over trajectories in stochastic solvers.; average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers.; mc_corr_eps : float {1e-10}; Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve.; ntraj : int {500}; Number of trajectories in stochastic solvers.; openmp_threads : int; Number of OPENMP threads to use. Default is number of cpu cores.; rhs_reuse : bool {False,True}; Reuse Hamiltonian data.; rhs_with_state : bool {False,True}; Whether or not to include the state in the Hamiltonian function; callback signature.; rhs_filename : str; Name for compiled Cython file.; seeds : ndarray; Array containing random number seeds for mcsolver.; store_final_state : bool {False, True}; Whether or not to store the final state of the evolution in the; result class.; store_states : bool {False, True}; Whether or not to store the state vectors or density matrices in the; result class, even if expectation values operators are given. If no; expectation are provided, then states are stored by default and this; option has no effect.; use_openmp : bool {True, False}; Use OPENMP for sparse matrix vector multiplication. D",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:7775,Availability,toler,tolerance,7775,"th_state : bool {False,True}; Whether or not to include the state in the Hamiltonian function; callback signature.; rhs_filename : str; Name for compiled Cython file.; seeds : ndarray; Array containing random number seeds for mcsolver.; store_final_state : bool {False, True}; Whether or not to store the final state of the evolution in the; result class.; store_states : bool {False, True}; Whether or not to store the state vectors or density matrices in the; result class, even if expectation values operators are given. If no; expectation are provided, then states are stored by default and this; option has no effect.; use_openmp : bool {True, False}; Use OPENMP for sparse matrix vector multiplication. Default; None means auto check. """""". def __init__(self, atol=1e-8, rtol=1e-6, method='adams', order=12,; nsteps=1000, first_step=0, max_step=0, min_step=0,; average_expect=True, average_states=False, tidy=True,; num_cpus=0, norm_tol=1e-3, norm_t_tol=1e-6, norm_steps=5,; rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False,; rhs_with_state=False, store_final_state=False,; store_states=False, steady_state_average=False,; seeds=None,; normalize_output=True, use_openmp=None, openmp_threads=None):; # Absolute tolerance (default = 1e-8); self.atol = atol; # Relative tolerance (default = 1e-6); self.rtol = rtol; # Integration method (default = 'adams', for stiff 'bdf'); self.method = method; # Max. number of internal steps/call; self.nsteps = nsteps; # Size of initial step (0 = determined by solver); self.first_step = first_step; # Minimal step size (0 = determined by solver); self.min_step = min_step; # Max step size (0 = determined by solver); self.max_step = max_step; # Maximum order used by integrator (<=12 for 'adams', <=5 for 'bdf'); self.order = order; # Average expectation values over trajectories (default = True); self.average_states = average_states; # average expectation values; self.average_expect = average_expect; # Number of trajectories (default = 500); self.n",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:7832,Availability,toler,tolerance,7832," or not to store the final state of the evolution in the; result class.; store_states : bool {False, True}; Whether or not to store the state vectors or density matrices in the; result class, even if expectation values operators are given. If no; expectation are provided, then states are stored by default and this; option has no effect.; use_openmp : bool {True, False}; Use OPENMP for sparse matrix vector multiplication. Default; None means auto check. """""". def __init__(self, atol=1e-8, rtol=1e-6, method='adams', order=12,; nsteps=1000, first_step=0, max_step=0, min_step=0,; average_expect=True, average_states=False, tidy=True,; num_cpus=0, norm_tol=1e-3, norm_t_tol=1e-6, norm_steps=5,; rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False,; rhs_with_state=False, store_final_state=False,; store_states=False, steady_state_average=False,; seeds=None,; normalize_output=True, use_openmp=None, openmp_threads=None):; # Absolute tolerance (default = 1e-8); self.atol = atol; # Relative tolerance (default = 1e-6); self.rtol = rtol; # Integration method (default = 'adams', for stiff 'bdf'); self.method = method; # Max. number of internal steps/call; self.nsteps = nsteps; # Size of initial step (0 = determined by solver); self.first_step = first_step; # Minimal step size (0 = determined by solver); self.min_step = min_step; # Max step size (0 = determined by solver); self.max_step = max_step; # Maximum order used by integrator (<=12 for 'adams', <=5 for 'bdf'); self.order = order; # Average expectation values over trajectories (default = True); self.average_states = average_states; # average expectation values; self.average_expect = average_expect; # Number of trajectories (default = 500); self.ntraj = ntraj; # Holds seeds for rand num gen; self.seeds = seeds; # tidyup Hamiltonian before calculation (default = True); self.tidy = tidy; # include the state in the function callback signature; self.rhs_with_state = rhs_with_state; # Use preexisting RHS function for time-dependen",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:13798,Availability,toler,tolerance,13798,"pect) > 0:; s += ""expect = True\nnum_expect = "" + str(self.num_expect) + "", ""; else:; s += ""states = True, expect = True\n"" + \; ""num_expect = "" + str(self.num_expect) + "", ""; s += ""num_collapse = "" + str(self.num_collapse); if self.solver == 'mcsolve':; s += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). # %%%%%%%%%%% remove ?; [docs]class SolverConfiguration():; def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):; # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. self.soft_reset(). def soft_reset(self):; # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op ish",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:5381,Deployability,integrat,integrator,5381,"]:; result.append(np.real(self.raw_out[ii, :])); else:; result.append(self.raw_out[ii, :]); if self.e_ops_dict:; result = {e: result[n]; for n, e in enumerate(self.e_ops_dict.keys())}; return result. def __eq__(self, other):; if isinstance(other, ExpectOps):; other = other.raw_e_ops; return self.raw_e_ops == other. def __ne__(self, other):; return not (self == other). def __bool__(self):; return bool(self.e_num). [docs]class Options():; """"""; Class of options for evolution solvers such as :func:`qutip.mesolve` and; :func:`qutip.mcsolve`. Options can be specified either as arguments to the; constructor::. opts = Options(order=10, ...). or by changing the class attributes after creation::. opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes; ----------. atol : float {1e-8}; Absolute tolerance.; rtol : float {1e-6}; Relative tolerance.; method : str {'adams','bdf'}; Integration method.; order : int {12}; Order of integrator (<=12 'adams', <=5 'bdf'); nsteps : int {2500}; Max. number of internal steps/call.; first_step : float {0}; Size of initial step (0 = automatic).; min_step : float {0}; Minimum step size (0 = automatic).; max_step : float {0}; Maximum step size (0 = automatic); tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms.; num_cpus : int; Number of cpus used by mcsolver (default = # of cpus).; norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve.; norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve.; average_states : bool {False}; Average states values over trajectories in stochastic solvers.; average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers.; mc_corr_eps : float {1e-10}; Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve.; ntraj : int {500}; Number of trajectories in stochastic solver",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:8268,Deployability,integrat,integrator,8268,"one means auto check. """""". def __init__(self, atol=1e-8, rtol=1e-6, method='adams', order=12,; nsteps=1000, first_step=0, max_step=0, min_step=0,; average_expect=True, average_states=False, tidy=True,; num_cpus=0, norm_tol=1e-3, norm_t_tol=1e-6, norm_steps=5,; rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False,; rhs_with_state=False, store_final_state=False,; store_states=False, steady_state_average=False,; seeds=None,; normalize_output=True, use_openmp=None, openmp_threads=None):; # Absolute tolerance (default = 1e-8); self.atol = atol; # Relative tolerance (default = 1e-6); self.rtol = rtol; # Integration method (default = 'adams', for stiff 'bdf'); self.method = method; # Max. number of internal steps/call; self.nsteps = nsteps; # Size of initial step (0 = determined by solver); self.first_step = first_step; # Minimal step size (0 = determined by solver); self.min_step = min_step; # Max step size (0 = determined by solver); self.max_step = max_step; # Maximum order used by integrator (<=12 for 'adams', <=5 for 'bdf'); self.order = order; # Average expectation values over trajectories (default = True); self.average_states = average_states; # average expectation values; self.average_expect = average_expect; # Number of trajectories (default = 500); self.ntraj = ntraj; # Holds seeds for rand num gen; self.seeds = seeds; # tidyup Hamiltonian before calculation (default = True); self.tidy = tidy; # include the state in the function callback signature; self.rhs_with_state = rhs_with_state; # Use preexisting RHS function for time-dependent solvers; self.rhs_reuse = rhs_reuse; # Use filename for preexisting RHS function (will default to last; # compiled function if None & rhs_exists=True); self.rhs_filename = rhs_filename; # small value in mc solver for computing correlations; self.mc_corr_eps = 1e-10; # Number of processors to use (mcsolve only); if num_cpus:; self.num_cpus = num_cpus; else:; self.num_cpus = qset.num_cpus; # Tolerance for wavefunction norm (mcsolv",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:13247,Deployability,update,update,13247,"ver. """"""; def __init__(self):; self.solver = None; self.times = None; self.states = []; self.expect = []; self.num_expect = 0; self.num_collapse = 0; self.ntraj = None; self.seeds = None; self.col_times = None; self.col_which = None. def __str__(self):; s = ""Result object ""; if self.solver:; s += ""with "" + self.solver + "" data.\n""; else:; s += ""missing solver information.\n""; s += ""-"" * (len(s) - 1) + ""\n""; if self.states is not None and len(self.states) > 0:; s += ""states = True\n""; elif self.expect is not None and len(self.expect) > 0:; s += ""expect = True\nnum_expect = "" + str(self.num_expect) + "", ""; else:; s += ""states = True, expect = True\n"" + \; ""num_expect = "" + str(self.num_expect) + "", ""; s += ""num_collapse = "" + str(self.num_collapse); if self.solver == 'mcsolve':; s += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). # %%%%%%%%%%% remove ?; [docs]class SolverConfiguration():; def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):; # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. self.soft_reset(). def soft",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:13478,Deployability,update,update,13478," self.col_which = None. def __str__(self):; s = ""Result object ""; if self.solver:; s += ""with "" + self.solver + "" data.\n""; else:; s += ""missing solver information.\n""; s += ""-"" * (len(s) - 1) + ""\n""; if self.states is not None and len(self.states) > 0:; s += ""states = True\n""; elif self.expect is not None and len(self.expect) > 0:; s += ""expect = True\nnum_expect = "" + str(self.num_expect) + "", ""; else:; s += ""states = True, expect = True\n"" + \; ""num_expect = "" + str(self.num_expect) + "", ""; s += ""num_collapse = "" + str(self.num_collapse); if self.solver == 'mcsolve':; s += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). # %%%%%%%%%%% remove ?; [docs]class SolverConfiguration():; def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):; # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. self.soft_reset(). def soft_reset(self):; # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs; self.h_data = None # List of sparse matrix data; self",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:29730,Deployability,update,updated,29730,"ps[ii][0], tuple):; do_tests = False; for kk in range(len(c_ops[ii][0])):; _temp_state = c_ops[ii][0][kk]; _structure_check(Hdims, Htype, _temp_state); else:; raise Exception('Invalid td-list element.'); if do_tests:; _structure_check(Hdims, Htype, _temp_state). if isinstance(e_ops, list):; for ii in range(len(e_ops)):; if isinstance(e_ops[ii], Qobj):; _temp_state = e_ops[ii]; elif isinstance(e_ops[ii], list):; _temp_state = e_ops[ii][0]; else:; raise Exception('Invalid td-list element.'); _structure_check(Hdims,Htype,_temp_state); elif isinstance(e_ops, FunctionType):; pass; else:; raise Exception('Invalid e_ops specification.'). def _structure_check(Hdims, Htype, state):; if state is not None:; # Input state is a ket vector; if state.type == 'ket':; # Input is Hamiltonian; if Htype == 'oper':; if Hdims[1] != state.dims[0]:; raise Exception('Input operator and ket do not '; 'share same structure.'); # Input is super and state is ket; elif Htype == 'super':; if Hdims[1][1] != state.dims[0]:; raise Exception('Input operator and ket do not '; 'share same structure.'); else:; raise Exception('Invalid input operator.'); # Input state is a density matrix; elif state.type == 'oper':; # Input is Hamiltonian and state is density matrix; if Htype == 'oper':; if Hdims[1] != state.dims[0]:; raise Exception('Input operators do not '; 'share same structure.'); # Input is super op. and state is density matrix; elif Htype == 'super':; if Hdims[1] != state.dims:; raise Exception('Input operators do not '; 'share same structure.'). #; # create a global instance of the SolverConfiguration class; #; config = SolverConfiguration(). # for backwards compatibility; Odeoptions = Options; Odedata = Result. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:5381,Integrability,integrat,integrator,5381,"]:; result.append(np.real(self.raw_out[ii, :])); else:; result.append(self.raw_out[ii, :]); if self.e_ops_dict:; result = {e: result[n]; for n, e in enumerate(self.e_ops_dict.keys())}; return result. def __eq__(self, other):; if isinstance(other, ExpectOps):; other = other.raw_e_ops; return self.raw_e_ops == other. def __ne__(self, other):; return not (self == other). def __bool__(self):; return bool(self.e_num). [docs]class Options():; """"""; Class of options for evolution solvers such as :func:`qutip.mesolve` and; :func:`qutip.mcsolve`. Options can be specified either as arguments to the; constructor::. opts = Options(order=10, ...). or by changing the class attributes after creation::. opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes; ----------. atol : float {1e-8}; Absolute tolerance.; rtol : float {1e-6}; Relative tolerance.; method : str {'adams','bdf'}; Integration method.; order : int {12}; Order of integrator (<=12 'adams', <=5 'bdf'); nsteps : int {2500}; Max. number of internal steps/call.; first_step : float {0}; Size of initial step (0 = automatic).; min_step : float {0}; Minimum step size (0 = automatic).; max_step : float {0}; Maximum step size (0 = automatic); tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms.; num_cpus : int; Number of cpus used by mcsolver (default = # of cpus).; norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve.; norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve.; average_states : bool {False}; Average states values over trajectories in stochastic solvers.; average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers.; mc_corr_eps : float {1e-10}; Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve.; ntraj : int {500}; Number of trajectories in stochastic solver",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:8268,Integrability,integrat,integrator,8268,"one means auto check. """""". def __init__(self, atol=1e-8, rtol=1e-6, method='adams', order=12,; nsteps=1000, first_step=0, max_step=0, min_step=0,; average_expect=True, average_states=False, tidy=True,; num_cpus=0, norm_tol=1e-3, norm_t_tol=1e-6, norm_steps=5,; rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False,; rhs_with_state=False, store_final_state=False,; store_states=False, steady_state_average=False,; seeds=None,; normalize_output=True, use_openmp=None, openmp_threads=None):; # Absolute tolerance (default = 1e-8); self.atol = atol; # Relative tolerance (default = 1e-6); self.rtol = rtol; # Integration method (default = 'adams', for stiff 'bdf'); self.method = method; # Max. number of internal steps/call; self.nsteps = nsteps; # Size of initial step (0 = determined by solver); self.first_step = first_step; # Minimal step size (0 = determined by solver); self.min_step = min_step; # Max step size (0 = determined by solver); self.max_step = max_step; # Maximum order used by integrator (<=12 for 'adams', <=5 for 'bdf'); self.order = order; # Average expectation values over trajectories (default = True); self.average_states = average_states; # average expectation values; self.average_expect = average_expect; # Number of trajectories (default = 500); self.ntraj = ntraj; # Holds seeds for rand num gen; self.seeds = seeds; # tidyup Hamiltonian before calculation (default = True); self.tidy = tidy; # include the state in the function callback signature; self.rhs_with_state = rhs_with_state; # Use preexisting RHS function for time-dependent solvers; self.rhs_reuse = rhs_reuse; # Use filename for preexisting RHS function (will default to last; # compiled function if None & rhs_exists=True); self.rhs_filename = rhs_filename; # small value in mc solver for computing correlations; self.mc_corr_eps = 1e-10; # Number of processors to use (mcsolve only); if num_cpus:; self.num_cpus = num_cpus; else:; self.num_cpus = qset.num_cpus; # Tolerance for wavefunction norm (mcsolv",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:8829,Integrability,depend,dependent,8829,"elf.atol = atol; # Relative tolerance (default = 1e-6); self.rtol = rtol; # Integration method (default = 'adams', for stiff 'bdf'); self.method = method; # Max. number of internal steps/call; self.nsteps = nsteps; # Size of initial step (0 = determined by solver); self.first_step = first_step; # Minimal step size (0 = determined by solver); self.min_step = min_step; # Max step size (0 = determined by solver); self.max_step = max_step; # Maximum order used by integrator (<=12 for 'adams', <=5 for 'bdf'); self.order = order; # Average expectation values over trajectories (default = True); self.average_states = average_states; # average expectation values; self.average_expect = average_expect; # Number of trajectories (default = 500); self.ntraj = ntraj; # Holds seeds for rand num gen; self.seeds = seeds; # tidyup Hamiltonian before calculation (default = True); self.tidy = tidy; # include the state in the function callback signature; self.rhs_with_state = rhs_with_state; # Use preexisting RHS function for time-dependent solvers; self.rhs_reuse = rhs_reuse; # Use filename for preexisting RHS function (will default to last; # compiled function if None & rhs_exists=True); self.rhs_filename = rhs_filename; # small value in mc solver for computing correlations; self.mc_corr_eps = 1e-10; # Number of processors to use (mcsolve only); if num_cpus:; self.num_cpus = num_cpus; else:; self.num_cpus = qset.num_cpus; # Tolerance for wavefunction norm (mcsolve only); self.norm_tol = norm_tol; # Tolerance for collapse time precision (mcsolve only); self.norm_t_tol = norm_t_tol; # Max. number of steps taken to find wavefunction norm to within; # norm_tol (mcsolve only); self.norm_steps = norm_steps; # Number of threads for openmp; if openmp_threads is None:; self.openmp_threads = qset.num_cpus; else:; self.openmp_threads = openmp_threads; # store final state?; self.store_final_state = store_final_state; # store states even if expectation operators are given?; self.store_states = store",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:14069,Integrability,depend,dependence,14069,"raj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). # %%%%%%%%%%% remove ?; [docs]class SolverConfiguration():; def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):; # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. self.soft_reset(). def soft_reset(self):; # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op ind",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:14229,Integrability,depend,dependent,14229,"s pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). # %%%%%%%%%%% remove ?; [docs]class SolverConfiguration():; def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):; # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. self.soft_reset(). def soft_reset(self):; # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:14350,Integrability,depend,dependent,14350,"es what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). # %%%%%%%%%%% remove ?; [docs]class SolverConfiguration():; def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):; # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. self.soft_reset(). def soft_reset(self):; # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = []",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:14986,Integrability,depend,dependent,14986,"state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. self.soft_reset(). def soft_reset(self):; # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect func",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:15182,Integrability,depend,dependent,15182,"pse operators; self.tflag = 0 # Flag signaling time-dependent problem. self.soft_reset(). def soft_reset(self):; # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver. def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt i",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:15417,Integrability,depend,dependent,15417,"strs and funcs; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver. def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt is not None:; sect_percent = 100*t/tt; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% section, {:03.2f}% total)"".format(; sect_percent, solve_percent); elif tt is not None:; sect_percent = 100*t/tt; time_str += "" ({:03.2f}% section)"".fo",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:15546,Integrability,depend,dependence,15546,"elf.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver. def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt is not None:; sect_percent = 100*t/tt; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% section, {:03.2f}% total)"".format(; sect_percent, solve_percent); elif tt is not None:; sect_percent = 100*t/tt; time_str += "" ({:03.2f}% section)"".format(sect_percent). elif ttt is not None:; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% total)"".format(solve_",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:15739,Integrability,depend,dependent,15739,"pect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver. def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt is not None:; sect_percent = 100*t/tt; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% section, {:03.2f}% total)"".format(; sect_percent, solve_percent); elif tt is not None:; sect_percent = 100*t/tt; time_str += "" ({:03.2f}% section)"".format(sect_percent). elif ttt is not None:; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% total)"".format(solve_percent). return time_str. [docs]class Stats:; """"""; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor, then all statistics; w",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:19990,Integrability,message,message,19990,"ion of value. value : int; Initial value of the count, or added to an existing count. section : string or :class:`_StatsSection`; Section which to add the count to.; If None given, the default (first) section will be used; """""". self._get_section(section).add_count(key, value). [docs] def add_timing(self, key, value, section=None):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters; ----------; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value. value : int; Initial value of the timing, or added to an existing timing. section: string or `class` : _StatsSection; Section which to add the timing to.; If None given, the default (first) section will be used; """"""; self._get_section(section).add_timing(key, value). [docs] def add_message(self, key, value, section=None, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters; ----------; key : string; key for the section.messages dictionary; reusing a key will result in concatenation of value. value : int; Initial value of the message, or added to an existing message. sep : string; Message will be prefixed with this string when concatenating. section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used; """"""; self._get_section(section).add_message(key, value, sep=sep). [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters; ----------; value : float; Time in seconds to complete the solver section. section : strin",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:20126,Integrability,message,message,20126,"given, the default (first) section will be used; """""". self._get_section(section).add_count(key, value). [docs] def add_timing(self, key, value, section=None):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters; ----------; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value. value : int; Initial value of the timing, or added to an existing timing. section: string or `class` : _StatsSection; Section which to add the timing to.; If None given, the default (first) section will be used; """"""; self._get_section(section).add_timing(key, value). [docs] def add_message(self, key, value, section=None, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters; ----------; key : string; key for the section.messages dictionary; reusing a key will result in concatenation of value. value : int; Initial value of the message, or added to an existing message. sep : string; Message will be prefixed with this string when concatenating. section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used; """"""; self._get_section(section).add_message(key, value, sep=sep). [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters; ----------; value : float; Time in seconds to complete the solver section. section : string or `class` : _StatsSection; Section which to set the total_time for; If None given, the total_time for complete solve is set; """"""; if not isinstance(value, float):; try:; v",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:20234,Integrability,message,messages,20234,"ection=None):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters; ----------; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value. value : int; Initial value of the timing, or added to an existing timing. section: string or `class` : _StatsSection; Section which to add the timing to.; If None given, the default (first) section will be used; """"""; self._get_section(section).add_timing(key, value). [docs] def add_message(self, key, value, section=None, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters; ----------; key : string; key for the section.messages dictionary; reusing a key will result in concatenation of value. value : int; Initial value of the message, or added to an existing message. sep : string; Message will be prefixed with this string when concatenating. section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used; """"""; self._get_section(section).add_message(key, value, sep=sep). [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters; ----------; value : float; Time in seconds to complete the solver section. section : string or `class` : _StatsSection; Section which to set the total_time for; If None given, the total_time for complete solve is set; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if section is None:; self.total_time = value; else:; sect = sel",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:20342,Integrability,message,message,20342,"ection then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters; ----------; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value. value : int; Initial value of the timing, or added to an existing timing. section: string or `class` : _StatsSection; Section which to add the timing to.; If None given, the default (first) section will be used; """"""; self._get_section(section).add_timing(key, value). [docs] def add_message(self, key, value, section=None, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters; ----------; key : string; key for the section.messages dictionary; reusing a key will result in concatenation of value. value : int; Initial value of the message, or added to an existing message. sep : string; Message will be prefixed with this string when concatenating. section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used; """"""; self._get_section(section).add_message(key, value, sep=sep). [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters; ----------; value : float; Time in seconds to complete the solver section. section : string or `class` : _StatsSection; Section which to set the total_time for; If None given, the total_time for complete solve is set; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if section is None:; self.total_time = value; else:; sect = self._get_section(section); sect.total_time = value. [docs] def report(self, ",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:20375,Integrability,message,message,20375,"ection then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters; ----------; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value. value : int; Initial value of the timing, or added to an existing timing. section: string or `class` : _StatsSection; Section which to add the timing to.; If None given, the default (first) section will be used; """"""; self._get_section(section).add_timing(key, value). [docs] def add_message(self, key, value, section=None, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters; ----------; key : string; key for the section.messages dictionary; reusing a key will result in concatenation of value. value : int; Initial value of the message, or added to an existing message. sep : string; Message will be prefixed with this string when concatenating. section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used; """"""; self._get_section(section).add_message(key, value, sep=sep). [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters; ----------; value : float; Time in seconds to complete the solver section. section : string or `class` : _StatsSection; Section which to set the total_time for; If None given, the total_time for complete solve is set; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if section is None:; self.total_time = value; else:; sect = self._get_section(section); sect.total_time = value. [docs] def report(self, ",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:20529,Integrability,message,message,20529,"s. Parameters; ----------; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value. value : int; Initial value of the timing, or added to an existing timing. section: string or `class` : _StatsSection; Section which to add the timing to.; If None given, the default (first) section will be used; """"""; self._get_section(section).add_timing(key, value). [docs] def add_message(self, key, value, section=None, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters; ----------; key : string; key for the section.messages dictionary; reusing a key will result in concatenation of value. value : int; Initial value of the message, or added to an existing message. sep : string; Message will be prefixed with this string when concatenating. section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used; """"""; self._get_section(section).add_message(key, value, sep=sep). [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters; ----------; value : float; Time in seconds to complete the solver section. section : string or `class` : _StatsSection; Section which to set the total_time for; If None given, the total_time for complete solve is set; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if section is None:; self.total_time = value; else:; sect = self._get_section(section); sect.total_time = value. [docs] def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in t",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:21402,Integrability,message,messages,21402,"ring; Message will be prefixed with this string when concatenating. section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used; """"""; self._get_section(section).add_message(key, value, sep=sep). [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters; ----------; value : float; Time in seconds to complete the solver section. section : string or `class` : _StatsSection; Section which to set the total_time for; If None given, the total_time for complete solve is set; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if section is None:; self.total_time = value; else:; sect = self._get_section(section); sect.total_time = value. [docs] def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters; ----------; output : stream; file or console stream - anything that support write - where; the output will be written; """""". if not hasattr(output, 'write'):; raise TypeError(""output must have a write method""). if self.header:; output.write(""{}\n{}\n"".format(self.header,; (""=""*len(self.header)))); for name, sect in self.sections.items():; sect.report(output). if self.total_time is not None:; output.write(""\nSummary\n-------\n""); output.write(""{}\t solver total time\n"".format(; _format_time(self.total_time))). [docs] def clear(self):; """"""; Clear counts, timings and messages from all sections; """"""; for sect in",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:21541,Integrability,message,messages,21541,"""""; self._get_section(section).add_message(key, value, sep=sep). [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters; ----------; value : float; Time in seconds to complete the solver section. section : string or `class` : _StatsSection; Section which to set the total_time for; If None given, the total_time for complete solve is set; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if section is None:; self.total_time = value; else:; sect = self._get_section(section); sect.total_time = value. [docs] def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters; ----------; output : stream; file or console stream - anything that support write - where; the output will be written; """""". if not hasattr(output, 'write'):; raise TypeError(""output must have a write method""). if self.header:; output.write(""{}\n{}\n"".format(self.header,; (""=""*len(self.header)))); for name, sect in self.sections.items():; sect.report(output). if self.total_time is not None:; output.write(""\nSummary\n-------\n""); output.write(""{}\t solver total time\n"".format(; _format_time(self.total_time))). [docs] def clear(self):; """"""; Clear counts, timings and messages from all sections; """"""; for sect in self.sections.values():; sect.clear(); self.total_time = None. class _StatsSection(object):; """"""; Not intended to be directly instantiated; This is the type for the SolverStats.sections values. The method p",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:22349,Integrability,message,messages,22349,"output=sys.stdout):; """"""; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters; ----------; output : stream; file or console stream - anything that support write - where; the output will be written; """""". if not hasattr(output, 'write'):; raise TypeError(""output must have a write method""). if self.header:; output.write(""{}\n{}\n"".format(self.header,; (""=""*len(self.header)))); for name, sect in self.sections.items():; sect.report(output). if self.total_time is not None:; output.write(""\nSummary\n-------\n""); output.write(""{}\t solver total time\n"".format(; _format_time(self.total_time))). [docs] def clear(self):; """"""; Clear counts, timings and messages from all sections; """"""; for sect in self.sections.values():; sect.clear(); self.total_time = None. class _StatsSection(object):; """"""; Not intended to be directly instantiated; This is the type for the SolverStats.sections values. The method parameter descriptions are the same as for those the parent; with the same method name. Parameters; ----------; name : string; key for the parent sections dictionary; will also be used as the header. parent : `class` : SolverStats; The container for all the sections. Attributes; ----------; name : string; key for the parent sections dictionary; will also be used as the header. parent : `class` : SolverStats; The container for all the sections. header : string; Used as heading for section in report. counts : OrderedDict; The integer type statistics for the stats section. timings : OrderedDict; The timing type statistics for the stats section; Expected to contain float values representing values in seconds. messages : OrderedDict; Text typ",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:23314,Integrability,message,messages,23314,"ngs and messages from all sections; """"""; for sect in self.sections.values():; sect.clear(); self.total_time = None. class _StatsSection(object):; """"""; Not intended to be directly instantiated; This is the type for the SolverStats.sections values. The method parameter descriptions are the same as for those the parent; with the same method name. Parameters; ----------; name : string; key for the parent sections dictionary; will also be used as the header. parent : `class` : SolverStats; The container for all the sections. Attributes; ----------; name : string; key for the parent sections dictionary; will also be used as the header. parent : `class` : SolverStats; The container for all the sections. header : string; Used as heading for section in report. counts : OrderedDict; The integer type statistics for the stats section. timings : OrderedDict; The timing type statistics for the stats section; Expected to contain float values representing values in seconds. messages : OrderedDict; Text type output to be reported. total_time : float; Total time for processing in the section; Can be None, meaning that section timing percentages will be reported; """"""; def __init__(self, name, parent):; self.parent = parent; self.header = str(name); self.name = name; self.counts = OrderedDict(); self.timings = OrderedDict(); self.messages = OrderedDict(); self.total_time = None. def add_count(self, key, value):; """"""; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the given value; value is expected to be an integer; """"""; if not isinstance(value, int):; try:; value = int(value); except:; raise TypeError(""value is expected to be an integer""). if key in self.counts:; self.counts[key] += value; else:; self.counts[key] = value. def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increase",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:23673,Integrability,message,messages,23673,"arameters; ----------; name : string; key for the parent sections dictionary; will also be used as the header. parent : `class` : SolverStats; The container for all the sections. Attributes; ----------; name : string; key for the parent sections dictionary; will also be used as the header. parent : `class` : SolverStats; The container for all the sections. header : string; Used as heading for section in report. counts : OrderedDict; The integer type statistics for the stats section. timings : OrderedDict; The timing type statistics for the stats section; Expected to contain float values representing values in seconds. messages : OrderedDict; Text type output to be reported. total_time : float; Total time for processing in the section; Can be None, meaning that section timing percentages will be reported; """"""; def __init__(self, name, parent):; self.parent = parent; self.header = str(name); self.name = name; self.counts = OrderedDict(); self.timings = OrderedDict(); self.messages = OrderedDict(); self.total_time = None. def add_count(self, key, value):; """"""; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the given value; value is expected to be an integer; """"""; if not isinstance(value, int):; try:; value = int(value); except:; raise TypeError(""value is expected to be an integer""). if key in self.counts:; self.counts[key] += value; else:; self.counts[key] = value. def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value. def add_message(self, key, value, sep="";""):; """"""; Add v",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:24697,Integrability,message,message,24697,"elf.messages = OrderedDict(); self.total_time = None. def add_count(self, key, value):; """"""; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the given value; value is expected to be an integer; """"""; if not isinstance(value, int):; try:; value = int(value); except:; raise TypeError(""value is expected to be an integer""). if key in self.counts:; self.counts[key] += value; else:; self.counts[key] = value. def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value. def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value ""; ""with the given seperator""); self.messages[key] += value; else:; self.messages[key] = value. def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Tim",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:24833,Integrability,message,message,24833,"th this value.; If key already exists it is increased by the given value; value is expected to be an integer; """"""; if not isinstance(value, int):; try:; value = int(value); except:; raise TypeError(""value is expected to be an integer""). if key in self.counts:; self.counts[key] += value; else:; self.counts[key] = value. def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value. def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value ""; ""with the given seperator""); self.messages[key] += value; else:; self.messages[key] = value. def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} to",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:24923,Integrability,message,messages,24923," = int(value); except:; raise TypeError(""value is expected to be an integer""). if key in self.counts:; self.counts[key] += value; else:; self.counts[key] = value. def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value. def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value ""; ""with the given seperator""); self.messages[key] += value; else:; self.messages[key] = value. def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt),; self.name)). # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".f",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:25083,Integrability,message,messages,25083,"ts:; self.counts[key] += value; else:; self.counts[key] = value. def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value. def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value ""; ""with the given seperator""); self.messages[key] += value; else:; self.messages[key] = value. def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt),; self.name)). # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l). # Report messages; output.write(""### Messages:\n""); for key, v",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:25119,Integrability,message,messages,25119,"e; else:; self.counts[key] = value. def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value. def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value ""; ""with the given seperator""); self.messages[key] += value; else:; self.messages[key] = value. def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt),; self.name)). # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l). # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items()",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:25216,Integrability,message,messages,25216,"Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value. def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value ""; ""with the given seperator""); self.messages[key] += value; else:; self.messages[key] = value. def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt),; self.name)). # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l). # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l). def clear(self):;",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:26048,Integrability,message,messages,26048,"ith the given seperator""); self.messages[key] += value; else:; self.messages[key] = value. def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt),; self.name)). # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l). # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l). def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None. def _solver_safety_check(H, state=None, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type; else",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:26114,Integrability,message,messages,26114,".messages[key] = value. def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt),; self.name)). # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l). # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l). def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None. def _solver_safety_check(H, state=None, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type; else:; raise Exception('Invalid td-list element.'); # Check all operato",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:26238,Integrability,message,messages,26238,"s section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt),; self.name)). # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l). # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l). def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None. def _solver_safety_check(H, state=None, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].ty",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:26319,Integrability,message,messages,26319," parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt),; self.name)). # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l). # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l). def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None. def _solver_safety_check(H, state=None, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].type; elif isinstance(H[ii], list):; _temp_dims = H[ii][0].dims; _temp_type = H[ii][0].type; e",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:27587,Integrability,depend,dependent,27587,"; # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].type; elif isinstance(H[ii], list):; _temp_dims = H[ii][0].dims; _temp_type = H[ii][0].type; elif isinstance(H[ii], (FunctionType, BuiltinFunctionType)):; _temp_dims = H[ii](0,args).dims; _temp_type = H[ii](0,args).type; else:; raise Exception('Invalid td-list element.'); _structure_check(_temp_dims,_temp_type,state). else:; raise Exception('Invalid time-dependent format.'). for ii in range(len(c_ops)):; do_tests = True; if isinstance(c_ops[ii], Qobj):; _temp_state = c_ops[ii]; elif isinstance(c_ops[ii], list):; if isinstance(c_ops[ii][0], Qobj):; _temp_state = c_ops[ii][0]; elif isinstance(c_ops[ii][0], tuple):; do_tests = False; for kk in range(len(c_ops[ii][0])):; _temp_state = c_ops[ii][0][kk]; _structure_check(Hdims, Htype, _temp_state); else:; raise Exception('Invalid td-list element.'); if do_tests:; _structure_check(Hdims, Htype, _temp_state). if isinstance(e_ops, list):; for ii in range(len(e_ops)):; if isinstance(e_ops[ii], Qobj):; _temp_state = e_ops[ii]; elif isinstance(e_ops[ii], list):; _temp_state = e_ops[ii][0]; else:; raise Exception('Invalid td-list element.'); _structure_check(Hdims,Htype,_temp_state); elif isinstance(e_ops, FunctionType):; pass; else:; raise Exception('Invalid e_ops specification.'). def _structure_check(Hdims, Htype, state):; if state is not None:; # Input state is a ket vector; if state.",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:16031,Modifiability,variab,variables,16031,"a = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver. def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt is not None:; sect_percent = 100*t/tt; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% section, {:03.2f}% total)"".format(; sect_percent, solve_percent); elif tt is not None:; sect_percent = 100*t/tt; time_str += "" ({:03.2f}% section)"".format(sect_percent). elif ttt is not None:; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% total)"".format(solve_percent). return time_str. [docs]class Stats:; """"""; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor, then all statistics; will be added to one section 'main'. Parameters; ----------; section_names : list; list of keys that will be used as keys for the sections; These keys will also be used as names for the sections; The text in the output can be overidden by setting the header property; of the sec",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:29439,Modifiability,config,config,29439,"ps[ii][0], tuple):; do_tests = False; for kk in range(len(c_ops[ii][0])):; _temp_state = c_ops[ii][0][kk]; _structure_check(Hdims, Htype, _temp_state); else:; raise Exception('Invalid td-list element.'); if do_tests:; _structure_check(Hdims, Htype, _temp_state). if isinstance(e_ops, list):; for ii in range(len(e_ops)):; if isinstance(e_ops[ii], Qobj):; _temp_state = e_ops[ii]; elif isinstance(e_ops[ii], list):; _temp_state = e_ops[ii][0]; else:; raise Exception('Invalid td-list element.'); _structure_check(Hdims,Htype,_temp_state); elif isinstance(e_ops, FunctionType):; pass; else:; raise Exception('Invalid e_ops specification.'). def _structure_check(Hdims, Htype, state):; if state is not None:; # Input state is a ket vector; if state.type == 'ket':; # Input is Hamiltonian; if Htype == 'oper':; if Hdims[1] != state.dims[0]:; raise Exception('Input operator and ket do not '; 'share same structure.'); # Input is super and state is ket; elif Htype == 'super':; if Hdims[1][1] != state.dims[0]:; raise Exception('Input operator and ket do not '; 'share same structure.'); else:; raise Exception('Invalid input operator.'); # Input state is a density matrix; elif state.type == 'oper':; # Input is Hamiltonian and state is density matrix; if Htype == 'oper':; if Hdims[1] != state.dims[0]:; raise Exception('Input operators do not '; 'share same structure.'); # Input is super op. and state is density matrix; elif Htype == 'super':; if Hdims[1] != state.dims:; raise Exception('Input operators do not '; 'share same structure.'). #; # create a global instance of the SolverConfiguration class; #; config = SolverConfiguration(). # for backwards compatibility; Odeoptions = Options; Odedata = Result. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:13373,Performance,load,loading,13373,"expect = []; self.num_expect = 0; self.num_collapse = 0; self.ntraj = None; self.seeds = None; self.col_times = None; self.col_which = None. def __str__(self):; s = ""Result object ""; if self.solver:; s += ""with "" + self.solver + "" data.\n""; else:; s += ""missing solver information.\n""; s += ""-"" * (len(s) - 1) + ""\n""; if self.states is not None and len(self.states) > 0:; s += ""states = True\n""; elif self.expect is not None and len(self.expect) > 0:; s += ""expect = True\nnum_expect = "" + str(self.num_expect) + "", ""; else:; s += ""states = True, expect = True\n"" + \; ""num_expect = "" + str(self.num_expect) + "", ""; s += ""num_collapse = "" + str(self.num_collapse); if self.solver == 'mcsolve':; s += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). # %%%%%%%%%%% remove ?; [docs]class SolverConfiguration():; def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):; # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. self.soft_reset(). def soft_reset(self):; # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltoni",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:16623,Performance,perform,performance,16623,"]; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver. def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt is not None:; sect_percent = 100*t/tt; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% section, {:03.2f}% total)"".format(; sect_percent, solve_percent); elif tt is not None:; sect_percent = 100*t/tt; time_str += "" ({:03.2f}% section)"".format(sect_percent). elif ttt is not None:; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% total)"".format(solve_percent). return time_str. [docs]class Stats:; """"""; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor, then all statistics; will be added to one section 'main'. Parameters; ----------; section_names : list; list of keys that will be used as keys for the sections; These keys will also be used as names for the sections; The text in the output can be overidden by setting the header property; of the section; If no names are given then one section called 'main' is created. Attributes; ----------; sections : OrderedDict of _StatsSection; These are the sections that are created automatically on instantiation; or added using add_section. header : string; Some text that will be used as the heading in the report; By default there is None. total_time : float; Time in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported; """""". def __init__(self, section_names=None):; self._def_section_name = 'main'; self.sections = OrderedDict(",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:22304,Usability,clear,clear,22304,"output=sys.stdout):; """"""; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters; ----------; output : stream; file or console stream - anything that support write - where; the output will be written; """""". if not hasattr(output, 'write'):; raise TypeError(""output must have a write method""). if self.header:; output.write(""{}\n{}\n"".format(self.header,; (""=""*len(self.header)))); for name, sect in self.sections.items():; sect.report(output). if self.total_time is not None:; output.write(""\nSummary\n-------\n""); output.write(""{}\t solver total time\n"".format(; _format_time(self.total_time))). [docs] def clear(self):; """"""; Clear counts, timings and messages from all sections; """"""; for sect in self.sections.values():; sect.clear(); self.total_time = None. class _StatsSection(object):; """"""; Not intended to be directly instantiated; This is the type for the SolverStats.sections values. The method parameter descriptions are the same as for those the parent; with the same method name. Parameters; ----------; name : string; key for the parent sections dictionary; will also be used as the header. parent : `class` : SolverStats; The container for all the sections. Attributes; ----------; name : string; key for the parent sections dictionary; will also be used as the header. parent : `class` : SolverStats; The container for all the sections. header : string; Used as heading for section in report. counts : OrderedDict; The integer type statistics for the stats section. timings : OrderedDict; The timing type statistics for the stats section; Expected to contain float values representing values in seconds. messages : OrderedDict; Text typ",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:22424,Usability,clear,clear,22424,"Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters; ----------; output : stream; file or console stream - anything that support write - where; the output will be written; """""". if not hasattr(output, 'write'):; raise TypeError(""output must have a write method""). if self.header:; output.write(""{}\n{}\n"".format(self.header,; (""=""*len(self.header)))); for name, sect in self.sections.items():; sect.report(output). if self.total_time is not None:; output.write(""\nSummary\n-------\n""); output.write(""{}\t solver total time\n"".format(; _format_time(self.total_time))). [docs] def clear(self):; """"""; Clear counts, timings and messages from all sections; """"""; for sect in self.sections.values():; sect.clear(); self.total_time = None. class _StatsSection(object):; """"""; Not intended to be directly instantiated; This is the type for the SolverStats.sections values. The method parameter descriptions are the same as for those the parent; with the same method name. Parameters; ----------; name : string; key for the parent sections dictionary; will also be used as the header. parent : `class` : SolverStats; The container for all the sections. Attributes; ----------; name : string; key for the parent sections dictionary; will also be used as the header. parent : `class` : SolverStats; The container for all the sections. header : string; Used as heading for section in report. counts : OrderedDict; The integer type statistics for the stats section. timings : OrderedDict; The timing type statistics for the stats section; Expected to contain float values representing values in seconds. messages : OrderedDict; Text type output to be reported. total_time : float; Total time for processing in the section",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:26193,Usability,clear,clear,26193,"s section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt),; self.name)). # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l). # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l). def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None. def _solver_safety_check(H, state=None, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].ty",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:26283,Usability,clear,clear,26283,"total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt),; self.name)). # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l). # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l). def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None. def _solver_safety_check(H, state=None, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].type; elif isinstance(H[ii], list):; _temp_dims = H[ii][0].d",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:26305,Usability,clear,clear,26305,"iven if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt),; self.name)). # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l). # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l). def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None. def _solver_safety_check(H, state=None, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].type; elif isinstance(H[ii], list):; _temp_dims = H[ii][0].dims; _temp_type = H[ii",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/solver.html:26328,Usability,clear,clear,26328,"or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt),; self.name)). # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l). # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l). def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None. def _solver_safety_check(H, state=None, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].type; elif isinstance(H[ii], list):; _temp_dims = H[ii][0].dims; _temp_type = H[ii][0].type; elif isinsta",MatchSource.WIKI,docs/4.6/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html
https://qutip.org/docs/4.6/modules/qutip/states.html:15941,Availability,down,down,15941,"[3]], \; shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j]; [ 0.+0.j 0.+0.j 0.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j]]. """"""; if Q.type == 'ket':; out = Q * Q.dag(); elif Q.type == 'bra':; out = Q.dag() * Q; else:; raise TypeError(""Input is not a ket or bra vector.""); return Qobj(out). #; # projection operator; #; [docs]def projection(N, n, m, offset=None):; r""""""; The projection operator that projects state :math:`\lvert m\rangle` on; state :math:`\lvert n\rangle`. Parameters; ----------; N : int; Number of basis states in Hilbert space. n, m : float; The number states in the projection. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the projector. Returns; -------; oper : qobj; Requested projection operator.; """"""; ket1 = basis(N, n, offset=offset); ket2 = basis(N, m, offset=offset). return ket1 * ket2.dag(). #; # composite qubit states; #; def qstate(string):; r""""""Creates a tensor product for a set of qubits in either; the 'up' :math:`\lvert0\rangle` or 'down' :math:`\lvert1\rangle` state. Parameters; ----------; string : str; String containing 'u' or 'd' for each qubit (ex. 'ududd'). Returns; -------; qstate : qobj; Qobj for tensor product corresponding to input string. Notes; -----; Look at ket and bra for more general functions; creating multiparticle states. Examples; --------; >>> qstate('udu') # doctest: +SKIP; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]; """"""; n = len(string); if n != (string.count('u') + string.count('d')):; raise TypeError('String input to QSTATE must consist ' +; 'of ""u"" and ""d"" elements only'); else:; up = basis(2, 1); dn = basis(2, 0); lst = []; for k in range(n):; if string[k] == 'u':; lst.append(up); else:; lst.append(dn); return tensor(lst). #; # different qubit notation dictionary; #; _qubit_dict = {'g': 0, # ground state; 'e': 1, # excited state; '",MatchSource.WIKI,docs/4.6/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/states.html
https://qutip.org/docs/4.6/modules/qutip/states.html:16917,Availability,down,down,16917,"et of qubits in either; the 'up' :math:`\lvert0\rangle` or 'down' :math:`\lvert1\rangle` state. Parameters; ----------; string : str; String containing 'u' or 'd' for each qubit (ex. 'ududd'). Returns; -------; qstate : qobj; Qobj for tensor product corresponding to input string. Notes; -----; Look at ket and bra for more general functions; creating multiparticle states. Examples; --------; >>> qstate('udu') # doctest: +SKIP; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]; """"""; n = len(string); if n != (string.count('u') + string.count('d')):; raise TypeError('String input to QSTATE must consist ' +; 'of ""u"" and ""d"" elements only'); else:; up = basis(2, 1); dn = basis(2, 0); lst = []; for k in range(n):; if string[k] == 'u':; lst.append(up); else:; lst.append(dn); return tensor(lst). #; # different qubit notation dictionary; #; _qubit_dict = {'g': 0, # ground state; 'e': 1, # excited state; 'u': 0, # spin up; 'd': 1, # spin down; 'H': 0, # horizontal polarization; 'V': 1} # vertical polarization. def _character_to_qudit(x):; """"""; Converts a character representing a one-particle state into int.; """"""; if x in _qubit_dict:; return _qubit_dict[x]; else:; return int(x). [docs]def ket(seq, dim=2):; """"""; Produces a multiparticle ket state for a list or string,; where each element stands for state of the respective particle. Parameters; ----------; seq : str / list of ints or characters; Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string ""1101"").; For qubits it is also possible to use the following conventions:; - 'g'/'e' (ground and excited state); - 'u'/'d' (spin up and down); - 'H'/'V' (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dim : int (default: 2) / list of ints; Space dimension for each particle:; int if there are the same, list if they are different. Returns; -------; ket : qobj. Examples; ----",MatchSource.WIKI,docs/4.6/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/states.html
https://qutip.org/docs/4.6/modules/qutip/states.html:17603,Availability,down,down,17603," ""u"" and ""d"" elements only'); else:; up = basis(2, 1); dn = basis(2, 0); lst = []; for k in range(n):; if string[k] == 'u':; lst.append(up); else:; lst.append(dn); return tensor(lst). #; # different qubit notation dictionary; #; _qubit_dict = {'g': 0, # ground state; 'e': 1, # excited state; 'u': 0, # spin up; 'd': 1, # spin down; 'H': 0, # horizontal polarization; 'V': 1} # vertical polarization. def _character_to_qudit(x):; """"""; Converts a character representing a one-particle state into int.; """"""; if x in _qubit_dict:; return _qubit_dict[x]; else:; return int(x). [docs]def ket(seq, dim=2):; """"""; Produces a multiparticle ket state for a list or string,; where each element stands for state of the respective particle. Parameters; ----------; seq : str / list of ints or characters; Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string ""1101"").; For qubits it is also possible to use the following conventions:; - 'g'/'e' (ground and excited state); - 'u'/'d' (spin up and down); - 'H'/'V' (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dim : int (default: 2) / list of ints; Space dimension for each particle:; int if there are the same, list if they are different. Returns; -------; ket : qobj. Examples; --------; >>> ket(""10"") # doctest: +SKIP; Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 1.]; [ 0.]]. >>> ket(""Hue"") # doctest: +SKIP; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""12"", 3) # doctest: +SKIP; Quantum object: dims = [[3, 3], [1, 1]], shape = [9, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""31"", [5, 2]) # doctest: +SKIP; Quantum object: dims = [[5, 2], [1, 1]], shape = [10, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]; """"""",MatchSource.WIKI,docs/4.6/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/states.html
https://qutip.org/docs/4.6/modules/qutip/states.html:19167,Availability,down,down,19167,".]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""12"", 3) # doctest: +SKIP; Quantum object: dims = [[3, 3], [1, 1]], shape = [9, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""31"", [5, 2]) # doctest: +SKIP; Quantum object: dims = [[5, 2], [1, 1]], shape = [10, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]; """"""; if isinstance(dim, int):; dim = [dim] * len(seq); return tensor([basis(dim[i], _character_to_qudit(x)); for i, x in enumerate(seq)]). [docs]def bra(seq, dim=2):; """"""; Produces a multiparticle bra state for a list or string,; where each element stands for state of the respective particle. Parameters; ----------; seq : str / list of ints or characters; Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string ""1101"").; For qubits it is also possible to use the following conventions:. - 'g'/'e' (ground and excited state); - 'u'/'d' (spin up and down); - 'H'/'V' (horizontal and vertical polarization). Note: for dimension > 9 you need to use a list. dim : int (default: 2) / list of ints; Space dimension for each particle:; int if there are the same, list if they are different. Returns; -------; bra : qobj. Examples; --------; >>> bra(""10"") # doctest: +SKIP; Quantum object: dims = [[1, 1], [2, 2]], shape = [1, 4], type = bra; Qobj data =; [[ 0. 0. 1. 0.]]. >>> bra(""Hue"") # doctest: +SKIP; Quantum object: dims = [[1, 1, 1], [2, 2, 2]], shape = [1, 8], type = bra; Qobj data =; [[ 0. 1. 0. 0. 0. 0. 0. 0.]]. >>> bra(""12"", 3) # doctest: +SKIP; Quantum object: dims = [[1, 1], [3, 3]], shape = [1, 9], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 1. 0. 0. 0.]]. >>> bra(""31"", [5, 2]) # doctest: +SKIP; Quantum object: dims = [[1, 1], [5, 2]], shape = [1, 10], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]]; """"""; return ket(seq, dim=dim).dag(). #; # quantum state number helper functions; #; [docs]def state_number_enumerate(dim",MatchSource.WIKI,docs/4.6/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/states.html
https://qutip.org/docs/4.6/modules/qutip/states.html:32179,Deployability,update,updated,32179,"))+tensor(basis(2, 1), basis(2)); elif state == '11':; Bell_state = tensor(; basis(2), basis(2, 1))-tensor(basis(2, 1), basis(2)). return Bell_state.unit(). [docs]def singlet_state():; r""""""; Returns the two particle singlet-state:. .. math::. \lvert S\rangle = \frac1{\sqrt2}(\lvert01\rangle-\lvert10\rangle). that is identical to the fourth bell state. Returns; -------; Bell_state : qobj; :math:`\lvert B_{11}\rangle` Bell state; """"""; return bell_state('11'). [docs]def triplet_states():; r""""""; Returns a list of the two particle triplet-states:. .. math::. \lvert T_1\rangle = \lvert11\rangle; \lvert T_2\rangle = \frac1{\sqrt2}(\lvert01\rangle + \lvert10\rangle); \lvert T_3\rangle = \lvert00\rangle. Returns; -------; trip_states : list; 2 particle triplet states. """"""; trip_states = []; trip_states.append(tensor(basis(2, 1), basis(2, 1))); trip_states.append(; (tensor(basis(2), basis(2, 1)) + tensor(basis(2, 1), basis(2))).unit(); ); trip_states.append(tensor(basis(2), basis(2))); return trip_states. [docs]def w_state(N=3):; """"""; Returns the N-qubit W-state. Parameters; ----------; N : int (default=3); Number of qubits in state. Returns; -------; W : qobj; N-qubit W-state. """"""; inds = np.zeros(N, dtype=int); inds[0] = 1; state = tensor([basis(2, x) for x in inds]); for kk in range(1, N):; perm_inds = np.roll(inds, kk); state += tensor([basis(2, x) for x in perm_inds]); return state.unit(). [docs]def ghz_state(N=3):; """"""; Returns the N-qubit GHZ-state. Parameters; ----------; N : int (default=3); Number of qubits in state. Returns; -------; G : qobj; N-qubit GHZ-state. """"""; state = (tensor([basis(2) for k in range(N)]) +; tensor([basis(2, 1) for k in range(N)])); return state/np.sqrt(2). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/states.html
https://qutip.org/docs/4.6/modules/qutip/states.html:4854,Testability,log,logic,4854,"ted. The shape must match ``dimensions``, e.g. if; ``dimensions`` is a list, then ``n`` must either be omitted or a list; of equal length. offset : int or list of ints, optional (default 0 for all dimensions); The lowest number state that is included in the finite number state; representation of the state in the relevant dimension. Returns; -------; state : :class:`qutip.Qobj`; Qobj representing the requested number state ``|n>``. Examples; --------; >>> basis(5,2) # doctest: +SKIP; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.+0.j]; [ 0.+0.j]; [ 1.+0.j]; [ 0.+0.j]; [ 0.+0.j]]; >>> basis([2,2,2], [0,1,0]) # doctest: +SKIP; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]; [0.]; [0.]; [0.]; [0.]]. Notes; -----; A subtle incompatibility with the quantum optics toolbox: In QuTiP::. basis(N, 0) = ground state. but in the qotoolbox::. basis(N, 1) = ground state. """"""; # Promote all parameters to lists to simplify later logic.; if not isinstance(dimensions, list):; dimensions = [dimensions]; n_dimensions = len(dimensions); ns = [m-off for m, off in zip(_promote_to_zero_list(n, n_dimensions),; _promote_to_zero_list(offset, n_dimensions))]; if any((not isinstance(x, numbers.Integral)) or x < 0 for x in dimensions):; raise ValueError(""All dimensions must be >= 0.""); if not all(0 <= n < dimension for n, dimension in zip(ns, dimensions)):; raise ValueError(""All basis indices must be ""; ""`offset <= n < dimension+offset`.""); location, size = 0, 1; for m, dimension in zip(reversed(ns), reversed(dimensions)):; location += m*size; size *= dimension; data = np.array([1], dtype=complex); ind = np.array([0], dtype=np.int32); ptr = np.array([0]*(location+1) + [1]*(size-location), dtype=np.int32); return Qobj(fast_csr_matrix((data, ind, ptr), shape=(size, 1)),; dims=[dimensions, [1]*n_dimensions], isherm=False). [docs]def qutrit_basis():; """"""Basis states for a three level system (qutrit). R",MatchSource.WIKI,docs/4.6/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/states.html
https://qutip.org/docs/4.6/modules/qutip/states.html:13606,Testability,log,log,13606,"-------; >>> thermal_dm(5, 1) # doctest: +SKIP; Quantum object: dims = [[5], [5]], \; shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.51612903 0. 0. 0. 0. ]; [ 0. 0.25806452 0. 0. 0. ]; [ 0. 0. 0.12903226 0. 0. ]; [ 0. 0. 0. 0.06451613 0. ]; [ 0. 0. 0. 0. 0.03225806]]. >>> thermal_dm(5, 1, 'analytic') # doctest: +SKIP; Quantum object: dims = [[5], [5]], \; shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. Notes; -----; The 'operator' method (default) generates; the thermal state using the truncated number operator ``num(N)``. This; is the method that should be used in computations. The; 'analytic' method uses the analytic coefficients derived in; an infinite Hilbert space. The analytic form is not necessarily normalized,; if truncated too aggressively. """"""; if n == 0:; return fock_dm(N, 0); else:; i = arange(N); if method == 'operator':; beta = np.log(1.0 / n + 1.0); diags = np.exp(-beta * i); diags = diags / np.sum(diags); # populates diagonal terms using truncated operator expression; rm = sp.spdiags(diags, 0, N, N, format='csr'); elif method == 'analytic':; # populates diagonal terms using analytic values; rm = sp.spdiags((1.0 + n) ** (-1.0) * (n / (1.0 + n)) ** (i),; 0, N, N, format='csr'); else:; raise ValueError(""The method option can only take ""; ""values 'operator' or 'analytic'""); return Qobj(rm). [docs]def maximally_mixed_dm(N):; """"""; Returns the maximally mixed density matrix for a Hilbert space of; dimension N. Parameters; ----------; N : int; Number of basis states in Hilbert space. Returns; -------; dm : qobj; Thermal state density matrix.; """"""; if (not isinstance(N, (int, np.int64))) or N <= 0:; raise ValueError(""N must be integer N > 0""). dm = sp.spdiags(np.ones(N, dtype=complex)/float(N), 0, N, N, format='csr'). return Qobj(dm, isherm=True). [docs]def ket2dm(Q):; """"""Takes input ket or bra vector and returns density ",MatchSource.WIKI,docs/4.6/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/states.html
https://qutip.org/docs/4.6/modules/qutip/states.html:4839,Usability,simpl,simplify,4839,"ted. The shape must match ``dimensions``, e.g. if; ``dimensions`` is a list, then ``n`` must either be omitted or a list; of equal length. offset : int or list of ints, optional (default 0 for all dimensions); The lowest number state that is included in the finite number state; representation of the state in the relevant dimension. Returns; -------; state : :class:`qutip.Qobj`; Qobj representing the requested number state ``|n>``. Examples; --------; >>> basis(5,2) # doctest: +SKIP; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.+0.j]; [ 0.+0.j]; [ 1.+0.j]; [ 0.+0.j]; [ 0.+0.j]]; >>> basis([2,2,2], [0,1,0]) # doctest: +SKIP; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]; [0.]; [0.]; [0.]; [0.]]. Notes; -----; A subtle incompatibility with the quantum optics toolbox: In QuTiP::. basis(N, 0) = ground state. but in the qotoolbox::. basis(N, 1) = ground state. """"""; # Promote all parameters to lists to simplify later logic.; if not isinstance(dimensions, list):; dimensions = [dimensions]; n_dimensions = len(dimensions); ns = [m-off for m, off in zip(_promote_to_zero_list(n, n_dimensions),; _promote_to_zero_list(offset, n_dimensions))]; if any((not isinstance(x, numbers.Integral)) or x < 0 for x in dimensions):; raise ValueError(""All dimensions must be >= 0.""); if not all(0 <= n < dimension for n, dimension in zip(ns, dimensions)):; raise ValueError(""All basis indices must be ""; ""`offset <= n < dimension+offset`.""); location, size = 0, 1; for m, dimension in zip(reversed(ns), reversed(dimensions)):; location += m*size; size *= dimension; data = np.array([1], dtype=complex); ind = np.array([0], dtype=np.int32); ptr = np.array([0]*(location+1) + [1]*(size-location), dtype=np.int32); return Qobj(fast_csr_matrix((data, ind, ptr), shape=(size, 1)),; dims=[dimensions, [1]*n_dimensions], isherm=False). [docs]def qutrit_basis():; """"""Basis states for a three level system (qutrit). R",MatchSource.WIKI,docs/4.6/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/states.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:5759,Availability,avail,availability,5759,"100, 'diag_pivot_thresh': 0.1, 'maxiter': 1000,; 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2',; 'restart': 20,; 'max_iter_refine': 10,; 'scaling_vectors': True,; 'weighted_matching': True,; 'return_info': False, 'info': _empty_info_dict(),; 'verbose': False, 'solver': 'scipy', 'weight': None,; 'tol': 1e-12, 'matol': 1e-15, 'mtol': None}; return def_args. [docs]def steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs):; """"""; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`~Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : {'scipy', 'mkl'}, optional; Selects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. method : str, default 'direct'; The allowed methods are. - 'direct'; - 'eigen'; - 'iterative-gmres'; - 'iterative-lgmres'; - 'iterative-bicgstab'; - 'svd'; - 'power'; - 'power-gmres'; - 'power-lgmres'; - 'power-bicgstab'. Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen', iterative GMRES; method 'iterative-gmres', iterative LGMRES method 'iterative-lgmres',; iterative BICGSTAB method 'iterative-bicgstab', SVD 'svd' (dense), or; inverse-power method 'power'. The iterative power methods; 'power-gmres', 'power-lgmres', 'power-bicgstab' use the same solvers as; their direct counterparts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; ma",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:8080,Availability,toler,tolerance,8080,"; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refine : int, default 10; MKL ONLY. Max. number of iterative refinements to perform. scaling_vectors : bool; MKL ONLY. Scale matrix to unit norm columns and rows. weighted_matching : bool; MKL ONLY. Use weighted matching to better condition diagonal. x0 : ndarray, optional; ITERATIVE ONLY. Initial guess for solution vector. maxiter : int, default 1000; ITERATIVE ONLY. Maximum number of iterations to perform. tol : float, default 1e-12; ITERATIVE ONLY. Tolerance used for terminating solver. mtol : float, optional; ITERATIVE 'power' methods ONLY. Tolerance for lu solve method. If None; given then ``max(0.1*tol, 1e-15)`` is used. matol : float, default 1e-15; ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_spec : str, optional; ITERATIVE ONLY. Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' (default); and 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. use_precond : bool, default False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the 'iterative' GMRES and BICG solvers. Speeds up; convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and ``use_precond = True``, then one; is generated automatically. fill_factor : float, default 100; ITERATIVE ONLY. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values s",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:23160,Availability,error,error,23160," M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'iterative-bicgstab':; v, check = bicgstab(L, b, tol=ss_args['tol'],; atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); _iter_end = time.time(). ss_args['info']['iter_time'] = _iter_end - _iter_start; if 'precond_time' in ss_args['info'].keys():; ss_args['info']['solution_time'] = (ss_args['info']['iter_time'] +; ss_args['info']['precond_time']); else:; ss_args['info']['solution_time'] = ss_args['info']['iter_time']; ss_args['info']['iterations'] = ss_iters['iter']; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_st",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:23181,Availability,toler,tolerance,23181," M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'iterative-bicgstab':; v, check = bicgstab(L, b, tol=ss_args['tol'],; atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); _iter_end = time.time(). ss_args['info']['iter_time'] = _iter_end - _iter_start; if 'precond_time' in ss_args['info'].keys():; ss_args['info']['solution_time'] = (ss_args['info']['iter_time'] +; ss_args['info']['precond_time']); else:; ss_args['info']['solution_time'] = ss_args['info']['iter_time']; ss_args['info']['iterations'] = ss_iters['iter']; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_st",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:23352,Availability,error,error,23352,"l'],; atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); _iter_end = time.time(). ss_args['info']['iter_time'] = _iter_end - _iter_start; if 'precond_time' in ss_args['info'].keys():; ss_args['info']['solution_time'] = (ss_args['info']['iter_time'] +; ss_args['info']['precond_time']); else:; ss_args['info']['solution_time'] = ss_args['info']['iter_time']; ss_args['info']['iterations'] = ss_iters['iter']; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; retur",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:23377,Availability,error,error,23377,"l'],; atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); _iter_end = time.time(). ss_args['info']['iter_time'] = _iter_end - _iter_start; if 'precond_time' in ss_args['info'].keys():; ss_args['info']['solution_time'] = (ss_args['info']['iter_time'] +; ss_args['info']['precond_time']); else:; ss_args['info']['solution_time'] = ss_args['info']['iter_time']; ss_args['info']['iterations'] = ss_iters['iter']; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; retur",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:38377,Availability,avail,available,38377,"e, for the Liouvillian; superoperator L. w : double; frequency at which to evaluate pseudo-inverse. Can be zero for dense; systems and large sparse systems. Small sparse systems can fail for; zero frequencies. sparse : bool; Flag that indicate whether to use sparse or dense matrix methods when; computing the pseudo inverse. method : string; Name of method to use. For sparse=True, allowed values are 'spsolve',; 'splu' and 'spilu'. For sparse=False, allowed values are 'direct' and; 'numpy'. kwargs : dictionary; Additional keyword arguments for setting parameters for solver methods. Returns; -------; R : Qobj; Returns a Qobj instance representing the pseudo inverse of L. Note; ----; In general the inverse of a sparse matrix will be dense. If you; are applying the inverse to a density matrix then it is better to; cast the problem as an Ax=b type problem where the explicit calculation; of the inverse is not required. See page 67 of ""Electrons in; nanostructures"" C. Flindt, PhD Thesis available online:; http://orbit.dtu.dk/fedora/objects/orbit:82314/datastreams/; file_4732600/content. Note also that the definition of the pseudo-inverse herein is different; from numpys pinv() alone, as it includes pre and post projection onto; the subspace defined by the projector Q. """"""; pseudo_args = _default_steadystate_args(); for key in kwargs.keys():; if key in pseudo_args.keys():; pseudo_args[key] = kwargs[key]; else:; raise Exception(; ""Invalid keyword argument '""+key+""' passed to pseudo_inverse.""); if 'method' not in kwargs.keys():; pseudo_args['method'] = 'splu'. # Set column perm to NATURAL if using RCM and not specified by user; if pseudo_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; pseudo_args['permc_spec'] = 'NATURAL'. if rhoss is None:; rhoss = steadystate(L, **pseudo_args). if sparse:; return _pseudo_inverse_sparse(L, rhoss, w=w, **pseudo_args); else:; if pseudo_args['method'] != 'splu':; pseudo_args['method'] = pseudo_args['method']; else:; pseudo_args['method",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:39646,Deployability,update,updated,39646,". For sparse=True, allowed values are 'spsolve',; 'splu' and 'spilu'. For sparse=False, allowed values are 'direct' and; 'numpy'. kwargs : dictionary; Additional keyword arguments for setting parameters for solver methods. Returns; -------; R : Qobj; Returns a Qobj instance representing the pseudo inverse of L. Note; ----; In general the inverse of a sparse matrix will be dense. If you; are applying the inverse to a density matrix then it is better to; cast the problem as an Ax=b type problem where the explicit calculation; of the inverse is not required. See page 67 of ""Electrons in; nanostructures"" C. Flindt, PhD Thesis available online:; http://orbit.dtu.dk/fedora/objects/orbit:82314/datastreams/; file_4732600/content. Note also that the definition of the pseudo-inverse herein is different; from numpys pinv() alone, as it includes pre and post projection onto; the subspace defined by the projector Q. """"""; pseudo_args = _default_steadystate_args(); for key in kwargs.keys():; if key in pseudo_args.keys():; pseudo_args[key] = kwargs[key]; else:; raise Exception(; ""Invalid keyword argument '""+key+""' passed to pseudo_inverse.""); if 'method' not in kwargs.keys():; pseudo_args['method'] = 'splu'. # Set column perm to NATURAL if using RCM and not specified by user; if pseudo_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; pseudo_args['permc_spec'] = 'NATURAL'. if rhoss is None:; rhoss = steadystate(L, **pseudo_args). if sparse:; return _pseudo_inverse_sparse(L, rhoss, w=w, **pseudo_args); else:; if pseudo_args['method'] != 'splu':; pseudo_args['method'] = pseudo_args['method']; else:; pseudo_args['method'] = 'direct'; return _pseudo_inverse_dense(L, rhoss, w=w, **pseudo_args). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:5951,Energy Efficiency,power,power,5951,"ching': True,; 'return_info': False, 'info': _empty_info_dict(),; 'verbose': False, 'solver': 'scipy', 'weight': None,; 'tol': 1e-12, 'matol': 1e-15, 'mtol': None}; return def_args. [docs]def steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs):; """"""; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`~Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : {'scipy', 'mkl'}, optional; Selects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. method : str, default 'direct'; The allowed methods are. - 'direct'; - 'eigen'; - 'iterative-gmres'; - 'iterative-lgmres'; - 'iterative-bicgstab'; - 'svd'; - 'power'; - 'power-gmres'; - 'power-lgmres'; - 'power-bicgstab'. Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen', iterative GMRES; method 'iterative-gmres', iterative LGMRES method 'iterative-lgmres',; iterative BICGSTAB method 'iterative-bicgstab', SVD 'svd' (dense), or; inverse-power method 'power'. The iterative power methods; 'power-gmres', 'power-lgmres', 'power-bicgstab' use the same solvers as; their direct counterparts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, default False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_w",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:5962,Energy Efficiency,power,power-gmres,5962,"ching': True,; 'return_info': False, 'info': _empty_info_dict(),; 'verbose': False, 'solver': 'scipy', 'weight': None,; 'tol': 1e-12, 'matol': 1e-15, 'mtol': None}; return def_args. [docs]def steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs):; """"""; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`~Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : {'scipy', 'mkl'}, optional; Selects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. method : str, default 'direct'; The allowed methods are. - 'direct'; - 'eigen'; - 'iterative-gmres'; - 'iterative-lgmres'; - 'iterative-bicgstab'; - 'svd'; - 'power'; - 'power-gmres'; - 'power-lgmres'; - 'power-bicgstab'. Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen', iterative GMRES; method 'iterative-gmres', iterative LGMRES method 'iterative-lgmres',; iterative BICGSTAB method 'iterative-bicgstab', SVD 'svd' (dense), or; inverse-power method 'power'. The iterative power methods; 'power-gmres', 'power-lgmres', 'power-bicgstab' use the same solvers as; their direct counterparts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, default False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_w",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:5979,Energy Efficiency,power,power-lgmres,5979,"ching': True,; 'return_info': False, 'info': _empty_info_dict(),; 'verbose': False, 'solver': 'scipy', 'weight': None,; 'tol': 1e-12, 'matol': 1e-15, 'mtol': None}; return def_args. [docs]def steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs):; """"""; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`~Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : {'scipy', 'mkl'}, optional; Selects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. method : str, default 'direct'; The allowed methods are. - 'direct'; - 'eigen'; - 'iterative-gmres'; - 'iterative-lgmres'; - 'iterative-bicgstab'; - 'svd'; - 'power'; - 'power-gmres'; - 'power-lgmres'; - 'power-bicgstab'. Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen', iterative GMRES; method 'iterative-gmres', iterative LGMRES method 'iterative-lgmres',; iterative BICGSTAB method 'iterative-bicgstab', SVD 'svd' (dense), or; inverse-power method 'power'. The iterative power methods; 'power-gmres', 'power-lgmres', 'power-bicgstab' use the same solvers as; their direct counterparts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, default False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_w",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:5997,Energy Efficiency,power,power-bicgstab,5997,"ching': True,; 'return_info': False, 'info': _empty_info_dict(),; 'verbose': False, 'solver': 'scipy', 'weight': None,; 'tol': 1e-12, 'matol': 1e-15, 'mtol': None}; return def_args. [docs]def steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs):; """"""; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`~Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : {'scipy', 'mkl'}, optional; Selects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. method : str, default 'direct'; The allowed methods are. - 'direct'; - 'eigen'; - 'iterative-gmres'; - 'iterative-lgmres'; - 'iterative-bicgstab'; - 'svd'; - 'power'; - 'power-gmres'; - 'power-lgmres'; - 'power-bicgstab'. Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen', iterative GMRES; method 'iterative-gmres', iterative LGMRES method 'iterative-lgmres',; iterative BICGSTAB method 'iterative-bicgstab', SVD 'svd' (dense), or; inverse-power method 'power'. The iterative power methods; 'power-gmres', 'power-lgmres', 'power-bicgstab' use the same solvers as; their direct counterparts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, default False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_w",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:6305,Energy Efficiency,power,power,6305,"""; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`~Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : {'scipy', 'mkl'}, optional; Selects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. method : str, default 'direct'; The allowed methods are. - 'direct'; - 'eigen'; - 'iterative-gmres'; - 'iterative-lgmres'; - 'iterative-bicgstab'; - 'svd'; - 'power'; - 'power-gmres'; - 'power-lgmres'; - 'power-bicgstab'. Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen', iterative GMRES; method 'iterative-gmres', iterative LGMRES method 'iterative-lgmres',; iterative BICGSTAB method 'iterative-bicgstab', SVD 'svd' (dense), or; inverse-power method 'power'. The iterative power methods; 'power-gmres', 'power-lgmres', 'power-bicgstab' use the same solvers as; their direct counterparts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, default False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbm : bool, default False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets t",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:6319,Energy Efficiency,power,power,6319,"""; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`~Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : {'scipy', 'mkl'}, optional; Selects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. method : str, default 'direct'; The allowed methods are. - 'direct'; - 'eigen'; - 'iterative-gmres'; - 'iterative-lgmres'; - 'iterative-bicgstab'; - 'svd'; - 'power'; - 'power-gmres'; - 'power-lgmres'; - 'power-bicgstab'. Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen', iterative GMRES; method 'iterative-gmres', iterative LGMRES method 'iterative-lgmres',; iterative BICGSTAB method 'iterative-bicgstab', SVD 'svd' (dense), or; inverse-power method 'power'. The iterative power methods; 'power-gmres', 'power-lgmres', 'power-bicgstab' use the same solvers as; their direct counterparts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, default False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbm : bool, default False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets t",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:6341,Energy Efficiency,power,power,6341,"Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`~Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : {'scipy', 'mkl'}, optional; Selects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. method : str, default 'direct'; The allowed methods are. - 'direct'; - 'eigen'; - 'iterative-gmres'; - 'iterative-lgmres'; - 'iterative-bicgstab'; - 'svd'; - 'power'; - 'power-gmres'; - 'power-lgmres'; - 'power-bicgstab'. Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen', iterative GMRES; method 'iterative-gmres', iterative LGMRES method 'iterative-lgmres',; iterative BICGSTAB method 'iterative-bicgstab', SVD 'svd' (dense), or; inverse-power method 'power'. The iterative power methods; 'power-gmres', 'power-lgmres', 'power-bicgstab' use the same solvers as; their direct counterparts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, default False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbm : bool, default False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_r",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:6357,Energy Efficiency,power,power-gmres,6357,"Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`~Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : {'scipy', 'mkl'}, optional; Selects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. method : str, default 'direct'; The allowed methods are. - 'direct'; - 'eigen'; - 'iterative-gmres'; - 'iterative-lgmres'; - 'iterative-bicgstab'; - 'svd'; - 'power'; - 'power-gmres'; - 'power-lgmres'; - 'power-bicgstab'. Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen', iterative GMRES; method 'iterative-gmres', iterative LGMRES method 'iterative-lgmres',; iterative BICGSTAB method 'iterative-bicgstab', SVD 'svd' (dense), or; inverse-power method 'power'. The iterative power methods; 'power-gmres', 'power-lgmres', 'power-bicgstab' use the same solvers as; their direct counterparts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, default False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbm : bool, default False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_r",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:6372,Energy Efficiency,power,power-lgmres,6372,"Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`~Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : {'scipy', 'mkl'}, optional; Selects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. method : str, default 'direct'; The allowed methods are. - 'direct'; - 'eigen'; - 'iterative-gmres'; - 'iterative-lgmres'; - 'iterative-bicgstab'; - 'svd'; - 'power'; - 'power-gmres'; - 'power-lgmres'; - 'power-bicgstab'. Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen', iterative GMRES; method 'iterative-gmres', iterative LGMRES method 'iterative-lgmres',; iterative BICGSTAB method 'iterative-bicgstab', SVD 'svd' (dense), or; inverse-power method 'power'. The iterative power methods; 'power-gmres', 'power-lgmres', 'power-bicgstab' use the same solvers as; their direct counterparts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, default False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbm : bool, default False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_r",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:6388,Energy Efficiency,power,power-bicgstab,6388,"Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`~Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : {'scipy', 'mkl'}, optional; Selects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. method : str, default 'direct'; The allowed methods are. - 'direct'; - 'eigen'; - 'iterative-gmres'; - 'iterative-lgmres'; - 'iterative-bicgstab'; - 'svd'; - 'power'; - 'power-gmres'; - 'power-lgmres'; - 'power-bicgstab'. Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen', iterative GMRES; method 'iterative-gmres', iterative LGMRES method 'iterative-lgmres',; iterative BICGSTAB method 'iterative-bicgstab', SVD 'svd' (dense), or; inverse-power method 'power'. The iterative power methods; 'power-gmres', 'power-lgmres', 'power-bicgstab' use the same solvers as; their direct counterparts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, default False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbm : bool, default False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_r",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:7920,Energy Efficiency,power,power,7920," Liouvillian. use_wbm : bool, default False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refine : int, default 10; MKL ONLY. Max. number of iterative refinements to perform. scaling_vectors : bool; MKL ONLY. Scale matrix to unit norm columns and rows. weighted_matching : bool; MKL ONLY. Use weighted matching to better condition diagonal. x0 : ndarray, optional; ITERATIVE ONLY. Initial guess for solution vector. maxiter : int, default 1000; ITERATIVE ONLY. Maximum number of iterations to perform. tol : float, default 1e-12; ITERATIVE ONLY. Tolerance used for terminating solver. mtol : float, optional; ITERATIVE 'power' methods ONLY. Tolerance for lu solve method. If None; given then ``max(0.1*tol, 1e-15)`` is used. matol : float, default 1e-15; ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_spec : str, optional; ITERATIVE ONLY. Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' (default); and 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. use_precond : bool, default False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the 'iterative' GMRES and BICG solvers. Speeds up; convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and ``use_precond = Tru",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:9323,Energy Efficiency,reduce,reduced,9323,"_precond : bool, default False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the 'iterative' GMRES and BICG solvers. Speeds up; convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and ``use_precond = True``, then one; is generated automatically. fill_factor : float, default 100; ITERATIVE ONLY. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, default 1e-4; ITERATIVE ONLY. Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional; ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, default 'smilu_2'; ITERATIVE ONLY. Selects the incomplete LU decomposition method algoithm; used in creating the preconditoner. Should only be used by advanced; users. Returns; -------; dm : qobj; Steady state density matrix.; info : dict, optional; Dictionary containing solver-specific information about the solution. Notes; -----; The SVD method works only for dense operators (i.e. small systems).; """"""; if solver is None:; solver = 'scipy'; if settings.has_mkl:; if method in ['direct', 'power']:; solver = 'mkl'; elif solver == 'mkl' and \; (method not in ['direct', 'power']):; raise Exception('MKL solver only for direct or power methods.'). elif solver not in [",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:10205,Energy Efficiency,power,power,10205,"of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional; ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, default 'smilu_2'; ITERATIVE ONLY. Selects the incomplete LU decomposition method algoithm; used in creating the preconditoner. Should only be used by advanced; users. Returns; -------; dm : qobj; Steady state density matrix.; info : dict, optional; Dictionary containing solver-specific information about the solution. Notes; -----; The SVD method works only for dense operators (i.e. small systems).; """"""; if solver is None:; solver = 'scipy'; if settings.has_mkl:; if method in ['direct', 'power']:; solver = 'mkl'; elif solver == 'mkl' and \; (method not in ['direct', 'power']):; raise Exception('MKL solver only for direct or power methods.'). elif solver not in ['scipy', 'mkl']:; raise Exception('Invalid solver kwarg.'). ss_args = _default_steadystate_args(); ss_args['method'] = method; if solver is not None:; ss_args['solver'] = solver; ss_args['info']['solver'] = ss_args['solver']; ss_args['info']['method'] = ss_args['method']. for key in kwargs.keys():; if key in ss_args.keys():; ss_args[key] = kwargs[key]; else:; raise Exception(; ""Invalid keyword argument '""+key+""' passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. # Create & check Liouvillian; A = _steadystate_setup(A, c_op_list). # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; ss_args['weight'] = np.mean(np.abs(A.data.data.max())); ss_args['info']['weight'] = ss_args['weight']. ",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:10286,Energy Efficiency,power,power,10286,"of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional; ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, default 'smilu_2'; ITERATIVE ONLY. Selects the incomplete LU decomposition method algoithm; used in creating the preconditoner. Should only be used by advanced; users. Returns; -------; dm : qobj; Steady state density matrix.; info : dict, optional; Dictionary containing solver-specific information about the solution. Notes; -----; The SVD method works only for dense operators (i.e. small systems).; """"""; if solver is None:; solver = 'scipy'; if settings.has_mkl:; if method in ['direct', 'power']:; solver = 'mkl'; elif solver == 'mkl' and \; (method not in ['direct', 'power']):; raise Exception('MKL solver only for direct or power methods.'). elif solver not in ['scipy', 'mkl']:; raise Exception('Invalid solver kwarg.'). ss_args = _default_steadystate_args(); ss_args['method'] = method; if solver is not None:; ss_args['solver'] = solver; ss_args['info']['solver'] = ss_args['solver']; ss_args['info']['method'] = ss_args['method']. for key in kwargs.keys():; if key in ss_args.keys():; ss_args[key] = kwargs[key]; else:; raise Exception(; ""Invalid keyword argument '""+key+""' passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. # Create & check Liouvillian; A = _steadystate_setup(A, c_op_list). # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; ss_args['weight'] = np.mean(np.abs(A.data.data.max())); ss_args['info']['weight'] = ss_args['weight']. ",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:10344,Energy Efficiency,power,power,10344,"of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional; ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, default 'smilu_2'; ITERATIVE ONLY. Selects the incomplete LU decomposition method algoithm; used in creating the preconditoner. Should only be used by advanced; users. Returns; -------; dm : qobj; Steady state density matrix.; info : dict, optional; Dictionary containing solver-specific information about the solution. Notes; -----; The SVD method works only for dense operators (i.e. small systems).; """"""; if solver is None:; solver = 'scipy'; if settings.has_mkl:; if method in ['direct', 'power']:; solver = 'mkl'; elif solver == 'mkl' and \; (method not in ['direct', 'power']):; raise Exception('MKL solver only for direct or power methods.'). elif solver not in ['scipy', 'mkl']:; raise Exception('Invalid solver kwarg.'). ss_args = _default_steadystate_args(); ss_args['method'] = method; if solver is not None:; ss_args['solver'] = solver; ss_args['info']['solver'] = ss_args['solver']; ss_args['info']['method'] = ss_args['method']. for key in kwargs.keys():; if key in ss_args.keys():; ss_args[key] = kwargs[key]; else:; raise Exception(; ""Invalid keyword argument '""+key+""' passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. # Create & check Liouvillian; A = _steadystate_setup(A, c_op_list). # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; ss_args['weight'] = np.mean(np.abs(A.data.data.max())); ss_args['info']['weight'] = ss_args['weight']. ",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:11804,Energy Efficiency,power,power,11804,"erm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. # Create & check Liouvillian; A = _steadystate_setup(A, c_op_list). # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; ss_args['weight'] = np.mean(np.abs(A.data.data.max())); ss_args['info']['weight'] = ss_args['weight']. if ss_args['method'] == 'direct':; if (ss_args['solver'] == 'scipy' and ss_args['sparse']) \; or ss_args['solver'] == 'mkl':; return _steadystate_direct_sparse(A, ss_args); else:; return _steadystate_direct_dense(A, ss_args). elif ss_args['method'] == 'eigen':; return _steadystate_eigen(A, ss_args). elif ss_args['method'] in ['iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab']:; return _steadystate_iterative(A, ss_args). elif ss_args['method'] == 'svd':; return _steadystate_svd_dense(A, ss_args). elif ss_args['method'] in ['power', 'power-gmres',; 'power-lgmres', 'power-bicgstab']:; return _steadystate_power(A, ss_args). else:; raise ValueError('Invalid method argument for steadystate.'). def _steadystate_setup(A, c_op_list):; """"""Build Liouvillian (if necessary) and check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n)",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:11813,Energy Efficiency,power,power-gmres,11813,"erm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. # Create & check Liouvillian; A = _steadystate_setup(A, c_op_list). # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; ss_args['weight'] = np.mean(np.abs(A.data.data.max())); ss_args['info']['weight'] = ss_args['weight']. if ss_args['method'] == 'direct':; if (ss_args['solver'] == 'scipy' and ss_args['sparse']) \; or ss_args['solver'] == 'mkl':; return _steadystate_direct_sparse(A, ss_args); else:; return _steadystate_direct_dense(A, ss_args). elif ss_args['method'] == 'eigen':; return _steadystate_eigen(A, ss_args). elif ss_args['method'] in ['iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab']:; return _steadystate_iterative(A, ss_args). elif ss_args['method'] == 'svd':; return _steadystate_svd_dense(A, ss_args). elif ss_args['method'] in ['power', 'power-gmres',; 'power-lgmres', 'power-bicgstab']:; return _steadystate_power(A, ss_args). else:; raise ValueError('Invalid method argument for steadystate.'). def _steadystate_setup(A, c_op_list):; """"""Build Liouvillian (if necessary) and check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n)",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:11829,Energy Efficiency,power,power-lgmres,11829,"erm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. # Create & check Liouvillian; A = _steadystate_setup(A, c_op_list). # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; ss_args['weight'] = np.mean(np.abs(A.data.data.max())); ss_args['info']['weight'] = ss_args['weight']. if ss_args['method'] == 'direct':; if (ss_args['solver'] == 'scipy' and ss_args['sparse']) \; or ss_args['solver'] == 'mkl':; return _steadystate_direct_sparse(A, ss_args); else:; return _steadystate_direct_dense(A, ss_args). elif ss_args['method'] == 'eigen':; return _steadystate_eigen(A, ss_args). elif ss_args['method'] in ['iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab']:; return _steadystate_iterative(A, ss_args). elif ss_args['method'] == 'svd':; return _steadystate_svd_dense(A, ss_args). elif ss_args['method'] in ['power', 'power-gmres',; 'power-lgmres', 'power-bicgstab']:; return _steadystate_power(A, ss_args). else:; raise ValueError('Invalid method argument for steadystate.'). def _steadystate_setup(A, c_op_list):; """"""Build Liouvillian (if necessary) and check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n)",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:11845,Energy Efficiency,power,power-bicgstab,11845,"erm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. # Create & check Liouvillian; A = _steadystate_setup(A, c_op_list). # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; ss_args['weight'] = np.mean(np.abs(A.data.data.max())); ss_args['info']['weight'] = ss_args['weight']. if ss_args['method'] == 'direct':; if (ss_args['solver'] == 'scipy' and ss_args['sparse']) \; or ss_args['solver'] == 'mkl':; return _steadystate_direct_sparse(A, ss_args); else:; return _steadystate_direct_dense(A, ss_args). elif ss_args['method'] == 'eigen':; return _steadystate_eigen(A, ss_args). elif ss_args['method'] in ['iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab']:; return _steadystate_iterative(A, ss_args). elif ss_args['method'] == 'svd':; return _steadystate_svd_dense(A, ss_args). elif ss_args['method'] in ['power', 'power-gmres',; 'power-lgmres', 'power-bicgstab']:; return _steadystate_power(A, ss_args). else:; raise ValueError('Invalid method argument for steadystate.'). def _steadystate_setup(A, c_op_list):; """"""Build Liouvillian (if necessary) and check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n)",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:24660,Energy Efficiency,power,power,24660,"a, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if ss_args['solver'] == 'mkl':; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; orig_nnz = L.nnz; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:26395,Energy Efficiency,power,power,26395,"nd('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; if ss_args['solver'] == 'scipy':; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_ar",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:26538,Energy Efficiency,power,power,26538,"gger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; if ss_args['solver'] == 'scipy':; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)),; ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing withou",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:26922,Energy Efficiency,power,power,26922,"ute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; if ss_args['solver'] == 'scipy':; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)),; ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning). ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if ss_args['solver'] == 'mkl':; lu = mkl_splu(L, max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); else:; lu = splu(L, permc_spec=ss_args['permc_spec'],; di",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:27318,Energy Efficiency,power,power-gmres,27318,"eturn L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; if ss_args['solver'] == 'scipy':; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)),; ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning). ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if ss_args['solver'] == 'mkl':; lu = mkl_splu(L, max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); else:; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; check = 0; if ss_args[",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:27334,Energy Efficiency,power,power-lgmres,27334,"eturn L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; if ss_args['solver'] == 'scipy':; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)),; ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning). ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if ss_args['solver'] == 'mkl':; lu = mkl_splu(L, max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); else:; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; check = 0; if ss_args[",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:27351,Energy Efficiency,power,power-bicgstab,27351,"eturn L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; if ss_args['solver'] == 'scipy':; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)),; ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning). ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if ss_args['solver'] == 'mkl':; lu = mkl_splu(L, max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); else:; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; check = 0; if ss_args[",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:27698,Energy Efficiency,power,power,27698,"# Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; if ss_args['solver'] == 'scipy':; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)),; ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning). ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if ss_args['solver'] == 'mkl':; lu = mkl_splu(L, max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); else:; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; check = 0; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count, callback_type='legacy'); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:28318,Energy Efficiency,power,power,28318," \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)),; ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning). ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if ss_args['solver'] == 'mkl':; lu = mkl_splu(L, max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); else:; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; check = 0; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count, callback_type='legacy'); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); if check > 0:; raise Exception(""{} failed to find solution in ""; ""{} iterations."".format(ss_args['method'],; check)); if check < 0:; raise Exception(""Breakdown in {}"".format(ss_args['method'])); v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and s",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:28371,Energy Efficiency,power,power-gmres,28371,"ss_args['method'] == 'power':; if ss_args['solver'] == 'mkl':; lu = mkl_splu(L, max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); else:; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; check = 0; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count, callback_type='legacy'); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); if check > 0:; raise Exception(""{} failed to find solution in ""; ""{} iterations."".format(ss_args['method'],; check)); if check < 0:; raise Exception(""Breakdown in {}"".format(ss_args['method'])); v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and ss_args['solver'] == 'mkl':; lu.delete(); if ss_args['return_info']:; ss_args['info']['max_iter_refine'] = ss_args['max_iter_refine']; ss_args['info']['scaling_vectors'] = ss_args['scaling_vectors']; ss_args['info']['weighted_matching'] = ss_args['weighted_matching']. if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end ",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:28610,Energy Efficiency,power,power-lgmres,28610,"ss_args['method'] == 'power':; if ss_args['solver'] == 'mkl':; lu = mkl_splu(L, max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); else:; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; check = 0; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count, callback_type='legacy'); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); if check > 0:; raise Exception(""{} failed to find solution in ""; ""{} iterations."".format(ss_args['method'],; check)); if check < 0:; raise Exception(""Breakdown in {}"".format(ss_args['method'])); v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and ss_args['solver'] == 'mkl':; lu.delete(); if ss_args['return_info']:; ss_args['info']['max_iter_refine'] = ss_args['max_iter_refine']; ss_args['info']['scaling_vectors'] = ss_args['scaling_vectors']; ss_args['info']['weighted_matching'] = ss_args['weighted_matching']. if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end ",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:28798,Energy Efficiency,power,power-bicgstab,28798,"ss_args['method'] == 'power':; if ss_args['solver'] == 'mkl':; lu = mkl_splu(L, max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); else:; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; check = 0; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count, callback_type='legacy'); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); if check > 0:; raise Exception(""{} failed to find solution in ""; ""{} iterations."".format(ss_args['method'],; check)); if check < 0:; raise Exception(""Breakdown in {}"".format(ss_args['method'])); v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and ss_args['solver'] == 'mkl':; lu.delete(); if ss_args['return_info']:; ss_args['info']['max_iter_refine'] = ss_args['max_iter_refine']; ss_args['info']['scaling_vectors'] = ss_args['scaling_vectors']; ss_args['info']['weighted_matching'] = ss_args['weighted_matching']. if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end ",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:29280,Energy Efficiency,power,power,29280," check = 0; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count, callback_type='legacy'); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); if check > 0:; raise Exception(""{} failed to find solution in ""; ""{} iterations."".format(ss_args['method'],; check)); if check < 0:; raise Exception(""Breakdown in {}"".format(ss_args['method'])); v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and ss_args['solver'] == 'mkl':; lu.delete(); if ss_args['return_info']:; ss_args['info']['max_iter_refine'] = ss_args['max_iter_refine']; ss_args['info']['scaling_vectors'] = ss_args['scaling_vectors']; ss_args['info']['weighted_matching'] = ss_args['weighted_matching']. if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end = time.time(); ss_args['info']['solution_time'] = _power_end-_power_start; ss_args['info']['iterations'] = it; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*v, np.inf); if settings.debug:; logger.debug('Number of iterations: %i' % it). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. # normalise according to type of problem; if sflag:; trow = v[::rhoss.shape[0]+1]; data = v / np.sum(trow); else:; data = data / la.norm(v). data = dense2D_to_fastcsr_fmode(vec2mat(data),; rhoss.shape[0],; rhoss.shape[0]); rhoss.data = 0.5 * (data + data.H); rhoss.isherm = True; if ss_args['",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:31617,Energy Efficiency,power,power,31617,"n operator. c_op_list : list; A list of collapse operators. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. method : str, default = 'iterative'; Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use 'iterative'.; For power iterative methods use 'power'. permc_spec : str, optional, default='COLAMD'; Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' and; 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. fill_factor : float, optional, default = 100; Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4; Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None; Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diag",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:31646,Energy Efficiency,power,power,31646,"n operator. c_op_list : list; A list of collapse operators. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. method : str, default = 'iterative'; Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use 'iterative'.; For power iterative methods use 'power'. permc_spec : str, optional, default='COLAMD'; Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' and; 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. fill_factor : float, optional, default = 100; Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4; Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None; Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diag",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:32274,Energy Efficiency,reduce,reduced,32274," linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. method : str, default = 'iterative'; Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use 'iterative'.; For power iterative methods use 'power'. permc_spec : str, optional, default='COLAMD'; Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' and; 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. fill_factor : float, optional, default = 100; Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4; Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None; Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, optional, default = 'smilu_2'; Selects the incomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns; -------; lu : object; Returns a SuperLU object representing iLU preconditioner. info : dict, optional; Dictionary containing solver-specific information.; """"""; ss_args = _default_steadystate_args(); ss_args['method'] = 'iterative'; for key in kwargs.keys():; if key in ss_args.keys():; ss_args[key] = kwargs[key]; else:; raise Exception(""Invalid keyword argument '"" + key +; ""' passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:33840,Energy Efficiency,power,power,33840,"-------; lu : object; Returns a SuperLU object representing iLU preconditioner. info : dict, optional; Dictionary containing solver-specific information.; """"""; ss_args = _default_steadystate_args(); ss_args['method'] = 'iterative'; for key in kwargs.keys():; if key in ss_args.keys():; ss_args[key] = kwargs[key]; else:; raise Exception(""Invalid keyword argument '"" + key +; ""' passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. L = _steadystate_setup(A, c_op_list); # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; ss_args['weight'] = np.mean(np.abs(L.data.data.max())); ss_args['info']['weight'] = ss_args['weight']. n = int(np.sqrt(L.shape[0])); if ss_args['method'] == 'iterative':; ss_list = _steadystate_LU_liouvillian(L, ss_args); L, perm, perm2, rev_perm, ss_args = ss_list; elif ss_args['method'] == 'power':; ss_list = _steadystate_power_liouvillian(L, ss_args); L, perm, perm2, rev_perm, ss_args = ss_list; else:; raise Exception(""Invalid preconditioning method.""). M, ss_args = _iterative_precondition(L, n, ss_args). if ss_args['return_info']:; return M, ss_args['info']; else:; return M. def _pseudo_inverse_dense(L, rhoss, w=None, **pseudo_args):; """"""; Internal function for computing the pseudo inverse of an Liouvillian using; dense matrix methods. See pseudo_inverse for details.; """"""; rho_vec = np.transpose(mat2vec(rhoss.full())). tr_mat = tensor([identity(n) for n in L.dims[0][0]]); tr_vec = np.transpose(mat2vec(tr_mat.full())); N = np.prod(L.dims[0][0]); I = np.identity(N * N); P = np.kron(np.transpose(rho_vec), tr_vec); Q = I - P. if w is None:; L = L; else:; L = 1.0j*w*spre(tr_mat)+L. if pseudo_args['method'] == 'direct':; try:; LIQ = np.linalg.solve(L.full(), Q); except:; LIQ = np.linalg.lstsq(L.full(), Q)[0]. R = np.dot(Q, LIQ). return Qobj(R, dims=L.dims). elif pseudo_a",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:3366,Integrability,wrap,wrapped,3366,"port warnings. from packaging.version import parse as _parse_version; import numpy as np; from numpy.linalg import svd; import scipy; import scipy.sparse as sp; import scipy.linalg as la; from scipy.sparse.linalg import (; use_solver, splu, spilu, eigs, LinearOperator, gmres, lgmres, bicgstab,; ); from qutip.qobj import Qobj, issuper, isoper. from qutip.superoperator import liouvillian, vec2mat, spre; from qutip.sparse import sp_permute, sp_bandwidth, sp_profile; from qutip.cy.spmath import zcsr_kron; from qutip.graph import weighted_bipartite_matching; from qutip import (mat2vec, tensor, identity, operator_to_vector); import qutip.settings as settings; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode. import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); logger.setLevel('DEBUG'). # Load MKL spsolve if avaiable; if settings.has_mkl:; from qutip._mkl.spsolve import (mkl_splu, mkl_spsolve). def _eat_kwargs(function, names):; """"""; Return a wrapped version of `function` that simply removes any keyword; arguments with one of the given names.; """"""; @functools.wraps(function); def out(*args, **kwargs):; for name in names:; if name in kwargs:; del kwargs[name]; return function(*args, **kwargs); return out. # From SciPy 1.4 onwards we need to pass the `callback_type='legacy'` argument; # to gmres to maintain the same behaviour we used to have. Since this should; # be the default behaviour, we use that in the main code and just ""eat"" the; # argument if passed to a lower version of SciPy that doesn't know about it.; # Similarly, SciPy < 1.1 does not recognise the `atol` keyword.; #; # Respective checks can be removed when SciPy version requirements are raised. if _parse_version(scipy.__version__) < _parse_version(""1.1""):; gmres = _eat_kwargs(gmres, ['atol', 'callback_type']); lgmres = _eat_kwargs(lgmres, ['atol']); bicgstab = _eat_kwargs(bicgstab, ['atol']); elif _parse_version(scipy.__version__) < _parse_version(""1.4""):; gmres = _eat_kwargs(gmres, ['cal",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:3485,Integrability,wrap,wraps,3485," scipy.linalg as la; from scipy.sparse.linalg import (; use_solver, splu, spilu, eigs, LinearOperator, gmres, lgmres, bicgstab,; ); from qutip.qobj import Qobj, issuper, isoper. from qutip.superoperator import liouvillian, vec2mat, spre; from qutip.sparse import sp_permute, sp_bandwidth, sp_profile; from qutip.cy.spmath import zcsr_kron; from qutip.graph import weighted_bipartite_matching; from qutip import (mat2vec, tensor, identity, operator_to_vector); import qutip.settings as settings; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode. import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); logger.setLevel('DEBUG'). # Load MKL spsolve if avaiable; if settings.has_mkl:; from qutip._mkl.spsolve import (mkl_splu, mkl_spsolve). def _eat_kwargs(function, names):; """"""; Return a wrapped version of `function` that simply removes any keyword; arguments with one of the given names.; """"""; @functools.wraps(function); def out(*args, **kwargs):; for name in names:; if name in kwargs:; del kwargs[name]; return function(*args, **kwargs); return out. # From SciPy 1.4 onwards we need to pass the `callback_type='legacy'` argument; # to gmres to maintain the same behaviour we used to have. Since this should; # be the default behaviour, we use that in the main code and just ""eat"" the; # argument if passed to a lower version of SciPy that doesn't know about it.; # Similarly, SciPy < 1.1 does not recognise the `atol` keyword.; #; # Respective checks can be removed when SciPy version requirements are raised. if _parse_version(scipy.__version__) < _parse_version(""1.1""):; gmres = _eat_kwargs(gmres, ['atol', 'callback_type']); lgmres = _eat_kwargs(lgmres, ['atol']); bicgstab = _eat_kwargs(bicgstab, ['atol']); elif _parse_version(scipy.__version__) < _parse_version(""1.4""):; gmres = _eat_kwargs(gmres, ['callback_type']). def _empty_info_dict():; def_info = {'perm': [], 'solution_time': None,; 'residual_norm': None,; 'solver': None, 'method': None}. return def_info. def _",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:14357,Integrability,message,message,14357,"args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' %; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve',; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol,; use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. if ss_args['solver'] == 'mkl':; has_mkl = 1; else:; has_mkl = 0. ss_lu_liouv_list = _steadystate_LU_liouvillian(L, ss_args, has_mkl); L, perm, perm2, rev_perm, ss_args = ss_lu_liouv_list; if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. if ss_args['solver'] == 'scipy':; ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:14436,Integrability,message,message,14436,"; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' %; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve',; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol,; use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. if ss_args['solver'] == 'mkl':; has_mkl = 1; else:; has_mkl = 0. ss_lu_liouv_list = _steadystate_LU_liouvillian(L, ss_args, has_mkl); L, perm, perm2, rev_perm, ss_args = ss_lu_liouv_list; if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. if ss_args['solver'] == 'scipy':; ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']. if not ss_args['solver'] == 'mkl':; # Use superLU solver; orig_nnz = L.nnz; _di",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:7466,Performance,perform,perform,7466,"ts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, default False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbm : bool, default False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refine : int, default 10; MKL ONLY. Max. number of iterative refinements to perform. scaling_vectors : bool; MKL ONLY. Scale matrix to unit norm columns and rows. weighted_matching : bool; MKL ONLY. Use weighted matching to better condition diagonal. x0 : ndarray, optional; ITERATIVE ONLY. Initial guess for solution vector. maxiter : int, default 1000; ITERATIVE ONLY. Maximum number of iterations to perform. tol : float, default 1e-12; ITERATIVE ONLY. Tolerance used for terminating solver. mtol : float, optional; ITERATIVE 'power' methods ONLY. Tolerance for lu solve method. If None; given then ``max(0.1*tol, 1e-15)`` is used. matol : float, default 1e-15; ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_spec : str, optional; ITERATIVE ONLY. Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' (default); and 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. use_precond : bool, default False; ITERATIVE ONLY. Use an incomplete spar",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:7793,Performance,perform,perform,7793,"er' systems. use_rcm : bool, default False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbm : bool, default False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refine : int, default 10; MKL ONLY. Max. number of iterative refinements to perform. scaling_vectors : bool; MKL ONLY. Scale matrix to unit norm columns and rows. weighted_matching : bool; MKL ONLY. Use weighted matching to better condition diagonal. x0 : ndarray, optional; ITERATIVE ONLY. Initial guess for solution vector. maxiter : int, default 1000; ITERATIVE ONLY. Maximum number of iterations to perform. tol : float, default 1e-12; ITERATIVE ONLY. Tolerance used for terminating solver. mtol : float, optional; ITERATIVE 'power' methods ONLY. Tolerance for lu solve method. If None; given then ``max(0.1*tol, 1e-15)`` is used. matol : float, default 1e-15; ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_spec : str, optional; ITERATIVE ONLY. Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' (default); and 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. use_precond : bool, default False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the 'iterative' GMRES and BICG solvers. Speeds up; convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective precondition",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:3138,Testability,log,logger,3138,"r the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators.; """""". __all__ = ['steadystate', 'steady', 'build_preconditioner',; 'pseudo_inverse']. import functools; import time; import warnings. from packaging.version import parse as _parse_version; import numpy as np; from numpy.linalg import svd; import scipy; import scipy.sparse as sp; import scipy.linalg as la; from scipy.sparse.linalg import (; use_solver, splu, spilu, eigs, LinearOperator, gmres, lgmres, bicgstab,; ); from qutip.qobj import Qobj, issuper, isoper. from qutip.superoperator import liouvillian, vec2mat, spre; from qutip.sparse import sp_permute, sp_bandwidth, sp_profile; from qutip.cy.spmath import zcsr_kron; from qutip.graph import weighted_bipartite_matching; from qutip import (mat2vec, tensor, identity, operator_to_vector); import qutip.settings as settings; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode. import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); logger.setLevel('DEBUG'). # Load MKL spsolve if avaiable; if settings.has_mkl:; from qutip._mkl.spsolve import (mkl_splu, mkl_spsolve). def _eat_kwargs(function, names):; """"""; Return a wrapped version of `function` that simply removes any keyword; arguments with one of the given names.; """"""; @functools.wraps(function); def out(*args, **kwargs):; for name in names:; if name in kwargs:; del kwargs[name]; return function(*args, **kwargs); return out. # From SciPy 1.4 onwards we need to pass the `callback_type='legacy'` argument; # to gmres to maintain the same behaviour we used to have. Since this should; # be the default behaviour, we use that in the main code and just ""eat"" the; # argument if passed to a lower version of SciPy that doesn't know about it.; # Similarly, SciPy < 1.1 does not recognise the `atol` keyword.; #; # Respective checks can be removed when SciPy version requirements are raised. if _parse_version(scipy.__version__) < _parse",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:3181,Testability,log,logger,3181,"pen quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators.; """""". __all__ = ['steadystate', 'steady', 'build_preconditioner',; 'pseudo_inverse']. import functools; import time; import warnings. from packaging.version import parse as _parse_version; import numpy as np; from numpy.linalg import svd; import scipy; import scipy.sparse as sp; import scipy.linalg as la; from scipy.sparse.linalg import (; use_solver, splu, spilu, eigs, LinearOperator, gmres, lgmres, bicgstab,; ); from qutip.qobj import Qobj, issuper, isoper. from qutip.superoperator import liouvillian, vec2mat, spre; from qutip.sparse import sp_permute, sp_bandwidth, sp_profile; from qutip.cy.spmath import zcsr_kron; from qutip.graph import weighted_bipartite_matching; from qutip import (mat2vec, tensor, identity, operator_to_vector); import qutip.settings as settings; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode. import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); logger.setLevel('DEBUG'). # Load MKL spsolve if avaiable; if settings.has_mkl:; from qutip._mkl.spsolve import (mkl_splu, mkl_spsolve). def _eat_kwargs(function, names):; """"""; Return a wrapped version of `function` that simply removes any keyword; arguments with one of the given names.; """"""; @functools.wraps(function); def out(*args, **kwargs):; for name in names:; if name in kwargs:; del kwargs[name]; return function(*args, **kwargs); return out. # From SciPy 1.4 onwards we need to pass the `callback_type='legacy'` argument; # to gmres to maintain the same behaviour we used to have. Since this should; # be the default behaviour, we use that in the main code and just ""eat"" the; # argument if passed to a lower version of SciPy that doesn't know about it.; # Similarly, SciPy < 1.1 does not recognise the `atol` keyword.; #; # Respective checks can be removed when SciPy version requirements are raised. if _parse_version(scipy.__version__) < _parse_version(""1.1""):; gmres = _eat_kwargs(gm",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:12997,Testability,log,logger,12997,".'). def _steadystate_setup(A, c_op_list):; """"""Build Liouvillian (if necessary) and check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)). if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:13060,Testability,log,logger,13060,"nd check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)). if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth redu",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:13155,Testability,log,logger,13155,"rror('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)). if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' %; (old_pro/rcm_pro",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:13489,Testability,log,logger,13489,"ouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)). if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' %; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve',; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return ",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:13579,Testability,log,logger,13579,"ape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)). if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' %; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve',; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol,; use_precond=use_precond). def _steadystate_direct_sparse(L, ",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:13975,Testability,log,logger,13975,"d = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' %; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve',; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol,; use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. if ss_args['solver'] == 'mkl':; has_mkl = 1; else:; has_mkl = 0. ss_lu_liouv_list = _steadystate_LU_liouvillian(L, ss_args,",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:14021,Testability,log,logger,14021,"ebug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' %; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve',; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol,; use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. if ss_args['solver'] == 'mkl':; has_mkl = 1; else:; has_mkl = 0. ss_lu_liouv_list = _steadystate_LU_liouvillian(L, ss_args, has_mkl); L, perm, perm2, rev_perm, ss_args = ss_lu_liouv_l",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:14092,Testability,log,logger,14092,"ger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' %; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve',; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol,; use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. if ss_args['solver'] == 'mkl':; has_mkl = 1; else:; has_mkl = 0. ss_lu_liouv_list = _steadystate_LU_liouvillian(L, ss_args, has_mkl); L, perm, perm2, rev_perm, ss_args = ss_lu_liouv_list; if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:14667,Testability,log,logger,14667,"; perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' %; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve',; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol,; use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. if ss_args['solver'] == 'mkl':; has_mkl = 1; else:; has_mkl = 0. ss_lu_liouv_list = _steadystate_LU_liouvillian(L, ss_args, has_mkl); L, perm, perm2, rev_perm, ss_args = ss_lu_liouv_list; if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. if ss_args['solver'] == 'scipy':; ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']. if not ss_args['solver'] == 'mkl':; # Use superLU solver; orig_nnz = L.nnz; _direct_start = time.time(); lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])); v = lu.solv",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:15995,Testability,log,logger,15995,"_lu_liouv_list; if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. if ss_args['solver'] == 'scipy':; ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']. if not ss_args['solver'] == 'mkl':; # Use superLU solver; orig_nnz = L.nnz; _direct_start = time.time(); lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])); v = lu.solve(b); _direct_end = time.time(); ss_args['info']['solution_time'] = _direct_end - _direct_start; if (settings.debug or ss_args['return_info']):; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['lu_fill_factor'] = (L_nnz + U_nnz)/L.nnz; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz + U_nnz)/orig_nnz)). else: # Use MKL solver; if len(ss_args['info']['perm']) != 0:; in_perm = np.arange(n**2, dtype=np.int32); else:; in_perm = None; _direct_start = time.time(); v = mkl_spsolve(L, b, perm=in_perm, verbose=ss_args['verbose'],; max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); _direct_end = time.time(); ss_args['info']['solution_time'] = _direct_end-_direct_start. if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf); ss_args['info']['max_iter_refine'] = ss_args['max_iter_refine']; ss_args['info']['scaling_vectors'] = ss_args['scaling_vectors']; ss_args['info']['weighted_matching'] = ss_args['weighted_matching']. if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = dense2D_to_fastcsr_fmode(vec2mat(v), n, n); data = 0.5 * (data + data.H); if ss_args['",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:16051,Testability,log,logger,16051,"= b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. if ss_args['solver'] == 'scipy':; ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']. if not ss_args['solver'] == 'mkl':; # Use superLU solver; orig_nnz = L.nnz; _direct_start = time.time(); lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])); v = lu.solve(b); _direct_end = time.time(); ss_args['info']['solution_time'] = _direct_end - _direct_start; if (settings.debug or ss_args['return_info']):; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['lu_fill_factor'] = (L_nnz + U_nnz)/L.nnz; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz + U_nnz)/orig_nnz)). else: # Use MKL solver; if len(ss_args['info']['perm']) != 0:; in_perm = np.arange(n**2, dtype=np.int32); else:; in_perm = None; _direct_start = time.time(); v = mkl_spsolve(L, b, perm=in_perm, verbose=ss_args['verbose'],; max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); _direct_end = time.time(); ss_args['info']['solution_time'] = _direct_end-_direct_start. if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf); ss_args['info']['max_iter_refine'] = ss_args['max_iter_refine']; ss_args['info']['scaling_vectors'] = ss_args['scaling_vectors']; ss_args['info']['weighted_matching'] = ss_args['weighted_matching']. if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = dense2D_to_fastcsr_fmode(vec2mat(v), n, n); data = 0.5 * (data + data.H); if ss_args['return_info']:; return Qobj(data, d",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:17279,Testability,log,logger,17279,"_spsolve(L, b, perm=in_perm, verbose=ss_args['verbose'],; max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); _direct_end = time.time(); ss_args['info']['solution_time'] = _direct_end-_direct_start. if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf); ss_args['info']['max_iter_refine'] = ss_args['max_iter_refine']; ss_args['info']['scaling_vectors'] = ss_args['scaling_vectors']; ss_args['info']['weighted_matching'] = ss_args['weighted_matching']. if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = dense2D_to_fastcsr_fmode(vec2mat(v), n, n); data = 0.5 * (data + data.H); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_direct_dense(L, ss_args):; """"""; Direct solver that uses numpy arrays. Suitable for small systems with few; states.; """"""; if settings.debug:; logger.debug('Starting direct dense solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L = L.full(); L[0, :] = np.diag(ss_args['weight']*np.ones(n)).reshape((1, n ** 2)); _dense_start = time.time(); v = np.linalg.solve(L, b); _dense_end = time.time(); ss_args['info']['solution_time'] = _dense_end-_dense_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L@v, np.inf); data = vec2mat(v); data = 0.5 * (data + data.conj().T). return Qobj(data, dims=dims, isherm=True). def _steadystate_eigen(L, ss_args):; """"""; Internal function for solving the steady state problem by; finding the eigenvector corresponding to the zero eigenvalue; of the Liouvillian using ARPACK.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting Eigen solver.'). dims = L.dims[0]; L = L.data.tocsc(). if ss_args['use_rcm']:; ss_args['info']['perm'].append('rcm'); if settings.debug:; old_band = sp_bandwidth(",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:18094,Testability,log,logger,18094,"a, dims=dims, isherm=True). def _steadystate_direct_dense(L, ss_args):; """"""; Direct solver that uses numpy arrays. Suitable for small systems with few; states.; """"""; if settings.debug:; logger.debug('Starting direct dense solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L = L.full(); L[0, :] = np.diag(ss_args['weight']*np.ones(n)).reshape((1, n ** 2)); _dense_start = time.time(); v = np.linalg.solve(L, b); _dense_end = time.time(); ss_args['info']['solution_time'] = _dense_end-_dense_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L@v, np.inf); data = vec2mat(v); data = 0.5 * (data + data.conj().T). return Qobj(data, dims=dims, isherm=True). def _steadystate_eigen(L, ss_args):; """"""; Internal function for solving the steady state problem by; finding the eigenvector corresponding to the zero eigenvalue; of the Liouvillian using ARPACK.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting Eigen solver.'). dims = L.dims[0]; L = L.data.tocsc(). if ss_args['use_rcm']:; ss_args['info']['perm'].append('rcm'); if settings.debug:; old_band = sp_bandwidth(L)[0]; logger.debug('Original bandwidth: %i' % old_band); perm = sp.csgraph.reverse_cuthill_mckee(L); rev_perm = np.argsort(perm); L = sp_permute(L, perm, perm, 'csc'); if settings.debug:; rcm_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)). _eigen_start = time.time(); eigval, eigvec = eigs(L, k=1, sigma=1e-15, tol=ss_args['tol'],; which='LM', maxiter=ss_args['maxiter']); _eigen_end = time.time(); ss_args['info']['solution_time'] = _eigen_end - _eigen_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*eigvec, np.inf); if ss_args['use_rcm']:; eigvec = eigvec[np.ix_(rev_perm,)]; _temp = vec2mat(eigvec); data = dense2D_to_fastcsr_fmode(_temp, _temp.shape[0], _temp.shape[1]); data = 0.5",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:18286,Testability,log,logger,18286,".debug:; logger.debug('Starting direct dense solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L = L.full(); L[0, :] = np.diag(ss_args['weight']*np.ones(n)).reshape((1, n ** 2)); _dense_start = time.time(); v = np.linalg.solve(L, b); _dense_end = time.time(); ss_args['info']['solution_time'] = _dense_end-_dense_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L@v, np.inf); data = vec2mat(v); data = 0.5 * (data + data.conj().T). return Qobj(data, dims=dims, isherm=True). def _steadystate_eigen(L, ss_args):; """"""; Internal function for solving the steady state problem by; finding the eigenvector corresponding to the zero eigenvalue; of the Liouvillian using ARPACK.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting Eigen solver.'). dims = L.dims[0]; L = L.data.tocsc(). if ss_args['use_rcm']:; ss_args['info']['perm'].append('rcm'); if settings.debug:; old_band = sp_bandwidth(L)[0]; logger.debug('Original bandwidth: %i' % old_band); perm = sp.csgraph.reverse_cuthill_mckee(L); rev_perm = np.argsort(perm); L = sp_permute(L, perm, perm, 'csc'); if settings.debug:; rcm_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)). _eigen_start = time.time(); eigval, eigvec = eigs(L, k=1, sigma=1e-15, tol=ss_args['tol'],; which='LM', maxiter=ss_args['maxiter']); _eigen_end = time.time(); ss_args['info']['solution_time'] = _eigen_end - _eigen_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*eigvec, np.inf); if ss_args['use_rcm']:; eigvec = eigvec[np.ix_(rev_perm,)]; _temp = vec2mat(eigvec); data = dense2D_to_fastcsr_fmode(_temp, _temp.shape[0], _temp.shape[1]); data = 0.5 * (data + data.H); out = Qobj(data, dims=dims, isherm=True); if ss_args['return_info']:; return out/out.tr(), ss_args['info']; else:; return out/out.tr(). def _iterative_preco",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:18499,Testability,log,logger,18499,".reshape((1, n ** 2)); _dense_start = time.time(); v = np.linalg.solve(L, b); _dense_end = time.time(); ss_args['info']['solution_time'] = _dense_end-_dense_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L@v, np.inf); data = vec2mat(v); data = 0.5 * (data + data.conj().T). return Qobj(data, dims=dims, isherm=True). def _steadystate_eigen(L, ss_args):; """"""; Internal function for solving the steady state problem by; finding the eigenvector corresponding to the zero eigenvalue; of the Liouvillian using ARPACK.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting Eigen solver.'). dims = L.dims[0]; L = L.data.tocsc(). if ss_args['use_rcm']:; ss_args['info']['perm'].append('rcm'); if settings.debug:; old_band = sp_bandwidth(L)[0]; logger.debug('Original bandwidth: %i' % old_band); perm = sp.csgraph.reverse_cuthill_mckee(L); rev_perm = np.argsort(perm); L = sp_permute(L, perm, perm, 'csc'); if settings.debug:; rcm_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)). _eigen_start = time.time(); eigval, eigvec = eigs(L, k=1, sigma=1e-15, tol=ss_args['tol'],; which='LM', maxiter=ss_args['maxiter']); _eigen_end = time.time(); ss_args['info']['solution_time'] = _eigen_end - _eigen_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*eigvec, np.inf); if ss_args['use_rcm']:; eigvec = eigvec[np.ix_(rev_perm,)]; _temp = vec2mat(eigvec); data = dense2D_to_fastcsr_fmode(_temp, _temp.shape[0], _temp.shape[1]); data = 0.5 * (data + data.H); out = Qobj(data, dims=dims, isherm=True); if ss_args['return_info']:; return out/out.tr(), ss_args['info']; else:; return out/out.tr(). def _iterative_precondition(A, n, ss_args):; """"""; Internal function for preconditioning the steadystate problem for use; with iterative solvers.; """"""; if settings.debug:; logger.debug('Starting preconditioner.'); _precond_start = tim",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:18545,Testability,log,logger,18545,"e(); v = np.linalg.solve(L, b); _dense_end = time.time(); ss_args['info']['solution_time'] = _dense_end-_dense_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L@v, np.inf); data = vec2mat(v); data = 0.5 * (data + data.conj().T). return Qobj(data, dims=dims, isherm=True). def _steadystate_eigen(L, ss_args):; """"""; Internal function for solving the steady state problem by; finding the eigenvector corresponding to the zero eigenvalue; of the Liouvillian using ARPACK.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting Eigen solver.'). dims = L.dims[0]; L = L.data.tocsc(). if ss_args['use_rcm']:; ss_args['info']['perm'].append('rcm'); if settings.debug:; old_band = sp_bandwidth(L)[0]; logger.debug('Original bandwidth: %i' % old_band); perm = sp.csgraph.reverse_cuthill_mckee(L); rev_perm = np.argsort(perm); L = sp_permute(L, perm, perm, 'csc'); if settings.debug:; rcm_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)). _eigen_start = time.time(); eigval, eigvec = eigs(L, k=1, sigma=1e-15, tol=ss_args['tol'],; which='LM', maxiter=ss_args['maxiter']); _eigen_end = time.time(); ss_args['info']['solution_time'] = _eigen_end - _eigen_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*eigvec, np.inf); if ss_args['use_rcm']:; eigvec = eigvec[np.ix_(rev_perm,)]; _temp = vec2mat(eigvec); data = dense2D_to_fastcsr_fmode(_temp, _temp.shape[0], _temp.shape[1]); data = 0.5 * (data + data.H); out = Qobj(data, dims=dims, isherm=True); if ss_args['return_info']:; return out/out.tr(), ss_args['info']; else:; return out/out.tr(). def _iterative_precondition(A, n, ss_args):; """"""; Internal function for preconditioning the steadystate problem for use; with iterative solvers.; """"""; if settings.debug:; logger.debug('Starting preconditioner.'); _precond_start = time.time(); try:; P = spilu(A, permc_spec=ss_arg",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:19421,Testability,log,logger,19421,"mute(L, perm, perm, 'csc'); if settings.debug:; rcm_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)). _eigen_start = time.time(); eigval, eigvec = eigs(L, k=1, sigma=1e-15, tol=ss_args['tol'],; which='LM', maxiter=ss_args['maxiter']); _eigen_end = time.time(); ss_args['info']['solution_time'] = _eigen_end - _eigen_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*eigvec, np.inf); if ss_args['use_rcm']:; eigvec = eigvec[np.ix_(rev_perm,)]; _temp = vec2mat(eigvec); data = dense2D_to_fastcsr_fmode(_temp, _temp.shape[0], _temp.shape[1]); data = 0.5 * (data + data.H); out = Qobj(data, dims=dims, isherm=True); if ss_args['return_info']:; return out/out.tr(), ss_args['info']; else:; return out/out.tr(). def _iterative_precondition(A, n, ss_args):; """"""; Internal function for preconditioning the steadystate problem for use; with iterative solvers.; """"""; if settings.debug:; logger.debug('Starting preconditioner.'); _precond_start = time.time(); try:; P = spilu(A, permc_spec=ss_args['permc_spec'],; drop_tol=ss_args['drop_tol'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; fill_factor=ss_args['fill_factor'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). P_x = lambda x: P.solve(x); M = LinearOperator((n ** 2, n ** 2), matvec=P_x); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)); L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['inf",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:20227,Testability,log,logger,20227,":; return out/out.tr(). def _iterative_precondition(A, n, ss_args):; """"""; Internal function for preconditioning the steadystate problem for use; with iterative solvers.; """"""; if settings.debug:; logger.debug('Starting preconditioner.'); _precond_start = time.time(); try:; P = spilu(A, permc_spec=ss_args['permc_spec'],; drop_tol=ss_args['drop_tol'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; fill_factor=ss_args['fill_factor'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). P_x = lambda x: P.solve(x); M = LinearOperator((n ** 2, n ** 2), matvec=P_x); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)); L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' % ss_args[",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:20271,Testability,log,logger,20271,"ition(A, n, ss_args):; """"""; Internal function for preconditioning the steadystate problem for use; with iterative solvers.; """"""; if settings.debug:; logger.debug('Starting preconditioner.'); _precond_start = time.time(); try:; P = spilu(A, permc_spec=ss_args['permc_spec'],; drop_tol=ss_args['drop_tol'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; fill_factor=ss_args['fill_factor'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). P_x = lambda x: P.solve(x); M = LinearOperator((n ** 2, n ** 2), matvec=P_x); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)); L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' % ss_args['method']). dims = L.dims[0]; n = int(np.sqrt(",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:20627,Testability,log,logger,20627," fill_factor=ss_args['fill_factor'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). P_x = lambda x: P.solve(x); M = LinearOperator((n ** 2, n ** 2), matvec=P_x); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)); L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' % ss_args['method']). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. use_solver(assumeSortedIndices=True). if ss_args['M'] is None and ss_args['use_precond']:; ss_args['M'], ss_args = _iterative_precond",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:20683,Testability,log,logger,20683,"; options=dict(ILU_MILU=ss_args['ILU_MILU'])). P_x = lambda x: P.solve(x); M = LinearOperator((n ** 2, n ** 2), matvec=P_x); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)); L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' % ss_args['method']). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. use_solver(assumeSortedIndices=True). if ss_args['M'] is None and ss_args['use_precond']:; ss_args['M'], ss_args = _iterative_precondition(L, n, ss_args); if ss_args['M",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:20740,Testability,log,logger,20740," LinearOperator((n ** 2, n ** 2), matvec=P_x); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)); L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' % ss_args['method']). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. use_solver(assumeSortedIndices=True). if ss_args['M'] is None and ss_args['use_precond']:; ss_args['M'], ss_args = _iterative_precondition(L, n, ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; Use",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:21182,Testability,log,logger,21182," ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)); L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' % ss_args['method']). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. use_solver(assumeSortedIndices=True). if ss_args['M'] is None and ss_args['use_precond']:; ss_args['M'], ss_args = _iterative_precondition(L, n, ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning). # Select iterative solver type; _iter_start = time.time(); if ss_args['method'] == 'iterative-gmres':; v, check = gmres(L, b, tol=ss_args['tol'], atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count, callback_type='legacy'); elif ss_args['method'] == 'iterative-lgmres':; v, check = lgmres(L, b, tol=ss_args['tol'], atol=ss_args['matol'],; M=ss_a",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:22990,Testability,log,logger,22990,"ter=ss_args['maxiter'],; callback=_iter_count, callback_type='legacy'); elif ss_args['method'] == 'iterative-lgmres':; v, check = lgmres(L, b, tol=ss_args['tol'], atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'iterative-bicgstab':; v, check = bicgstab(L, b, tol=ss_args['tol'],; atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); _iter_end = time.time(). ss_args['info']['iter_time'] = _iter_end - _iter_start; if 'precond_time' in ss_args['info'].keys():; ss_args['info']['solution_time'] = (ss_args['info']['iter_time'] +; ss_args['info']['precond_time']); else:; ss_args['info']['solution_time'] = ss_args['info']['iter_time']; ss_args['info']['iterations'] = ss_iters['iter']; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrice",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:23051,Testability,log,logger,23051,"r_count, callback_type='legacy'); elif ss_args['method'] == 'iterative-lgmres':; v, check = lgmres(L, b, tol=ss_args['tol'], atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'iterative-bicgstab':; v, check = bicgstab(L, b, tol=ss_args['tol'],; atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); _iter_end = time.time(). ss_args['info']['iter_time'] = _iter_end - _iter_start; if 'precond_time' in ss_args['info'].keys():; ss_args['info']['solution_time'] = (ss_args['info']['iter_time'] +; ss_args['info']['precond_time']); else:; ss_args['info']['solution_time'] = ss_args['info']['iter_time']; ss_args['info']['iterations'] = ss_iters['iter']; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0])",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:23889,Testability,log,logger,23889,"rgs['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if ss_args['solver'] == 'mkl':; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.e",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:25024,Testability,log,logger,25024,"lse); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if ss_args['solver'] == 'mkl':; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; orig_nnz = L.nnz; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.deb",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:25075,Testability,log,logger,25075," = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if ss_args['solver'] == 'mkl':; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; orig_nnz = L.nnz; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0];",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:25167,Testability,log,logger,25167,"gs['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if ss_args['solver'] == 'mkl':; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; orig_nnz = L.nnz; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:25529,Testability,log,logger,25529,"j(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if ss_args['solver'] == 'mkl':; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; orig_nnz = L.nnz; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; lo",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:25575,Testability,log,logger,25575,"r(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if ss_args['solver'] == 'mkl':; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; orig_nnz = L.nnz; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:25662,Testability,log,logger,25662,"ower based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if ss_args['solver'] == 'mkl':; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; orig_nnz = L.nnz; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter ",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:26058,Testability,log,logger,26058,"er.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvilli",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:26104,Testability,log,logger,26104,"'Original profile: %i' % old_pro). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with al",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:26175,Testability,log,logger,26175," if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['u",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:26218,Testability,log,logger,26218,"ipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; i",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:26497,Testability,log,logger,26497,"[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; if ss_args['solver'] == 'scipy':; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)),; ss_args); if ss_args['M'] is None:; warnings.warn(""Precond",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:28100,Testability,log,logger,28100,"; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; if ss_args['solver'] == 'scipy':; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)),; ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning). ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if ss_args['solver'] == 'mkl':; lu = mkl_splu(L, max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); else:; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; check = 0; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count, callback_type='legacy'); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); if check > 0:; raise Exception(""{} failed to find solution in ""; ""{} iteration",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:28156,Testability,log,logger,28156,"f ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; if ss_args['solver'] == 'scipy':; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)),; ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning). ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if ss_args['solver'] == 'mkl':; lu = mkl_splu(L, max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); else:; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; check = 0; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count, callback_type='legacy'); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); if check > 0:; raise Exception(""{} failed to find solution in ""; ""{} iterations."".format(ss_args['method'],; che",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:29893,Testability,log,logger,29893,"x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); if check > 0:; raise Exception(""{} failed to find solution in ""; ""{} iterations."".format(ss_args['method'],; check)); if check < 0:; raise Exception(""Breakdown in {}"".format(ss_args['method'])); v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and ss_args['solver'] == 'mkl':; lu.delete(); if ss_args['return_info']:; ss_args['info']['max_iter_refine'] = ss_args['max_iter_refine']; ss_args['info']['scaling_vectors'] = ss_args['scaling_vectors']; ss_args['info']['weighted_matching'] = ss_args['weighted_matching']. if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end = time.time(); ss_args['info']['solution_time'] = _power_end-_power_start; ss_args['info']['iterations'] = it; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*v, np.inf); if settings.debug:; logger.debug('Number of iterations: %i' % it). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. # normalise according to type of problem; if sflag:; trow = v[::rhoss.shape[0]+1]; data = v / np.sum(trow); else:; data = data / la.norm(v). data = dense2D_to_fastcsr_fmode(vec2mat(data),; rhoss.shape[0],; rhoss.shape[0]); rhoss.data = 0.5 * (data + data.H); rhoss.isherm = True; if ss_args['return_info']:; return rhoss, ss_args['info']; else:; return rhoss. [docs]def build_preconditioner(A, c_op_list=[], **kwargs):; """"""Constructs a iLU preconditioner necessary for solving for; the steady state density matrix using the iterative linear solvers; in the 'steadystate' function. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. use_rcm : bool, optional, default = False; Use reverse Cuth",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/steadystate.html:3401,Usability,simpl,simply,3401,"port warnings. from packaging.version import parse as _parse_version; import numpy as np; from numpy.linalg import svd; import scipy; import scipy.sparse as sp; import scipy.linalg as la; from scipy.sparse.linalg import (; use_solver, splu, spilu, eigs, LinearOperator, gmres, lgmres, bicgstab,; ); from qutip.qobj import Qobj, issuper, isoper. from qutip.superoperator import liouvillian, vec2mat, spre; from qutip.sparse import sp_permute, sp_bandwidth, sp_profile; from qutip.cy.spmath import zcsr_kron; from qutip.graph import weighted_bipartite_matching; from qutip import (mat2vec, tensor, identity, operator_to_vector); import qutip.settings as settings; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode. import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); logger.setLevel('DEBUG'). # Load MKL spsolve if avaiable; if settings.has_mkl:; from qutip._mkl.spsolve import (mkl_splu, mkl_spsolve). def _eat_kwargs(function, names):; """"""; Return a wrapped version of `function` that simply removes any keyword; arguments with one of the given names.; """"""; @functools.wraps(function); def out(*args, **kwargs):; for name in names:; if name in kwargs:; del kwargs[name]; return function(*args, **kwargs); return out. # From SciPy 1.4 onwards we need to pass the `callback_type='legacy'` argument; # to gmres to maintain the same behaviour we used to have. Since this should; # be the default behaviour, we use that in the main code and just ""eat"" the; # argument if passed to a lower version of SciPy that doesn't know about it.; # Similarly, SciPy < 1.1 does not recognise the `atol` keyword.; #; # Respective checks can be removed when SciPy version requirements are raised. if _parse_version(scipy.__version__) < _parse_version(""1.1""):; gmres = _eat_kwargs(gmres, ['atol', 'callback_type']); lgmres = _eat_kwargs(lgmres, ['atol']); bicgstab = _eat_kwargs(bicgstab, ['atol']); elif _parse_version(scipy.__version__) < _parse_version(""1.4""):; gmres = _eat_kwargs(gmres, ['cal",MatchSource.WIKI,docs/4.6/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:3285,Availability,avail,available,3285,"bj, isket, isoper, issuper; from qutip.states import ket2dm; from qutip.solver import Result; from qutip.qobjevo import QobjEvo; from qutip.superoperator import spre, spost, mat2vec, liouvillian; from qutip.solver import Options; from qutip.parallel import serial_map; from qutip.ui.progressbar import TextProgressBar; from qutip.pdpsolve import main_ssepdpsolve, main_smepdpsolve. __all__ = ['ssesolve', 'photocurrent_sesolve', 'smepdpsolve',; 'smesolve', 'photocurrent_mesolve', 'ssepdpsolve',; 'stochastic_solvers', 'general_stochastic']. [docs]def stochastic_solvers():; # This docstring contains several literal backslash characters inside LaTeX; # blocks, but it cannot be declared as a raw string because we also need to; # use a line continuation. At one point we need a restructured text; # ""definition list"", where the heading _must_ be entirely on one line,; # however it will violate our line-length reporting if we do that.; """"""; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions. Notes; -----; Available solvers for :obj:`~ssesolve` and :obj:`~smesolve`; euler-maruyama; A simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting ``sc_ops``. *not tested*. - Order 0.5; - Code: ``'euler-maruyama'``, ``'euler'`` or ``0.5``. milstein; An order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]_. - Order strong 1.0; - Code: ``'milstein'`` or ``1.0``. milstein-imp; An order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. - Order strong 1.0; - Code: ``'milstein-imp'``. predictor-corrector; Generalization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:10828,Availability,toler,tolerance,10828,"surement operators. The expected; format is a nested list with one measurement operator for each; stochastic increament, for each stochastic collapse operator. args : dict; Dictionary of parameters for time dependent systems. tol : float; Tolerance of the solver for implicit methods. ntraj : int; Number of trajectors. nsubsteps : int; Number of sub steps between each time-spep given in `times`. dW_factors : array; Array of length len(sc_ops), containing scaling factors for each; measurement operator in m_ops. solver : string; Name of the solver method to use for solving the stochastic; equations. Valid values are:. - order 1/2 algorithms: 'euler-maruyama', 'pc-euler', 'pc-euler-imp'; - order 1 algorithms: 'milstein', 'platen', 'milstein-imp', 'rouchon'; - order 3/2 algorithms: 'taylor1.5', 'taylor1.5-imp', 'explicit1.5'; - order 2 algorithms: 'taylor2.0'. See the documentation of :func:`~qutip.stochastic.stochastic_solvers`; for a description of the solvers. Implicit methods can adjust; tolerance via the kw 'tol'. Default is {'tol': 1e-6}. method : string ('homodyne', 'heterodyne'); The name of the type of measurement process that give rise to the; stochastic equation to solve. store_all_expect : bool (default False); Whether or not to store the e_ops expect values for all paths. store_measurement : bool (default False); Whether or not to store the measurement results in the; :class:`qutip.solver.Result` instance returned by the solver. noise : int, or 1D array of int, or 4D array of float; - int : seed of the noise; - 1D array : length = ntraj, seeds for each trajectories.; - 4D array : ``(ntraj, len(times), nsubsteps, len(sc_ops)*[1|2])``.; Vector for the noise, the len of the last dimensions is doubled for; solvers of order 1.5. This corresponds to results.noise. noiseDepth : int; Number of terms kept of the truncated series used to create the; noise used by taylor2.0 solver. normalize : bool; (default True for (photo)ssesolve, False for (photo)smesolve); Whether ",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:11937,Availability,error,errors,11937,"erodyne'); The name of the type of measurement process that give rise to the; stochastic equation to solve. store_all_expect : bool (default False); Whether or not to store the e_ops expect values for all paths. store_measurement : bool (default False); Whether or not to store the measurement results in the; :class:`qutip.solver.Result` instance returned by the solver. noise : int, or 1D array of int, or 4D array of float; - int : seed of the noise; - 1D array : length = ntraj, seeds for each trajectories.; - 4D array : ``(ntraj, len(times), nsubsteps, len(sc_ops)*[1|2])``.; Vector for the noise, the len of the last dimensions is doubled for; solvers of order 1.5. This corresponds to results.noise. noiseDepth : int; Number of terms kept of the truncated series used to create the; noise used by taylor2.0 solver. normalize : bool; (default True for (photo)ssesolve, False for (photo)smesolve); Whether or not to normalize the wave function during the evolution.; Normalizing density matrices introduce numerical errors. options : :class:`qutip.solver.Options`; Generic solver options. Only options.average_states and; options.store_states are used. map_func: function; A map function or managing the calls to single-trajactory solvers. map_kwargs: dictionary; Optional keyword arguments to the map_func function function. progress_bar : :class:`qutip.ui.BaseProgressBar`; Optional progress bar class instance.; """"""; def __init__(self, me, H=None, c_ops=[], sc_ops=[], state0=None,; e_ops=[], m_ops=None, store_all_expect=False,; store_measurement=False, dW_factors=None,; solver=None, method=""homodyne"", normalize=None,; times=None, nsubsteps=1, ntraj=1, tol=None,; generate_noise=None, noise=None,; progress_bar=None, map_func=None, map_kwargs=None,; args={}, options=None, noiseDepth=20):. if options is None:; options = Options(). if progress_bar is None:; progress_bar = TextProgressBar(). # System; # Cast to QobjEvo so the code has only one version for both the; # constant and time-d",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:41768,Availability,error,error,41768,"(sso.e_ops), len(sso.times)), dtype=complex); res.ss = np.zeros((len(sso.e_ops), len(sso.times)), dtype=complex); res.measurement = []; res.solver = sso.solver_name; res.ntraj = sso.ntraj; res.num_expect = len(sso.e_ops). nt = sso.ntraj; task = _single_trajectory; map_kwargs = {'progress_bar': sso.progress_bar}; map_kwargs.update(sso.map_kwargs); task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **map_kwargs); noise = []; for result in results:; states_list, dW, m, expect = result; res.states.append(states_list); noise.append(dW); res.measurement.append(m); res.expect += expect; res.ss += expect * expect; res.noise = np.stack(noise). if sso.store_all_expect:; paths_expect = []; for result in results:; paths_expect.append(result[3]); res.runs_expect = np.stack(paths_expect). # average density matrices (vectorized maybe); # ajgpitch 2019-10-25: np.any(res.states) seems to error; # I guess there may be a potential exception if there are no states?; # store individual trajectory states; res.traj_states = res.states; res.avg_states = None; if options.average_states and options.store_states:; avg_states_list = []; for n in range(len(res.times)):; tslot_states = [res.states[mm][n].data for mm in range(nt)]; if len(tslot_states) > 0:; state = Qobj(np.sum(tslot_states),; dims=res.states[0][n].dims).unit(); avg_states_list.append(state); # store average states; res.states = res.avg_states = avg_states_list. # average; res.expect = res.expect / nt. # standard error; if nt > 1:; res.se = (res.ss - nt * (res.expect ** 2)) / (nt * (nt - 1)); else:; res.se = None. # convert complex data to real if hermitian; res.expect = [np.real(res.expect[n, :]); if e.isherm else res.expect[n, :]; for n, e in enumerate(sso.e_ops)]. return res. def _single_trajectory(i, sso):; # Only one step?; ssolver = sso.solver_obj(); ssolver.set_solver(sso); result = ssolver.cy_sesolve_single_trajectory(i); return result. # The code for ssepdp",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:42358,Availability,error,error,42358," result; res.states.append(states_list); noise.append(dW); res.measurement.append(m); res.expect += expect; res.ss += expect * expect; res.noise = np.stack(noise). if sso.store_all_expect:; paths_expect = []; for result in results:; paths_expect.append(result[3]); res.runs_expect = np.stack(paths_expect). # average density matrices (vectorized maybe); # ajgpitch 2019-10-25: np.any(res.states) seems to error; # I guess there may be a potential exception if there are no states?; # store individual trajectory states; res.traj_states = res.states; res.avg_states = None; if options.average_states and options.store_states:; avg_states_list = []; for n in range(len(res.times)):; tslot_states = [res.states[mm][n].data for mm in range(nt)]; if len(tslot_states) > 0:; state = Qobj(np.sum(tslot_states),; dims=res.states[0][n].dims).unit(); avg_states_list.append(state); # store average states; res.states = res.avg_states = avg_states_list. # average; res.expect = res.expect / nt. # standard error; if nt > 1:; res.se = (res.ss - nt * (res.expect ** 2)) / (nt * (nt - 1)); else:; res.se = None. # convert complex data to real if hermitian; res.expect = [np.real(res.expect[n, :]); if e.isherm else res.expect[n, :]; for n, e in enumerate(sso.e_ops)]. return res. def _single_trajectory(i, sso):; # Only one step?; ssolver = sso.solver_obj(); ssolver.set_solver(sso); result = ssolver.cy_sesolve_single_trajectory(i); return result. # The code for ssepdpsolve have been moved to the file pdpsolve.; # The call is still in stochastic for consistance.; [docs]def ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs):; """"""; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use :func:`qutip.mcsolve` instead for quantum; trajectory simulations. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly space",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:41144,Deployability,update,update,41144," ""not fit the intial state""); else:; if shape_op[0] != l_vec or shape_op[1] != l_vec:; raise Exception(""The size of the e_ops does ""; ""not fit the intial state""). if sso.m_ops is not None:; for op in sso.m_ops:; shape_op = op.shape; if sso.me:; if shape_op[0]**2 != l_vec or shape_op[1]**2 != l_vec:; raise Exception(""The size of the m_ops does ""; ""not fit the intial state""); else:; if shape_op[0] != l_vec or shape_op[1] != l_vec:; raise Exception(""The size of the m_ops does ""; ""not fit the intial state""). def _sesolve_generic(sso, options, progress_bar):; """"""; Internal function. See smesolve.; """"""; res = Result(); res.times = sso.times; res.expect = np.zeros((len(sso.e_ops), len(sso.times)), dtype=complex); res.ss = np.zeros((len(sso.e_ops), len(sso.times)), dtype=complex); res.measurement = []; res.solver = sso.solver_name; res.ntraj = sso.ntraj; res.num_expect = len(sso.e_ops). nt = sso.ntraj; task = _single_trajectory; map_kwargs = {'progress_bar': sso.progress_bar}; map_kwargs.update(sso.map_kwargs); task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **map_kwargs); noise = []; for result in results:; states_list, dW, m, expect = result; res.states.append(states_list); noise.append(dW); res.measurement.append(m); res.expect += expect; res.ss += expect * expect; res.noise = np.stack(noise). if sso.store_all_expect:; paths_expect = []; for result in results:; paths_expect.append(result[3]); res.runs_expect = np.stack(paths_expect). # average density matrices (vectorized maybe); # ajgpitch 2019-10-25: np.any(res.states) seems to error; # I guess there may be a potential exception if there are no states?; # store individual trajectory states; res.traj_states = res.states; res.avg_states = None; if options.average_states and options.store_states:; avg_states_list = []; for n in range(len(res.times)):; tslot_states = [res.states[mm][n].data for mm in range(nt)]; if len(tslot_states) > 0:; state = Qobj(np.su",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:45420,Deployability,update,updated,45420,":class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`. """"""; return main_ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs). # The code for smepdpsolve have been moved to the file pdpsolve.; # The call is still in stochastic for consistance.; [docs]def smepdpsolve(H, rho0, times, c_ops, e_ops, **kwargs):; """"""; A stochastic (piecewse deterministic process) PDP solver for density matrix; evolution. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. rho0 : :class:`qutip.Qobj`; Initial density matrix. times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of :class:`qutip.Qobj`; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`. """"""; return main_smepdpsolve(H, rho0, times, c_ops, e_ops, **kwargs). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:8507,Integrability,depend,dependent,8507,"for; Quantum Feedback Control*, `arXiv:1410.5345 [quant-ph]; <https://arxiv.org/abs/1410.5345>`_, Phys. Rev. A 91, 012118,; (2015).; .. [4] Howard M. Wiseman, Gerard J. Milburn, *Quantum measurement and; control*.; """""". [docs]class StochasticSolverOptions:; """"""Class of options for stochastic solvers such as; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`, etc. The stochastic solvers :func:`qutip.stochastic.general_stochastic`,; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`,; :func:`qutip.stochastic.photocurrent_sesolve` and; :func:`qutip.stochastic.photocurrent_mesolve`; all take the same keyword arguments as; the constructor of these class, and internally they use these arguments to; construct an instance of this class, so it is rarely needed to explicitly; create an instance of this class. Within the attribute list, a ``time_dependent_object`` is either. - :class:`~Qobj`: a constant term; - 2-element list of ``[Qobj, time_dependence]``: a time-dependent term; where the ``Qobj`` will be multiplied by the time-dependent scalar. For more details on all allowed time-dependent objects, see the; documentation for :class:`~QobjEvo`. Attributes; ----------; H : time_dependent_object or list of time_dependent_object; System Hamiltonian in standard time-dependent list format. This is the; same as the argument that (e.g.) :func:`~mesolve` takes. If this is a; list of elements, they are summed. state0 : :class:`qutip.Qobj`; Initial state vector (ket) or density matrix. times : array_like of float; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of time_dependent_object; List of deterministic collapse operators. Each element of the list is; a separate operator; unlike the Hamiltonian, there is no implicit; summation over the terms. sc_ops : list of time_dependent_object; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation ",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:8573,Integrability,depend,dependent,8573,"for; Quantum Feedback Control*, `arXiv:1410.5345 [quant-ph]; <https://arxiv.org/abs/1410.5345>`_, Phys. Rev. A 91, 012118,; (2015).; .. [4] Howard M. Wiseman, Gerard J. Milburn, *Quantum measurement and; control*.; """""". [docs]class StochasticSolverOptions:; """"""Class of options for stochastic solvers such as; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`, etc. The stochastic solvers :func:`qutip.stochastic.general_stochastic`,; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`,; :func:`qutip.stochastic.photocurrent_sesolve` and; :func:`qutip.stochastic.photocurrent_mesolve`; all take the same keyword arguments as; the constructor of these class, and internally they use these arguments to; construct an instance of this class, so it is rarely needed to explicitly; create an instance of this class. Within the attribute list, a ``time_dependent_object`` is either. - :class:`~Qobj`: a constant term; - 2-element list of ``[Qobj, time_dependence]``: a time-dependent term; where the ``Qobj`` will be multiplied by the time-dependent scalar. For more details on all allowed time-dependent objects, see the; documentation for :class:`~QobjEvo`. Attributes; ----------; H : time_dependent_object or list of time_dependent_object; System Hamiltonian in standard time-dependent list format. This is the; same as the argument that (e.g.) :func:`~mesolve` takes. If this is a; list of elements, they are summed. state0 : :class:`qutip.Qobj`; Initial state vector (ket) or density matrix. times : array_like of float; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of time_dependent_object; List of deterministic collapse operators. Each element of the list is; a separate operator; unlike the Hamiltonian, there is no implicit; summation over the terms. sc_ops : list of time_dependent_object; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation ",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:8628,Integrability,depend,dependent,8628," Howard M. Wiseman, Gerard J. Milburn, *Quantum measurement and; control*.; """""". [docs]class StochasticSolverOptions:; """"""Class of options for stochastic solvers such as; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`, etc. The stochastic solvers :func:`qutip.stochastic.general_stochastic`,; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`,; :func:`qutip.stochastic.photocurrent_sesolve` and; :func:`qutip.stochastic.photocurrent_mesolve`; all take the same keyword arguments as; the constructor of these class, and internally they use these arguments to; construct an instance of this class, so it is rarely needed to explicitly; create an instance of this class. Within the attribute list, a ``time_dependent_object`` is either. - :class:`~Qobj`: a constant term; - 2-element list of ``[Qobj, time_dependence]``: a time-dependent term; where the ``Qobj`` will be multiplied by the time-dependent scalar. For more details on all allowed time-dependent objects, see the; documentation for :class:`~QobjEvo`. Attributes; ----------; H : time_dependent_object or list of time_dependent_object; System Hamiltonian in standard time-dependent list format. This is the; same as the argument that (e.g.) :func:`~mesolve` takes. If this is a; list of elements, they are summed. state0 : :class:`qutip.Qobj`; Initial state vector (ket) or density matrix. times : array_like of float; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of time_dependent_object; List of deterministic collapse operators. Each element of the list is; a separate operator; unlike the Hamiltonian, there is no implicit; summation over the terms. sc_ops : list of time_dependent_object; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. Each element of the list is a separate operator, like; ``c_ops``. e_ops :",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:8813,Integrability,depend,dependent,8813,"Class of options for stochastic solvers such as; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`, etc. The stochastic solvers :func:`qutip.stochastic.general_stochastic`,; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`,; :func:`qutip.stochastic.photocurrent_sesolve` and; :func:`qutip.stochastic.photocurrent_mesolve`; all take the same keyword arguments as; the constructor of these class, and internally they use these arguments to; construct an instance of this class, so it is rarely needed to explicitly; create an instance of this class. Within the attribute list, a ``time_dependent_object`` is either. - :class:`~Qobj`: a constant term; - 2-element list of ``[Qobj, time_dependence]``: a time-dependent term; where the ``Qobj`` will be multiplied by the time-dependent scalar. For more details on all allowed time-dependent objects, see the; documentation for :class:`~QobjEvo`. Attributes; ----------; H : time_dependent_object or list of time_dependent_object; System Hamiltonian in standard time-dependent list format. This is the; same as the argument that (e.g.) :func:`~mesolve` takes. If this is a; list of elements, they are summed. state0 : :class:`qutip.Qobj`; Initial state vector (ket) or density matrix. times : array_like of float; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of time_dependent_object; List of deterministic collapse operators. Each element of the list is; a separate operator; unlike the Hamiltonian, there is no implicit; summation over the terms. sc_ops : list of time_dependent_object; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. Each element of the list is a separate operator, like; ``c_ops``. e_ops : list of :class:`qutip.Qobj`; Single operator or list of operators for which to evaluate; expectation values. m_ops : list ",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:10033,Integrability,depend,dependent,10033,"sity matrix. times : array_like of float; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of time_dependent_object; List of deterministic collapse operators. Each element of the list is; a separate operator; unlike the Hamiltonian, there is no implicit; summation over the terms. sc_ops : list of time_dependent_object; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. Each element of the list is a separate operator, like; ``c_ops``. e_ops : list of :class:`qutip.Qobj`; Single operator or list of operators for which to evaluate; expectation values. m_ops : list of :class:`qutip.Qobj`; List of operators representing the measurement operators. The expected; format is a nested list with one measurement operator for each; stochastic increament, for each stochastic collapse operator. args : dict; Dictionary of parameters for time dependent systems. tol : float; Tolerance of the solver for implicit methods. ntraj : int; Number of trajectors. nsubsteps : int; Number of sub steps between each time-spep given in `times`. dW_factors : array; Array of length len(sc_ops), containing scaling factors for each; measurement operator in m_ops. solver : string; Name of the solver method to use for solving the stochastic; equations. Valid values are:. - order 1/2 algorithms: 'euler-maruyama', 'pc-euler', 'pc-euler-imp'; - order 1 algorithms: 'milstein', 'platen', 'milstein-imp', 'rouchon'; - order 3/2 algorithms: 'taylor1.5', 'taylor1.5-imp', 'explicit1.5'; - order 2 algorithms: 'taylor2.0'. See the documentation of :func:`~qutip.stochastic.stochastic_solvers`; for a description of the solvers. Implicit methods can adjust; tolerance via the kw 'tol'. Default is {'tol': 1e-6}. method : string ('homodyne', 'heterodyne'); The name of the type of measurement process that give rise to the; stochastic equation to so",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:12914,Integrability,depend,dependent,12914,"he evolution.; Normalizing density matrices introduce numerical errors. options : :class:`qutip.solver.Options`; Generic solver options. Only options.average_states and; options.store_states are used. map_func: function; A map function or managing the calls to single-trajactory solvers. map_kwargs: dictionary; Optional keyword arguments to the map_func function function. progress_bar : :class:`qutip.ui.BaseProgressBar`; Optional progress bar class instance.; """"""; def __init__(self, me, H=None, c_ops=[], sc_ops=[], state0=None,; e_ops=[], m_ops=None, store_all_expect=False,; store_measurement=False, dW_factors=None,; solver=None, method=""homodyne"", normalize=None,; times=None, nsubsteps=1, ntraj=1, tol=None,; generate_noise=None, noise=None,; progress_bar=None, map_func=None, map_kwargs=None,; args={}, options=None, noiseDepth=20):. if options is None:; options = Options(). if progress_bar is None:; progress_bar = TextProgressBar(). # System; # Cast to QobjEvo so the code has only one version for both the; # constant and time-dependent case.; self.me = me. if H is not None:; msg = ""The Hamiltonian format is not valid. ""; try:; self.H = QobjEvo(H, args=args, tlist=times,; e_ops=e_ops, state0=state0); except Exception as e:; raise ValueError(msg + str(e)) from e; else:; self.H = H. if sc_ops:; msg = (""The sc_ops format is not valid. Options are ""; ""[ Qobj / QobjEvo / [Qobj, coeff]]. ""); try:; self.sc_ops = [QobjEvo(op, args=args, tlist=times,; e_ops=e_ops, state0=state0); for op in sc_ops]; except Exception as e:; raise ValueError(msg + str(e)) from e; else:; self.sc_ops = sc_ops. if c_ops:; msg = (""The c_ops format is not valid. Options are ""; ""[ Qobj / QobjEvo / [Qobj, coeff]]. ""); try:; self.c_ops = [QobjEvo(op, args=args, tlist=times,; e_ops=e_ops, state0=state0); for op in c_ops]; except Exception as e:; raise ValueError(msg + str(e)) from e; else:; self.c_ops = c_ops. self.state0 = state0; self.rho0 = mat2vec(state0.full()).ravel(). # Observation. for e_op in e_op",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:18757,Integrability,depend,depending,18757,"ten', 'pc-euler', 'pc-euler-imp',; 'milstein', 'milstein-imp', 'rouchon', 'taylor1.5',; 'taylor1.5-imp', 'explicit1.5', 'taylor2.0',; ]; raise ValueError(""The solver should be one of {!r}"".format(known)). class StochasticSolverOptionsPhoto(StochasticSolverOptions):; """"""; Attributes; ----------. solver : string; Name of the solver method to use for solving the evolution; of the system.*; order 1 algorithms: 'euler'; order 2 algorithms: 'pred-corr'; In photocurrent evolution; """"""; def set_solver(self):; if self.solver in [None, 'euler', 1, 60]:; self.solver_code = 60; self.solver = 'euler'; elif self.solver in ['pred-corr', 'predictor-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of opera",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:18871,Integrability,depend,dependent,18871,", 'explicit1.5', 'taylor2.0',; ]; raise ValueError(""The solver should be one of {!r}"".format(known)). class StochasticSolverOptionsPhoto(StochasticSolverOptions):; """"""; Attributes; ----------. solver : string; Name of the solver method to use for solving the evolution; of the system.*; order 1 algorithms: 'euler'; order 2 algorithms: 'pred-corr'; In photocurrent evolution; """"""; def set_solver(self):; if self.solver in [None, 'euler', 1, 60]:; self.solver_code = 60; self.solver = 'euler'; elif self.solver in ['pred-corr', 'predictor-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:18915,Integrability,depend,depend,18915,"be one of {!r}"".format(known)). class StochasticSolverOptionsPhoto(StochasticSolverOptions):; """"""; Attributes; ----------. solver : string; Name of the solver method to use for solving the evolution; of the system.*; order 1 algorithms: 'euler'; order 2 algorithms: 'pred-corr'; In photocurrent evolution; """"""; def set_solver(self):; if self.solver in [None, 'euler', 1, 60]:; self.solver_code = 60; self.solver = 'euler'; elif self.solver in ['pred-corr', 'predictor-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------.",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:19176,Integrability,depend,dependent,19176,"s: 'euler'; order 2 algorithms: 'pred-corr'; In photocurrent evolution; """"""; def set_solver(self):; if self.solver in [None, 'euler', 1, 60]:; self.solver_code = 60; self.solver = 'euler'; elif self.solver in ['pred-corr', 'predictor-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`. """"""; if ""method"" in kwargs and kwargs[""method""] == ""photocurrent"":; print(""stochastic solver with photocurrent method has been moved to ""; ""i",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:19300,Integrability,depend,depend,19300,"ver_code = 60; self.solver = 'euler'; elif self.solver in ['pred-corr', 'predictor-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`. """"""; if ""method"" in kwargs and kwargs[""method""] == ""photocurrent"":; print(""stochastic solver with photocurrent method has been moved to ""; ""it's own function: photocurrent_mesolve""); return photocurrent_mesolve(H, rho0, times, c_ops=c_ops, sc_ops=sc_ops,; e_ops=e_ops, _safe_mode=_safe_mode,",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:19407,Integrability,depend,dependent,19407,"or-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`. """"""; if ""method"" in kwargs and kwargs[""method""] == ""photocurrent"":; print(""stochastic solver with photocurrent method has been moved to ""; ""it's own function: photocurrent_mesolve""); return photocurrent_mesolve(H, rho0, times, c_ops=c_ops, sc_ops=sc_ops,; e_ops=e_ops, _safe_mode=_safe_mode,; args=args, **kwargs); if isket(rho0):; rho0 = ket2dm(rho0). if isinstance(e_ops",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:19640,Integrability,depend,depend,19640,"args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`. """"""; if ""method"" in kwargs and kwargs[""method""] == ""photocurrent"":; print(""stochastic solver with photocurrent method has been moved to ""; ""it's own function: photocurrent_mesolve""); return photocurrent_mesolve(H, rho0, times, c_ops=c_ops, sc_ops=sc_ops,; e_ops=e_ops, _safe_mode=_safe_mode,; args=args, **kwargs); if isket(rho0):; rho0 = ket2dm(rho0). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptions(True, H=H, state0=rho0, times=times,; c_ops=c_ops, sc_ops=sc_ops, e_ops=e_ops,; args=args, **kwargs). if _safe_mode:; _safety_checks(sso",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:22808,Integrability,depend,depending,22808," != len(sso.m_ops):; raise Exception(""The len of dW_factors is not the same as sc_ops""). elif sso.method == ""photocurrent"":; raise NotImplementedError(""Moved to 'photocurrent_mesolve'""). else:; raise Exception(""The method must be one of None, homodyne, heterodyne""). sso.ce_ops = [QobjEvo(spre(op)) for op in sso.e_ops]; sso.cm_ops = [QobjEvo(spre(op)) for op in sso.m_ops]. sso.LH.compile(); [op.compile() for op in sso.sops]; [op.compile() for op in sso.cm_ops]; [op.compile() for op in sso.ce_ops]. if sso.solver_code in [103, 153]:; sso.imp = 1 - sso.LH * 0.5; sso.imp.compile(). sso.solver_obj = SMESolver; sso.solver_name = ""smesolve_"" + sso.solver. res = _sesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. [docs]def ssesolve(H, psi0, times, sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0 : :class:`qutip.Qobj`; State vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:22922,Integrability,depend,dependent,22922,"d == ""photocurrent"":; raise NotImplementedError(""Moved to 'photocurrent_mesolve'""). else:; raise Exception(""The method must be one of None, homodyne, heterodyne""). sso.ce_ops = [QobjEvo(spre(op)) for op in sso.e_ops]; sso.cm_ops = [QobjEvo(spre(op)) for op in sso.m_ops]. sso.LH.compile(); [op.compile() for op in sso.sops]; [op.compile() for op in sso.cm_ops]; [op.compile() for op in sso.ce_ops]. if sso.solver_code in [103, 153]:; sso.imp = 1 - sso.LH * 0.5; sso.imp.compile(). sso.solver_obj = SMESolver; sso.solver_name = ""smesolve_"" + sso.solver. res = _sesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. [docs]def ssesolve(H, psi0, times, sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0 : :class:`qutip.Qobj`; State vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if ""method"" in kwargs and kwargs[""method""] == ""photocurrent"":; print(""stochastic solve",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:22966,Integrability,depend,depend,22966,"t_mesolve'""). else:; raise Exception(""The method must be one of None, homodyne, heterodyne""). sso.ce_ops = [QobjEvo(spre(op)) for op in sso.e_ops]; sso.cm_ops = [QobjEvo(spre(op)) for op in sso.m_ops]. sso.LH.compile(); [op.compile() for op in sso.sops]; [op.compile() for op in sso.cm_ops]; [op.compile() for op in sso.ce_ops]. if sso.solver_code in [103, 153]:; sso.imp = 1 - sso.LH * 0.5; sso.imp.compile(). sso.solver_obj = SMESolver; sso.solver_name = ""smesolve_"" + sso.solver. res = _sesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. [docs]def ssesolve(H, psi0, times, sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0 : :class:`qutip.Qobj`; State vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if ""method"" in kwargs and kwargs[""method""] == ""photocurrent"":; print(""stochastic solver with photocurrent method has been moved to ""; ""it's own function: ph",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:23202,Integrability,depend,dependent,23202,"compile(); [op.compile() for op in sso.sops]; [op.compile() for op in sso.cm_ops]; [op.compile() for op in sso.ce_ops]. if sso.solver_code in [103, 153]:; sso.imp = 1 - sso.LH * 0.5; sso.imp.compile(). sso.solver_obj = SMESolver; sso.solver_name = ""smesolve_"" + sso.solver. res = _sesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. [docs]def ssesolve(H, psi0, times, sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0 : :class:`qutip.Qobj`; State vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if ""method"" in kwargs and kwargs[""method""] == ""photocurrent"":; print(""stochastic solver with photocurrent method has been moved to ""; ""it's own function: photocurrent_sesolve""); return photocurrent_sesolve(H, psi0, times, c_ops=c_ops,; e_ops=e_ops, _safe_mode=_safe_mode,; args=args, **kwargs). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:23435,Integrability,depend,depend,23435,"+ sso.solver. res = _sesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. [docs]def ssesolve(H, psi0, times, sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0 : :class:`qutip.Qobj`; State vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if ""method"" in kwargs and kwargs[""method""] == ""photocurrent"":; print(""stochastic solver with photocurrent method has been moved to ""; ""it's own function: photocurrent_sesolve""); return photocurrent_sesolve(H, psi0, times, c_ops=c_ops,; e_ops=e_ops, _safe_mode=_safe_mode,; args=args, **kwargs). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptions(False, H=H, state0=psi0, times=times,; sc_ops=sc_ops, e_ops=e_ops,; args=args, **kwargs). if _safe_mode:; _safety_checks(sso). if sso.solver_code == 120:; raise Exception(""rouchon only wor",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:28862,Integrability,depend,dependent,28862,"s2 += [spost(op.dag() * op2.dag())]. sso.ce_ops = [QobjEvo(spre(op)) for op in sso.e_ops]; sso.cm_ops = [QobjEvo(spre(op)) for op in sso.m_ops]; sso.preLH = spre(LH); sso.postLH = spost(LH.dag()). sso.preLH.compile(); sso.postLH.compile(); sso.pp.compile(); [op.compile() for op in sso.sops]; [op.compile() for op in sso.preops]; [op.compile() for op in sso.postops]; [op.compile() for op in sso.preops2]; [op.compile() for op in sso.postops2]; [op.compile() for op in sso.cm_ops]; [op.compile() for op in sso.ce_ops]. sso.solver_obj = PmSMESolver; sso.solver_name = ""smesolve_"" + sso.solver; res = _sesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation using the photocurrent method. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Opti",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:28906,Integrability,depend,depend,28906,"or op in sso.e_ops]; sso.cm_ops = [QobjEvo(spre(op)) for op in sso.m_ops]; sso.preLH = spre(LH); sso.postLH = spost(LH.dag()). sso.preLH.compile(); sso.postLH.compile(); sso.pp.compile(); [op.compile() for op in sso.sops]; [op.compile() for op in sso.preops]; [op.compile() for op in sso.postops]; [op.compile() for op in sso.preops2]; [op.compile() for op in sso.postops2]; [op.compile() for op in sso.cm_ops]; [op.compile() for op in sso.ce_ops]. sso.solver_obj = PmSMESolver; sso.solver_name = ""smesolve_"" + sso.solver; res = _sesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation using the photocurrent method. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolver",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:29167,Integrability,depend,dependent,29167,"() for op in sso.preops]; [op.compile() for op in sso.postops]; [op.compile() for op in sso.preops2]; [op.compile() for op in sso.postops2]; [op.compile() for op in sso.cm_ops]; [op.compile() for op in sso.ce_ops]. sso.solver_obj = PmSMESolver; sso.solver_name = ""smesolve_"" + sso.solver; res = _sesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation using the photocurrent method. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if isket(rho0):; rho0 = ket2dm(rho0). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:29291,Integrability,depend,depend,29291,"e() for op in sso.cm_ops]; [op.compile() for op in sso.ce_ops]. sso.solver_obj = PmSMESolver; sso.solver_name = ""smesolve_"" + sso.solver; res = _sesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation using the photocurrent method. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if isket(rho0):; rho0 = ket2dm(rho0). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptionsPhoto(True, H=H, state0=rho0, times=times,; c_ops=c_ops, sc_ops=sc_ops, e_ops=e",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:29398,Integrability,depend,dependent,29398," PmSMESolver; sso.solver_name = ""smesolve_"" + sso.solver; res = _sesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation using the photocurrent method. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if isket(rho0):; rho0 = ket2dm(rho0). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptionsPhoto(True, H=H, state0=rho0, times=times,; c_ops=c_ops, sc_ops=sc_ops, e_ops=e_ops,; args=args, **kwargs). if _safe_mode:; _safety_checks(sso). if sso.m_ops is",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:29631,Integrability,depend,depend,29631," times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation using the photocurrent method. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if isket(rho0):; rho0 = ket2dm(rho0). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptionsPhoto(True, H=H, state0=rho0, times=times,; c_ops=c_ops, sc_ops=sc_ops, e_ops=e_ops,; args=args, **kwargs). if _safe_mode:; _safety_checks(sso). if sso.m_ops is None:; sso.m_ops = [op * 0 for op in sso.sc_ops]; if not isinstance(sso.dW_factors, list):; sso.dW_factors = [1] * len(sso.sc_ops); elif len(sso.dW_factors) != len(sso.sc_ops):; raise Exception(""The len of dW_factors is not the same as sc_ops""). sso.solver_o",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:31679,Integrability,depend,dependent,31679,"solver_name = ""photocurrent_mesolve""; sso.LH = liouvillian(sso.H, c_ops=sso.c_ops) * sso.dt. def _prespostdag(op):; return spre(op) * spost(op.dag()). sso.sops = [[spre(op._cdc()) + spost(op._cdc()),; spre(op._cdc()),; op.apply(_prespostdag)._f_norm2()] for op in sso.sc_ops]; sso.ce_ops = [QobjEvo(spre(op)) for op in sso.e_ops]; sso.cm_ops = [QobjEvo(spre(op)) for op in sso.m_ops]. sso.LH.compile(); [[op.compile() for op in ops] for ops in sso.sops]; [op.compile() for op in sso.cm_ops]; [op.compile() for op in sso.ce_ops]. res = _sesolve_generic(sso, sso.options, sso.progress_bar); res.num_collapse = [np.count_nonzero(noise) for noise in res.noise]. if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic schrodinger equation using the photocurrent method. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:31723,Integrability,depend,depend,31723,"s=sso.c_ops) * sso.dt. def _prespostdag(op):; return spre(op) * spost(op.dag()). sso.sops = [[spre(op._cdc()) + spost(op._cdc()),; spre(op._cdc()),; op.apply(_prespostdag)._f_norm2()] for op in sso.sc_ops]; sso.ce_ops = [QobjEvo(spre(op)) for op in sso.e_ops]; sso.cm_ops = [QobjEvo(spre(op)) for op in sso.m_ops]. sso.LH.compile(); [[op.compile() for op in ops] for ops in sso.sops]; [op.compile() for op in sso.cm_ops]; [op.compile() for op in sso.ce_ops]. res = _sesolve_generic(sso, sso.options, sso.progress_bar); res.num_collapse = [np.count_nonzero(noise) for noise in res.noise]. if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic schrodinger equation using the photocurrent method. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = list(e_ops.values()); else:; e_ops_dict = None. sso = Stochastic",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:31967,Integrability,depend,dependent,31967," = [QobjEvo(spre(op)) for op in sso.e_ops]; sso.cm_ops = [QobjEvo(spre(op)) for op in sso.m_ops]. sso.LH.compile(); [[op.compile() for op in ops] for ops in sso.sops]; [op.compile() for op in sso.cm_ops]; [op.compile() for op in sso.ce_ops]. res = _sesolve_generic(sso, sso.options, sso.progress_bar); res.num_collapse = [np.count_nonzero(noise) for noise in res.noise]. if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic schrodinger equation using the photocurrent method. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = list(e_ops.values()); else:; e_ops_dict = None. sso = StochasticSolverOptionsPhoto(False, H=H, state0=psi0, times=times,; sc_ops=sc_ops, e_ops=e_ops,; args=args, **kwargs). if _safe_mode:; _safety_checks(sso). if sso.m_ops is None:; sso.m_ops = [op * 0 for op in sso.sc_ops]; if not",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:32200,Integrability,depend,depend,32200,"eric(sso, sso.options, sso.progress_bar); res.num_collapse = [np.count_nonzero(noise) for noise in res.noise]. if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic schrodinger equation using the photocurrent method. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = list(e_ops.values()); else:; e_ops_dict = None. sso = StochasticSolverOptionsPhoto(False, H=H, state0=psi0, times=times,; sc_ops=sc_ops, e_ops=e_ops,; args=args, **kwargs). if _safe_mode:; _safety_checks(sso). if sso.m_ops is None:; sso.m_ops = [op * 0 for op in sso.sc_ops]; if not isinstance(sso.dW_factors, list):; sso.dW_factors = [1] * len(sso.sc_ops); elif len(sso.dW_factors) != len(sso.sc_ops):; raise Exception(""The len of dW_factors is not the same as sc_ops""). sso.solver_obj = PcSSESolver; sso.solver_name = ""photocurrent_sesolve",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:34033,Integrability,depend,depending,34033,"lif len(sso.dW_factors) != len(sso.sc_ops):; raise Exception(""The len of dW_factors is not the same as sc_ops""). sso.solver_obj = PcSSESolver; sso.solver_name = ""photocurrent_sesolve""; sso.sops = [[op, op._cdc()] for op in sso.sc_ops]; sso.LH = sso.H * (-1j*sso.dt); for ops in sso.sops:; sso.LH -= ops[0]._cdc()*0.5*sso.dt; sso.ce_ops = [QobjEvo(op) for op in sso.e_ops]; sso.cm_ops = [QobjEvo(op) for op in sso.m_ops]. sso.LH.compile(); [[op.compile() for op in ops] for ops in sso.sops]; [op.compile() for op in sso.cm_ops]; [op.compile() for op in sso.ce_ops]. res = _sesolve_generic(sso, sso.options, sso.progress_bar); res.num_collapse = [np.count_nonzero(noise) for noise in res.noise]. if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def general_stochastic(state0, times, d1, d2, e_ops=[], m_ops=[],; _safe_mode=True, len_d2=1, args={}, **kwargs):; """"""; Solve stochastic general equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. state0 : :class:`qutip.Qobj`; Initial state vector (ket) or density matrix as a vector. times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. d1 : function, callable class; Function representing the deterministic evolution of the system. def d1(time (double), state (as a np.array vector)):; return 1d np.array. d2 : function, callable class; Function representing the stochastic evolution of the system. def d2(time (double), state (as a np.array vector)):; return 2d np.array (N_sc_ops, len(state0)). len_d2 : int; Number of output vector produced by d2. e_ops : list of :class:`qutip.Qobj`; single operator or list of operators for which to evaluate; expectation values.; Must be a superoperator if the state vector is a density matrix. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`; An",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:4115,Safety,predict,predictor-corrector,4115,"ill violate our line-length reporting if we do that.; """"""; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions. Notes; -----; Available solvers for :obj:`~ssesolve` and :obj:`~smesolve`; euler-maruyama; A simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting ``sc_ops``. *not tested*. - Order 0.5; - Code: ``'euler-maruyama'``, ``'euler'`` or ``0.5``. milstein; An order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]_. - Order strong 1.0; - Code: ``'milstein'`` or ``1.0``. milstein-imp; An order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. - Order strong 1.0; - Code: ``'milstein-imp'``. predictor-corrector; Generalization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]_. - Order strong 0.5, weak 1.0; - Codes to only correct the stochastic part (:math:`\\alpha=0`,; :math:`\\eta=1/2`): ``'pred-corr'``, ``'predictor-corrector'`` or; ``'pc-euler'``; - Codes to correct both the stochastic and deterministic parts; (:math:`\\alpha=1/2`, :math:`\\eta=1/2`): ``'pc-euler-imp'``,; ``'pc-euler-2'`` or ``'pred-corr-2'``. platen; Explicit scheme, creates the Milstein using finite differences; instead of analytic derivatives. Also contains some higher order; terms, thus converges better than Milstein while staying strong; order 1.0. Does not require derivatives, therefore usable by; :func:`~general_stochastic`. See eq. (7.47) of chapter 7 of [2]_. - Order strong 1.0, weak 2.0; - Code: ``'platen'``, ``'platen1'`` or ``'explicit1'``. rouchon; Scheme keeping the positivity of the density matrix; (:obj:`~smesolve` only). See eq. (4) with :math:`\\",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:4426,Safety,predict,predictor-corrector,4426,"hod for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting ``sc_ops``. *not tested*. - Order 0.5; - Code: ``'euler-maruyama'``, ``'euler'`` or ``0.5``. milstein; An order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]_. - Order strong 1.0; - Code: ``'milstein'`` or ``1.0``. milstein-imp; An order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. - Order strong 1.0; - Code: ``'milstein-imp'``. predictor-corrector; Generalization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]_. - Order strong 0.5, weak 1.0; - Codes to only correct the stochastic part (:math:`\\alpha=0`,; :math:`\\eta=1/2`): ``'pred-corr'``, ``'predictor-corrector'`` or; ``'pc-euler'``; - Codes to correct both the stochastic and deterministic parts; (:math:`\\alpha=1/2`, :math:`\\eta=1/2`): ``'pc-euler-imp'``,; ``'pc-euler-2'`` or ``'pred-corr-2'``. platen; Explicit scheme, creates the Milstein using finite differences; instead of analytic derivatives. Also contains some higher order; terms, thus converges better than Milstein while staying strong; order 1.0. Does not require derivatives, therefore usable by; :func:`~general_stochastic`. See eq. (7.47) of chapter 7 of [2]_. - Order strong 1.0, weak 2.0; - Code: ``'platen'``, ``'platen1'`` or ``'explicit1'``. rouchon; Scheme keeping the positivity of the density matrix; (:obj:`~smesolve` only). See eq. (4) with :math:`\\eta=1` of [3]_. - Order strong 1.0?; - Code: ``'rouchon'`` or ``'Rouchon'``. taylor1.5; Order 1.5 strong Taylor scheme. Solver with more terms of the; Ito-Taylor expansion. Default solver for :obj:`~smesolve` and; :obj:`~ssesolve`. See eq. (4.6) of chapter 10.4 of [1]_. - Order strong 1.5; - Code: ``'taylor1.5",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:7011,Safety,predict,predictor,7011,"1.5'``, ``'explicit15'`` or ``'platen15'``. taylor2.0; Order 2 strong Taylor scheme. Solver with more terms of the; Stratonovich expansion. See eq. (5.2) of chapter 10.5 of [1]_. - Order strong 2.0; - Code: ``'taylor2.0'``, ``'taylor20'`` or ``2.0``. All solvers, except taylor2.0, are usable in both smesolve and ssesolve; and for both heterodyne and homodyne. taylor2.0 only works for 1; stochastic operator independent of time with the homodyne method.; :func:`~general_stochastic` only accepts the derivative-free; solvers: ``'euler'``, ``'platen'`` and ``'explicit1.5'``. Available solvers for :obj:`~photocurrent_sesolve` and \; :obj:`~photocurrent_mesolve`; Photocurrent use ordinary differential equations between; stochastic ""jump/collapse"". euler; Euler method for ordinary differential equations between jumps.; Only one jump per time interval. Default solver. See eqs. (4.19); and (4.4) of chapter 4 of [4]_. - Order 1.0; - Code: ``'euler'``. predictor–corrector; predictor–corrector method (PECE) for ordinary differential; equations. Uses the Poisson distribution to obtain the number of; jumps at each timestep. - Order 2.0; - Code: ``'pred-corr'``. References; ----------; .. [1] Peter E. Kloeden and Exkhard Platen, *Numerical Solution of; Stochastic Differential Equations*.; .. [2] H.-P. Breuer and F. Petruccione, *The Theory of Open Quantum; Systems*.; .. [3] Pierre Rouchon and Jason F. Ralpha, *Efficient Quantum Filtering for; Quantum Feedback Control*, `arXiv:1410.5345 [quant-ph]; <https://arxiv.org/abs/1410.5345>`_, Phys. Rev. A 91, 012118,; (2015).; .. [4] Howard M. Wiseman, Gerard J. Milburn, *Quantum measurement and; control*.; """""". [docs]class StochasticSolverOptions:; """"""Class of options for stochastic solvers such as; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`, etc. The stochastic solvers :func:`qutip.stochastic.general_stochastic`,; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`,; :func:`qutip.stochastic.photoc",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:7032,Safety,predict,predictor,7032,"1.5'``, ``'explicit15'`` or ``'platen15'``. taylor2.0; Order 2 strong Taylor scheme. Solver with more terms of the; Stratonovich expansion. See eq. (5.2) of chapter 10.5 of [1]_. - Order strong 2.0; - Code: ``'taylor2.0'``, ``'taylor20'`` or ``2.0``. All solvers, except taylor2.0, are usable in both smesolve and ssesolve; and for both heterodyne and homodyne. taylor2.0 only works for 1; stochastic operator independent of time with the homodyne method.; :func:`~general_stochastic` only accepts the derivative-free; solvers: ``'euler'``, ``'platen'`` and ``'explicit1.5'``. Available solvers for :obj:`~photocurrent_sesolve` and \; :obj:`~photocurrent_mesolve`; Photocurrent use ordinary differential equations between; stochastic ""jump/collapse"". euler; Euler method for ordinary differential equations between jumps.; Only one jump per time interval. Default solver. See eqs. (4.19); and (4.4) of chapter 4 of [4]_. - Order 1.0; - Code: ``'euler'``. predictor–corrector; predictor–corrector method (PECE) for ordinary differential; equations. Uses the Poisson distribution to obtain the number of; jumps at each timestep. - Order 2.0; - Code: ``'pred-corr'``. References; ----------; .. [1] Peter E. Kloeden and Exkhard Platen, *Numerical Solution of; Stochastic Differential Equations*.; .. [2] H.-P. Breuer and F. Petruccione, *The Theory of Open Quantum; Systems*.; .. [3] Pierre Rouchon and Jason F. Ralpha, *Efficient Quantum Filtering for; Quantum Feedback Control*, `arXiv:1410.5345 [quant-ph]; <https://arxiv.org/abs/1410.5345>`_, Phys. Rev. A 91, 012118,; (2015).; .. [4] Howard M. Wiseman, Gerard J. Milburn, *Quantum measurement and; control*.; """""". [docs]class StochasticSolverOptions:; """"""Class of options for stochastic solvers such as; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`, etc. The stochastic solvers :func:`qutip.stochastic.general_stochastic`,; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`,; :func:`qutip.stochastic.photoc",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:16447,Safety,predict,predictor-corrector,16447,"; if noise.shape[1] < len(times):; raise ValueError(msg + ""shape[1] >= len(times)""); if noise.shape[2] < nsubsteps:; raise ValueError(msg + ""shape[2] >= nsubsteps""); if noise.shape[3] < len(self.sc_ops) * dw_len:; raise ValueError(msg + ""shape[3] >= len(self.sc_ops)"" +; dw_len_str); self.noise_type = 1; self.noise = noise. else:; self.noise = np.random.randint(0, 2**32, ntraj, dtype=np.uint32); self.noise_type = 0. # Map; self.progress_bar = progress_bar; if self.ntraj > 1 and map_func:; self.map_func = map_func; else:; self.map_func = serial_map; self.map_kwargs = map_kwargs if map_kwargs is not None else {}. # Other; self.options = options; self.args = args; self.set_solver(); self.p = noiseDepth. def set_solver(self):; if self.solver in ['euler-maruyama', 'euler', 50, 0.5]:; self.solver_code = 50; self.solver = 'euler-maruyama'; elif self.solver in ['platen', 'platen1', 'explicit1', 100]:; self.solver_code = 100; self.solver = 'platen'; elif self.solver in ['pred-corr', 'predictor-corrector',; 'pc-euler', 101]:; self.solver_code = 101; self.solver = 'pred-corr'; elif self.solver in ['milstein', 102, 1.0]:; self.solver_code = 102; self.solver = 'milstein'; elif self.solver in ['milstein-imp', 103]:; self.solver_code = 103; self.solver = 'milstein-imp'; elif self.solver in ['pred-corr-2', 'pc-euler-2', 'pc-euler-imp', 104]:; self.solver_code = 104; self.solver = 'pred-corr-2'; elif self.solver in ['Rouchon', 'rouchon', 120]:; self.solver_code = 120; self.solver = 'rouchon'; if not all((op.const for op in self.sc_ops)):; raise ValueError(""Rouchon only works with constant sc_ops""); elif self.solver in ['platen15', 'explicit1.5', 'explicit15', 150]:; self.solver_code = 150; self.solver = 'explicit1.5'; elif self.solver in ['taylor15', 'taylor1.5', None, 1.5, 152]:; self.solver_code = 152; self.solver = 'taylor1.5'; elif self.solver in ['taylor15-imp', 'taylor1.5-imp', 153]:; self.solver_code = 153; self.solver = 'taylor1.5-imp'; elif self.solver in ['taylor2.0', 'tayl",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:18400,Safety,predict,predictor-corrector,18400,"lor1.5-imp'; elif self.solver in ['taylor2.0', 'taylor20', 2.0, 202]:; self.solver_code = 202; self.solver = 'taylor2.0'; if not len(self.sc_ops) == 1 or \; not self.sc_ops[0].const or \; not self.method == ""homodyne"":; raise ValueError(; ""Taylor2.0 only works with 1 constant sc_ops and for""; "" homodyne method""; ); else:; known = [; None, 'euler-maruyama', 'platen', 'pc-euler', 'pc-euler-imp',; 'milstein', 'milstein-imp', 'rouchon', 'taylor1.5',; 'taylor1.5-imp', 'explicit1.5', 'taylor2.0',; ]; raise ValueError(""The solver should be one of {!r}"".format(known)). class StochasticSolverOptionsPhoto(StochasticSolverOptions):; """"""; Attributes; ----------. solver : string; Name of the solver method to use for solving the evolution; of the system.*; order 1 algorithms: 'euler'; order 2 algorithms: 'pred-corr'; In photocurrent evolution; """"""; def set_solver(self):; if self.solver in [None, 'euler', 1, 60]:; self.solver_code = 60; self.solver = 'euler'; elif self.solver in ['pred-corr', 'predictor-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:18558,Safety,predict,predictor-corrector,18558,"r2.0'; if not len(self.sc_ops) == 1 or \; not self.sc_ops[0].const or \; not self.method == ""homodyne"":; raise ValueError(; ""Taylor2.0 only works with 1 constant sc_ops and for""; "" homodyne method""; ); else:; known = [; None, 'euler-maruyama', 'platen', 'pc-euler', 'pc-euler-imp',; 'milstein', 'milstein-imp', 'rouchon', 'taylor1.5',; 'taylor1.5-imp', 'explicit1.5', 'taylor2.0',; ]; raise ValueError(""The solver should be one of {!r}"".format(known)). class StochasticSolverOptionsPhoto(StochasticSolverOptions):; """"""; Attributes; ----------. solver : string; Name of the solver method to use for solving the evolution; of the system.*; order 1 algorithms: 'euler'; order 2 algorithms: 'pred-corr'; In photocurrent evolution; """"""; def set_solver(self):; if self.solver in [None, 'euler', 1, 60]:; self.solver_code = 60; self.solver = 'euler'; elif self.solver in ['pred-corr', 'predictor-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a determinist",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:3616,Testability,test,tested,3616,"e import main_ssepdpsolve, main_smepdpsolve. __all__ = ['ssesolve', 'photocurrent_sesolve', 'smepdpsolve',; 'smesolve', 'photocurrent_mesolve', 'ssepdpsolve',; 'stochastic_solvers', 'general_stochastic']. [docs]def stochastic_solvers():; # This docstring contains several literal backslash characters inside LaTeX; # blocks, but it cannot be declared as a raw string because we also need to; # use a line continuation. At one point we need a restructured text; # ""definition list"", where the heading _must_ be entirely on one line,; # however it will violate our line-length reporting if we do that.; """"""; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions. Notes; -----; Available solvers for :obj:`~ssesolve` and :obj:`~smesolve`; euler-maruyama; A simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting ``sc_ops``. *not tested*. - Order 0.5; - Code: ``'euler-maruyama'``, ``'euler'`` or ``0.5``. milstein; An order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]_. - Order strong 1.0; - Code: ``'milstein'`` or ``1.0``. milstein-imp; An order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. - Order strong 1.0; - Code: ``'milstein-imp'``. predictor-corrector; Generalization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]_. - Order strong 0.5, weak 1.0; - Codes to only correct the stochastic part (:math:`\\alpha=0`,; :math:`\\eta=1/2`): ``'pred-corr'``, ``'predictor-corrector'`` or; ``'pc-euler'``; - Codes to correct both the stochastic and deterministic parts; (:math:`\\alpha=1/2`, :math:`\\eta=1/2`): ``'pc-euler-imp'``,; ``'pc-euler-2'`` or `",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:3438,Usability,simpl,simple,3438,"ost, mat2vec, liouvillian; from qutip.solver import Options; from qutip.parallel import serial_map; from qutip.ui.progressbar import TextProgressBar; from qutip.pdpsolve import main_ssepdpsolve, main_smepdpsolve. __all__ = ['ssesolve', 'photocurrent_sesolve', 'smepdpsolve',; 'smesolve', 'photocurrent_mesolve', 'ssepdpsolve',; 'stochastic_solvers', 'general_stochastic']. [docs]def stochastic_solvers():; # This docstring contains several literal backslash characters inside LaTeX; # blocks, but it cannot be declared as a raw string because we also need to; # use a line continuation. At one point we need a restructured text; # ""definition list"", where the heading _must_ be entirely on one line,; # however it will violate our line-length reporting if we do that.; """"""; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions. Notes; -----; Available solvers for :obj:`~ssesolve` and :obj:`~smesolve`; euler-maruyama; A simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting ``sc_ops``. *not tested*. - Order 0.5; - Code: ``'euler-maruyama'``, ``'euler'`` or ``0.5``. milstein; An order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]_. - Order strong 1.0; - Code: ``'milstein'`` or ``1.0``. milstein-imp; An order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. - Order strong 1.0; - Code: ``'milstein-imp'``. predictor-corrector; Generalization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]_. - Order strong 0.5, weak 1.0; - Codes to only correct the stochastic part (:math:`\\alpha=0`,; :math:`\\eta=1/2`): ``'pred-corr'``, ``'predictor-corrector'`` ",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:4889,Usability,usab,usable,4889,"stein'`` or ``1.0``. milstein-imp; An order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. - Order strong 1.0; - Code: ``'milstein-imp'``. predictor-corrector; Generalization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]_. - Order strong 0.5, weak 1.0; - Codes to only correct the stochastic part (:math:`\\alpha=0`,; :math:`\\eta=1/2`): ``'pred-corr'``, ``'predictor-corrector'`` or; ``'pc-euler'``; - Codes to correct both the stochastic and deterministic parts; (:math:`\\alpha=1/2`, :math:`\\eta=1/2`): ``'pc-euler-imp'``,; ``'pc-euler-2'`` or ``'pred-corr-2'``. platen; Explicit scheme, creates the Milstein using finite differences; instead of analytic derivatives. Also contains some higher order; terms, thus converges better than Milstein while staying strong; order 1.0. Does not require derivatives, therefore usable by; :func:`~general_stochastic`. See eq. (7.47) of chapter 7 of [2]_. - Order strong 1.0, weak 2.0; - Code: ``'platen'``, ``'platen1'`` or ``'explicit1'``. rouchon; Scheme keeping the positivity of the density matrix; (:obj:`~smesolve` only). See eq. (4) with :math:`\\eta=1` of [3]_. - Order strong 1.0?; - Code: ``'rouchon'`` or ``'Rouchon'``. taylor1.5; Order 1.5 strong Taylor scheme. Solver with more terms of the; Ito-Taylor expansion. Default solver for :obj:`~smesolve` and; :obj:`~ssesolve`. See eq. (4.6) of chapter 10.4 of [1]_. - Order strong 1.5; - Code: ``'taylor1.5'``, ``'taylor15'``, ``1.5``, or ``None``. taylor1.5-imp; Order 1.5 implicit strong Taylor scheme. Implicit Taylor 1.5; (:math:`\\alpha = 1/2`, :math:`\\beta` doesn't matter). See eq.; (2.18) of chapter 12.2 of [1]_. - Order strong 1.5; - Code: ``'taylor1.5-imp'`` or ``'taylor15-imp'``. explicit1.5; Explicit order 1.5 strong schemes. Reproduce the order 1.5 strong; Taylor scheme using finite difference instea",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:5936,Usability,usab,usable,5936,"47) of chapter 7 of [2]_. - Order strong 1.0, weak 2.0; - Code: ``'platen'``, ``'platen1'`` or ``'explicit1'``. rouchon; Scheme keeping the positivity of the density matrix; (:obj:`~smesolve` only). See eq. (4) with :math:`\\eta=1` of [3]_. - Order strong 1.0?; - Code: ``'rouchon'`` or ``'Rouchon'``. taylor1.5; Order 1.5 strong Taylor scheme. Solver with more terms of the; Ito-Taylor expansion. Default solver for :obj:`~smesolve` and; :obj:`~ssesolve`. See eq. (4.6) of chapter 10.4 of [1]_. - Order strong 1.5; - Code: ``'taylor1.5'``, ``'taylor15'``, ``1.5``, or ``None``. taylor1.5-imp; Order 1.5 implicit strong Taylor scheme. Implicit Taylor 1.5; (:math:`\\alpha = 1/2`, :math:`\\beta` doesn't matter). See eq.; (2.18) of chapter 12.2 of [1]_. - Order strong 1.5; - Code: ``'taylor1.5-imp'`` or ``'taylor15-imp'``. explicit1.5; Explicit order 1.5 strong schemes. Reproduce the order 1.5 strong; Taylor scheme using finite difference instead of derivatives.; Slower than ``taylor15`` but usable by; :func:`~general_stochastic`. See eq. (2.13) of chapter 11.2 of; [1]_. - Order strong 1.5; - Code: ``'explicit1.5'``, ``'explicit15'`` or ``'platen15'``. taylor2.0; Order 2 strong Taylor scheme. Solver with more terms of the; Stratonovich expansion. See eq. (5.2) of chapter 10.5 of [1]_. - Order strong 2.0; - Code: ``'taylor2.0'``, ``'taylor20'`` or ``2.0``. All solvers, except taylor2.0, are usable in both smesolve and ssesolve; and for both heterodyne and homodyne. taylor2.0 only works for 1; stochastic operator independent of time with the homodyne method.; :func:`~general_stochastic` only accepts the derivative-free; solvers: ``'euler'``, ``'platen'`` and ``'explicit1.5'``. Available solvers for :obj:`~photocurrent_sesolve` and \; :obj:`~photocurrent_mesolve`; Photocurrent use ordinary differential equations between; stochastic ""jump/collapse"". euler; Euler method for ordinary differential equations between jumps.; Only one jump per time interval. Default solver. See eqs. (4.",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:6342,Usability,usab,usable,6342,"d; :obj:`~ssesolve`. See eq. (4.6) of chapter 10.4 of [1]_. - Order strong 1.5; - Code: ``'taylor1.5'``, ``'taylor15'``, ``1.5``, or ``None``. taylor1.5-imp; Order 1.5 implicit strong Taylor scheme. Implicit Taylor 1.5; (:math:`\\alpha = 1/2`, :math:`\\beta` doesn't matter). See eq.; (2.18) of chapter 12.2 of [1]_. - Order strong 1.5; - Code: ``'taylor1.5-imp'`` or ``'taylor15-imp'``. explicit1.5; Explicit order 1.5 strong schemes. Reproduce the order 1.5 strong; Taylor scheme using finite difference instead of derivatives.; Slower than ``taylor15`` but usable by; :func:`~general_stochastic`. See eq. (2.13) of chapter 11.2 of; [1]_. - Order strong 1.5; - Code: ``'explicit1.5'``, ``'explicit15'`` or ``'platen15'``. taylor2.0; Order 2 strong Taylor scheme. Solver with more terms of the; Stratonovich expansion. See eq. (5.2) of chapter 10.5 of [1]_. - Order strong 2.0; - Code: ``'taylor2.0'``, ``'taylor20'`` or ``2.0``. All solvers, except taylor2.0, are usable in both smesolve and ssesolve; and for both heterodyne and homodyne. taylor2.0 only works for 1; stochastic operator independent of time with the homodyne method.; :func:`~general_stochastic` only accepts the derivative-free; solvers: ``'euler'``, ``'platen'`` and ``'explicit1.5'``. Available solvers for :obj:`~photocurrent_sesolve` and \; :obj:`~photocurrent_mesolve`; Photocurrent use ordinary differential equations between; stochastic ""jump/collapse"". euler; Euler method for ordinary differential equations between jumps.; Only one jump per time interval. Default solver. See eqs. (4.19); and (4.4) of chapter 4 of [4]_. - Order 1.0; - Code: ``'euler'``. predictor–corrector; predictor–corrector method (PECE) for ordinary differential; equations. Uses the Poisson distribution to obtain the number of; jumps at each timestep. - Order 2.0; - Code: ``'pred-corr'``. References; ----------; .. [1] Peter E. Kloeden and Exkhard Platen, *Numerical Solution of; Stochastic Differential Equations*.; .. [2] H.-P. Breuer and F.",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/stochastic.html:12306,Usability,progress bar,progress bar,12306,"array of int, or 4D array of float; - int : seed of the noise; - 1D array : length = ntraj, seeds for each trajectories.; - 4D array : ``(ntraj, len(times), nsubsteps, len(sc_ops)*[1|2])``.; Vector for the noise, the len of the last dimensions is doubled for; solvers of order 1.5. This corresponds to results.noise. noiseDepth : int; Number of terms kept of the truncated series used to create the; noise used by taylor2.0 solver. normalize : bool; (default True for (photo)ssesolve, False for (photo)smesolve); Whether or not to normalize the wave function during the evolution.; Normalizing density matrices introduce numerical errors. options : :class:`qutip.solver.Options`; Generic solver options. Only options.average_states and; options.store_states are used. map_func: function; A map function or managing the calls to single-trajactory solvers. map_kwargs: dictionary; Optional keyword arguments to the map_func function function. progress_bar : :class:`qutip.ui.BaseProgressBar`; Optional progress bar class instance.; """"""; def __init__(self, me, H=None, c_ops=[], sc_ops=[], state0=None,; e_ops=[], m_ops=None, store_all_expect=False,; store_measurement=False, dW_factors=None,; solver=None, method=""homodyne"", normalize=None,; times=None, nsubsteps=1, ntraj=1, tol=None,; generate_noise=None, noise=None,; progress_bar=None, map_func=None, map_kwargs=None,; args={}, options=None, noiseDepth=20):. if options is None:; options = Options(). if progress_bar is None:; progress_bar = TextProgressBar(). # System; # Cast to QobjEvo so the code has only one version for both the; # constant and time-dependent case.; self.me = me. if H is not None:; msg = ""The Hamiltonian format is not valid. ""; try:; self.H = QobjEvo(H, args=args, tlist=times,; e_ops=e_ops, state0=state0); except Exception as e:; raise ValueError(msg + str(e)) from e; else:; self.H = H. if sc_ops:; msg = (""The sc_ops format is not valid. Options are ""; ""[ Qobj / QobjEvo / [Qobj, coeff]]. ""); try:; self.sc_ops = [QobjEv",MatchSource.WIKI,docs/4.6/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html
https://qutip.org/docs/4.6/modules/qutip/superoperator.html:11723,Deployability,update,updated,11723,"herm=A.isherm, superrep='super'); S.dims = [[A.dims[0], A.dims[1]], [A.dims[0], A.dims[1]]]; S.data = zcsr_kron(A.data.T,; fast_identity(np.prod(A.shape[0]))); return S. [docs]def spre(A):; """"""Superoperator formed from pre-multiplication by operator A. Parameters; ----------; A : Qobj or QobjEvo; Quantum operator for pre-multiplication. Returns; --------; super :Qobj or QobjEvo; Superoperator formed from input quantum object.; """"""; if isinstance(A, QobjEvo):; return A.apply(spre). if not isinstance(A, Qobj):; raise TypeError('Input is not a quantum object'). if not A.isoper:; raise TypeError('Input is not a quantum operator'). S = Qobj(isherm=A.isherm, superrep='super'); S.dims = [[A.dims[0], A.dims[1]], [A.dims[0], A.dims[1]]]; S.data = zcsr_kron(fast_identity(np.prod(A.shape[1])), A.data); return S. def _drop_projected_dims(dims):; """"""; Eliminate subsystems that has been collapsed to only one state due to; a projection.; """"""; return [d for d in dims if d != 1]. [docs]def sprepost(A, B):; """"""Superoperator formed from pre-multiplication by operator A and post-; multiplication of operator B. Parameters; ----------; A : Qobj or QobjEvo; Quantum operator for pre-multiplication. B : Qobj or QobjEvo; Quantum operator for post-multiplication. Returns; --------; super : Qobj or QobjEvo; Superoperator formed from input quantum objects.; """"""; if isinstance(A, QobjEvo) or isinstance(B, QobjEvo):; return spre(A) * spost(B). else:; dims = [[_drop_projected_dims(A.dims[0]),; _drop_projected_dims(B.dims[1])],; [_drop_projected_dims(A.dims[1]),; _drop_projected_dims(B.dims[0])]]; data = zcsr_kron(B.data.T, A.data); return Qobj(data, dims=dims, superrep='super'). from qutip.qobjevo import QobjEvo. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/superoperator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/superoperator.html
https://qutip.org/docs/4.6/modules/qutip/superoperator.html:2773,Safety,avoid,avoids,2773,"R CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['liouvillian', 'liouvillian_ref', 'lindblad_dissipator',; 'operator_to_vector', 'vector_to_operator', 'mat2vec', 'vec2mat',; 'vec2mat_index', 'mat2vec_index', 'spost', 'spre', 'sprepost']. import scipy.sparse as sp; import numpy as np; from qutip.qobj import Qobj; from qutip.fastsparse import fast_csr_matrix, fast_identity; from qutip.sparse import sp_reshape; from qutip.cy.spmath import zcsr_kron; from functools import partial. [docs]def liouvillian(H, c_ops=[], data_only=False, chi=None):; """"""Assembles the Liouvillian superoperator from a Hamiltonian; and a ``list`` of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters; ----------; H : Qobj or QobjEvo; System Hamiltonian. c_ops : array_like of Qobj or QobjEvo; A ``list`` or ``array`` of collapse operators. Returns; -------; L : Qobj or QobjEvo; Liouvillian superoperator. """"""; if isinstance(c_ops, (Qobj, QobjEvo)):; c_ops = [c_ops]; if chi and len(chi) != len(c_ops):; raise ValueError('chi must be a list with same length as c_ops'). h = None; if H is not None:; if isinstance(H, QobjEvo):; h = H.cte; else:; h = H; if h.isoper:; op_dims = h.dims; op_shape = h.shape; elif h.issuper:; op_dims = h.dims[0]; op_shape = [np.prod(op_dims[0]), np.prod(op_dims[0])]; else:; raise TypeError(""Invalid type for Hamiltonian.""); else:; # no hamiltonian given, pick system size from a collapse operator; if isinstance(c_ops, list) and len(c_ops) > 0:; if isinstance(c_ops[0], QobjEvo):; c = c_ops[0].cte; else:; c = c_ops[0]; if c.isoper:; op_dims = c.dims; op_shape = c.shape; elif c.issup",MatchSource.WIKI,docs/4.6/modules/qutip/superoperator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/superoperator.html
https://qutip.org/docs/4.6/modules/qutip/superop_reps.html:10927,Availability,down,down,10927,"other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims. # We normally should not multiply objects of different; # superreps, so Qobj warns about that. Here, however, we're actively; # converting between, so the superrep of B is irrelevant.; # To suppress warnings, we pretend that B is also a chi.; B.superrep = 'chi'. # The Chi matrix has tr(chi) == d², so we need to divide out; # by that to get back to the Choi form.; return Qobj((B * q_oper * B.dag()) / q_oper.shape[0], superrep='choi'). def _svd_u_to_kraus(U, S, d, dK, indims, outdims):; """"""; Given a partial isometry U and a vector of square-roots of singular values S; obtained from an SVD, produces the Kraus operators represented by U. Returns; -------; Ks : list of Qobj; Quantum objects represnting each of the Kraus operators.; """"""; # We use U * S since S is 1-index, such that this is equivalent to; # U . diag(S), but easier to write down.; Ks = list(map(Qobj, array(U * S).reshape((d, d, dK), order='F').transpose((2, 0, 1)))); for K in Ks:; K.dims = [outdims, indims]; return Ks. def _generalized_kraus(q_oper, thresh=1e-10):; # TODO: document!; # TODO: use this to generalize to_kraus to the case where U != V.; # This is critical for non-CP maps, as appear in (for example); # diamond norm differences between two CP maps.; if q_oper.type != ""super"" or q_oper.superrep != ""choi"":; raise ValueError(""Expected a Choi matrix, got a {} (superrep {})."".format(q_oper.type, q_oper.superrep)). # Remember the shape of the underlying space,; # as we'll need this to make Kraus operators later.; dL, dR = map(int, map(sqrt, q_oper.shape)); # Also remember the dims breakout.; out_dims, in_dims = q_oper.dims; out_left, out_right = out_dims; in_left, in_right = in_dims. # Find the SVD.; U, S, V = svd(q_oper.full()). # Truncate away the zero singular values, up to a threshold.; nonzero_idxs = S > thresh; dK = nonzero_idxs.sum",MatchSource.WIKI,docs/4.6/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/superop_reps.html
https://qutip.org/docs/4.6/modules/qutip/superop_reps.html:18655,Availability,error,errors,18655,"ting an operator in the Kraus decomposition of the given map. Parameters; ----------; q_oper : Qobj; Superoperator to be converted to Kraus representation. If; ``q_oper`` is ``type=""oper""``, then it is taken to act by conjugation,; such that ``to_kraus(A) == to_kraus(sprepost(A, A.dag())) == [A]``. tol : Float; Optional threshold parameter for eigenvalues/Kraus ops to be discarded.; The default is to=1e-9. Returns; -------; kraus_ops : list of Qobj; A list of quantum objects, each representing a Kraus operator in the; decomposition of ``q_oper``. Raises; ------; TypeError: if the given quantum object is not a map, or cannot be; decomposed into Kraus operators.; """"""; if q_oper.type == 'super':; if q_oper.superrep in (""super"", ""chi""):; return to_kraus(to_choi(q_oper), tol); elif q_oper.superrep == 'choi':; return choi_to_kraus(q_oper, tol); elif q_oper.type == 'oper': # Assume unitary; return [q_oper]; else:; raise TypeError(; ""Conversion of Qobj with type = {0.type} ""; ""and superrep = {0.superrep} to Kraus decomposition not ""; ""supported."".format(q_oper); ). [docs]def to_stinespring(q_oper):; r""""""; Converts a Qobj representing a quantum map $\Lambda$ to a pair of partial isometries; $A$ and $B$ such that $\Lambda(X) = \Tr_2(A X B^\dagger)$ for all inputs $X$, where; the partial trace is taken over a a new index on the output dimensions of $A$ and $B$. For completely positive inputs, $A$ will always equal $B$ up to precision errors. Parameters; ----------; q_oper : Qobj; Superoperator to be converted to a Stinespring pair. Returns; -------; A, B : Qobj; Quantum objects representing each of the Stinespring matrices for the input Qobj.; """"""; return choi_to_stinespring(to_choi(q_oper)). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/superop_reps.html
https://qutip.org/docs/4.6/modules/qutip/superop_reps.html:19107,Deployability,update,updated,19107,"ting an operator in the Kraus decomposition of the given map. Parameters; ----------; q_oper : Qobj; Superoperator to be converted to Kraus representation. If; ``q_oper`` is ``type=""oper""``, then it is taken to act by conjugation,; such that ``to_kraus(A) == to_kraus(sprepost(A, A.dag())) == [A]``. tol : Float; Optional threshold parameter for eigenvalues/Kraus ops to be discarded.; The default is to=1e-9. Returns; -------; kraus_ops : list of Qobj; A list of quantum objects, each representing a Kraus operator in the; decomposition of ``q_oper``. Raises; ------; TypeError: if the given quantum object is not a map, or cannot be; decomposed into Kraus operators.; """"""; if q_oper.type == 'super':; if q_oper.superrep in (""super"", ""chi""):; return to_kraus(to_choi(q_oper), tol); elif q_oper.superrep == 'choi':; return choi_to_kraus(q_oper, tol); elif q_oper.type == 'oper': # Assume unitary; return [q_oper]; else:; raise TypeError(; ""Conversion of Qobj with type = {0.type} ""; ""and superrep = {0.superrep} to Kraus decomposition not ""; ""supported."".format(q_oper); ). [docs]def to_stinespring(q_oper):; r""""""; Converts a Qobj representing a quantum map $\Lambda$ to a pair of partial isometries; $A$ and $B$ such that $\Lambda(X) = \Tr_2(A X B^\dagger)$ for all inputs $X$, where; the partial trace is taken over a a new index on the output dimensions of $A$ and $B$. For completely positive inputs, $A$ will always equal $B$ up to precision errors. Parameters; ----------; q_oper : Qobj; Superoperator to be converted to a Stinespring pair. Returns; -------; A, B : Qobj; Quantum objects representing each of the Stinespring matrices for the input Qobj.; """"""; return choi_to_stinespring(to_choi(q_oper)). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/superop_reps.html
https://qutip.org/docs/4.6/modules/qutip/superop_reps.html:6031,Energy Efficiency,power,powers,6031,"main work of converting between representations,; # and are exposed below by other functions that add postconditions about types.; #; # TODO: handle type='kraus' as a three-index Qobj, rather than as a list?. def _super_tofrom_choi(q_oper):; """"""; We exploit that the basis transformation between Choi and supermatrix; representations squares to the identity, so that if we munge Qobj.type,; we can use the same function. Since this function doesn't respect :attr:`Qobj.type`, we mark it as; private; only those functions which wrap this in a way so as to preserve; type should be called externally.; """"""; data = q_oper.data.toarray(); dims = q_oper.dims; new_dims = [[dims[1][1], dims[0][1]], [dims[1][0], dims[0][0]]]; d0 = np.prod(np.ravel(new_dims[0])); d1 = np.prod(np.ravel(new_dims[1])); s0 = np.prod(dims[0][0]); s1 = np.prod(dims[1][1]); return Qobj(dims=new_dims,; inpt=data.reshape([s0, s1, s0, s1]).; transpose(3, 1, 2, 0).reshape((d0, d1))). def _isqubitdims(dims):; """"""Checks whether all entries in a dims list are integer powers of 2. Parameters; ----------; dims : nested list of ints; Dimensions to be checked. Returns; -------; isqubitdims : bool; True if and only if every member of the flattened dims; list is an integer power of 2.; """"""; return all([; 2**floor(log2(dim)) == dim; for dim in flatten(dims); ]). def _super_to_superpauli(q_oper):; """"""; Converts a superoperator in the column-stacking basis to; the Pauli basis (assuming qubit dimensions). This is an internal function, as QuTiP does not currently have; a way to mark that superoperators are represented in the Pauli; basis as opposed to the column-stacking basis; a Pauli-basis; ``type='super'`` would thus break other conversion functions.; """"""; # Ensure we start with a column-stacking-basis superoperator.; sqobj = to_super(q_oper); if not _isqubitdims(sqobj.dims):; raise ValueError(""Pauli basis is only defined for qubits.""); nq = int(log2(sqobj.shape[0]) / 2); B = _pauli_basis(nq) / sqrt(2**nq); # To do this, ",MatchSource.WIKI,docs/4.6/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/superop_reps.html
https://qutip.org/docs/4.6/modules/qutip/superop_reps.html:6235,Energy Efficiency,power,power,6235,"her than as a list?. def _super_tofrom_choi(q_oper):; """"""; We exploit that the basis transformation between Choi and supermatrix; representations squares to the identity, so that if we munge Qobj.type,; we can use the same function. Since this function doesn't respect :attr:`Qobj.type`, we mark it as; private; only those functions which wrap this in a way so as to preserve; type should be called externally.; """"""; data = q_oper.data.toarray(); dims = q_oper.dims; new_dims = [[dims[1][1], dims[0][1]], [dims[1][0], dims[0][0]]]; d0 = np.prod(np.ravel(new_dims[0])); d1 = np.prod(np.ravel(new_dims[1])); s0 = np.prod(dims[0][0]); s1 = np.prod(dims[1][1]); return Qobj(dims=new_dims,; inpt=data.reshape([s0, s1, s0, s1]).; transpose(3, 1, 2, 0).reshape((d0, d1))). def _isqubitdims(dims):; """"""Checks whether all entries in a dims list are integer powers of 2. Parameters; ----------; dims : nested list of ints; Dimensions to be checked. Returns; -------; isqubitdims : bool; True if and only if every member of the flattened dims; list is an integer power of 2.; """"""; return all([; 2**floor(log2(dim)) == dim; for dim in flatten(dims); ]). def _super_to_superpauli(q_oper):; """"""; Converts a superoperator in the column-stacking basis to; the Pauli basis (assuming qubit dimensions). This is an internal function, as QuTiP does not currently have; a way to mark that superoperators are represented in the Pauli; basis as opposed to the column-stacking basis; a Pauli-basis; ``type='super'`` would thus break other conversion functions.; """"""; # Ensure we start with a column-stacking-basis superoperator.; sqobj = to_super(q_oper); if not _isqubitdims(sqobj.dims):; raise ValueError(""Pauli basis is only defined for qubits.""); nq = int(log2(sqobj.shape[0]) / 2); B = _pauli_basis(nq) / sqrt(2**nq); # To do this, we have to hack a bit and force the dims to match,; # since the _pauli_basis function makes different assumptions; # about indices than we need here.; B.dims = sqobj.dims; return (B.dag() ",MatchSource.WIKI,docs/4.6/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/superop_reps.html
https://qutip.org/docs/4.6/modules/qutip/superop_reps.html:9283,Energy Efficiency,power,power,9283,"or i in range(2)][::-1]; return [Qobj(inpt=sqrt(val)*vec2mat(vec, shape=shape),; dims=q_oper.dims[0][::-1]); for val, vec in zip(vals, vecs) if abs(val) >= tol]. [docs]def kraus_to_choi(kraus_list):; """"""; Takes a list of Kraus operators and returns the Choi matrix for the channel; represented by the Kraus operators in `kraus_list`; """"""; kraus_mat_list = list(map(lambda x: x.data.toarray(), kraus_list)); op_rng = range(kraus_mat_list[0].shape[0]); choi_blocks = array([[sum([; np.outer(op[:, c_ix],; np.transpose(np.conjugate(op))[r_ix, :]); for op in kraus_mat_list]); for r_ix in op_rng]; for c_ix in op_rng]); return Qobj(inpt=hstack(hstack(choi_blocks)),; dims=[kraus_list[0].dims[::-1], kraus_list[0].dims[::-1]],; type='super', superrep='choi'). [docs]def kraus_to_super(kraus_list):; """"""; Converts a list of Kraus operators and returns a super operator.; """"""; return choi_to_super(kraus_to_choi(kraus_list)). def _nq(dims):; dim = np.product(dims[0][0]); nq = int(log2(dim)); if 2 ** nq != dim:; raise ValueError(""{} is not an integer power of 2."".format(dim)); return nq. [docs]def choi_to_chi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims; B.superrep = 'choi'. return Qobj(B.dag() * q_oper * B, superrep='chi'). [docs]def chi_to_choi(q_oper):; """"""; Converts a Chi matrix to a Choi matrix. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims. # We normally should not multiply objects of different; # superreps, so Qobj warns about that. Here, however, we're actively; # converting between, so the s",MatchSource.WIKI,docs/4.6/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/superop_reps.html
https://qutip.org/docs/4.6/modules/qutip/superop_reps.html:5522,Integrability,wrap,wrap,5522,"s slow as can be.; # TODO: Make this sparse. CSR format was causing problems for the [idx, :]; # slicing below.; B = zeros((4 ** nq, 4 ** nq), dtype=complex); dims = [[[2] * nq] * 2] * 2. for idx, op in enumerate(starmap(tensor,; product(_SINGLE_QUBIT_PAULI_BASIS,; repeat=nq))):; B[:, idx] = operator_to_vector(op).dag().full(). return Qobj(B, dims=dims). # PRIVATE CONVERSION FUNCTIONS ------------------------------------------------; # These functions handle the main work of converting between representations,; # and are exposed below by other functions that add postconditions about types.; #; # TODO: handle type='kraus' as a three-index Qobj, rather than as a list?. def _super_tofrom_choi(q_oper):; """"""; We exploit that the basis transformation between Choi and supermatrix; representations squares to the identity, so that if we munge Qobj.type,; we can use the same function. Since this function doesn't respect :attr:`Qobj.type`, we mark it as; private; only those functions which wrap this in a way so as to preserve; type should be called externally.; """"""; data = q_oper.data.toarray(); dims = q_oper.dims; new_dims = [[dims[1][1], dims[0][1]], [dims[1][0], dims[0][0]]]; d0 = np.prod(np.ravel(new_dims[0])); d1 = np.prod(np.ravel(new_dims[1])); s0 = np.prod(dims[0][0]); s1 = np.prod(dims[1][1]); return Qobj(dims=new_dims,; inpt=data.reshape([s0, s1, s0, s1]).; transpose(3, 1, 2, 0).reshape((d0, d1))). def _isqubitdims(dims):; """"""Checks whether all entries in a dims list are integer powers of 2. Parameters; ----------; dims : nested list of ints; Dimensions to be checked. Returns; -------; isqubitdims : bool; True if and only if every member of the flattened dims; list is an integer power of 2.; """"""; return all([; 2**floor(log2(dim)) == dim; for dim in flatten(dims); ]). def _super_to_superpauli(q_oper):; """"""; Converts a superoperator in the column-stacking basis to; the Pauli basis (assuming qubit dimensions). This is an internal function, as QuTiP does not currently hav",MatchSource.WIKI,docs/4.6/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/superop_reps.html
https://qutip.org/docs/4.6/modules/qutip/superop_reps.html:9476,Modifiability,extend,extend,9476,"ix for the channel; represented by the Kraus operators in `kraus_list`; """"""; kraus_mat_list = list(map(lambda x: x.data.toarray(), kraus_list)); op_rng = range(kraus_mat_list[0].shape[0]); choi_blocks = array([[sum([; np.outer(op[:, c_ix],; np.transpose(np.conjugate(op))[r_ix, :]); for op in kraus_mat_list]); for r_ix in op_rng]; for c_ix in op_rng]); return Qobj(inpt=hstack(hstack(choi_blocks)),; dims=[kraus_list[0].dims[::-1], kraus_list[0].dims[::-1]],; type='super', superrep='choi'). [docs]def kraus_to_super(kraus_list):; """"""; Converts a list of Kraus operators and returns a super operator.; """"""; return choi_to_super(kraus_to_choi(kraus_list)). def _nq(dims):; dim = np.product(dims[0][0]); nq = int(log2(dim)); if 2 ** nq != dim:; raise ValueError(""{} is not an integer power of 2."".format(dim)); return nq. [docs]def choi_to_chi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims; B.superrep = 'choi'. return Qobj(B.dag() * q_oper * B, superrep='chi'). [docs]def chi_to_choi(q_oper):; """"""; Converts a Chi matrix to a Choi matrix. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims. # We normally should not multiply objects of different; # superreps, so Qobj warns about that. Here, however, we're actively; # converting between, so the superrep of B is irrelevant.; # To suppress warnings, we pretend that B is also a chi.; B.superrep = 'chi'. # The Chi matrix has tr(chi) == d², so we need to divide out; # by that to get back to the Choi form.; return Qobj((B * q_oper * B.dag()) / q_oper.shape[0],",MatchSource.WIKI,docs/4.6/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/superop_reps.html
https://qutip.org/docs/4.6/modules/qutip/superop_reps.html:9883,Modifiability,extend,extend,9883,"kraus_list[0].dims[::-1], kraus_list[0].dims[::-1]],; type='super', superrep='choi'). [docs]def kraus_to_super(kraus_list):; """"""; Converts a list of Kraus operators and returns a super operator.; """"""; return choi_to_super(kraus_to_choi(kraus_list)). def _nq(dims):; dim = np.product(dims[0][0]); nq = int(log2(dim)); if 2 ** nq != dim:; raise ValueError(""{} is not an integer power of 2."".format(dim)); return nq. [docs]def choi_to_chi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims; B.superrep = 'choi'. return Qobj(B.dag() * q_oper * B, superrep='chi'). [docs]def chi_to_choi(q_oper):; """"""; Converts a Chi matrix to a Choi matrix. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims. # We normally should not multiply objects of different; # superreps, so Qobj warns about that. Here, however, we're actively; # converting between, so the superrep of B is irrelevant.; # To suppress warnings, we pretend that B is also a chi.; B.superrep = 'chi'. # The Chi matrix has tr(chi) == d², so we need to divide out; # by that to get back to the Choi form.; return Qobj((B * q_oper * B.dag()) / q_oper.shape[0], superrep='choi'). def _svd_u_to_kraus(U, S, d, dK, indims, outdims):; """"""; Given a partial isometry U and a vector of square-roots of singular values S; obtained from an SVD, produces the Kraus operators represented by U. Returns; -------; Ks : list of Qobj; Quantum objects represnting each of the Kraus operators.; """"""; # We use U * S since S is 1-index, such that this is equivalent to; # U . diag(S), b",MatchSource.WIKI,docs/4.6/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/superop_reps.html
https://qutip.org/docs/4.6/modules/qutip/superop_reps.html:2865,Safety,avoid,avoid,2865,"RACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; #; # This module was initially contributed by Ben Criger.; #; """"""; This module implements transformations between superoperator representations,; including supermatrix, Kraus, Choi and Chi (process) matrix formalisms.; """""". __all__ = ['super_to_choi', 'choi_to_super', 'choi_to_kraus', 'kraus_to_choi',; 'kraus_to_super', 'choi_to_chi', 'chi_to_choi', 'to_choi',; 'to_chi', 'to_super', 'to_kraus', 'to_stinespring'; ]. # Python Standard Library; from itertools import starmap, product. # NumPy/SciPy; from numpy.core.multiarray import array, zeros; from numpy.core.shape_base import hstack; from numpy.matrixlib.defmatrix import matrix; from numpy import sqrt, floor, log2; from numpy import dot; from scipy.linalg import eig, svd; # Needed to avoid conflict with itertools.product.; import numpy as np. # Other QuTiP functions and classes; from qutip.superoperator import vec2mat, operator_to_vector, sprepost; from qutip.operators import identity, sigmax, sigmay, sigmaz; from qutip.tensor import tensor, flatten; from qutip.qobj import Qobj; from qutip.states import basis. # SPECIFIC SUPEROPERATORS -----------------------------------------------------. def _dep_super(pe):; """"""; Returns the superoperator corresponding to qubit depolarization for a; given parameter pe. TODO: if this is going into production (hopefully it isn't) then check; CPTP, expand to arbitrary dimensional systems, etc.; """"""; return Qobj(dims=[[[2], [2]], [[2], [2]]],; inpt=array([[1. - pe / 2., 0., 0., pe / 2.],; [0., 1. - pe, 0., 0.],; [0., 0., 1. - pe, 0.],; [pe / 2., 0., 0., 1. - pe / 2.]])). def _dep_choi(pe):; """"""; Returns the choi matrix corresponding to qubit depolarization for a; given parameter pe. TODO: if this is going into production (hopefull",MatchSource.WIKI,docs/4.6/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/superop_reps.html
https://qutip.org/docs/4.6/modules/qutip/superop_reps.html:5055,Security,expose,exposed,5055,"- pe / 2., 0., 0., 1. - pe],; [0., pe / 2., 0., 0.],; [0., 0., pe / 2., 0.],; [1. - pe, 0., 0., 1. - pe / 2.]]),; superrep='choi'). # CHANGE OF BASIS FUNCTIONS ---------------------------------------------------; # These functions find change of basis matrices, and are useful in converting; # between (for instance) Choi and chi matrices. At some point, these should; # probably be moved out to another module. _SINGLE_QUBIT_PAULI_BASIS = (identity(2), sigmax(), sigmay(), sigmaz()). def _pauli_basis(nq=1):; # NOTE: This is slow as can be.; # TODO: Make this sparse. CSR format was causing problems for the [idx, :]; # slicing below.; B = zeros((4 ** nq, 4 ** nq), dtype=complex); dims = [[[2] * nq] * 2] * 2. for idx, op in enumerate(starmap(tensor,; product(_SINGLE_QUBIT_PAULI_BASIS,; repeat=nq))):; B[:, idx] = operator_to_vector(op).dag().full(). return Qobj(B, dims=dims). # PRIVATE CONVERSION FUNCTIONS ------------------------------------------------; # These functions handle the main work of converting between representations,; # and are exposed below by other functions that add postconditions about types.; #; # TODO: handle type='kraus' as a three-index Qobj, rather than as a list?. def _super_tofrom_choi(q_oper):; """"""; We exploit that the basis transformation between Choi and supermatrix; representations squares to the identity, so that if we munge Qobj.type,; we can use the same function. Since this function doesn't respect :attr:`Qobj.type`, we mark it as; private; only those functions which wrap this in a way so as to preserve; type should be called externally.; """"""; data = q_oper.data.toarray(); dims = q_oper.dims; new_dims = [[dims[1][1], dims[0][1]], [dims[1][0], dims[0][0]]]; d0 = np.prod(np.ravel(new_dims[0])); d1 = np.prod(np.ravel(new_dims[1])); s0 = np.prod(dims[0][0]); s1 = np.prod(dims[1][1]); return Qobj(dims=new_dims,; inpt=data.reshape([s0, s1, s0, s1]).; transpose(3, 1, 2, 0).reshape((d0, d1))). def _isqubitdims(dims):; """"""Checks whether all entries ",MatchSource.WIKI,docs/4.6/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/superop_reps.html
https://qutip.org/docs/4.6/modules/qutip/superop_reps.html:12569,Testability,assert,assert,12569,"p(int, map(sqrt, q_oper.shape)); # Also remember the dims breakout.; out_dims, in_dims = q_oper.dims; out_left, out_right = out_dims; in_left, in_right = in_dims. # Find the SVD.; U, S, V = svd(q_oper.full()). # Truncate away the zero singular values, up to a threshold.; nonzero_idxs = S > thresh; dK = nonzero_idxs.sum(); U = U[:, nonzero_idxs]; S = sqrt(S[nonzero_idxs]); # Since NumPy returns V and not V+, we need to take the dagger; # to get back to quantum info notation for Stinespring pairs.; V = V.conj().T[:, nonzero_idxs]. # Next, we convert each of U and V into Kraus operators.; # Finally, we want the Kraus index to be left-most so that we; # can map over it when making Qobjs.; # FIXME: does not preserve dims!; kU = _svd_u_to_kraus(U, S, dL, dK, out_right, out_left); kV = _svd_u_to_kraus(V, S, dL, dK, in_right, in_left). return kU, kV. def choi_to_stinespring(q_oper, thresh=1e-10):; # TODO: document!; kU, kV = _generalized_kraus(q_oper, thresh=thresh). assert(len(kU) == len(kV)); dK = len(kU); dL = kU[0].shape[0]; dR = kV[0].shape[1]; # Also remember the dims breakout.; out_dims, in_dims = q_oper.dims; out_left, out_right = out_dims; in_left, in_right = in_dims. A = Qobj(zeros((dK * dL, dL)), dims=[out_left + [dK], out_right + [1]]); B = Qobj(zeros((dK * dR, dR)), dims=[in_left + [dK], in_right + [1]]). for idx_kraus, (KL, KR) in enumerate(zip(kU, kV)):; A += tensor(KL, basis(dK, idx_kraus)); B += tensor(KR, basis(dK, idx_kraus)). # There is no input (right) Kraus index, so strip that off.; del A.dims[1][-1]; del B.dims[1][-1]. return A, B. # PUBLIC CONVERSION FUNCTIONS -------------------------------------------------; # These functions handle superoperator conversions in a way that preserves the; # correctness of Qobj.type, and in a way that automatically branches based on; # the input Qobj.type. [docs]def to_choi(q_oper):; """"""; Converts a Qobj representing a quantum map to the Choi representation,; such that the trace of the returned operator is equal to t",MatchSource.WIKI,docs/4.6/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/superop_reps.html
https://qutip.org/docs/4.6/modules/qutip/tensor.html:3755,Availability,error,error,3755,"rgs : array_like; ``list`` or ``array`` of quantum objects for tensor product. Returns; -------; obj : qobj; A composite quantum object. Examples; --------; >>> tensor([sigmax(), sigmax()]) # doctest: +SKIP; Quantum object: dims = [[2, 2], [2, 2]], \; shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]; """""". if not args:; raise TypeError(""Requires at least one input argument""). if len(args) == 1 and isinstance(args[0], (list, np.ndarray)):; # this is the case when tensor is called on the form:; # tensor([q1, q2, q3, ...]); qlist = args[0]. elif len(args) == 1 and isinstance(args[0], Qobj):; # tensor is called with a single Qobj as an argument, do nothing; return args[0]. else:; # this is the case when tensor is called on the form:; # tensor(q1, q2, q3, ...); qlist = args. if not all([isinstance(q, Qobj) for q in qlist]):; # raise error if one of the inputs is not a quantum object; raise TypeError(""One of inputs is not a quantum object""). out = Qobj(). if qlist[0].issuper:; out.superrep = qlist[0].superrep; if not all([q.superrep == out.superrep for q in qlist]):; raise TypeError(""In tensor products of superroperators, all must"" +; ""have the same representation""). out.isherm = True; for n, q in enumerate(qlist):; if n == 0:; out.data = q.data; out.dims = q.dims; else:; out.data = zcsr_kron(out.data, q.data). out.dims = [out.dims[0] + q.dims[0], out.dims[1] + q.dims[1]]. out.isherm = out.isherm and q.isherm. if not out.isherm:; out._isherm = None. return out.tidyup() if qutip.settings.auto_tidyup else out. [docs]def super_tensor(*args):; """"""Calculates the tensor product of input superoperators, by tensoring; together the underlying Hilbert spaces on which each vectorized operator; acts. Parameters; ----------; args : array_like; ``list`` or ``array`` of quantum objects with ``type=""super""``. Returns; -------; obj : qobj; A composite quan",MatchSource.WIKI,docs/4.6/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/tensor.html
https://qutip.org/docs/4.6/modules/qutip/tensor.html:12042,Deployability,update,updated,12042,"ot* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); tensor_dims = dims_to_tensor_shape(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(tensor_dims). # Contract out the indices from the flattened object.; # Note that we need to feed pairs through dims_idxs_to_tensor_idxs; # to ensure that we are contracting the right indices.; qtens = _tensor_contract_dense(qtens, *dims_idxs_to_tensor_idxs(dims, pairs)). # Remove the contracted indexes from dims so we know how to; # reshape back.; # This concerns dims, and not the tensor indices, so we need; # to make sure to use the original dims indices and not the ones; # generated by dims_to_* functions.; contracted_idxs = deep_remove(dims_idxs, *flatten(list(map(list, pairs)))); contracted_dims = unflatten(flatten(dims), contracted_idxs). # We don't need to check for tensor idxs versus dims idxs here,; # as column- versus row-stacking will never move an index for the; # vectorized operator spaces all the way from the left to the right.; l_mtx_dims, r_mtx_dims = map(np.product, map(flatten, contracted_dims)). # Reshape back into a 2D matrix.; qmtx = qtens.reshape((l_mtx_dims, r_mtx_dims)). # Return back as a qobj.; return Qobj(qmtx, dims=contracted_dims, superrep=qobj.superrep). import qutip.states. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/tensor.html
https://qutip.org/docs/4.6/modules/qutip/tensor.html:2658,Integrability,depend,dependency,2658,"OCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; Module for the creation of composite quantum objects via the tensor product.; """""". __all__ = [; 'tensor', 'super_tensor', 'composite', 'tensor_swap', 'tensor_contract'; ]. import numpy as np; import scipy.sparse as sp; from qutip.cy.spmath import zcsr_kron; from qutip.qobj import Qobj; from qutip.permute import reshuffle; from qutip.superoperator import operator_to_vector; from qutip.dimensions import (; flatten, enumerate_flat, unflatten, deep_remove,; dims_to_tensor_shape, dims_idxs_to_tensor_idxs; ). import qutip.settings; import qutip.superop_reps # Avoid circular dependency here. [docs]def tensor(*args):; """"""Calculates the tensor product of input operators. Parameters; ----------; args : array_like; ``list`` or ``array`` of quantum objects for tensor product. Returns; -------; obj : qobj; A composite quantum object. Examples; --------; >>> tensor([sigmax(), sigmax()]) # doctest: +SKIP; Quantum object: dims = [[2, 2], [2, 2]], \; shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]; """""". if not args:; raise TypeError(""Requires at least one input argument""). if len(args) == 1 and isinstance(args[0], (list, np.ndarray)):; # this is the case when tensor is called on the form:; # tensor([q1, q2, q3, ...]); qlist = args[0]. elif len(args) == 1 and isinstance(args[0], Qobj):; # tensor is called with a single Qobj as an argument, do nothing; return args[0]. else:; # this is the case when tensor is called on the for",MatchSource.WIKI,docs/4.6/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/tensor.html
https://qutip.org/docs/4.6/modules/qutip/tensor.html:8070,Integrability,contract,contract,8070,"e already type=super, while it will; # promote unitaries to superunitaries.; return super_tensor(*map(qutip.superop_reps.to_super, args)). else:; # Everything's just an oper, so ordinary tensor products work.; return tensor(*args). elif all(map(_isketlike, args)):; # Ket-likes.; if any(arg.isoperket for arg in args):; # We have a vectorized operator, we we may need to promote; # something.; return super_tensor(*(; arg if arg.isoperket; else operator_to_vector(qutip.states.ket2dm(arg)); for arg in args; )). else:; # Everything's ordinary, so we can use the tensor product here.; return tensor(*args). elif all(map(_isbralike, args)):; # Turn into ket-likes and recurse.; return composite(*(arg.dag() for arg in args)).dag(). else:; raise TypeError(""Unsupported Qobj types [{}]."".format(; "", "".join(arg.type for arg in args); )). def _tensor_contract_single(arr, i, j):; """"""; Contracts a dense tensor along a single index pair.; """"""; if arr.shape[i] != arr.shape[j]:; raise ValueError(""Cannot contract over indices of different length.""); idxs = np.arange(arr.shape[i]); sl = tuple(slice(None, None, None); if idx not in (i, j) else idxs for idx in range(arr.ndim)); contract_at = i if j == i + 1 else 0; return np.sum(arr[sl], axis=contract_at). def _tensor_contract_dense(arr, *pairs):; """"""; Contracts a dense tensor along one or more index pairs,; keeping track of how the indices are relabeled by the removal; of other indices.; """"""; axis_idxs = list(range(arr.ndim)); for pair in pairs:; # axis_idxs.index effectively evaluates the mapping from; # original index labels to the labels after contraction.; arr = _tensor_contract_single(arr, *map(axis_idxs.index, pair)); list(map(axis_idxs.remove, pair)); return arr. def tensor_swap(q_oper, *pairs):; """"""Transposes one or more pairs of indices of a Qobj.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; `",MatchSource.WIKI,docs/4.6/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/tensor.html
https://qutip.org/docs/4.6/modules/qutip/tensor.html:8672,Integrability,contract,contraction,8672,"e tensor product here.; return tensor(*args). elif all(map(_isbralike, args)):; # Turn into ket-likes and recurse.; return composite(*(arg.dag() for arg in args)).dag(). else:; raise TypeError(""Unsupported Qobj types [{}]."".format(; "", "".join(arg.type for arg in args); )). def _tensor_contract_single(arr, i, j):; """"""; Contracts a dense tensor along a single index pair.; """"""; if arr.shape[i] != arr.shape[j]:; raise ValueError(""Cannot contract over indices of different length.""); idxs = np.arange(arr.shape[i]); sl = tuple(slice(None, None, None); if idx not in (i, j) else idxs for idx in range(arr.ndim)); contract_at = i if j == i + 1 else 0; return np.sum(arr[sl], axis=contract_at). def _tensor_contract_dense(arr, *pairs):; """"""; Contracts a dense tensor along one or more index pairs,; keeping track of how the indices are relabeled by the removal; of other indices.; """"""; axis_idxs = list(range(arr.ndim)); for pair in pairs:; # axis_idxs.index effectively evaluates the mapping from; # original index labels to the labels after contraction.; arr = _tensor_contract_single(arr, *map(axis_idxs.index, pair)); list(map(axis_idxs.remove, pair)); return arr. def tensor_swap(q_oper, *pairs):; """"""Transposes one or more pairs of indices of a Qobj.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be swapped. Returns; -------. sqobj : Qobj; The original Qobj with all named index pairs swapped with each other; """"""; dims = q_oper.dims; tensor_pairs = dims_idxs_to_tensor_idxs(dims, pairs). data = q_oper.data.toarray(). # Reshape into tensor indices; data = data.reshape(dims_to_tensor_shape(dims)). # Now permute the dims list so we know how to get back.; flat_dims = flatten(dims); perm = list(range(len(flat_dims))); for i, j in pairs:; flat_dims[i], flat_dims[j] = flat_dims[j], flat_dims[i]; for i",MatchSource.WIKI,docs/4.6/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/tensor.html
https://qutip.org/docs/4.6/modules/qutip/tensor.html:10326,Integrability,contract,contracted,10326,"ensor_pairs = dims_idxs_to_tensor_idxs(dims, pairs). data = q_oper.data.toarray(). # Reshape into tensor indices; data = data.reshape(dims_to_tensor_shape(dims)). # Now permute the dims list so we know how to get back.; flat_dims = flatten(dims); perm = list(range(len(flat_dims))); for i, j in pairs:; flat_dims[i], flat_dims[j] = flat_dims[j], flat_dims[i]; for i, j in tensor_pairs:; perm[i], perm[j] = perm[j], perm[i]; dims = unflatten(flat_dims, enumerate_flat(dims)). # Next, permute the actual indices of the dense tensor.; data = data.transpose(perm). # Reshape back, using the left and right of dims.; data = data.reshape(list(map(np.prod, dims))). return Qobj(inpt=data, dims=dims, superrep=q_oper.superrep). [docs]def tensor_contract(qobj, *pairs):; """"""Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); tensor_dims = dims_to_tensor_shape(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(tensor_dims). # Contract out the indices from the flattened object.; # Note that we need to feed pairs through dims_idxs_to_tensor_idxs; # to ensure that we are contracting the right indices.; qtens = _tensor_contract_dense(qtens, *dims_idxs_to_tensor_idxs(dims, pairs)). # Remove the contracted indexes from dims so we know how to; # reshape back.; # This concerns dims, and not the tensor indices, so we need; # to make sure to use the original dims indices and not the ones; # generated by dims_to_* functions.; contracted_idxs = dee",MatchSource.WIKI,docs/4.6/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/tensor.html
https://qutip.org/docs/4.6/modules/qutip/tensor.html:10415,Integrability,contract,contracted,10415,".reshape(dims_to_tensor_shape(dims)). # Now permute the dims list so we know how to get back.; flat_dims = flatten(dims); perm = list(range(len(flat_dims))); for i, j in pairs:; flat_dims[i], flat_dims[j] = flat_dims[j], flat_dims[i]; for i, j in tensor_pairs:; perm[i], perm[j] = perm[j], perm[i]; dims = unflatten(flat_dims, enumerate_flat(dims)). # Next, permute the actual indices of the dense tensor.; data = data.transpose(perm). # Reshape back, using the left and right of dims.; data = data.reshape(list(map(np.prod, dims))). return Qobj(inpt=data, dims=dims, superrep=q_oper.superrep). [docs]def tensor_contract(qobj, *pairs):; """"""Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); tensor_dims = dims_to_tensor_shape(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(tensor_dims). # Contract out the indices from the flattened object.; # Note that we need to feed pairs through dims_idxs_to_tensor_idxs; # to ensure that we are contracting the right indices.; qtens = _tensor_contract_dense(qtens, *dims_idxs_to_tensor_idxs(dims, pairs)). # Remove the contracted indexes from dims so we know how to; # reshape back.; # This concerns dims, and not the tensor indices, so we need; # to make sure to use the original dims indices and not the ones; # generated by dims_to_* functions.; contracted_idxs = deep_remove(dims_idxs, *flatten(list(map(list, pairs)))); contracted_dims = unflatten(flatten(dims), contracted_idxs). # We don'",MatchSource.WIKI,docs/4.6/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/tensor.html
https://qutip.org/docs/4.6/modules/qutip/tensor.html:10894,Integrability,contract,contracting,10894,"d right of dims.; data = data.reshape(list(map(np.prod, dims))). return Qobj(inpt=data, dims=dims, superrep=q_oper.superrep). [docs]def tensor_contract(qobj, *pairs):; """"""Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); tensor_dims = dims_to_tensor_shape(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(tensor_dims). # Contract out the indices from the flattened object.; # Note that we need to feed pairs through dims_idxs_to_tensor_idxs; # to ensure that we are contracting the right indices.; qtens = _tensor_contract_dense(qtens, *dims_idxs_to_tensor_idxs(dims, pairs)). # Remove the contracted indexes from dims so we know how to; # reshape back.; # This concerns dims, and not the tensor indices, so we need; # to make sure to use the original dims indices and not the ones; # generated by dims_to_* functions.; contracted_idxs = deep_remove(dims_idxs, *flatten(list(map(list, pairs)))); contracted_dims = unflatten(flatten(dims), contracted_idxs). # We don't need to check for tensor idxs versus dims idxs here,; # as column- versus row-stacking will never move an index for the; # vectorized operator spaces all the way from the left to the right.; l_mtx_dims, r_mtx_dims = map(np.product, map(flatten, contracted_dims)). # Reshape back into a 2D matrix.; qmtx = qtens.reshape((l_mtx_dims, r_mtx_dims)). # Return back as a qobj.; return Qobj(qmtx, dims=contracted_dims, superrep=qobj.superrep). import qutip.states. © Copyri",MatchSource.WIKI,docs/4.6/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/tensor.html
https://qutip.org/docs/4.6/modules/qutip/tensor.html:11018,Integrability,contract,contracted,11018," a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); tensor_dims = dims_to_tensor_shape(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(tensor_dims). # Contract out the indices from the flattened object.; # Note that we need to feed pairs through dims_idxs_to_tensor_idxs; # to ensure that we are contracting the right indices.; qtens = _tensor_contract_dense(qtens, *dims_idxs_to_tensor_idxs(dims, pairs)). # Remove the contracted indexes from dims so we know how to; # reshape back.; # This concerns dims, and not the tensor indices, so we need; # to make sure to use the original dims indices and not the ones; # generated by dims_to_* functions.; contracted_idxs = deep_remove(dims_idxs, *flatten(list(map(list, pairs)))); contracted_dims = unflatten(flatten(dims), contracted_idxs). # We don't need to check for tensor idxs versus dims idxs here,; # as column- versus row-stacking will never move an index for the; # vectorized operator spaces all the way from the left to the right.; l_mtx_dims, r_mtx_dims = map(np.product, map(flatten, contracted_dims)). # Reshape back into a 2D matrix.; qmtx = qtens.reshape((l_mtx_dims, r_mtx_dims)). # Return back as a qobj.; return Qobj(qmtx, dims=contracted_dims, superrep=qobj.superrep). import qutip.states. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last u",MatchSource.WIKI,docs/4.6/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/tensor.html
https://qutip.org/docs/4.6/modules/qutip/three_level_atom.html:2396,Deployability,configurat,configuration,2396,"ING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; r'''; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. import numpy as np; from qutip.states import qutrit_basis. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():; ''' ",MatchSource.WIKI,docs/4.6/modules/qutip/three_level_atom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/three_level_atom.html
https://qutip.org/docs/4.6/modules/qutip/three_level_atom.html:2485,Deployability,configurat,configurations,2485,"ARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; r'''; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. import numpy as np; from qutip.states import qutrit_basis. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():; ''' Operators for a three level system (qutrit). Returns; --------; ops : array; `array` of thre",MatchSource.WIKI,docs/4.6/modules/qutip/three_level_atom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/three_level_atom.html
https://qutip.org/docs/4.6/modules/qutip/three_level_atom.html:4089,Deployability,update,updated,4089,"el atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. import numpy as np; from qutip.states import qutrit_basis. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():; ''' Operators for a three level system (qutrit). Returns; --------; ops : array; `array` of three level operators. '''; out = np.empty((5,), dtype=object); one, two, three = qutrit_basis(); # Note that the three level operators are different; # from the qutrit operators. A three level atom only; # has transitions 1 <-> 2 <-> 3, so we define the; # operators seperately from the qutrit code; out[0] = one * one.dag(); out[1] = two * two.dag(); out[2] = three * three.dag(); out[3] = one * two.dag(); out[4] = three * two.dag(); return out. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/three_level_atom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/three_level_atom.html
https://qutip.org/docs/4.6/modules/qutip/three_level_atom.html:2396,Modifiability,config,configuration,2396,"ING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; r'''; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. import numpy as np; from qutip.states import qutrit_basis. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():; ''' ",MatchSource.WIKI,docs/4.6/modules/qutip/three_level_atom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/three_level_atom.html
https://qutip.org/docs/4.6/modules/qutip/three_level_atom.html:2485,Modifiability,config,configurations,2485,"ARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; r'''; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. import numpy as np; from qutip.states import qutrit_basis. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():; ''' Operators for a three level system (qutrit). Returns; --------; ops : array; `array` of thre",MatchSource.WIKI,docs/4.6/modules/qutip/three_level_atom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/three_level_atom.html
https://qutip.org/docs/4.6/modules/qutip/tomography.html:6785,Deployability,update,updated,6785,"be transparent. If; not set, all bars are colored according to the color map. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure.; """""". if ax is None:; if fig is None:; fig = plt.figure(figsize=figsize); ax = fig.add_subplot(1, 1, 1, projection='3d', position=[0, 0, 1, 1]). xlabels = []; for inds in _index_permutations([len(lbls) for lbls in lbls_list]):; xlabels.append("""".join(; [lbls_list[k][inds[k]] for k in range(len(lbls_list))])). if not title:; title = r""$\chi$"". matrix_histogram_complex(chi, xlabels, xlabels, title=title, ax=ax,; threshold=threshold). return fig, ax. [docs]def qpt(U, op_basis_list):; """"""; Calculate the quantum process tomography chi matrix for a given (possibly; nonunitary) transformation matrix U, which transforms a density matrix in; vector form according to:. vec(rho) = U * vec(rho0). or. rho = vec2mat(U * mat2vec(rho0)). U can be calculated for an open quantum system using the QuTiP propagator; function. Parameters; ----------; U : Qobj; Transformation operator. Can be calculated using QuTiP propagator; function. op_basis_list : list; A list of Qobj's representing the basis states. Returns; -------; chi : array; QPT chi matrix. """""". E_ops = []; # loop over all index permutations; for inds in _index_permutations([len(ops) for ops in op_basis_list]):; # loop over all composite systems; E_op_list = [op_basis_list[k][inds[k]] for k in range(len(; op_basis_list))]; E_ops.append(tensor(E_op_list)). EE_ops = [spre(E1) * spost(E2.dag()) for E1 in E_ops for E2 in E_ops]. M = hstack([mat2vec(EE.full()) for EE in EE_ops]). Uvec = mat2vec(U.full()). chi_vec = la.solve(M, Uvec). return vec2mat(chi_vec). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/tomography.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/tomography.html
https://qutip.org/docs/4.6/modules/qutip/topology.html:4596,Deployability,update,updated,4596,"ctions. Returns; -------; b_curv : numpy ndarray; A two dimensional array of the discretized Berry curvature defined for; the values of the two parameters defined in the eigfs.; """"""; nparam0 = eigfs.shape[0]; nparam1 = eigfs.shape[1]; nocc = eigfs.shape[2]; b_curv = np.zeros((nparam0-1, nparam1-1), dtype=float). for i in range(nparam0-1):; for j in range(nparam1-1):; rect_prd = np.identity(nocc, dtype=complex); innP0 = np.zeros([nocc, nocc], dtype=complex); innP1 = np.zeros([nocc, nocc], dtype=complex); innP2 = np.zeros([nocc, nocc], dtype=complex); innP3 = np.zeros([nocc, nocc], dtype=complex). for k in range(nocc):; for l in range(nocc):; wf0 = eigfs[i, j, k, :]; wf1 = eigfs[i+1, j, l, :]; innP0[k, l] = np.dot(wf0.conjugate(), wf1). wf1 = eigfs[i+1, j, k, :]; wf2 = eigfs[i+1, j+1, l, :]; innP1[k, l] = np.dot(wf1.conjugate(), wf2). wf2 = eigfs[i+1, j+1, k, :]; wf3 = eigfs[i, j+1, l, :]; innP2[k, l] = np.dot(wf2.conjugate(), wf3). wf3 = eigfs[i, j+1, k, :]; wf0 = eigfs[i, j, l, :]; innP3[k, l] = np.dot(wf3.conjugate(), wf0). rect_prd = np.dot(rect_prd, innP0); rect_prd = np.dot(rect_prd, innP1); rect_prd = np.dot(rect_prd, innP2); rect_prd = np.dot(rect_prd, innP3). dett = np.linalg.det(rect_prd); curl_z = np.angle(dett); b_curv[i, j] = curl_z. return b_curv. [docs]def plot_berry_curvature(eigfs):; """"""Plots the discretized Berry curvature on the two dimensional grid; of parameters. The function works well for cases with no band mixing.""""""; b_curv = berry_curvature(eigfs); fig, ax = plt.subplots(); ax.imshow(b_curv, origin=""lower""); ax.set_title(""Berry curvature""); ax.set_xlabel(r""$Parameter0$""); ax.set_ylabel(r""$Parameter1$""); fig.tight_layout(); fig.savefig(""berry_curvature.pdf""). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/topology.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/topology.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:9400,Availability,avail,available,9400,"rsion_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas. def available_cpu_count():; """"""; Get the number of cpus.; It tries to only get the number available to qutip.; """"""; import os; import multiprocessing; try:; import psutil; except ImportError:; psutil = None; num_cpu = 0. if 'QUTIP_NUM_PROCESSES' in os.environ:; # We consider QUTIP_NUM_PROCESSES=0 as unset.; num_cpu = int(os.environ['QUTIP_NUM_PROCESSES']). if num_cpu == 0 and 'SLURM_CPUS_PER_TASK' in os.environ:; num_cpu = int(os.environ['SLURM_CPUS_PER_TASK']). if num_cpu == 0 and hasattr(os, 'sched_getaffinity'):; num_cpu = len(os.sched_getaffinity(0)). if (; num_cpu == 0; and psutil is not None; and hasattr(psutil.Process(), ""cpu_affinity""); ):; num_cpu = len(psutil.Process().cpu_affinity()). if num_cpu == 0:; try:; num_cpu = multiprocessing.cpu_count(); except NotImplementedError:; pass. return num_cpu or 1. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ;",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:10322,Deployability,update,updated,10322,".split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas. def available_cpu_count():; """"""; Get the number of cpus.; It tries to only get the number available to qutip.; """"""; import os; import multiprocessing; try:; import psutil; except ImportError:; psutil = None; num_cpu = 0. if 'QUTIP_NUM_PROCESSES' in os.environ:; # We consider QUTIP_NUM_PROCESSES=0 as unset.; num_cpu = int(os.environ['QUTIP_NUM_PROCESSES']). if num_cpu == 0 and 'SLURM_CPUS_PER_TASK' in os.environ:; num_cpu = int(os.environ['SLURM_CPUS_PER_TASK']). if num_cpu == 0 and hasattr(os, 'sched_getaffinity'):; num_cpu = len(os.sched_getaffinity(0)). if (; num_cpu == 0; and psutil is not None; and hasattr(psutil.Process(), ""cpu_affinity""); ):; num_cpu = len(psutil.Process().cpu_affinity()). if num_cpu == 0:; try:; num_cpu = multiprocessing.cpu_count(); except NotImplementedError:; pass. return num_cpu or 1. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:5383,Energy Efficiency,energy,energy,5383,"+ j3))), np.int32); sign = (-1) ** (vmin + j2 + m2); for i,v in enumerate(range(vmin, vmax + 1)):; factor = s_factors[i,:]; _factorial_prod(j2 + j3 + m1 - v, factor); _factorial_prod(j1 - m1 + v, factor); _factorial_div(j3 - j1 + j2 - v, factor); _factorial_div(j3 + m3 - v, factor); _factorial_div(v + j1 - j2 - m3, factor); _factorial_div(v, factor); common_denominator = -np.min(s_factors, axis=0); numerators = s_factors + common_denominator; S = sum([(-1)**i * _to_long(vec) for i,vec in enumerate(numerators)]) * \; sign / _to_long(common_denominator); return C * S. # -----------------------------------------------------------------------------; # Functions for unit conversions; #; _e = 1.602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : flo",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:5472,Energy Efficiency,energy,energy,5472,"+ 1)):; factor = s_factors[i,:]; _factorial_prod(j2 + j3 + m1 - v, factor); _factorial_prod(j1 - m1 + v, factor); _factorial_div(j3 - j1 + j2 - v, factor); _factorial_div(j3 + m3 - v, factor); _factorial_div(v + j1 - j2 - m3, factor); _factorial_div(v, factor); common_denominator = -np.min(s_factors, axis=0); numerators = s_factors + common_denominator; S = sum([(-1)**i * _to_long(vec) for i,vec in enumerate(numerators)]) * \; sign / _to_long(common_denominator); return C * S. # -----------------------------------------------------------------------------; # Functions for unit conversions; #; _e = 1.602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The en",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:5699,Energy Efficiency,energy,energy,5699,"factor); _factorial_div(v, factor); common_denominator = -np.min(s_factors, axis=0); numerators = s_factors + common_denominator; S = sum([(-1)**i * _to_long(vec) for i,vec in enumerate(numerators)]) * \; sign / _to_long(common_denominator); return C * S. # -----------------------------------------------------------------------------; # Functions for unit conversions; #; _e = 1.602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in ",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:5995,Energy Efficiency,energy,energy,5995,"-----------------------------; # Functions for unit conversions; #; _e = 1.602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Return",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:6076,Energy Efficiency,energy,energy,6076,".602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; #",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:6150,Energy Efficiency,energy,energy,6150,"_unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_t",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:6301,Energy Efficiency,energy,energy,6301,"1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit ",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:6382,Energy Efficiency,energy,energy,6382,"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 me",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:6456,Energy Efficiency,energy,energy,6456,"-; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """""";",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:6594,Energy Efficiency,energy,energy,6594,"he name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit :",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:6673,Energy Efficiency,energy,energy,6673,"-; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 m",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:6747,Energy Efficiency,energy,energy,6747,"rig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """,MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:6880,Energy Efficiency,energy,energy,6880,"t %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_ne",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:6959,Energy Efficiency,energy,energy,6959,"o]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:7033,Energy Efficiency,energy,energy,7033,"unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:7162,Energy Efficiency,energy,energy,7162," in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:7242,Energy Efficiency,energy,energy,7242," * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; ----",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:7316,Energy Efficiency,energy,energy,7316,"nergy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz ",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:7454,Energy Efficiency,energy,energy,7454,"ay; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a""",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:7534,Energy Efficiency,energy,energy,7534,"= w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:7608,Energy Efficiency,energy,energy,7608,"energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:7748,Energy Efficiency,energy,energy,7748," The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(confi",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:7828,Energy Efficiency,energy,energy,7828," w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info =",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:7902,Energy Efficiency,energy,energy,7902,"rom unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if has",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:8113,Energy Efficiency,energy,energy,8113,"return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in bl",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:8193,Energy Efficiency,energy,energy,8193,"eV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:8267,Energy Efficiency,energy,energy,8267,"he old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; bl",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:3285,Modifiability,coupling,coupling,3285,"docs]def n_thermal(w, w_th):; """"""; Return the number of photons in thermal equilibrium for an harmonic; oscillator mode with frequency 'w', at the temperature described by; 'w_th' where :math:`\\omega_{\\rm th} = k_BT/\\hbar`. Parameters; ----------. w : *float* or *array*; Frequency of the oscillator. w_th : *float*; The temperature in units of frequency (or the same units as `w`). Returns; -------. n_avg : *float* or *array*. Return the number of average photons in thermal equilibrium for a; an oscillator with the given frequency and temperature. """""". if isinstance(w, np.ndarray):; return 1.0 / (np.exp(w / w_th) - 1.0). else:; if (w_th > 0) and np.exp(w / w_th) != 1.0:; return 1.0 / (np.exp(w / w_th) - 1.0); else:; return 0.0. def _factorial_prod(N, arr):; arr[:int(N)] += 1. def _factorial_div(N, arr):; arr[:int(N)] -= 1. def _to_long(arr):; prod = 1; for i, v in enumerate(arr):; prod *= (i+1)**int(v); return prod. [docs]def clebsch(j1, j2, j3, m1, m2, m3):; """"""Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters; ----------; j1 : float; Total angular momentum 1. j2 : float; Total angular momentum 2. j3 : float; Total angular momentum 3. m1 : float; z-component of angular momentum 1. m2 : float; z-component of angular momentum 2. m3 : float; z-component of angular momentum 3. Returns; -------; cg_coeff : float; Requested Clebsch-Gordan coefficient. """"""; if m3 != m1 + m2:; return 0; vmin = int(np.max([-j1 + j2 + m3, -j1 + m1, 0])); vmax = int(np.min([j2 + j3 + m1, j3 - j1 + j2, j3 + m3])). c_factor = np.zeros((int(j1 + j2 + j3 + 1)), np.int32); _factorial_prod(j3 + j1 - j2, c_factor); _factorial_prod(j3 - j1 + j2, c_factor); _factorial_prod(j1 + j2 - j3, c_factor); _factorial_prod(j3 + m3, c_factor); _factorial_prod(j3 - m3, c_factor); _factorial_div(j1 + j2 + j3 + 1, c_factor); _factorial_div(j1 - m1, c_factor); _factorial_div(j1 + m1, c_factor); _factorial_div(j2 - m2, c_factor); _factorial_div(j2 + m2, c_factor)",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:8616,Modifiability,config,config,8616,"gy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas. def available_cpu_count():; """"""; Get the number of cpus.; It tries to only get the number available to qutip.; """"""; import os; import multiprocessing; try:; import psutil; except ImportError:; psutil = None; num_cpu = 0. if 'QUTIP_NUM_PROCESSES' in os.environ:; # We consider QUTIP_NUM_PROCESSES=0 as u",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:8651,Modifiability,config,config,8651,"w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas. def available_cpu_count():; """"""; Get the number of cpus.; It tries to only get the number available to qutip.; """"""; import os; import multiprocessing; try:; import psutil; except ImportError:; psutil = None; num_cpu = 0. if 'QUTIP_NUM_PROCESSES' in os.environ:; # We consider QUTIP_NUM_PROCESSES=0 as unset.; num_cpu = int(os.environ['QUTIP_NUM_PROCESSES']",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:8696,Modifiability,config,config,8696,"w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas. def available_cpu_count():; """"""; Get the number of cpus.; It tries to only get the number available to qutip.; """"""; import os; import multiprocessing; try:; import psutil; except ImportError:; psutil = None; num_cpu = 0. if 'QUTIP_NUM_PROCESSES' in os.environ:; # We consider QUTIP_NUM_PROCESSES=0 as unset.; num_cpu = int(os.environ['QUTIP_NUM_PROCESSES']",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:8737,Modifiability,config,config,8737,"t an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas. def available_cpu_count():; """"""; Get the number of cpus.; It tries to only get the number available to qutip.; """"""; import os; import multiprocessing; try:; import psutil; except ImportError:; psutil = None; num_cpu = 0. if 'QUTIP_NUM_PROCESSES' in os.environ:; # We consider QUTIP_NUM_PROCESSES=0 as unset.; num_cpu = int(os.environ['QUTIP_NUM_PROCESSES']). if num_cpu == 0 and 'SLURM_CPUS_PER_TASK' in os.environ:; num_cpu = int(os",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:8776,Modifiability,config,config,8776,"t an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas. def available_cpu_count():; """"""; Get the number of cpus.; It tries to only get the number available to qutip.; """"""; import os; import multiprocessing; try:; import psutil; except ImportError:; psutil = None; num_cpu = 0. if 'QUTIP_NUM_PROCESSES' in os.environ:; # We consider QUTIP_NUM_PROCESSES=0 as unset.; num_cpu = int(os.environ['QUTIP_NUM_PROCESSES']). if num_cpu == 0 and 'SLURM_CPUS_PER_TASK' in os.environ:; num_cpu = int(os",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:8893,Modifiability,config,config,8893," w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas. def available_cpu_count():; """"""; Get the number of cpus.; It tries to only get the number available to qutip.; """"""; import os; import multiprocessing; try:; import psutil; except ImportError:; psutil = None; num_cpu = 0. if 'QUTIP_NUM_PROCESSES' in os.environ:; # We consider QUTIP_NUM_PROCESSES=0 as unset.; num_cpu = int(os.environ['QUTIP_NUM_PROCESSES']). if num_cpu == 0 and 'SLURM_CPUS_PER_TASK' in os.environ:; num_cpu = int(os.environ['SLURM_CPUS_PER_TASK']). if num_cpu == 0 and hasattr(os, 'sched_getaffinity'):; num_cpu = len(os.sched_getaffinity(0)). if (; num_cpu == 0; and psutil is not None; and hasattr(psutil.Process(), ""cpu_affinity""); ):; num_cpu = len(psutil.Process().cpu_affinity()). if num_cp",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/utilities.html:9024,Modifiability,config,config,9024," w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas. def available_cpu_count():; """"""; Get the number of cpus.; It tries to only get the number available to qutip.; """"""; import os; import multiprocessing; try:; import psutil; except ImportError:; psutil = None; num_cpu = 0. if 'QUTIP_NUM_PROCESSES' in os.environ:; # We consider QUTIP_NUM_PROCESSES=0 as unset.; num_cpu = int(os.environ['QUTIP_NUM_PROCESSES']). if num_cpu == 0 and 'SLURM_CPUS_PER_TASK' in os.environ:; num_cpu = int(os.environ['SLURM_CPUS_PER_TASK']). if num_cpu == 0 and hasattr(os, 'sched_getaffinity'):; num_cpu = len(os.sched_getaffinity(0)). if (; num_cpu == 0; and psutil is not None; and hasattr(psutil.Process(), ""cpu_affinity""); ):; num_cpu = len(psutil.Process().cpu_affinity()). if num_cp",MatchSource.WIKI,docs/4.6/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html
https://qutip.org/docs/4.6/modules/qutip/visualization.html:43005,Deployability,update,updated,43005,"width, height); The size of the matplotlib figure (in inches) if it is to be created; (that is, if no 'fig' and 'ax' arguments are passed). Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. """"""; if not isket(ket):; raise Exception(""Schmidt plot works only for pure states, i.e. kets.""). if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). dim_list = ket.dims[0]. if splitting is None:; splitting = (len(dim_list) + 1) // 2. if isinstance(labels_iteration, int):; labels_iteration = labels_iteration, labels_iteration. ketdata = ket.full(). dim_list_y = dim_list[:splitting]; dim_list_x = dim_list[splitting:]. size_x = np.prod(dim_list_x); size_y = np.prod(dim_list_y). ketdata = ketdata.reshape((size_y, size_x)). dim_list_small_x = dim_list_x[:labels_iteration[1]]; dim_list_small_y = dim_list_y[:labels_iteration[0]]. quadrants_x = np.prod(dim_list_small_x); quadrants_y = np.prod(dim_list_small_y). ticks_x = [size_x / quadrants_x * (i + 0.5); for i in range(quadrants_x)]; ticks_y = [size_y / quadrants_y * (quadrants_y - i - 0.5); for i in range(quadrants_y)]. labels_x = [_sequence_to_latex(_index_to_sequence(i*size_x // quadrants_x,; dim_list=dim_list_x)); for i in range(quadrants_x)]; labels_y = [_sequence_to_latex(_index_to_sequence(i*size_y // quadrants_y,; dim_list=dim_list_y)); for i in range(quadrants_y)]. ax.set_xticks(ticks_x); ax.set_xticklabels(labels_x); ax.set_yticks(ticks_y); ax.set_yticklabels(labels_y); ax.set_xlabel(""last particles""); ax.set_ylabel(""first particles""). ax.imshow(complex_array_to_rgb(ketdata, theme=theme),; interpolation=""none"",; extent=(0, size_x, 0, size_y)). return fig, ax. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/visualization.html
https://qutip.org/docs/4.6/modules/qutip/visualization.html:18188,Energy Efficiency,energy,energy,18188,"!= len(xtics):; raise ValueError(f""got {nxlabels} xlabels but needed {len(xtics)}""); ax.set_xticklabels(xlabels); ax.tick_params(axis='x', labelsize=12). # y axis; ytics = -0.5 + np.arange(M.shape[1]); ax.axes.w_yaxis.set_major_locator(plt.FixedLocator(ytics)); if ylabels:; nylabels = len(ylabels); if nylabels != len(ytics):; raise ValueError(f""got {nylabels} ylabels but needed {len(ytics)}""); ax.set_yticklabels(ylabels); ax.tick_params(axis='y', labelsize=12). # z axis; if limits and isinstance(limits, list):; ax.set_zlim3d(limits); else:; ax.set_zlim3d([0, 1]) # use min/max; # ax.set_zlabel('abs'). # color axis; if colorbar:; cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0); cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm); cb.set_ticks([-pi, -pi / 2, 0, pi / 2, pi]); cb.set_ticklabels(; (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$')); cb.set_label('arg'). return fig, ax. [docs]def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; figsize=(8, 12), fig=None, ax=None):; """"""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """""". if not isi",MatchSource.WIKI,docs/4.6/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/visualization.html
https://qutip.org/docs/4.6/modules/qutip/visualization.html:18255,Energy Efficiency,energy,energy,18255,"labels); ax.tick_params(axis='x', labelsize=12). # y axis; ytics = -0.5 + np.arange(M.shape[1]); ax.axes.w_yaxis.set_major_locator(plt.FixedLocator(ytics)); if ylabels:; nylabels = len(ylabels); if nylabels != len(ytics):; raise ValueError(f""got {nylabels} ylabels but needed {len(ytics)}""); ax.set_yticklabels(ylabels); ax.tick_params(axis='y', labelsize=12). # z axis; if limits and isinstance(limits, list):; ax.set_zlim3d(limits); else:; ax.set_zlim3d([0, 1]) # use min/max; # ax.set_zlabel('abs'). # color axis; if colorbar:; cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0); cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm); cb.set_ticks([-pi, -pi / 2, 0, pi / 2, pi]); cb.set_ticklabels(; (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$')); cb.set_label('arg'). return fig, ax. [docs]def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; figsize=(8, 12), fig=None, ax=None):; """"""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """""". if not isinstance(H_list, list):; raise ValueError(""H_list must be a list of Qobj instances""). if not fig and not a",MatchSource.WIKI,docs/4.6/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/visualization.html
https://qutip.org/docs/4.6/modules/qutip/visualization.html:18302,Energy Efficiency,energy,energy,18302,"ax.axes.w_yaxis.set_major_locator(plt.FixedLocator(ytics)); if ylabels:; nylabels = len(ylabels); if nylabels != len(ytics):; raise ValueError(f""got {nylabels} ylabels but needed {len(ytics)}""); ax.set_yticklabels(ylabels); ax.tick_params(axis='y', labelsize=12). # z axis; if limits and isinstance(limits, list):; ax.set_zlim3d(limits); else:; ax.set_zlim3d([0, 1]) # use min/max; # ax.set_zlabel('abs'). # color axis; if colorbar:; cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0); cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm); cb.set_ticks([-pi, -pi / 2, 0, pi / 2, pi]); cb.set_ticklabels(; (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$')); cb.set_label('arg'). return fig, ax. [docs]def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; figsize=(8, 12), fig=None, ax=None):; """"""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """""". if not isinstance(H_list, list):; raise ValueError(""H_list must be a list of Qobj instances""). if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). H = H_list[0]; N = H.shape[0] if N == 0 else mi",MatchSource.WIKI,docs/4.6/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/visualization.html
https://qutip.org/docs/4.6/modules/qutip/visualization.html:18634,Energy Efficiency,energy,energy,18634,"s; if limits and isinstance(limits, list):; ax.set_zlim3d(limits); else:; ax.set_zlim3d([0, 1]) # use min/max; # ax.set_zlabel('abs'). # color axis; if colorbar:; cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0); cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm); cb.set_ticks([-pi, -pi / 2, 0, pi / 2, pi]); cb.set_ticklabels(; (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$')); cb.set_label('arg'). return fig, ax. [docs]def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; figsize=(8, 12), fig=None, ax=None):; """"""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """""". if not isinstance(H_list, list):; raise ValueError(""H_list must be a list of Qobj instances""). if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). H = H_list[0]; N = H.shape[0] if N == 0 else min(H.shape[0], N). xticks = []; yticks = []. x = 0; evals0 = H.eigenenergies(eigvals=N); for e_idx, e in enumerate(evals0[:N]):; ax.plot([x, x + 2], np.array([1, 1]) * e, 'b', linewidth=2); yticks.append(e); xticks.append(x + 1); x += 2. for H1 in H_list[1:]:. H = H + H1;",MatchSource.WIKI,docs/4.6/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/visualization.html
https://qutip.org/docs/4.6/modules/qutip/visualization.html:18700,Energy Efficiency,energy,energy,18700,"et_zlim3d([0, 1]) # use min/max; # ax.set_zlabel('abs'). # color axis; if colorbar:; cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0); cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm); cb.set_ticks([-pi, -pi / 2, 0, pi / 2, pi]); cb.set_ticklabels(; (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$')); cb.set_label('arg'). return fig, ax. [docs]def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; figsize=(8, 12), fig=None, ax=None):; """"""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """""". if not isinstance(H_list, list):; raise ValueError(""H_list must be a list of Qobj instances""). if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). H = H_list[0]; N = H.shape[0] if N == 0 else min(H.shape[0], N). xticks = []; yticks = []. x = 0; evals0 = H.eigenenergies(eigvals=N); for e_idx, e in enumerate(evals0[:N]):; ax.plot([x, x + 2], np.array([1, 1]) * e, 'b', linewidth=2); yticks.append(e); xticks.append(x + 1); x += 2. for H1 in H_list[1:]:. H = H + H1; evals1 = H.eigenenergies(). for e_idx, e in enumerate(evals1[:N]):; ax.plot(",MatchSource.WIKI,docs/4.6/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/visualization.html
https://qutip.org/docs/4.6/modules/qutip/visualization.html:21517,Energy Efficiency,green,green,21517," plot_fock_distribution(rho, offset=0, fig=None, ax=None,; figsize=(8, 6), title=None, unit_y_range=True):; """"""; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters; ----------; rho : :class:`qutip.qobj.Qobj`; The density matrix (or ket) of the state to visualize. fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. title : string; An optional title for the figure. figsize : (width, height); The size of the matplotlib figure (in inches) if it is to be created; (that is, if no 'fig' and 'ax' arguments are passed). Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure.; """""". if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). if isket(rho):; rho = ket2dm(rho). N = rho.shape[0]. ax.bar(np.arange(offset, offset + N), np.real(rho.diag()),; color=""green"", alpha=0.6, width=0.8); if unit_y_range:; ax.set_ylim(0, 1). ax.set_xlim(-.5 + offset, N + offset); ax.set_xlabel('Fock number', fontsize=12); ax.set_ylabel('Occupation probability', fontsize=12). if title:; ax.set_title(title). return fig, ax. def fock_distribution(rho, offset=0, fig=None, ax=None,; figsize=(8, 6), title=None, unit_y_range=True):; warnings.warn(""Deprecated: Use plot_fock_distribution""); return plot_fock_distribution(rho, offset=offset, fig=fig, ax=ax,; figsize=figsize, title=title,; unit_y_range=unit_y_range). [docs]def plot_wigner(rho, fig=None, ax=None, figsize=(6, 6),; cmap=None, alpha_max=7.5, colorbar=False,; method='clenshaw', projection='2d'):; """"""; Plot the the Wigner function for a density matrix (or ket) that describes; an oscillator mode. Parameters; ----------; rho : :class:`qutip.qobj.Qobj`; The density matrix (or ket) of the state to visualize. fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib",MatchSource.WIKI,docs/4.6/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/visualization.html
https://qutip.org/docs/4.6/modules/qutip/visualization.html:16408,Safety,avoid,avoid,16408,"gs; list of y labels. title : string; title of the plot (optional). limits : list/array with two float numbers; The z-axis limits [min, max] (optional). phase_limits : list/array with two float numbers; The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance; The axes context in which the plot will be drawn. threshold: float (None); Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------; ValueError; Input argument is not valid. """""". if isinstance(M, Qobj):; # extract matrix data from Qobj; M = M.full(). n = np.size(M); xpos, ypos = np.meshgrid(range(M.shape[0]), range(M.shape[1])); xpos = xpos.T.flatten() - 0.5; ypos = ypos.T.flatten() - 0.5; zpos = np.zeros(n); dx = dy = 0.8 * np.ones(n); Mvec = M.flatten(); dz = abs(Mvec). # make small numbers real, to avoid random colors; idx, = np.where(abs(Mvec) < 0.001); Mvec[idx] = abs(Mvec[idx]). if phase_limits: # check that limits is a list type; phase_min = phase_limits[0]; phase_max = phase_limits[1]; else:; phase_min = -pi; phase_max = pi. norm = mpl.colors.Normalize(phase_min, phase_max); cmap = complex_phase_cmap(). colors = cmap(norm(angle(Mvec))); if threshold is not None:; colors[:, 3] = 1 * (dz > threshold). if ax is None:; fig = plt.figure(); ax = _axes3D(fig, azim=-35, elev=35). ax.bar3d(xpos, ypos, zpos, dx, dy, dz, color=colors). if title and fig:; ax.set_title(title). # x axis; xtics = -0.5 + np.arange(M.shape[0]); ax.axes.w_xaxis.set_major_locator(plt.FixedLocator(xtics)); if xlabels:; nxlabels = len(xlabels); if nxlabels != len(xtics):; raise ValueError(f""got {nxlabels} xlabels but needed {len(xtics)}""); ax.set_xticklabels(xlabels); ax.tick_params(axis='x', labelsize=12). # y axis; ytics = -0.5 + np.arange(M.shape[1]); ax.axes.w_yaxis.set_major_locator(plt.FixedLocator(ytics))",MatchSource.WIKI,docs/4.6/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/visualization.html
https://qutip.org/docs/4.6/modules/qutip/visualization.html:37109,Security,access,access,37109,"id_iteration' or 'all'; Show labels for first ``2*legend_iteration`` particles. Option; 'grid_iteration' sets the same number of particles as for; grid_iteration. Option 'all' makes label for all particles. Typically; it should be 0, 1, 2 or perhaps 3. fig : a matplotlib figure instance; The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance; The axis context in which the plot will be drawn. figsize : (width, height); The size of the matplotlib figure (in inches) if it is to be created; (that is, if no 'fig' and 'ax' arguments are passed). Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Notes; -----; See also [1]_. References; ----------; .. [1] J. Rodriguez-Laguna, P. Migdal, M. Ibanez Berganza, M. Lewenstein; and G. Sierra, *Qubism: self-similar visualization of many-body; wavefunctions*, `New J. Phys. 14 053028; <http://dx.doi.org/10.1088/1367-2630/14/5/053028>`_, arXiv:1112.3560; (2012), open access.; """""". if not isket(ket):; raise Exception(""Qubism works only for pure states, i.e. kets.""); # add for dm? (perhaps a separate function, plot_qubism_dm). if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). dim_list = ket.dims[0]; n = len(dim_list). # for odd number of particles - pixels are rectangular; if n % 2 == 1:; ket = tensor(ket, Qobj([1] * dim_list[-1])); dim_list = ket.dims[0]; n += 1. ketdata = ket.full(). if how == 'pairs':; dim_list_y = dim_list[::2]; dim_list_x = dim_list[1::2]; elif how == 'pairs_skewed':; dim_list_y = dim_list[::2]; dim_list_x = dim_list[1::2]; if dim_list_x != dim_list_y:; raise Exception(""For 'pairs_skewed' pairs "" +; ""of dimensions need to be the same.""); elif how == 'before_after':; dim_list_y = list(reversed(dim_list[:(n // 2)])); dim_list_x = dim_list[(n // 2):]; else:; raise Exception(""No such 'how'.""). size_x = np.prod(dim_list_x); size_y = np.prod(dim_list_y). qub = np.zeros([size_x, size_y], dtype=complex); for i",MatchSource.WIKI,docs/4.6/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/visualization.html
https://qutip.org/docs/4.6/modules/qutip/wigner.html:3724,Availability,error,errors,3724,"ty, steps, slicearray):; """"""takes the density matrix or state vector of any finite state and; generates the Wigner function for that state on a sphere, generating a spin; Wigner function useful for displaying the quasi-probability for a qubit or; any qudit. For the standard, continuous-variable Wigner function for; position and momentum variables, wigner() should be used. Parameters; ----------; psi : qobj; a state vector or density matrix.; j : int; the total angular momentum of the quantum state.; fullparity : bool; should the parity of the full SU space be used?; steps : int; number of points at which the Wigner transform is calculated.; slicearray : list of str; the angle slice to be used for each particle in case of a; multi-particle quantum state. 'l' yields an equal angle; slice. 'x', 'y' and 'z' angle slices can also be chosen. Returns; ----------; wigner : list of float; the wigner transformation at `steps` different theta and phi. Raises; ------; ComplexWarning; This can be ignored as it is caused due to rounding errors. Notes; ------; See example notebook wigner_visualisation. References; ------; [1] T. Tilma, M. J. Everitt, J. H. Samson, W. J. Munro,; and K. Nemoto, Phys. Rev. Lett. 117, 180401 (2016).; [2] R. P. Rundle, P. W. Mills, T. Tilma, J. H. Samson, and; M. J. Everitt, Phys. Rev. A 96, 022117 (2017).; """"""; if not (psi.type == 'ket' or psi.type == 'operator' or psi.type == 'bra'):; raise TypeError('Input state is not a valid operator.'). if psi.type == 'ket' or psi.type == 'bra':; rho = ket2dm(psi); else:; rho = psi. sun = 2 # The order of the SU group. # calculate total number of particles in quantum state:; N = np.int32(np.log(np.shape(rho)[0]) / np.log(2 * j + 1)). theta = np.zeros((N, steps)); phi = np.zeros((N, steps)). for i in range(N):; theta[i, :] = np.linspace(0, np.pi, steps); phi[i, :] = np.linspace(0, 2 * np.pi, steps). theta, phi = _angle_slice(np.array(slicearray, dtype=str), theta, phi). wigner = np.zeros((steps, steps)); if fullpa",MatchSource.WIKI,docs/4.6/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html
https://qutip.org/docs/4.6/modules/qutip/wigner.html:18884,Availability,toler,tolerance,18884," but have shapes {xvec.shape} and {yvec.shape}.""; ); return xvec, yvec. class _QFuncCoherentGrid:; """"""; Internal function to compute coherent state operators corresponding to a; grid of complex values in phase space. For efficiency reasons, this class; produces the adjoint of the coherent states, to save allocations when; calculating inner products later. Examples; --------; Initialise the grid calculator. >>> xvec = yvec = np.linspace(-1, 1, 21); >>> g = np.sqrt(0.5); >>> max_ns = 10; >>> grid = _QFuncCoherentGrid(xvec, yvec, g). The naive construction of the grid is. >>> xs, ys = np.meshgrid(xvec, yvec); >>> all_alphas = 0.5 * g * (xs + 1j*ys); >>> naive = np.array([; ... [; ... qutip.coherent(max_ns, alpha, method='analytic'); ... .dag().full().ravel(); ... for alpha in x_alphas; ... ]; ... for y_alphas in all_alphas; ... ]). The naive approach is typically several of orders of magnitude slower than; this class, which uses much simpler vectorised operations. The outputs are; within close tolerance, however:. >>> np.allclose(naive, grid(max_ns)); True; >>> np.allclose(naive[:, :, 4:7], grid(4, 7)); True; """"""; def __init__(self, xvec, yvec, g: float):; self.xvec, self.yvec = _qfunc_check_coordinates(xvec, yvec); x, y = np.meshgrid(0.5 * g * self.xvec, 0.5 * g * self.yvec); self.grid = np.empty(x.shape, dtype=np.complex128); self.grid.real = x; # We produce the adjoint of the coherent states to save an operation; # later when computing dot products, hence the negative imaginary part.; self.grid.imag = -y; self.prefactor = np.exp(-0.5 * (x * x + y * y)).astype(np.complex128). def _start(self, first: int):; """"""; Get the coherent state matrix corresponding to the first needed Fock; state.; """"""; if first == 0:; return self.prefactor.copy(); out = np.power(self.grid, first); out *= self.prefactor; return out. def __call__(self, first: int, last: int = None):; """"""; Get a 3D array of shape ``(yvec.size, xvec.size, last - first)`` of the; coherent-state vectors for all the F",MatchSource.WIKI,docs/4.6/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html
https://qutip.org/docs/4.6/modules/qutip/wigner.html:2961,Deployability,continuous,continuous-variable,2961,"############################################################################. __all__ = ['wigner', 'qfunc', 'QFunc', 'spin_q_function',; 'spin_wigner', 'wigner_transform']. import numpy as np; import warnings; from numpy import (; zeros, array, arange, exp, real, conj, pi, copy, sqrt, meshgrid, cos, sin,; ); import scipy.sparse as sp; import scipy.fftpack as ft; import scipy.linalg as la; import scipy.special; from scipy.special import genlaguerre, binom, sph_harm, factorial. import qutip; from qutip import Qobj, ket2dm, jmat; from qutip.parallel import parfor; from qutip.cy.sparse_utils import _csr_get_diag; from qutip.sparse import eigh. def wigner_transform(psi, j, fullparity, steps, slicearray):; """"""takes the density matrix or state vector of any finite state and; generates the Wigner function for that state on a sphere, generating a spin; Wigner function useful for displaying the quasi-probability for a qubit or; any qudit. For the standard, continuous-variable Wigner function for; position and momentum variables, wigner() should be used. Parameters; ----------; psi : qobj; a state vector or density matrix.; j : int; the total angular momentum of the quantum state.; fullparity : bool; should the parity of the full SU space be used?; steps : int; number of points at which the Wigner transform is calculated.; slicearray : list of str; the angle slice to be used for each particle in case of a; multi-particle quantum state. 'l' yields an equal angle; slice. 'x', 'y' and 'z' angle slices can also be chosen. Returns; ----------; wigner : list of float; the wigner transformation at `steps` different theta and phi. Raises; ------; ComplexWarning; This can be ignored as it is caused due to rounding errors. Notes; ------; See example notebook wigner_visualisation. References; ------; [1] T. Tilma, M. J. Everitt, J. H. Samson, W. J. Munro,; and K. Nemoto, Phys. Rev. Lett. 117, 180401 (2016).; [2] R. P. Rundle, P. W. Mills, T. Tilma, J. H. Samson, and; M. J. Everitt, Phys. ",MatchSource.WIKI,docs/4.6/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html
https://qutip.org/docs/4.6/modules/qutip/wigner.html:28228,Deployability,integrat,integrated,28228,"state.isket:; out = _qfunc_iterative_single(state.full().ravel(), alpha_grid, g); out /= np.pi; return out; # We don't use Qobj.eigenstates() to avoid building many unnecessary CSR; # versions of dense matrices.; values, vectors = eigh(state.full()); vectors = vectors.T; out = values[0] * _qfunc_iterative_single(vectors[0], alpha_grid, g); for value, vector in zip(values[1:], vectors[1:]):; out += value * _qfunc_iterative_single(vector, alpha_grid, g); out /= np.pi; return out. # -----------------------------------------------------------------------------; # PSEUDO DISTRIBUTION FUNCTIONS FOR SPINS; #; [docs]def spin_q_function(rho, theta, phi):; r""""""The Husimi Q function for spins is defined as ``Q(theta, phi) =; SCS.dag() * rho * SCS`` for the spin coherent state ``SCS = spin_coherent(; j, theta, phi)`` where j is the spin length.; The implementation here is more efficient as it doesn't; generate all of the SCS at theta and phi (see references). The spin Q function is normal when integrated over the surface of the; sphere. .. math:: \frac{4 \pi}{2j + 1}\int_\phi \int_\theta; Q(\theta, \phi) \sin(\theta) d\theta d\phi = 1. Parameters; ----------; state : qobj; A state vector or density matrix for a spin-j quantum system.; theta : array_like; Polar (colatitude) angle at which to calculate the Husimi-Q function.; phi : array_like; Azimuthal angle at which to calculate the Husimi-Q function. Returns; -------; Q, THETA, PHI : 2d-array; Values representing the spin Husimi Q function at the values specified; by THETA and PHI. References; ----------; [1] Lee Loh, Y., & Kim, M. (2015). American J. of Phys., 83(1), 30–35.; https://doi.org/10.1119/1.4898595. """""". if rho.type == 'bra':; rho = rho.dag(). if rho.type == 'ket':; rho = ket2dm(rho). J = rho.shape[0]; j = (J - 1) / 2. THETA, PHI = meshgrid(theta, phi). Q = np.zeros_like(THETA, dtype=complex). for m1 in arange(-j, j + 1):; Q += binom(2 * j, j + m1) * cos(THETA / 2) ** (2 * (j + m1)) * \; sin(THETA / 2) ** (2 * (j - m",MatchSource.WIKI,docs/4.6/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html
https://qutip.org/docs/4.6/modules/qutip/wigner.html:30418,Deployability,integrat,integrated,30418,"ETA / 2) ** (2 * j - m1 - m2)) * \; (exp(1j * (m1 - m2) * PHI) * rho.data[int(j - m1), int(j - m2)] +; exp(1j * (m2 - m1) * PHI) * rho.data[int(j - m2), int(j - m1)]). return Q.real, THETA, PHI. def _rho_kq(rho, j, k, q):; """"""; This calculates the trace of the multipole operator T_kq and the density; matrix rho for use in the spin Wigner quasiprobability distribution. Parameters; ----------; rho : qobj; A density matrix for a spin-j quantum system.; j : float; The spin length of the system.; k : int; Spherical harmonic degree; q : int; Spherical harmonic order. Returns; -------; v : float; Overlap of state with multipole operator T_kq; """""". v = 0j; for m1 in arange(-j, j+1):; for m2 in arange(-j, j+1):; v += (; (-1) ** (2 * j - k - m1 - m2); * np.sqrt((2 * k + 1) / (2 * j + 1)); * qutip.clebsch(j, k, j, -m1, q, -m2); * rho.data[int(j - m1), int(j - m2)]; ); return v. [docs]def spin_wigner(rho, theta, phi):; r""""""Wigner function for a spin-j system. The spin W function is normal when integrated over the surface of the; sphere. .. math:: \sqrt{\frac{4 \pi}{2j + 1}}\int_\phi \int_\theta; W(\theta,\phi) \sin(\theta) d\theta d\phi = 1. Parameters; ----------; state : qobj; A state vector or density matrix for a spin-j quantum system.; theta : array_like; Polar (colatitude) angle at which to calculate the W function.; phi : array_like; Azimuthal angle at which to calculate the W function. Returns; -------; W, THETA, PHI : 2d-array; Values representing the spin Wigner function at the values specified; by THETA and PHI. References; ----------; [1] Agarwal, G. S. (1981). Phys. Rev. A, 24(6), 2889–2896.; https://doi.org/10.1103/PhysRevA.24.2889. [2] Dowling, J. P., Agarwal, G. S., & Schleich, W. P. (1994).; Phys. Rev. A, 49(5), 4101–4109. https://doi.org/10.1103/PhysRevA.49.4101. [3] Conversion between Wigner 3-j symbol and Clebsch-Gordan coefficients; taken from Wikipedia (https://en.wikipedia.org/wiki/3-j_symbol). """""". if rho.type == 'bra':; rho = rho.dag(). if rho.type == 'k",MatchSource.WIKI,docs/4.6/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html
https://qutip.org/docs/4.6/modules/qutip/wigner.html:31952,Deployability,update,updated,31952,"rator T_kq; """""". v = 0j; for m1 in arange(-j, j+1):; for m2 in arange(-j, j+1):; v += (; (-1) ** (2 * j - k - m1 - m2); * np.sqrt((2 * k + 1) / (2 * j + 1)); * qutip.clebsch(j, k, j, -m1, q, -m2); * rho.data[int(j - m1), int(j - m2)]; ); return v. [docs]def spin_wigner(rho, theta, phi):; r""""""Wigner function for a spin-j system. The spin W function is normal when integrated over the surface of the; sphere. .. math:: \sqrt{\frac{4 \pi}{2j + 1}}\int_\phi \int_\theta; W(\theta,\phi) \sin(\theta) d\theta d\phi = 1. Parameters; ----------; state : qobj; A state vector or density matrix for a spin-j quantum system.; theta : array_like; Polar (colatitude) angle at which to calculate the W function.; phi : array_like; Azimuthal angle at which to calculate the W function. Returns; -------; W, THETA, PHI : 2d-array; Values representing the spin Wigner function at the values specified; by THETA and PHI. References; ----------; [1] Agarwal, G. S. (1981). Phys. Rev. A, 24(6), 2889–2896.; https://doi.org/10.1103/PhysRevA.24.2889. [2] Dowling, J. P., Agarwal, G. S., & Schleich, W. P. (1994).; Phys. Rev. A, 49(5), 4101–4109. https://doi.org/10.1103/PhysRevA.49.4101. [3] Conversion between Wigner 3-j symbol and Clebsch-Gordan coefficients; taken from Wikipedia (https://en.wikipedia.org/wiki/3-j_symbol). """""". if rho.type == 'bra':; rho = rho.dag(). if rho.type == 'ket':; rho = ket2dm(rho). J = rho.shape[0]; j = (J - 1) / 2. THETA, PHI = meshgrid(theta, phi). W = np.zeros_like(THETA, dtype=complex). for k in range(int(2 * j)+1):; for q in arange(-k, k+1):; # sph_harm takes azimuthal angle then polar angle as arguments; W += _rho_kq(rho, j, k, q) * sph_harm(q, k, PHI, THETA). return W.real, THETA, PHI. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html
https://qutip.org/docs/4.6/modules/qutip/wigner.html:7919,Energy Efficiency,efficient,efficient,7919,"rix at points; `xvec + i * yvec`. Parameters; ----------. state : qobj; A state vector or density matrix. xvec : array_like; x-coordinates at which to calculate the Wigner function. yvec : array_like; y-coordinates at which to calculate the Wigner function. Does not; apply to the 'fft' method. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`.; The value of `g` is related to the value of `hbar` in the commutation; relation `[x, y] = i * hbar` via `hbar=2/g^2` giving the default; value `hbar=1`. method : string {'clenshaw', 'iterative', 'laguerre', 'fft'}; Select method 'clenshaw' 'iterative', 'laguerre', or 'fft', where 'clenshaw'; and 'iterative' use an iterative method to evaluate the Wigner functions for density; matrices :math:`|m><n|`, while 'laguerre' uses the Laguerre polynomials; in scipy for the same task. The 'fft' method evaluates the Fourier; transform of the density matrix. The 'iterative' method is default, and; in general recommended, but the 'laguerre' method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The 'clenshaw' method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). 'clenshaw' is a fast and numerically stable method. sparse : bool {False, True}; Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance. parfor : bool {False, True}; Flag for calculating the Laguerre polynomial based Wigner function; method='laguerre' in parallel using the parfor function. Returns; -------. W : array; Values representing the Wigner function calculated over the specified; range [xvec,yvec]. yvex : array; FFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; -----; The 'fft' method accepts only an xvec input for the x-coordinate.; The y-coor",MatchSource.WIKI,docs/4.6/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html
https://qutip.org/docs/4.6/modules/qutip/wigner.html:15017,Energy Efficiency,efficient,efficient,15017,"0]]),; np.fliplr(psi.conj()),; np.zeros((1, n//2 - 1))), axis=1); r2 = np.concatenate((np.array([[0]]), psi,; np.zeros((1, n//2 - 1))), axis=1); w = la.toeplitz(np.zeros((n//2, 1)), r1) * \; np.flipud(la.toeplitz(np.zeros((n//2, 1)), r2)); w = np.concatenate((w[:, n//2:n], w[:, 0:n//2]), axis=1); w = ft.fft(w); w = np.real(np.concatenate((w[:, 3*n//4:n+1], w[:, 0:n//4]), axis=1)); p = np.arange(-n/4, n/4)*np.pi / (n*(xvec[1] - xvec[0])); w = w / (p[1] - p[0]) / n; return w, p. def _osc_eigen(N, pnts):; """"""; Vector of and N-dim oscillator eigenfunctions evaluated; at the points in pnts.; """"""; pnts = np.asarray(pnts); lpnts = len(pnts); A = np.zeros((N, lpnts)); A[0, :] = np.exp(-pnts ** 2 / 2.0) / pi ** 0.25; if N == 1:; return A; else:; A[1, :] = np.sqrt(2) * pnts * A[0, :]; for k in range(2, N):; A[k, :] = np.sqrt(2.0 / k) * pnts * A[k - 1, :] - \; np.sqrt((k - 1.0) / k) * A[k - 2, :]; return A. def _wigner_clenshaw(rho, xvec, yvec, g=sqrt(2), sparse=False):; r""""""; Using Clenshaw summation - numerically stable and efficient; iterative algorithm to evaluate polynomial series. The Wigner function is calculated as; :math:`W = e^(-0.5*x^2)/pi * \sum_{L} c_L (2x)^L / \sqrt(L!)` where; :math:`c_L = \sum_n \rho_{n,L+n} LL_n^L` where; :math:`LL_n^L = (-1)^n \sqrt(L!n!/(L+n)!) LaguerreL[n,L,x]`; """""". M = np.prod(rho.shape[0]); X,Y = np.meshgrid(xvec, yvec); #A = 0.5 * g * (X + 1.0j * Y); A2 = g * (X + 1.0j * Y) #this is A2 = 2*A. B = np.abs(A2); B *= B; w0 = (2*rho.data[0,-1])*np.ones_like(A2); L = M-1; #calculation of \sum_{L} c_L (2x)^L / \sqrt(L!); #using Horner's method; if not sparse:; rho = rho.full() * (2*np.ones((M,M)) - np.diag(np.ones(M))); while L > 0:; L -= 1; #here c_L = _wig_laguerre_val(L, B, np.diag(rho, L)); w0 = _wig_laguerre_val(L, B, np.diag(rho, L)) + w0 * A2 * (L+1)**-0.5; else:; while L > 0:; L -= 1; diag = _csr_get_diag(rho.data.data,rho.data.indices,; rho.data.indptr,L); if L != 0:; diag *= 2; #here c_L = _wig_laguerre_val(L, B, np.diag(rho, L)); w0 ",MatchSource.WIKI,docs/4.6/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html
https://qutip.org/docs/4.6/modules/qutip/wigner.html:19654,Energy Efficiency,power,power,19654,"in x_alphas; ... ]; ... for y_alphas in all_alphas; ... ]). The naive approach is typically several of orders of magnitude slower than; this class, which uses much simpler vectorised operations. The outputs are; within close tolerance, however:. >>> np.allclose(naive, grid(max_ns)); True; >>> np.allclose(naive[:, :, 4:7], grid(4, 7)); True; """"""; def __init__(self, xvec, yvec, g: float):; self.xvec, self.yvec = _qfunc_check_coordinates(xvec, yvec); x, y = np.meshgrid(0.5 * g * self.xvec, 0.5 * g * self.yvec); self.grid = np.empty(x.shape, dtype=np.complex128); self.grid.real = x; # We produce the adjoint of the coherent states to save an operation; # later when computing dot products, hence the negative imaginary part.; self.grid.imag = -y; self.prefactor = np.exp(-0.5 * (x * x + y * y)).astype(np.complex128). def _start(self, first: int):; """"""; Get the coherent state matrix corresponding to the first needed Fock; state.; """"""; if first == 0:; return self.prefactor.copy(); out = np.power(self.grid, first); out *= self.prefactor; return out. def __call__(self, first: int, last: int = None):; """"""; Get a 3D array of shape ``(yvec.size, xvec.size, last - first)`` of the; coherent-state vectors for all the Fock states in the range ``first``; to ``last``, excluding the end point. The first two axes are the y-; and x-coordinates of phase space (i.e. Cartesian indexing, like; ``numpy.meshgrid``), and the last runs over the selected range of; Fock-space dimensions.; """"""; ns = np.arange(first, last).reshape(1, 1, -1); # Technically we could avoid hitting the limits of floating-point; # exponents for longer by doing all this in logarithmic space (using; # scipy.special.gammaln), but that ends up involving more; # floating-point operations overall, and needs special care around the; # point alpha = 0 to avoid nan appearing, due to how Python handles; # mixed-width arithmetic operations.; out = np.empty(self.grid.shape + (ns.size,), dtype=np.complex128); out[:, :, 0] = self._start(",MatchSource.WIKI,docs/4.6/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html
https://qutip.org/docs/4.6/modules/qutip/wigner.html:21928,Energy Efficiency,efficient,efficient,21928,"ifferent; quantum states at fixed phase-space points ``0.5*g* (xvec + i*yvec)``.; This class has slightly higher first-usage costs than :obj:`.qfunc`, but; subsequent operations will be several times faster. However, it can require; quite a lot of memory. Call the created object as a function to retrieve; the Husimi-Q function. Parameters; ----------; xvec, yvec : array_like; x- and y-coordinates at which to calculate the Husimi-Q function. g : float, default sqrt(2); Scaling factor for ``a = 0.5 * g * (x + iy)``. The value of `g` is; related to the value of `hbar` in the commutation relation; :math:`[x,\,y] = i\hbar` via :math:`\hbar=2/g^2`, so the default; corresponds to :math:`\hbar=1`. memory : real, default 1024; Size in MB that may be used internally as workspace. This class will; raise ``MemoryError`` if subsequently passed a state of sufficiently; large dimension that this bound would be exceeded. In those cases, use; :obj:`.qfunc` with ``precompute_memory=None`` instead to force using; the slower, more memory-efficient algorithm. Examples; --------; Initialise the class for a square set of coordinates, with some states we; want to investigate. >>> xvec = np.linspace(-2, 2, 101); >>> states = [qutip.rand_dm(10) for _ in [None]*10]; >>> qfunc = qutip.QFunc(xvec, xvec). Now we can calculate the Husimi-Q function over each of the states more; efficiently with:. >>> husimiq = np.array([qfunc(state) for state in states]). See Also; --------; :obj:`.qfunc` :; a single function version, which will involve computing several; quantities multiple times in order to use less memory.; """""". def __init__(; self, xvec, yvec, g: float = np.sqrt(2), memory: float = 1024; ):; self._g = g; self._coherent_grid = _QFuncCoherentGrid(xvec, yvec, g); # 16 bytes per complex, 1024**2 bytes per MB.; self._size_mb = self._coherent_grid.grid.size * 16 / (1024 ** 2); self._memory_mb = memory; self._max_size = int(self._memory_mb // self._size_mb); self._current_size = 0; self._cache = None",MatchSource.WIKI,docs/4.6/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html
https://qutip.org/docs/4.6/modules/qutip/wigner.html:22264,Energy Efficiency,efficient,efficiently,22264,"----------; xvec, yvec : array_like; x- and y-coordinates at which to calculate the Husimi-Q function. g : float, default sqrt(2); Scaling factor for ``a = 0.5 * g * (x + iy)``. The value of `g` is; related to the value of `hbar` in the commutation relation; :math:`[x,\,y] = i\hbar` via :math:`\hbar=2/g^2`, so the default; corresponds to :math:`\hbar=1`. memory : real, default 1024; Size in MB that may be used internally as workspace. This class will; raise ``MemoryError`` if subsequently passed a state of sufficiently; large dimension that this bound would be exceeded. In those cases, use; :obj:`.qfunc` with ``precompute_memory=None`` instead to force using; the slower, more memory-efficient algorithm. Examples; --------; Initialise the class for a square set of coordinates, with some states we; want to investigate. >>> xvec = np.linspace(-2, 2, 101); >>> states = [qutip.rand_dm(10) for _ in [None]*10]; >>> qfunc = qutip.QFunc(xvec, xvec). Now we can calculate the Husimi-Q function over each of the states more; efficiently with:. >>> husimiq = np.array([qfunc(state) for state in states]). See Also; --------; :obj:`.qfunc` :; a single function version, which will involve computing several; quantities multiple times in order to use less memory.; """""". def __init__(; self, xvec, yvec, g: float = np.sqrt(2), memory: float = 1024; ):; self._g = g; self._coherent_grid = _QFuncCoherentGrid(xvec, yvec, g); # 16 bytes per complex, 1024**2 bytes per MB.; self._size_mb = self._coherent_grid.grid.size * 16 / (1024 ** 2); self._memory_mb = memory; self._max_size = int(self._memory_mb // self._size_mb); self._current_size = 0; self._cache = None. def _alphas(self, size: int):; r""""""; Retrive the full tensor of (the conjugate of) coherent states over all; values of :math:`\alpha`, for states of dimension ``size``.; """"""; if self._current_size >= size:; return self._cache[:, :, :size]; if size > self._max_size:; requirement = self._size_mb * size; raise MemoryError(; f""Refusing to pr",MatchSource.WIKI,docs/4.6/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html
https://qutip.org/docs/4.6/modules/qutip/wigner.html:24847,Energy Efficiency,power,powers,24847,"n np.abs(np.dot(alphas, (self._g * 0.5) * vector)) ** 2. def __call__(self, state: Qobj):; """"""; Get the Husimi-Q function for the given state vector or density matrix,; over the coordinates used to initialise the class. If called multiple; times, the states do not need to have the same dimensions, but none of; them can have tensor-product structure.; """"""; state = _qfunc_check_state(state); alphas = self._alphas(state.shape[0]); if state.isket:; return self._single(state.full().ravel(), alphas) / np.pi; # We don't use Qobj.eigenstates() to avoid building many unnecessary; # CSR versions of dense matrices.; values, vectors = eigh(state.full()); vectors = vectors.T; out = values[0] * self._single(vectors[0], alphas); for value, vector in zip(values[1:], vectors[1:]):; out += value * self._single(vector, alphas); return out / np.pi. def _qfunc_iterative_single(; vector: np.ndarray, alpha_grid: _QFuncCoherentGrid, g: float,; ):; r""""""; Get the Q function (without the :math:`\pi` scaling factor) of a single; state vector, using the iterative algorithm which recomputes the powers of; the coherent-state matrix.; """"""; ns = np.arange(vector.shape[0]); out = np.polyval(; (0.5*g * vector / np.sqrt(scipy.special.factorial(ns)))[::-1],; alpha_grid.grid,; ); out *= alpha_grid.prefactor; return np.abs(out)**2. [docs]def qfunc(; state: Qobj,; xvec,; yvec,; g: float = sqrt(2),; precompute_memory: float = 1024,; ):; r""""""; Husimi-Q function of a given state vector or density matrix at phase-space; points ``0.5 * g * (xvec + i*yvec)``. Parameters; ----------; state : :obj:`.Qobj`; A state vector or density matrix. This cannot have tensor-product; structure. xvec, yvec : array_like; x- and y-coordinates at which to calculate the Husimi-Q function. g : float, default sqrt(2); Scaling factor for ``a = 0.5 * g * (x + iy)``. The value of `g` is; related to the value of :math:`\hbar` in the commutation relation; :math:`[x,\,y] = i\hbar` via :math:`\hbar=2/g^2`, so the default; corresponds to :m",MatchSource.WIKI,docs/4.6/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html
https://qutip.org/docs/4.6/modules/qutip/wigner.html:26426,Energy Efficiency,efficient,efficient,26426,"nd y-coordinates at which to calculate the Husimi-Q function. g : float, default sqrt(2); Scaling factor for ``a = 0.5 * g * (x + iy)``. The value of `g` is; related to the value of :math:`\hbar` in the commutation relation; :math:`[x,\,y] = i\hbar` via :math:`\hbar=2/g^2`, so the default; corresponds to :math:`\hbar=1`. precompute_memory : real, default 1024; Size in MB that may be used during calculations as working space when; dealing with density-matrix inputs. This is ignored for state-vector; inputs. The bound is not quite exact due to other, order-of-magnitude; smaller, intermediaries being necessary, but is a good approximation.; If you want to use the same iterative algorithm for density matrices; that is used for single kets, set ``precompute_memory=None``. Returns; --------; ndarray; Values representing the Husimi-Q function calculated over the specified; range ``[xvec, yvec]``. See Also; --------; :obj:`.QFunc` :; a class-based version, more efficient if you want to calculate the; Husimi-Q function for several states over the same coordinates.; """"""; state = _qfunc_check_state(state); xvec, yvec = _qfunc_check_coordinates(xvec, yvec); required_memory = state.shape[0] * xvec.size * yvec.size * 16 / (1024 ** 2); enough_memory = (; precompute_memory is not None; and precompute_memory > required_memory; ); if state.isoper and enough_memory:; return QFunc(xvec, yvec, g)(state); if precompute_memory is not None and state.isoper:; warnings.warn(; ""Falling back to iterative algorithm due to lack of memory.""; f"" Needed {required_memory:.2f} MB, but only allowed to use""; f"" {precompute_memory:.2f} MB. Increase `precompute_memory` to""; "" raise limit, or set to `None` to suppress warning.""; ); alpha_grid = _QFuncCoherentGrid(xvec, yvec, g); if state.isket:; out = _qfunc_iterative_single(state.full().ravel(), alpha_grid, g); out /= np.pi; return out; # We don't use Qobj.eigenstates() to avoid building many unnecessary CSR; # versions of dense matrices.; values, vectors",MatchSource.WIKI,docs/4.6/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html
https://qutip.org/docs/4.6/modules/qutip/wigner.html:28109,Energy Efficiency,efficient,efficient,28109,"it, or set to `None` to suppress warning.""; ); alpha_grid = _QFuncCoherentGrid(xvec, yvec, g); if state.isket:; out = _qfunc_iterative_single(state.full().ravel(), alpha_grid, g); out /= np.pi; return out; # We don't use Qobj.eigenstates() to avoid building many unnecessary CSR; # versions of dense matrices.; values, vectors = eigh(state.full()); vectors = vectors.T; out = values[0] * _qfunc_iterative_single(vectors[0], alpha_grid, g); for value, vector in zip(values[1:], vectors[1:]):; out += value * _qfunc_iterative_single(vector, alpha_grid, g); out /= np.pi; return out. # -----------------------------------------------------------------------------; # PSEUDO DISTRIBUTION FUNCTIONS FOR SPINS; #; [docs]def spin_q_function(rho, theta, phi):; r""""""The Husimi Q function for spins is defined as ``Q(theta, phi) =; SCS.dag() * rho * SCS`` for the spin coherent state ``SCS = spin_coherent(; j, theta, phi)`` where j is the spin length.; The implementation here is more efficient as it doesn't; generate all of the SCS at theta and phi (see references). The spin Q function is normal when integrated over the surface of the; sphere. .. math:: \frac{4 \pi}{2j + 1}\int_\phi \int_\theta; Q(\theta, \phi) \sin(\theta) d\theta d\phi = 1. Parameters; ----------; state : qobj; A state vector or density matrix for a spin-j quantum system.; theta : array_like; Polar (colatitude) angle at which to calculate the Husimi-Q function.; phi : array_like; Azimuthal angle at which to calculate the Husimi-Q function. Returns; -------; Q, THETA, PHI : 2d-array; Values representing the spin Husimi Q function at the values specified; by THETA and PHI. References; ----------; [1] Lee Loh, Y., & Kim, M. (2015). American J. of Phys., 83(1), 30–35.; https://doi.org/10.1119/1.4898595. """""". if rho.type == 'bra':; rho = rho.dag(). if rho.type == 'ket':; rho = ket2dm(rho). J = rho.shape[0]; j = (J - 1) / 2. THETA, PHI = meshgrid(theta, phi). Q = np.zeros_like(THETA, dtype=complex). for m1 in arange(-j, j + 1)",MatchSource.WIKI,docs/4.6/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html
https://qutip.org/docs/4.6/modules/qutip/wigner.html:28228,Integrability,integrat,integrated,28228,"state.isket:; out = _qfunc_iterative_single(state.full().ravel(), alpha_grid, g); out /= np.pi; return out; # We don't use Qobj.eigenstates() to avoid building many unnecessary CSR; # versions of dense matrices.; values, vectors = eigh(state.full()); vectors = vectors.T; out = values[0] * _qfunc_iterative_single(vectors[0], alpha_grid, g); for value, vector in zip(values[1:], vectors[1:]):; out += value * _qfunc_iterative_single(vector, alpha_grid, g); out /= np.pi; return out. # -----------------------------------------------------------------------------; # PSEUDO DISTRIBUTION FUNCTIONS FOR SPINS; #; [docs]def spin_q_function(rho, theta, phi):; r""""""The Husimi Q function for spins is defined as ``Q(theta, phi) =; SCS.dag() * rho * SCS`` for the spin coherent state ``SCS = spin_coherent(; j, theta, phi)`` where j is the spin length.; The implementation here is more efficient as it doesn't; generate all of the SCS at theta and phi (see references). The spin Q function is normal when integrated over the surface of the; sphere. .. math:: \frac{4 \pi}{2j + 1}\int_\phi \int_\theta; Q(\theta, \phi) \sin(\theta) d\theta d\phi = 1. Parameters; ----------; state : qobj; A state vector or density matrix for a spin-j quantum system.; theta : array_like; Polar (colatitude) angle at which to calculate the Husimi-Q function.; phi : array_like; Azimuthal angle at which to calculate the Husimi-Q function. Returns; -------; Q, THETA, PHI : 2d-array; Values representing the spin Husimi Q function at the values specified; by THETA and PHI. References; ----------; [1] Lee Loh, Y., & Kim, M. (2015). American J. of Phys., 83(1), 30–35.; https://doi.org/10.1119/1.4898595. """""". if rho.type == 'bra':; rho = rho.dag(). if rho.type == 'ket':; rho = ket2dm(rho). J = rho.shape[0]; j = (J - 1) / 2. THETA, PHI = meshgrid(theta, phi). Q = np.zeros_like(THETA, dtype=complex). for m1 in arange(-j, j + 1):; Q += binom(2 * j, j + m1) * cos(THETA / 2) ** (2 * (j + m1)) * \; sin(THETA / 2) ** (2 * (j - m",MatchSource.WIKI,docs/4.6/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html
https://qutip.org/docs/4.6/modules/qutip/wigner.html:30418,Integrability,integrat,integrated,30418,"ETA / 2) ** (2 * j - m1 - m2)) * \; (exp(1j * (m1 - m2) * PHI) * rho.data[int(j - m1), int(j - m2)] +; exp(1j * (m2 - m1) * PHI) * rho.data[int(j - m2), int(j - m1)]). return Q.real, THETA, PHI. def _rho_kq(rho, j, k, q):; """"""; This calculates the trace of the multipole operator T_kq and the density; matrix rho for use in the spin Wigner quasiprobability distribution. Parameters; ----------; rho : qobj; A density matrix for a spin-j quantum system.; j : float; The spin length of the system.; k : int; Spherical harmonic degree; q : int; Spherical harmonic order. Returns; -------; v : float; Overlap of state with multipole operator T_kq; """""". v = 0j; for m1 in arange(-j, j+1):; for m2 in arange(-j, j+1):; v += (; (-1) ** (2 * j - k - m1 - m2); * np.sqrt((2 * k + 1) / (2 * j + 1)); * qutip.clebsch(j, k, j, -m1, q, -m2); * rho.data[int(j - m1), int(j - m2)]; ); return v. [docs]def spin_wigner(rho, theta, phi):; r""""""Wigner function for a spin-j system. The spin W function is normal when integrated over the surface of the; sphere. .. math:: \sqrt{\frac{4 \pi}{2j + 1}}\int_\phi \int_\theta; W(\theta,\phi) \sin(\theta) d\theta d\phi = 1. Parameters; ----------; state : qobj; A state vector or density matrix for a spin-j quantum system.; theta : array_like; Polar (colatitude) angle at which to calculate the W function.; phi : array_like; Azimuthal angle at which to calculate the W function. Returns; -------; W, THETA, PHI : 2d-array; Values representing the spin Wigner function at the values specified; by THETA and PHI. References; ----------; [1] Agarwal, G. S. (1981). Phys. Rev. A, 24(6), 2889–2896.; https://doi.org/10.1103/PhysRevA.24.2889. [2] Dowling, J. P., Agarwal, G. S., & Schleich, W. P. (1994).; Phys. Rev. A, 49(5), 4101–4109. https://doi.org/10.1103/PhysRevA.49.4101. [3] Conversion between Wigner 3-j symbol and Clebsch-Gordan coefficients; taken from Wikipedia (https://en.wikipedia.org/wiki/3-j_symbol). """""". if rho.type == 'bra':; rho = rho.dag(). if rho.type == 'k",MatchSource.WIKI,docs/4.6/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html
https://qutip.org/docs/4.6/modules/qutip/wigner.html:2972,Modifiability,variab,variable,2972,"############################################################################. __all__ = ['wigner', 'qfunc', 'QFunc', 'spin_q_function',; 'spin_wigner', 'wigner_transform']. import numpy as np; import warnings; from numpy import (; zeros, array, arange, exp, real, conj, pi, copy, sqrt, meshgrid, cos, sin,; ); import scipy.sparse as sp; import scipy.fftpack as ft; import scipy.linalg as la; import scipy.special; from scipy.special import genlaguerre, binom, sph_harm, factorial. import qutip; from qutip import Qobj, ket2dm, jmat; from qutip.parallel import parfor; from qutip.cy.sparse_utils import _csr_get_diag; from qutip.sparse import eigh. def wigner_transform(psi, j, fullparity, steps, slicearray):; """"""takes the density matrix or state vector of any finite state and; generates the Wigner function for that state on a sphere, generating a spin; Wigner function useful for displaying the quasi-probability for a qubit or; any qudit. For the standard, continuous-variable Wigner function for; position and momentum variables, wigner() should be used. Parameters; ----------; psi : qobj; a state vector or density matrix.; j : int; the total angular momentum of the quantum state.; fullparity : bool; should the parity of the full SU space be used?; steps : int; number of points at which the Wigner transform is calculated.; slicearray : list of str; the angle slice to be used for each particle in case of a; multi-particle quantum state. 'l' yields an equal angle; slice. 'x', 'y' and 'z' angle slices can also be chosen. Returns; ----------; wigner : list of float; the wigner transformation at `steps` different theta and phi. Raises; ------; ComplexWarning; This can be ignored as it is caused due to rounding errors. Notes; ------; See example notebook wigner_visualisation. References; ------; [1] T. Tilma, M. J. Everitt, J. H. Samson, W. J. Munro,; and K. Nemoto, Phys. Rev. Lett. 117, 180401 (2016).; [2] R. P. Rundle, P. W. Mills, T. Tilma, J. H. Samson, and; M. J. Everitt, Phys. ",MatchSource.WIKI,docs/4.6/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html
https://qutip.org/docs/4.6/modules/qutip/wigner.html:3024,Modifiability,variab,variables,3024,"############################################################################. __all__ = ['wigner', 'qfunc', 'QFunc', 'spin_q_function',; 'spin_wigner', 'wigner_transform']. import numpy as np; import warnings; from numpy import (; zeros, array, arange, exp, real, conj, pi, copy, sqrt, meshgrid, cos, sin,; ); import scipy.sparse as sp; import scipy.fftpack as ft; import scipy.linalg as la; import scipy.special; from scipy.special import genlaguerre, binom, sph_harm, factorial. import qutip; from qutip import Qobj, ket2dm, jmat; from qutip.parallel import parfor; from qutip.cy.sparse_utils import _csr_get_diag; from qutip.sparse import eigh. def wigner_transform(psi, j, fullparity, steps, slicearray):; """"""takes the density matrix or state vector of any finite state and; generates the Wigner function for that state on a sphere, generating a spin; Wigner function useful for displaying the quasi-probability for a qubit or; any qudit. For the standard, continuous-variable Wigner function for; position and momentum variables, wigner() should be used. Parameters; ----------; psi : qobj; a state vector or density matrix.; j : int; the total angular momentum of the quantum state.; fullparity : bool; should the parity of the full SU space be used?; steps : int; number of points at which the Wigner transform is calculated.; slicearray : list of str; the angle slice to be used for each particle in case of a; multi-particle quantum state. 'l' yields an equal angle; slice. 'x', 'y' and 'z' angle slices can also be chosen. Returns; ----------; wigner : list of float; the wigner transformation at `steps` different theta and phi. Raises; ------; ComplexWarning; This can be ignored as it is caused due to rounding errors. Notes; ------; See example notebook wigner_visualisation. References; ------; [1] T. Tilma, M. J. Everitt, J. H. Samson, W. J. Munro,; and K. Nemoto, Phys. Rev. Lett. 117, 180401 (2016).; [2] R. P. Rundle, P. W. Mills, T. Tilma, J. H. Samson, and; M. J. Everitt, Phys. ",MatchSource.WIKI,docs/4.6/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html
https://qutip.org/docs/4.6/modules/qutip/wigner.html:8421,Performance,perform,performance,8421,"^2` giving the default; value `hbar=1`. method : string {'clenshaw', 'iterative', 'laguerre', 'fft'}; Select method 'clenshaw' 'iterative', 'laguerre', or 'fft', where 'clenshaw'; and 'iterative' use an iterative method to evaluate the Wigner functions for density; matrices :math:`|m><n|`, while 'laguerre' uses the Laguerre polynomials; in scipy for the same task. The 'fft' method evaluates the Fourier; transform of the density matrix. The 'iterative' method is default, and; in general recommended, but the 'laguerre' method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The 'clenshaw' method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). 'clenshaw' is a fast and numerically stable method. sparse : bool {False, True}; Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance. parfor : bool {False, True}; Flag for calculating the Laguerre polynomial based Wigner function; method='laguerre' in parallel using the parfor function. Returns; -------. W : array; Values representing the Wigner function calculated over the specified; range [xvec,yvec]. yvex : array; FFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; -----; The 'fft' method accepts only an xvec input for the x-coordinate.; The y-coordinates are calculated internally. References; ----------. Ulf Leonhardt,; Measuring the Quantum State of Light, (Cambridge University Press, 1997). """""". if not (psi.type == 'ket' or psi.type == 'oper' or psi.type == 'bra'):; raise TypeError('Input state is not a valid operator.'). if method == 'fft':; return _wigner_fourier(psi, xvec, g). if psi.type == 'ket' or psi.type == 'bra':; rho = ket2dm(psi); else:; rho = psi. if method == 'iterative':; return _wigner_iterative(rho, xvec, yve",MatchSource.WIKI,docs/4.6/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html
https://qutip.org/docs/4.6/modules/qutip/wigner.html:20214,Safety,avoid,avoid,20214,"uce the adjoint of the coherent states to save an operation; # later when computing dot products, hence the negative imaginary part.; self.grid.imag = -y; self.prefactor = np.exp(-0.5 * (x * x + y * y)).astype(np.complex128). def _start(self, first: int):; """"""; Get the coherent state matrix corresponding to the first needed Fock; state.; """"""; if first == 0:; return self.prefactor.copy(); out = np.power(self.grid, first); out *= self.prefactor; return out. def __call__(self, first: int, last: int = None):; """"""; Get a 3D array of shape ``(yvec.size, xvec.size, last - first)`` of the; coherent-state vectors for all the Fock states in the range ``first``; to ``last``, excluding the end point. The first two axes are the y-; and x-coordinates of phase space (i.e. Cartesian indexing, like; ``numpy.meshgrid``), and the last runs over the selected range of; Fock-space dimensions.; """"""; ns = np.arange(first, last).reshape(1, 1, -1); # Technically we could avoid hitting the limits of floating-point; # exponents for longer by doing all this in logarithmic space (using; # scipy.special.gammaln), but that ends up involving more; # floating-point operations overall, and needs special care around the; # point alpha = 0 to avoid nan appearing, due to how Python handles; # mixed-width arithmetic operations.; out = np.empty(self.grid.shape + (ns.size,), dtype=np.complex128); out[:, :, 0] = self._start(ns.flat[0]); for i in range(ns.size - 1):; out[:, :, i+1] = out[:, :, i] * self.grid; out /= np.sqrt(scipy.special.factorial(ns)); return out. [docs]class QFunc:; r""""""; Class-based method of calculating the Husimi-Q function of many different; quantum states at fixed phase-space points ``0.5*g* (xvec + i*yvec)``.; This class has slightly higher first-usage costs than :obj:`.qfunc`, but; subsequent operations will be several times faster. However, it can require; quite a lot of memory. Call the created object as a function to retrieve; the Husimi-Q function. Parameters; ----------; xvec, ",MatchSource.WIKI,docs/4.6/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html
https://qutip.org/docs/4.6/modules/qutip/wigner.html:20480,Safety,avoid,avoid,20480,")).astype(np.complex128). def _start(self, first: int):; """"""; Get the coherent state matrix corresponding to the first needed Fock; state.; """"""; if first == 0:; return self.prefactor.copy(); out = np.power(self.grid, first); out *= self.prefactor; return out. def __call__(self, first: int, last: int = None):; """"""; Get a 3D array of shape ``(yvec.size, xvec.size, last - first)`` of the; coherent-state vectors for all the Fock states in the range ``first``; to ``last``, excluding the end point. The first two axes are the y-; and x-coordinates of phase space (i.e. Cartesian indexing, like; ``numpy.meshgrid``), and the last runs over the selected range of; Fock-space dimensions.; """"""; ns = np.arange(first, last).reshape(1, 1, -1); # Technically we could avoid hitting the limits of floating-point; # exponents for longer by doing all this in logarithmic space (using; # scipy.special.gammaln), but that ends up involving more; # floating-point operations overall, and needs special care around the; # point alpha = 0 to avoid nan appearing, due to how Python handles; # mixed-width arithmetic operations.; out = np.empty(self.grid.shape + (ns.size,), dtype=np.complex128); out[:, :, 0] = self._start(ns.flat[0]); for i in range(ns.size - 1):; out[:, :, i+1] = out[:, :, i] * self.grid; out /= np.sqrt(scipy.special.factorial(ns)); return out. [docs]class QFunc:; r""""""; Class-based method of calculating the Husimi-Q function of many different; quantum states at fixed phase-space points ``0.5*g* (xvec + i*yvec)``.; This class has slightly higher first-usage costs than :obj:`.qfunc`, but; subsequent operations will be several times faster. However, it can require; quite a lot of memory. Call the created object as a function to retrieve; the Husimi-Q function. Parameters; ----------; xvec, yvec : array_like; x- and y-coordinates at which to calculate the Husimi-Q function. g : float, default sqrt(2); Scaling factor for ``a = 0.5 * g * (x + iy)``. The value of `g` is; related to the valu",MatchSource.WIKI,docs/4.6/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html
https://qutip.org/docs/4.6/modules/qutip/wigner.html:24310,Safety,avoid,avoid,24310,"elf._memory_mb} MB is allowed.""; ); if self._cache is None:; self._cache = self._coherent_grid(self._current_size, size); else:; self._cache = np.dstack(; [self._cache, self._coherent_grid(self._current_size, size)]; ); self._current_size = size; return self._cache. def _single(self, vector: np.ndarray, alphas: np.ndarray):; r""""""; Get the Q function (without the :math:`\pi` scaling factor) of a single; state vector.; """"""; return np.abs(np.dot(alphas, (self._g * 0.5) * vector)) ** 2. def __call__(self, state: Qobj):; """"""; Get the Husimi-Q function for the given state vector or density matrix,; over the coordinates used to initialise the class. If called multiple; times, the states do not need to have the same dimensions, but none of; them can have tensor-product structure.; """"""; state = _qfunc_check_state(state); alphas = self._alphas(state.shape[0]); if state.isket:; return self._single(state.full().ravel(), alphas) / np.pi; # We don't use Qobj.eigenstates() to avoid building many unnecessary; # CSR versions of dense matrices.; values, vectors = eigh(state.full()); vectors = vectors.T; out = values[0] * self._single(vectors[0], alphas); for value, vector in zip(values[1:], vectors[1:]):; out += value * self._single(vector, alphas); return out / np.pi. def _qfunc_iterative_single(; vector: np.ndarray, alpha_grid: _QFuncCoherentGrid, g: float,; ):; r""""""; Get the Q function (without the :math:`\pi` scaling factor) of a single; state vector, using the iterative algorithm which recomputes the powers of; the coherent-state matrix.; """"""; ns = np.arange(vector.shape[0]); out = np.polyval(; (0.5*g * vector / np.sqrt(scipy.special.factorial(ns)))[::-1],; alpha_grid.grid,; ); out *= alpha_grid.prefactor; return np.abs(out)**2. [docs]def qfunc(; state: Qobj,; xvec,; yvec,; g: float = sqrt(2),; precompute_memory: float = 1024,; ):; r""""""; Husimi-Q function of a given state vector or density matrix at phase-space; points ``0.5 * g * (xvec + i*yvec)``. Parameters; ----------; state ",MatchSource.WIKI,docs/4.6/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html
https://qutip.org/docs/4.6/modules/qutip/wigner.html:27376,Safety,avoid,avoid,27376,"class-based version, more efficient if you want to calculate the; Husimi-Q function for several states over the same coordinates.; """"""; state = _qfunc_check_state(state); xvec, yvec = _qfunc_check_coordinates(xvec, yvec); required_memory = state.shape[0] * xvec.size * yvec.size * 16 / (1024 ** 2); enough_memory = (; precompute_memory is not None; and precompute_memory > required_memory; ); if state.isoper and enough_memory:; return QFunc(xvec, yvec, g)(state); if precompute_memory is not None and state.isoper:; warnings.warn(; ""Falling back to iterative algorithm due to lack of memory.""; f"" Needed {required_memory:.2f} MB, but only allowed to use""; f"" {precompute_memory:.2f} MB. Increase `precompute_memory` to""; "" raise limit, or set to `None` to suppress warning.""; ); alpha_grid = _QFuncCoherentGrid(xvec, yvec, g); if state.isket:; out = _qfunc_iterative_single(state.full().ravel(), alpha_grid, g); out /= np.pi; return out; # We don't use Qobj.eigenstates() to avoid building many unnecessary CSR; # versions of dense matrices.; values, vectors = eigh(state.full()); vectors = vectors.T; out = values[0] * _qfunc_iterative_single(vectors[0], alpha_grid, g); for value, vector in zip(values[1:], vectors[1:]):; out += value * _qfunc_iterative_single(vector, alpha_grid, g); out /= np.pi; return out. # -----------------------------------------------------------------------------; # PSEUDO DISTRIBUTION FUNCTIONS FOR SPINS; #; [docs]def spin_q_function(rho, theta, phi):; r""""""The Husimi Q function for spins is defined as ``Q(theta, phi) =; SCS.dag() * rho * SCS`` for the spin coherent state ``SCS = spin_coherent(; j, theta, phi)`` where j is the spin length.; The implementation here is more efficient as it doesn't; generate all of the SCS at theta and phi (see references). The spin Q function is normal when integrated over the surface of the; sphere. .. math:: \frac{4 \pi}{2j + 1}\int_\phi \int_\theta; Q(\theta, \phi) \sin(\theta) d\theta d\phi = 1. Parameters; ----------; stat",MatchSource.WIKI,docs/4.6/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html
https://qutip.org/docs/4.6/modules/qutip/wigner.html:4357,Testability,log,log,4357,"the angle slice to be used for each particle in case of a; multi-particle quantum state. 'l' yields an equal angle; slice. 'x', 'y' and 'z' angle slices can also be chosen. Returns; ----------; wigner : list of float; the wigner transformation at `steps` different theta and phi. Raises; ------; ComplexWarning; This can be ignored as it is caused due to rounding errors. Notes; ------; See example notebook wigner_visualisation. References; ------; [1] T. Tilma, M. J. Everitt, J. H. Samson, W. J. Munro,; and K. Nemoto, Phys. Rev. Lett. 117, 180401 (2016).; [2] R. P. Rundle, P. W. Mills, T. Tilma, J. H. Samson, and; M. J. Everitt, Phys. Rev. A 96, 022117 (2017).; """"""; if not (psi.type == 'ket' or psi.type == 'operator' or psi.type == 'bra'):; raise TypeError('Input state is not a valid operator.'). if psi.type == 'ket' or psi.type == 'bra':; rho = ket2dm(psi); else:; rho = psi. sun = 2 # The order of the SU group. # calculate total number of particles in quantum state:; N = np.int32(np.log(np.shape(rho)[0]) / np.log(2 * j + 1)). theta = np.zeros((N, steps)); phi = np.zeros((N, steps)). for i in range(N):; theta[i, :] = np.linspace(0, np.pi, steps); phi[i, :] = np.linspace(0, 2 * np.pi, steps). theta, phi = _angle_slice(np.array(slicearray, dtype=str), theta, phi). wigner = np.zeros((steps, steps)); if fullparity:; pari = _parity(sun**N, j); else:; pari = _parity(sun, j); for t in range(steps):; for p in range(steps):; wigner[t, p] = np.real(np.trace(rho.data @ _kernelsu2(; theta[:, t], phi[:, p], N, j, pari, fullparity))); return wigner. def _parity(N, j):; """"""Private function to calculate the parity of the quantum system.; """"""; if j == 0.5:; pi = np.identity(N) - np.sqrt((N - 1) * N * (N + 1) / 2) * _lambda_f(N); return pi / N; elif j > 0.5:; mult = np.int32(2 * j + 1); matrix = np.zeros((mult, mult)); foo = np.ones(mult); for n in np.arange(-j, j + 1, 1):; for l in np.arange(0, mult, 1):; foo[l] = (2 * l + 1) * qutip.clebsch(j, l, j, n, 0, n); matrix[np.int32(n + j), n",MatchSource.WIKI,docs/4.6/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html
https://qutip.org/docs/4.6/modules/qutip/wigner.html:4384,Testability,log,log,4384,"ach particle in case of a; multi-particle quantum state. 'l' yields an equal angle; slice. 'x', 'y' and 'z' angle slices can also be chosen. Returns; ----------; wigner : list of float; the wigner transformation at `steps` different theta and phi. Raises; ------; ComplexWarning; This can be ignored as it is caused due to rounding errors. Notes; ------; See example notebook wigner_visualisation. References; ------; [1] T. Tilma, M. J. Everitt, J. H. Samson, W. J. Munro,; and K. Nemoto, Phys. Rev. Lett. 117, 180401 (2016).; [2] R. P. Rundle, P. W. Mills, T. Tilma, J. H. Samson, and; M. J. Everitt, Phys. Rev. A 96, 022117 (2017).; """"""; if not (psi.type == 'ket' or psi.type == 'operator' or psi.type == 'bra'):; raise TypeError('Input state is not a valid operator.'). if psi.type == 'ket' or psi.type == 'bra':; rho = ket2dm(psi); else:; rho = psi. sun = 2 # The order of the SU group. # calculate total number of particles in quantum state:; N = np.int32(np.log(np.shape(rho)[0]) / np.log(2 * j + 1)). theta = np.zeros((N, steps)); phi = np.zeros((N, steps)). for i in range(N):; theta[i, :] = np.linspace(0, np.pi, steps); phi[i, :] = np.linspace(0, 2 * np.pi, steps). theta, phi = _angle_slice(np.array(slicearray, dtype=str), theta, phi). wigner = np.zeros((steps, steps)); if fullparity:; pari = _parity(sun**N, j); else:; pari = _parity(sun, j); for t in range(steps):; for p in range(steps):; wigner[t, p] = np.real(np.trace(rho.data @ _kernelsu2(; theta[:, t], phi[:, p], N, j, pari, fullparity))); return wigner. def _parity(N, j):; """"""Private function to calculate the parity of the quantum system.; """"""; if j == 0.5:; pi = np.identity(N) - np.sqrt((N - 1) * N * (N + 1) / 2) * _lambda_f(N); return pi / N; elif j > 0.5:; mult = np.int32(2 * j + 1); matrix = np.zeros((mult, mult)); foo = np.ones(mult); for n in np.arange(-j, j + 1, 1):; for l in np.arange(0, mult, 1):; foo[l] = (2 * l + 1) * qutip.clebsch(j, l, j, n, 0, n); matrix[np.int32(n + j), np.int32(n + j)] = np.sum(foo); ",MatchSource.WIKI,docs/4.6/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html
https://qutip.org/docs/4.6/modules/qutip/wigner.html:20302,Testability,log,logarithmic,20302,"uce the adjoint of the coherent states to save an operation; # later when computing dot products, hence the negative imaginary part.; self.grid.imag = -y; self.prefactor = np.exp(-0.5 * (x * x + y * y)).astype(np.complex128). def _start(self, first: int):; """"""; Get the coherent state matrix corresponding to the first needed Fock; state.; """"""; if first == 0:; return self.prefactor.copy(); out = np.power(self.grid, first); out *= self.prefactor; return out. def __call__(self, first: int, last: int = None):; """"""; Get a 3D array of shape ``(yvec.size, xvec.size, last - first)`` of the; coherent-state vectors for all the Fock states in the range ``first``; to ``last``, excluding the end point. The first two axes are the y-; and x-coordinates of phase space (i.e. Cartesian indexing, like; ``numpy.meshgrid``), and the last runs over the selected range of; Fock-space dimensions.; """"""; ns = np.arange(first, last).reshape(1, 1, -1); # Technically we could avoid hitting the limits of floating-point; # exponents for longer by doing all this in logarithmic space (using; # scipy.special.gammaln), but that ends up involving more; # floating-point operations overall, and needs special care around the; # point alpha = 0 to avoid nan appearing, due to how Python handles; # mixed-width arithmetic operations.; out = np.empty(self.grid.shape + (ns.size,), dtype=np.complex128); out[:, :, 0] = self._start(ns.flat[0]); for i in range(ns.size - 1):; out[:, :, i+1] = out[:, :, i] * self.grid; out /= np.sqrt(scipy.special.factorial(ns)); return out. [docs]class QFunc:; r""""""; Class-based method of calculating the Husimi-Q function of many different; quantum states at fixed phase-space points ``0.5*g* (xvec + i*yvec)``.; This class has slightly higher first-usage costs than :obj:`.qfunc`, but; subsequent operations will be several times faster. However, it can require; quite a lot of memory. Call the created object as a function to retrieve; the Husimi-Q function. Parameters; ----------; xvec, ",MatchSource.WIKI,docs/4.6/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html
https://qutip.org/docs/4.6/modules/qutip/wigner.html:18823,Usability,simpl,simpler,18823,"loat64); if xvec.ndim != 1 or yvec.ndim != 1:; raise ValueError(; f""xvec and yvec must be 1D, but have shapes {xvec.shape} and {yvec.shape}.""; ); return xvec, yvec. class _QFuncCoherentGrid:; """"""; Internal function to compute coherent state operators corresponding to a; grid of complex values in phase space. For efficiency reasons, this class; produces the adjoint of the coherent states, to save allocations when; calculating inner products later. Examples; --------; Initialise the grid calculator. >>> xvec = yvec = np.linspace(-1, 1, 21); >>> g = np.sqrt(0.5); >>> max_ns = 10; >>> grid = _QFuncCoherentGrid(xvec, yvec, g). The naive construction of the grid is. >>> xs, ys = np.meshgrid(xvec, yvec); >>> all_alphas = 0.5 * g * (xs + 1j*ys); >>> naive = np.array([; ... [; ... qutip.coherent(max_ns, alpha, method='analytic'); ... .dag().full().ravel(); ... for alpha in x_alphas; ... ]; ... for y_alphas in all_alphas; ... ]). The naive approach is typically several of orders of magnitude slower than; this class, which uses much simpler vectorised operations. The outputs are; within close tolerance, however:. >>> np.allclose(naive, grid(max_ns)); True; >>> np.allclose(naive[:, :, 4:7], grid(4, 7)); True; """"""; def __init__(self, xvec, yvec, g: float):; self.xvec, self.yvec = _qfunc_check_coordinates(xvec, yvec); x, y = np.meshgrid(0.5 * g * self.xvec, 0.5 * g * self.yvec); self.grid = np.empty(x.shape, dtype=np.complex128); self.grid.real = x; # We produce the adjoint of the coherent states to save an operation; # later when computing dot products, hence the negative imaginary part.; self.grid.imag = -y; self.prefactor = np.exp(-0.5 * (x * x + y * y)).astype(np.complex128). def _start(self, first: int):; """"""; Get the coherent state matrix corresponding to the first needed Fock; state.; """"""; if first == 0:; return self.prefactor.copy(); out = np.power(self.grid, first); out *= self.prefactor; return out. def __call__(self, first: int, last: int = None):; """"""; Get a 3D array o",MatchSource.WIKI,docs/4.6/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:6350,Availability,error,error,6350,"ummary and self.dump_all):; lvl = 'FULL'. return lvl. @level.setter; def level(self, value):; self._level = value; self._apply_level(). @property; def dump_any(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_all(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_dir(self):; if self._dump_dir is None:; self.create_dump_dir(); return self._dump_dir. @dump_dir.setter; def dump_dir(self, value):; self._dump_dir = value; if not self.create_dump_dir():; self._dump_dir = None. [docs] def create_dump_dir(self):; """"""; Checks dump directory exists, creates it if not; """"""; if self._dump_dir is None or len(self._dump_dir) == 0:; self._dump_dir = DUMP_DIR. dir_ok, self._dump_dir, msg = qtrlio.create_dir(; self._dump_dir, desc='dump'). if not dir_ok:; self.write_to_file = False; msg += ""\ndump file output will be suppressed.""; logger.error(msg). return dir_ok. @property; def fname_base(self):; return self._fname_base. @fname_base.setter; def fname_base(self, value):; if not _is_string(value):; raise ValueError(""File name base must be a string""); self._fname_base = value; self._summary_file_path = None. @property; def summary_file(self):; if self._summary_file_path is None:; fname = ""{}-summary.{}"".format(self._fname_base, self.dump_file_ext); self._summary_file_path = os.path.join(self.dump_dir, fname); return self._summary_file_path. @summary_file.setter; def summary_file(self, value):; if not _is_string(value):; raise ValueError(""File path must be a string""); self._summary_file_specified = True; if os.path.abspath(value):; self._summary_file_path = value; elif '~' in value:; self._summary_file_path = os.path.expanduser(value); else:; self._summary_file_path = os.path.join(self.dump_dir, value). [docs]class OptimDump(Dump):; """"""; A container for dumps of optimisation data generated during the pulse; optimisation. Attrib",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:7649,Availability,error,error,7649,"le(self):; if self._summary_file_path is None:; fname = ""{}-summary.{}"".format(self._fname_base, self.dump_file_ext); self._summary_file_path = os.path.join(self.dump_dir, fname); return self._summary_file_path. @summary_file.setter; def summary_file(self, value):; if not _is_string(value):; raise ValueError(""File path must be a string""); self._summary_file_specified = True; if os.path.abspath(value):; self._summary_file_path = value; elif '~' in value:; self._summary_file_path = os.path.expanduser(value); else:; self._summary_file_path = os.path.join(self.dump_dir, value). [docs]class OptimDump(Dump):; """"""; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes; ----------; dump_summary : bool; When True summary items are appended to the iter_summary. iter_summary : list of :class:`optimizer.OptimIterSummary`; Summary at each iteration. dump_fid_err : bool; When True values are appended to the fid_err_log. fid_err_log : list of float; Fidelity error at each call of the fid_err_func. dump_grad_norm : bool; When True values are appended to the fid_err_log. grad_norm_log : list of float; Gradient norm at each call of the grad_norm_log. dump_grad : bool; When True values are appended to the grad_log. grad_log : list of ndarray; Gradients at each call of the fid_grad_func. """"""; def __init__(self, optim, level='SUMMARY'):; from qutip.control.optimizer import Optimizer; if not isinstance(optim, Optimizer):; raise TypeError(""Must instantiate with {} type"".format(; Optimizer)); self.parent = optim; self._level = level; self.reset(). def reset(self):; Dump.reset(self); self._apply_level(); self.iter_summary = []; self.fid_err_log = []; self.grad_norm_log = []; self.grad_log = []; self._fname_base = 'optimdump'; self._fid_err_file = None; self._grad_norm_file = None. def clear(self):; del self.iter_summary[:]; self.fid_err_log[:]; self.grad_norm_log[:]; self.grad_log[:]. @property; def dump_any(self):; """"""True if anything other than th",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:9870,Availability,avail,available,9870,"e summary) is to be dumped""""""; if (self.dump_fid_err and self.dump_grad_norm and self.dump_grad):; return True; else:; return False. def _apply_level(self, level=None):; if level is None:; level = self._level. if not _is_string(level):; raise ValueError(""Dump level must be a string""); level = level.upper(); if level == 'CUSTOM':; if self._level == 'CUSTOM':; # dumping level has not changed keep the same specific config; pass; else:; # Switching to custom, start from SUMMARY; level = 'SUMMARY'. if level == 'SUMMARY':; self.dump_summary = True; self.dump_fid_err = False; self.dump_grad_norm = False; self.dump_grad = False; elif level == 'FULL':; self.dump_summary = True; self.dump_fid_err = True; self.dump_grad_norm = True; self.dump_grad = True; else:; raise ValueError(""No option for dumping level '{}'"".format(level)). [docs] def add_iter_summary(self):; """"""add copy of current optimizer iteration summary""""""; optim = self.parent; if optim.iter_summary is None:; raise RuntimeError(""Cannot add iter_summary as not available""); ois = copy.copy(optim.iter_summary); ois.idx = len(self.iter_summary); self.iter_summary.append(ois); if self.write_to_file:; if ois.idx == 0:; f = open(self.summary_file, 'w'); f.write(""{}\n{}\n"".format(; ois.get_header_line(self.summary_sep),; ois.get_value_line(self.summary_sep))); else:; f = open(self.summary_file, 'a'); f.write(""{}\n"".format(; ois.get_value_line(self.summary_sep))). f.close(); return ois. @property; def fid_err_file(self):; if self._fid_err_file is None:; fname = ""{}-fid_err_log.{}"".format(self.fname_base,; self.dump_file_ext); self._fid_err_file = os.path.join(self.dump_dir, fname); return self._fid_err_file. [docs] def update_fid_err_log(self, fid_err):; """"""add an entry to the fid_err log""""""; self.fid_err_log.append(fid_err); if self.write_to_file:; if len(self.fid_err_log) == 1:; mode = 'w'; else:; mode = 'a'; f = open(self.fid_err_file, mode); f.write(""{}\n"".format(fid_err)); f.close(). @property; def grad_norm_file(self):",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:12995,Availability,error,errors,12995,"ed then it must be a byte mode file; as numpy.savetxt is used, and requires this.; """"""; fall = None; # If specific file given then write everything to it; if hasattr(f, 'write'):; if not 'b' in f.mode:; raise RuntimeError(""File stream must be in binary mode""); # write all to this stream; fall = f; fs = f; closefall = False; closefs = False; elif f:; # Assume f is a filename; fall = open(f, 'wb'); fs = fall; closefs = False; closefall = True; else:; self.create_dump_dir(); closefall = False; if self.dump_summary:; fs = open(self.summary_file, 'wb'); closefs = True. if self.dump_summary:; for ois in self.iter_summary:; if ois.idx == 0:; fs.write(asbytes(""{}\n{}\n"".format(; ois.get_header_line(self.summary_sep),; ois.get_value_line(self.summary_sep)))); else:; fs.write(asbytes(""{}\n"".format(; ois.get_value_line(self.summary_sep)))). if closefs:; fs.close(); logger.info(""Optim dump summary saved to {}"".format(; self.summary_file)). if self.dump_fid_err:; if fall:; fall.write(asbytes(""Fidelity errors:\n"")); np.savetxt(fall, self.fid_err_log); else:; np.savetxt(self.fid_err_file, self.fid_err_log). if self.dump_grad_norm:; if fall:; fall.write(asbytes(""gradients norms:\n"")); np.savetxt(fall, self.grad_norm_log); else:; np.savetxt(self.grad_norm_file, self.grad_norm_log). if self.dump_grad:; g_num = 0; for grad in self.grad_log:; g_num += 1; if fall:; fall.write(asbytes(""gradients (call {}):\n"".format(g_num))); np.savetxt(fall, grad); else:; fname = ""{}-fid_err_gradients{}.{}"".format(self.fname_base,; g_num,; self.dump_file_ext); fpath = os.path.join(self.dump_dir, fname); np.savetxt(fpath, grad, delimiter=self.data_sep). if closefall:; fall.close(); logger.info(""Optim dump saved to {}"".format(f)); else:; if fall:; logger.info(""Optim dump saved to specified stream""); else:; logger.info(""Optim dump saved to {}"".format(self.dump_dir)). [docs]class DynamicsDump(Dump):; """"""; A container for dumps of dynamics data. Mainly time evolution calculations. Attributes; ----------; dump",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:17946,Availability,avail,available,17946,"se:; raise ValueError(""No option for dumping level '{}'"".format(level)). [docs] def add_evo_dump(self):; """"""Add dump of current time evolution generating objects""""""; dyn = self.parent; item = EvoCompDumpItem(self); item.idx = len(self.evo_dumps); self.evo_dumps.append(item); if self.dump_amps:; item.ctrl_amps = copy.deepcopy(dyn.ctrl_amps); if self.dump_dyn_gen:; item.dyn_gen = copy.deepcopy(dyn._dyn_gen); if self.dump_prop:; item.prop = copy.deepcopy(dyn._prop); if self.dump_prop_grad:; item.prop_grad = copy.deepcopy(dyn._prop_grad); if self.dump_fwd_evo:; item.fwd_evo = copy.deepcopy(dyn._fwd_evo); if self.dump_onwd_evo:; item.onwd_evo = copy.deepcopy(dyn._onwd_evo); if self.dump_onto_evo:; item.onto_evo = copy.deepcopy(dyn._onto_evo). if self.write_to_file:; item.writeout(); return item. [docs] def add_evo_comp_summary(self, dump_item_idx=None):; """"""add copy of current evo comp summary""""""; dyn = self.parent; if dyn.tslot_computer.evo_comp_summary is None:; raise RuntimeError(""Cannot add evo_comp_summary as not available""); ecs = copy.copy(dyn.tslot_computer.evo_comp_summary); ecs.idx = len(self.evo_summary); ecs.evo_dump_idx = dump_item_idx; if dyn.stats:; ecs.iter_num = dyn.stats.num_iter; ecs.fid_func_call_num = dyn.stats.num_fidelity_func_calls; ecs.grad_func_call_num = dyn.stats.num_grad_func_calls. self.evo_summary.append(ecs); if self.write_to_file:; if ecs.idx == 0:; f = open(self.summary_file, 'w'); f.write(""{}\n{}\n"".format(; ecs.get_header_line(self.summary_sep),; ecs.get_value_line(self.summary_sep))); else:; f = open(self.summary_file, 'a'); f.write(""{}\n"".format(ecs.get_value_line(self.summary_sep))). f.close(); return ecs. [docs] def writeout(self, f=None):; """"""; Write all the dump items and the summary out to file(s). Parameters; ----------; f : filename or filehandle; If specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated in; the dump_dir. If a filehandle is specified the",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:26038,Deployability,update,updated,26038,"es(""Evolution from {} to end\n"".format(k))); np.savetxt(f, self.fwd_evo[k], delimiter=dump.data_sep); k += 1; if closef: f.close(). # onto evolution; if not self.onto_evo is None:; k = 0; if fall:; f = fall; f.write(asbytes(""Onto evolution\n"")); else:; fname = ""{}-onto_evo.{}"".format(fnbase,; dump.dump_file_ext); f = open(os.path.join(dump.dump_dir, fname), 'wb'); closef = True; for dg in self.dyn_gen:; f.write(asbytes(""Evolution from {} onto target\n"".format(k))); np.savetxt(f, self.fwd_evo[k], delimiter=dump.data_sep); k += 1; if closef: f.close(). if closefall:; fall.close(). [docs]class DumpSummaryItem:; """"""; A summary of the most recent iteration. Abstract class only. Attributes; ----------; idx : int; Index in the summary list in which this is stored; """"""; min_col_width = 11; summary_property_names = (). summary_property_fmt_type = (). summary_property_fmt_prec = (). @classmethod; def get_header_line(cls, sep=' '):; if sep == ' ':; line = ''; i = 0; for a in cls.summary_property_names:; if i > 0:; line += sep; i += 1; line += format(a, str(max(len(a), cls.min_col_width)) + 's'); else:; line = sep.join(cls.summary_property_names); return line. def reset(self):; self.idx = 0. def get_value_line(self, sep=' '):; line = """"; i = 0; for a in zip(self.summary_property_names,; self.summary_property_fmt_type,; self.summary_property_fmt_prec):; if i > 0:; line += sep; i += 1; v = getattr(self, a[0]); w = max(len(a[0]), self.min_col_width); if v is not None:; fmt = ''; if sep == ' ':; fmt += str(w); else:; fmt += '0'; if a[2] > 0:; fmt += '.' + str(a[2]); fmt += a[1]; line += format(v, fmt); else:; if sep == ' ':; line += format('None', str(w) + 's'); else:; line += 'None'. return line. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:2874,Integrability,depend,depends,2874," (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. """"""; Classes that enable the storing of historical objects created during the; pulse optimisation.; These are intented for debugging.; See the optimizer and dynamics objects for instrutcions on how to enable; data dumping.; """""". import os; import numpy as np; import copy; # QuTiP logging; import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); # QuTiP control modules; import qutip.control.io as qtrlio; from numpy.compat import asbytes. DUMP_DIR = ""~/.qtrl_dump"". def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Dump(object):; """"""; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes; ----------; parent : some control object (Dynamics or Optimizer); aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir : str; directory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. level : string; level of data dumping: SUMMARY, FULL or CUSTOM; See property docstring for details; Set automatically if dump is created by the setting host dumping attrib. write_to_file : bool; When set True data and summaries (as configured) will be written; interactively to file during the processing; Set during instantiation by the host based on its dump_to_file attrib. dump_file_ext : str; Default file extension for any file names that are auto generated. fname_base : str; First part of any auto generated file names.; ",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:3583,Modifiability,config,configured,3583,"nce(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Dump(object):; """"""; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes; ----------; parent : some control object (Dynamics or Optimizer); aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir : str; directory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. level : string; level of data dumping: SUMMARY, FULL or CUSTOM; See property docstring for details; Set automatically if dump is created by the setting host dumping attrib. write_to_file : bool; When set True data and summaries (as configured) will be written; interactively to file during the processing; Set during instantiation by the host based on its dump_to_file attrib. dump_file_ext : str; Default file extension for any file names that are auto generated. fname_base : str; First part of any auto generated file names.; This is usually overridden in the subclass. dump_summary : bool; If True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sep : str; delimiter for the summary file.; default is a space. data_sep : str; delimiter for the data files (arrays saved to file).; default is a space. summary_file : str; File path for summary file.; Automatically generated. Can be set specifically. """"""; def __init__(self):; self.reset(). def reset(self):; if self.parent:; self.log_level = self.parent.log_level; self.write_to_file = self.parent.dump_to_file; else:; self.write_to_file = False; self._dump_dir = None; self.dump_file_ext = ""txt""; self._fname_base = 'dump'; self.dump_summary = True; self.summary_sep = ' '",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:9261,Modifiability,config,config,9261,"reset(self); self._apply_level(); self.iter_summary = []; self.fid_err_log = []; self.grad_norm_log = []; self.grad_log = []; self._fname_base = 'optimdump'; self._fid_err_file = None; self._grad_norm_file = None. def clear(self):; del self.iter_summary[:]; self.fid_err_log[:]; self.grad_norm_log[:]; self.grad_log[:]. @property; def dump_any(self):; """"""True if anything other than the summary is to be dumped""""""; if (self.dump_fid_err or self.dump_grad_norm or self.dump_grad):; return True; else:; return False. @property; def dump_all(self):; """"""True if everything (ignoring the summary) is to be dumped""""""; if (self.dump_fid_err and self.dump_grad_norm and self.dump_grad):; return True; else:; return False. def _apply_level(self, level=None):; if level is None:; level = self._level. if not _is_string(level):; raise ValueError(""Dump level must be a string""); level = level.upper(); if level == 'CUSTOM':; if self._level == 'CUSTOM':; # dumping level has not changed keep the same specific config; pass; else:; # Switching to custom, start from SUMMARY; level = 'SUMMARY'. if level == 'SUMMARY':; self.dump_summary = True; self.dump_fid_err = False; self.dump_grad_norm = False; self.dump_grad = False; elif level == 'FULL':; self.dump_summary = True; self.dump_fid_err = True; self.dump_grad_norm = True; self.dump_grad = True; else:; raise ValueError(""No option for dumping level '{}'"".format(level)). [docs] def add_iter_summary(self):; """"""add copy of current optimizer iteration summary""""""; optim = self.parent; if optim.iter_summary is None:; raise RuntimeError(""Cannot add iter_summary as not available""); ois = copy.copy(optim.iter_summary); ois.idx = len(self.iter_summary); self.iter_summary.append(ois); if self.write_to_file:; if ois.idx == 0:; f = open(self.summary_file, 'w'); f.write(""{}\n{}\n"".format(; ois.get_header_line(self.summary_sep),; ois.get_value_line(self.summary_sep))); else:; f = open(self.summary_file, 'a'); f.write(""{}\n"".format(; ois.get_value_line(self.summar",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:16314,Modifiability,config,config,16314,"any(self):; """"""True if any of the calculation objects are to be dumped""""""; if (self.dump_amps or; self.dump_dyn_gen or; self.dump_prop or; self.dump_prop_grad or; self.dump_fwd_evo or; self.dump_onwd_evo or; self.dump_onto_evo):; return True; else:; return False. @property; def dump_all(self):; """"""True if all of the calculation objects are to be dumped""""""; dyn = self.parent; if (self.dump_amps and; self.dump_dyn_gen and; self.dump_prop and; self.dump_prop_grad and; self.dump_fwd_evo and; (self.dump_onwd_evo) or; (self.dump_onwd_evo == dyn.fid_computer.uses_onwd_evo) and; (self.dump_onto_evo or; (self.dump_onto_evo == dyn.fid_computer.uses_onto_evo))):; return True; else:; return False. def _apply_level(self, level=None):; dyn = self.parent; if level is None:; level = self._level. if not _is_string(level):; raise ValueError(""Dump level must be a string""); level = level.upper(); if level == 'CUSTOM':; if self._level == 'CUSTOM':; # dumping level has not changed keep the same specific config; pass; else:; # Switching to custom, start from SUMMARY; level = 'SUMMARY'. if level == 'SUMMARY':; self.dump_summary = True; self.dump_amps = False; self.dump_dyn_gen = False; self.dump_prop = False; self.dump_prop_grad = False; self.dump_fwd_evo = False; self.dump_onwd_evo = False; self.dump_onto_evo = False; elif level == 'FULL':; self.dump_summary = True; self.dump_amps = True; self.dump_dyn_gen = True; self.dump_prop = True; self.dump_prop_grad = True; self.dump_fwd_evo = True; self.dump_onwd_evo = dyn.fid_computer.uses_onwd_evo; self.dump_onto_evo = dyn.fid_computer.uses_onto_evo; else:; raise ValueError(""No option for dumping level '{}'"".format(level)). [docs] def add_evo_dump(self):; """"""Add dump of current time evolution generating objects""""""; dyn = self.parent; item = EvoCompDumpItem(self); item.idx = len(self.evo_dumps); self.evo_dumps.append(item); if self.dump_amps:; item.ctrl_amps = copy.deepcopy(dyn.ctrl_amps); if self.dump_dyn_gen:; item.dyn_gen = copy.deepcopy(dyn._",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:2248,Performance,optimiz,optimizer,2248,"LDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. """"""; Classes that enable the storing of historical objects created during the; pulse optimisation.; These are intented for debugging.; See the optimizer and dynamics objects for instrutcions on how to enable; data dumping.; """""". import os; import numpy as np; import copy; # QuTiP logging; import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); # QuTiP control modules; import qutip.control.io as qtrlio; from numpy.compat import asbytes. DUMP_DIR = ""~/.qtrl_dump"". def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Dump(object):; """"""; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes; ----------; parent : some control object (Dynamics or Optimizer); aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir : str; directory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file i",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:7484,Performance,optimiz,optimizer,7484,"lf, value):; if not _is_string(value):; raise ValueError(""File name base must be a string""); self._fname_base = value; self._summary_file_path = None. @property; def summary_file(self):; if self._summary_file_path is None:; fname = ""{}-summary.{}"".format(self._fname_base, self.dump_file_ext); self._summary_file_path = os.path.join(self.dump_dir, fname); return self._summary_file_path. @summary_file.setter; def summary_file(self, value):; if not _is_string(value):; raise ValueError(""File path must be a string""); self._summary_file_specified = True; if os.path.abspath(value):; self._summary_file_path = value; elif '~' in value:; self._summary_file_path = os.path.expanduser(value); else:; self._summary_file_path = os.path.join(self.dump_dir, value). [docs]class OptimDump(Dump):; """"""; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes; ----------; dump_summary : bool; When True summary items are appended to the iter_summary. iter_summary : list of :class:`optimizer.OptimIterSummary`; Summary at each iteration. dump_fid_err : bool; When True values are appended to the fid_err_log. fid_err_log : list of float; Fidelity error at each call of the fid_err_func. dump_grad_norm : bool; When True values are appended to the fid_err_log. grad_norm_log : list of float; Gradient norm at each call of the grad_norm_log. dump_grad : bool; When True values are appended to the grad_log. grad_log : list of ndarray; Gradients at each call of the fid_grad_func. """"""; def __init__(self, optim, level='SUMMARY'):; from qutip.control.optimizer import Optimizer; if not isinstance(optim, Optimizer):; raise TypeError(""Must instantiate with {} type"".format(; Optimizer)); self.parent = optim; self._level = level; self.reset(). def reset(self):; Dump.reset(self); self._apply_level(); self.iter_summary = []; self.fid_err_log = []; self.grad_norm_log = []; self.grad_log = []; self._fname_base = 'optimdump'; self._fid_err_file = None; self._grad_norm_file = N",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:8049,Performance,optimiz,optimizer,8049,"; self._summary_file_path = os.path.expanduser(value); else:; self._summary_file_path = os.path.join(self.dump_dir, value). [docs]class OptimDump(Dump):; """"""; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes; ----------; dump_summary : bool; When True summary items are appended to the iter_summary. iter_summary : list of :class:`optimizer.OptimIterSummary`; Summary at each iteration. dump_fid_err : bool; When True values are appended to the fid_err_log. fid_err_log : list of float; Fidelity error at each call of the fid_err_func. dump_grad_norm : bool; When True values are appended to the fid_err_log. grad_norm_log : list of float; Gradient norm at each call of the grad_norm_log. dump_grad : bool; When True values are appended to the grad_log. grad_log : list of ndarray; Gradients at each call of the fid_grad_func. """"""; def __init__(self, optim, level='SUMMARY'):; from qutip.control.optimizer import Optimizer; if not isinstance(optim, Optimizer):; raise TypeError(""Must instantiate with {} type"".format(; Optimizer)); self.parent = optim; self._level = level; self.reset(). def reset(self):; Dump.reset(self); self._apply_level(); self.iter_summary = []; self.fid_err_log = []; self.grad_norm_log = []; self.grad_log = []; self._fname_base = 'optimdump'; self._fid_err_file = None; self._grad_norm_file = None. def clear(self):; del self.iter_summary[:]; self.fid_err_log[:]; self.grad_norm_log[:]; self.grad_log[:]. @property; def dump_any(self):; """"""True if anything other than the summary is to be dumped""""""; if (self.dump_fid_err or self.dump_grad_norm or self.dump_grad):; return True; else:; return False. @property; def dump_all(self):; """"""True if everything (ignoring the summary) is to be dumped""""""; if (self.dump_fid_err and self.dump_grad_norm and self.dump_grad):; return True; else:; return False. def _apply_level(self, level=None):; if level is None:; level = self._level. if not _is_string(level):; raise ValueError(""Dump l",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:9734,Performance,optimiz,optimizer,9734," self.dump_grad):; return True; else:; return False. @property; def dump_all(self):; """"""True if everything (ignoring the summary) is to be dumped""""""; if (self.dump_fid_err and self.dump_grad_norm and self.dump_grad):; return True; else:; return False. def _apply_level(self, level=None):; if level is None:; level = self._level. if not _is_string(level):; raise ValueError(""Dump level must be a string""); level = level.upper(); if level == 'CUSTOM':; if self._level == 'CUSTOM':; # dumping level has not changed keep the same specific config; pass; else:; # Switching to custom, start from SUMMARY; level = 'SUMMARY'. if level == 'SUMMARY':; self.dump_summary = True; self.dump_fid_err = False; self.dump_grad_norm = False; self.dump_grad = False; elif level == 'FULL':; self.dump_summary = True; self.dump_fid_err = True; self.dump_grad_norm = True; self.dump_grad = True; else:; raise ValueError(""No option for dumping level '{}'"".format(level)). [docs] def add_iter_summary(self):; """"""add copy of current optimizer iteration summary""""""; optim = self.parent; if optim.iter_summary is None:; raise RuntimeError(""Cannot add iter_summary as not available""); ois = copy.copy(optim.iter_summary); ois.idx = len(self.iter_summary); self.iter_summary.append(ois); if self.write_to_file:; if ois.idx == 0:; f = open(self.summary_file, 'w'); f.write(""{}\n{}\n"".format(; ois.get_header_line(self.summary_sep),; ois.get_value_line(self.summary_sep))); else:; f = open(self.summary_file, 'a'); f.write(""{}\n"".format(; ois.get_value_line(self.summary_sep))). f.close(); return ois. @property; def fid_err_file(self):; if self._fid_err_file is None:; fname = ""{}-fid_err_log.{}"".format(self.fname_base,; self.dump_file_ext); self._fid_err_file = os.path.join(self.dump_dir, fname); return self._fid_err_file. [docs] def update_fid_err_log(self, fid_err):; """"""add an entry to the fid_err log""""""; self.fid_err_log.append(fid_err); if self.write_to_file:; if len(self.fid_err_log) == 1:; mode = 'w'; else:; mode = 'a",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:2386,Testability,log,logging,2386,"NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. """"""; Classes that enable the storing of historical objects created during the; pulse optimisation.; These are intented for debugging.; See the optimizer and dynamics objects for instrutcions on how to enable; data dumping.; """""". import os; import numpy as np; import copy; # QuTiP logging; import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); # QuTiP control modules; import qutip.control.io as qtrlio; from numpy.compat import asbytes. DUMP_DIR = ""~/.qtrl_dump"". def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Dump(object):; """"""; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes; ----------; parent : some control object (Dynamics or Optimizer); aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir : str; directory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. level : string; leve",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:2423,Testability,log,logger,2423,"ABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. """"""; Classes that enable the storing of historical objects created during the; pulse optimisation.; These are intented for debugging.; See the optimizer and dynamics objects for instrutcions on how to enable; data dumping.; """""". import os; import numpy as np; import copy; # QuTiP logging; import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); # QuTiP control modules; import qutip.control.io as qtrlio; from numpy.compat import asbytes. DUMP_DIR = ""~/.qtrl_dump"". def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Dump(object):; """"""; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes; ----------; parent : some control object (Dynamics or Optimizer); aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir : str; directory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. level : string; level of data dumping: SUMMARY, FULL or CUSTOM; See prop",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:4758,Testability,log,logger,4758," : str; Default file extension for any file names that are auto generated. fname_base : str; First part of any auto generated file names.; This is usually overridden in the subclass. dump_summary : bool; If True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sep : str; delimiter for the summary file.; default is a space. data_sep : str; delimiter for the data files (arrays saved to file).; default is a space. summary_file : str; File path for summary file.; Automatically generated. Can be set specifically. """"""; def __init__(self):; self.reset(). def reset(self):; if self.parent:; self.log_level = self.parent.log_level; self.write_to_file = self.parent.dump_to_file; else:; self.write_to_file = False; self._dump_dir = None; self.dump_file_ext = ""txt""; self._fname_base = 'dump'; self.dump_summary = True; self.summary_sep = ' '; self.data_sep = ' '; self._summary_file_path = None; self._summary_file_specified = False. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def level(self):; """"""; The level of data dumping that will occur. SUMMARY; A summary will be recorded. FULL; All possible dumping. CUSTOM; Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped; """"""; lvl = 'CUSTOM'; if (self.dump_summary and not self.dump_any):; lvl = 'SUMMARY'; elif (self.dump_summary and self.dump_all):; lvl = 'FULL'. return lvl. @level.setter; def level(self, value):; self._level = value; self._apply_level(). @property; def dump_any(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_all(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsD",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:4876,Testability,log,logger,4876,"t of any auto generated file names.; This is usually overridden in the subclass. dump_summary : bool; If True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sep : str; delimiter for the summary file.; default is a space. data_sep : str; delimiter for the data files (arrays saved to file).; default is a space. summary_file : str; File path for summary file.; Automatically generated. Can be set specifically. """"""; def __init__(self):; self.reset(). def reset(self):; if self.parent:; self.log_level = self.parent.log_level; self.write_to_file = self.parent.dump_to_file; else:; self.write_to_file = False; self._dump_dir = None; self.dump_file_ext = ""txt""; self._fname_base = 'dump'; self.dump_summary = True; self.summary_sep = ' '; self.data_sep = ' '; self._summary_file_path = None; self._summary_file_specified = False. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def level(self):; """"""; The level of data dumping that will occur. SUMMARY; A summary will be recorded. FULL; All possible dumping. CUSTOM; Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped; """"""; lvl = 'CUSTOM'; if (self.dump_summary and not self.dump_any):; lvl = 'SUMMARY'; elif (self.dump_summary and self.dump_all):; lvl = 'FULL'. return lvl. @level.setter; def level(self, value):; self._level = value; self._apply_level(). @property; def dump_any(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_all(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_dir(self):; if self._dump_dir is None:; self.create_dump_dir();",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:4897,Testability,log,logger,4897,"t of any auto generated file names.; This is usually overridden in the subclass. dump_summary : bool; If True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sep : str; delimiter for the summary file.; default is a space. data_sep : str; delimiter for the data files (arrays saved to file).; default is a space. summary_file : str; File path for summary file.; Automatically generated. Can be set specifically. """"""; def __init__(self):; self.reset(). def reset(self):; if self.parent:; self.log_level = self.parent.log_level; self.write_to_file = self.parent.dump_to_file; else:; self.write_to_file = False; self._dump_dir = None; self.dump_file_ext = ""txt""; self._fname_base = 'dump'; self.dump_summary = True; self.summary_sep = ' '; self.data_sep = ' '; self._summary_file_path = None; self._summary_file_specified = False. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def level(self):; """"""; The level of data dumping that will occur. SUMMARY; A summary will be recorded. FULL; All possible dumping. CUSTOM; Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped; """"""; lvl = 'CUSTOM'; if (self.dump_summary and not self.dump_any):; lvl = 'SUMMARY'; elif (self.dump_summary and self.dump_all):; lvl = 'FULL'. return lvl. @level.setter; def level(self, value):; self._level = value; self._apply_level(). @property; def dump_any(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_all(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_dir(self):; if self._dump_dir is None:; self.create_dump_dir();",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:4924,Testability,log,logger,4924,"class. dump_summary : bool; If True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sep : str; delimiter for the summary file.; default is a space. data_sep : str; delimiter for the data files (arrays saved to file).; default is a space. summary_file : str; File path for summary file.; Automatically generated. Can be set specifically. """"""; def __init__(self):; self.reset(). def reset(self):; if self.parent:; self.log_level = self.parent.log_level; self.write_to_file = self.parent.dump_to_file; else:; self.write_to_file = False; self._dump_dir = None; self.dump_file_ext = ""txt""; self._fname_base = 'dump'; self.dump_summary = True; self.summary_sep = ' '; self.data_sep = ' '; self._summary_file_path = None; self._summary_file_specified = False. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def level(self):; """"""; The level of data dumping that will occur. SUMMARY; A summary will be recorded. FULL; All possible dumping. CUSTOM; Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped; """"""; lvl = 'CUSTOM'; if (self.dump_summary and not self.dump_any):; lvl = 'SUMMARY'; elif (self.dump_summary and self.dump_all):; lvl = 'FULL'. return lvl. @level.setter; def level(self, value):; self._level = value; self._apply_level(). @property; def dump_any(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_all(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_dir(self):; if self._dump_dir is None:; self.create_dump_dir(); return self._dump_dir. @dump_dir.setter; def dump_dir(self, value):; self",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:6343,Testability,log,logger,6343,"elf.dump_summary and self.dump_all):; lvl = 'FULL'. return lvl. @level.setter; def level(self, value):; self._level = value; self._apply_level(). @property; def dump_any(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_all(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_dir(self):; if self._dump_dir is None:; self.create_dump_dir(); return self._dump_dir. @dump_dir.setter; def dump_dir(self, value):; self._dump_dir = value; if not self.create_dump_dir():; self._dump_dir = None. [docs] def create_dump_dir(self):; """"""; Checks dump directory exists, creates it if not; """"""; if self._dump_dir is None or len(self._dump_dir) == 0:; self._dump_dir = DUMP_DIR. dir_ok, self._dump_dir, msg = qtrlio.create_dir(; self._dump_dir, desc='dump'). if not dir_ok:; self.write_to_file = False; msg += ""\ndump file output will be suppressed.""; logger.error(msg). return dir_ok. @property; def fname_base(self):; return self._fname_base. @fname_base.setter; def fname_base(self, value):; if not _is_string(value):; raise ValueError(""File name base must be a string""); self._fname_base = value; self._summary_file_path = None. @property; def summary_file(self):; if self._summary_file_path is None:; fname = ""{}-summary.{}"".format(self._fname_base, self.dump_file_ext); self._summary_file_path = os.path.join(self.dump_dir, fname); return self._summary_file_path. @summary_file.setter; def summary_file(self, value):; if not _is_string(value):; raise ValueError(""File path must be a string""); self._summary_file_specified = True; if os.path.abspath(value):; self._summary_file_path = value; elif '~' in value:; self._summary_file_path = os.path.expanduser(value); else:; self._summary_file_path = os.path.join(self.dump_dir, value). [docs]class OptimDump(Dump):; """"""; A container for dumps of optimisation data generated during the pulse; optimisat",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:10601,Testability,log,log,10601," = True; self.dump_grad = True; else:; raise ValueError(""No option for dumping level '{}'"".format(level)). [docs] def add_iter_summary(self):; """"""add copy of current optimizer iteration summary""""""; optim = self.parent; if optim.iter_summary is None:; raise RuntimeError(""Cannot add iter_summary as not available""); ois = copy.copy(optim.iter_summary); ois.idx = len(self.iter_summary); self.iter_summary.append(ois); if self.write_to_file:; if ois.idx == 0:; f = open(self.summary_file, 'w'); f.write(""{}\n{}\n"".format(; ois.get_header_line(self.summary_sep),; ois.get_value_line(self.summary_sep))); else:; f = open(self.summary_file, 'a'); f.write(""{}\n"".format(; ois.get_value_line(self.summary_sep))). f.close(); return ois. @property; def fid_err_file(self):; if self._fid_err_file is None:; fname = ""{}-fid_err_log.{}"".format(self.fname_base,; self.dump_file_ext); self._fid_err_file = os.path.join(self.dump_dir, fname); return self._fid_err_file. [docs] def update_fid_err_log(self, fid_err):; """"""add an entry to the fid_err log""""""; self.fid_err_log.append(fid_err); if self.write_to_file:; if len(self.fid_err_log) == 1:; mode = 'w'; else:; mode = 'a'; f = open(self.fid_err_file, mode); f.write(""{}\n"".format(fid_err)); f.close(). @property; def grad_norm_file(self):; if self._grad_norm_file is None:; fname = ""{}-grad_norm_log.{}"".format(self.fname_base,; self.dump_file_ext); self._grad_norm_file = os.path.join(self.dump_dir, fname); return self._grad_norm_file. [docs] def update_grad_norm_log(self, grad_norm):; """"""add an entry to the grad_norm log""""""; self.grad_norm_log.append(grad_norm); if self.write_to_file:; if len(self.grad_norm_log) == 1:; mode = 'w'; else:; mode = 'a'; f = open(self.grad_norm_file, mode); f.write(""{}\n"".format(grad_norm)); f.close(). [docs] def update_grad_log(self, grad):; """"""add an entry to the grad log""""""; self.grad_log.append(grad); if self.write_to_file:; fname = ""{}-fid_err_gradients{}.{}"".format(self.fname_base,; len(self.grad_log),; self.dump_",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:11129,Testability,log,log,11129,"get_header_line(self.summary_sep),; ois.get_value_line(self.summary_sep))); else:; f = open(self.summary_file, 'a'); f.write(""{}\n"".format(; ois.get_value_line(self.summary_sep))). f.close(); return ois. @property; def fid_err_file(self):; if self._fid_err_file is None:; fname = ""{}-fid_err_log.{}"".format(self.fname_base,; self.dump_file_ext); self._fid_err_file = os.path.join(self.dump_dir, fname); return self._fid_err_file. [docs] def update_fid_err_log(self, fid_err):; """"""add an entry to the fid_err log""""""; self.fid_err_log.append(fid_err); if self.write_to_file:; if len(self.fid_err_log) == 1:; mode = 'w'; else:; mode = 'a'; f = open(self.fid_err_file, mode); f.write(""{}\n"".format(fid_err)); f.close(). @property; def grad_norm_file(self):; if self._grad_norm_file is None:; fname = ""{}-grad_norm_log.{}"".format(self.fname_base,; self.dump_file_ext); self._grad_norm_file = os.path.join(self.dump_dir, fname); return self._grad_norm_file. [docs] def update_grad_norm_log(self, grad_norm):; """"""add an entry to the grad_norm log""""""; self.grad_norm_log.append(grad_norm); if self.write_to_file:; if len(self.grad_norm_log) == 1:; mode = 'w'; else:; mode = 'a'; f = open(self.grad_norm_file, mode); f.write(""{}\n"".format(grad_norm)); f.close(). [docs] def update_grad_log(self, grad):; """"""add an entry to the grad log""""""; self.grad_log.append(grad); if self.write_to_file:; fname = ""{}-fid_err_gradients{}.{}"".format(self.fname_base,; len(self.grad_log),; self.dump_file_ext); fpath = os.path.join(self.dump_dir, fname); np.savetxt(fpath, grad, delimiter=self.data_sep). [docs] def writeout(self, f=None):; """"""write all the logs and the summary out to file(s). Parameters; ----------; f : filename or filehandle; If specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this.; """"""; fall = None; #",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:11416,Testability,log,log,11416,"g.{}"".format(self.fname_base,; self.dump_file_ext); self._fid_err_file = os.path.join(self.dump_dir, fname); return self._fid_err_file. [docs] def update_fid_err_log(self, fid_err):; """"""add an entry to the fid_err log""""""; self.fid_err_log.append(fid_err); if self.write_to_file:; if len(self.fid_err_log) == 1:; mode = 'w'; else:; mode = 'a'; f = open(self.fid_err_file, mode); f.write(""{}\n"".format(fid_err)); f.close(). @property; def grad_norm_file(self):; if self._grad_norm_file is None:; fname = ""{}-grad_norm_log.{}"".format(self.fname_base,; self.dump_file_ext); self._grad_norm_file = os.path.join(self.dump_dir, fname); return self._grad_norm_file. [docs] def update_grad_norm_log(self, grad_norm):; """"""add an entry to the grad_norm log""""""; self.grad_norm_log.append(grad_norm); if self.write_to_file:; if len(self.grad_norm_log) == 1:; mode = 'w'; else:; mode = 'a'; f = open(self.grad_norm_file, mode); f.write(""{}\n"".format(grad_norm)); f.close(). [docs] def update_grad_log(self, grad):; """"""add an entry to the grad log""""""; self.grad_log.append(grad); if self.write_to_file:; fname = ""{}-fid_err_gradients{}.{}"".format(self.fname_base,; len(self.grad_log),; self.dump_file_ext); fpath = os.path.join(self.dump_dir, fname); np.savetxt(fpath, grad, delimiter=self.data_sep). [docs] def writeout(self, f=None):; """"""write all the logs and the summary out to file(s). Parameters; ----------; f : filename or filehandle; If specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this.; """"""; fall = None; # If specific file given then write everything to it; if hasattr(f, 'write'):; if not 'b' in f.mode:; raise RuntimeError(""File stream must be in binary mode""); # write all to this stream; fall = f; fs = f; closefall = False; closefs = False; elif f:; # Assume f is a filename; fall = open(f, 'wb'",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:11726,Testability,log,logs,11726," mode = 'a'; f = open(self.fid_err_file, mode); f.write(""{}\n"".format(fid_err)); f.close(). @property; def grad_norm_file(self):; if self._grad_norm_file is None:; fname = ""{}-grad_norm_log.{}"".format(self.fname_base,; self.dump_file_ext); self._grad_norm_file = os.path.join(self.dump_dir, fname); return self._grad_norm_file. [docs] def update_grad_norm_log(self, grad_norm):; """"""add an entry to the grad_norm log""""""; self.grad_norm_log.append(grad_norm); if self.write_to_file:; if len(self.grad_norm_log) == 1:; mode = 'w'; else:; mode = 'a'; f = open(self.grad_norm_file, mode); f.write(""{}\n"".format(grad_norm)); f.close(). [docs] def update_grad_log(self, grad):; """"""add an entry to the grad log""""""; self.grad_log.append(grad); if self.write_to_file:; fname = ""{}-fid_err_gradients{}.{}"".format(self.fname_base,; len(self.grad_log),; self.dump_file_ext); fpath = os.path.join(self.dump_dir, fname); np.savetxt(fpath, grad, delimiter=self.data_sep). [docs] def writeout(self, f=None):; """"""write all the logs and the summary out to file(s). Parameters; ----------; f : filename or filehandle; If specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this.; """"""; fall = None; # If specific file given then write everything to it; if hasattr(f, 'write'):; if not 'b' in f.mode:; raise RuntimeError(""File stream must be in binary mode""); # write all to this stream; fall = f; fs = f; closefall = False; closefs = False; elif f:; # Assume f is a filename; fall = open(f, 'wb'); fs = fall; closefs = False; closefall = True; else:; self.create_dump_dir(); closefall = False; if self.dump_summary:; fs = open(self.summary_file, 'wb'); closefs = True. if self.dump_summary:; for ois in self.iter_summary:; if ois.idx == 0:; fs.write(asbytes(""{}\n{}\n"".format(; ois.get_header_line(self.summary_sep),; ois.ge",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:12858,Testability,log,logger,12858,"ata will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this.; """"""; fall = None; # If specific file given then write everything to it; if hasattr(f, 'write'):; if not 'b' in f.mode:; raise RuntimeError(""File stream must be in binary mode""); # write all to this stream; fall = f; fs = f; closefall = False; closefs = False; elif f:; # Assume f is a filename; fall = open(f, 'wb'); fs = fall; closefs = False; closefall = True; else:; self.create_dump_dir(); closefall = False; if self.dump_summary:; fs = open(self.summary_file, 'wb'); closefs = True. if self.dump_summary:; for ois in self.iter_summary:; if ois.idx == 0:; fs.write(asbytes(""{}\n{}\n"".format(; ois.get_header_line(self.summary_sep),; ois.get_value_line(self.summary_sep)))); else:; fs.write(asbytes(""{}\n"".format(; ois.get_value_line(self.summary_sep)))). if closefs:; fs.close(); logger.info(""Optim dump summary saved to {}"".format(; self.summary_file)). if self.dump_fid_err:; if fall:; fall.write(asbytes(""Fidelity errors:\n"")); np.savetxt(fall, self.fid_err_log); else:; np.savetxt(self.fid_err_file, self.fid_err_log). if self.dump_grad_norm:; if fall:; fall.write(asbytes(""gradients norms:\n"")); np.savetxt(fall, self.grad_norm_log); else:; np.savetxt(self.grad_norm_file, self.grad_norm_log). if self.dump_grad:; g_num = 0; for grad in self.grad_log:; g_num += 1; if fall:; fall.write(asbytes(""gradients (call {}):\n"".format(g_num))); np.savetxt(fall, grad); else:; fname = ""{}-fid_err_gradients{}.{}"".format(self.fname_base,; g_num,; self.dump_file_ext); fpath = os.path.join(self.dump_dir, fname); np.savetxt(fpath, grad, delimiter=self.data_sep). if closefall:; fall.close(); logger.info(""Optim dump saved to {}"".format(f)); else:; if fall:; logger.info(""Optim dump saved to specified stream""); else:; logger.info(""Optim dump saved to {}"".format(self.dump_dir)). [docs]c",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:13663,Testability,log,logger,13663,"format(; ois.get_header_line(self.summary_sep),; ois.get_value_line(self.summary_sep)))); else:; fs.write(asbytes(""{}\n"".format(; ois.get_value_line(self.summary_sep)))). if closefs:; fs.close(); logger.info(""Optim dump summary saved to {}"".format(; self.summary_file)). if self.dump_fid_err:; if fall:; fall.write(asbytes(""Fidelity errors:\n"")); np.savetxt(fall, self.fid_err_log); else:; np.savetxt(self.fid_err_file, self.fid_err_log). if self.dump_grad_norm:; if fall:; fall.write(asbytes(""gradients norms:\n"")); np.savetxt(fall, self.grad_norm_log); else:; np.savetxt(self.grad_norm_file, self.grad_norm_log). if self.dump_grad:; g_num = 0; for grad in self.grad_log:; g_num += 1; if fall:; fall.write(asbytes(""gradients (call {}):\n"".format(g_num))); np.savetxt(fall, grad); else:; fname = ""{}-fid_err_gradients{}.{}"".format(self.fname_base,; g_num,; self.dump_file_ext); fpath = os.path.join(self.dump_dir, fname); np.savetxt(fpath, grad, delimiter=self.data_sep). if closefall:; fall.close(); logger.info(""Optim dump saved to {}"".format(f)); else:; if fall:; logger.info(""Optim dump saved to specified stream""); else:; logger.info(""Optim dump saved to {}"".format(self.dump_dir)). [docs]class DynamicsDump(Dump):; """"""; A container for dumps of dynamics data. Mainly time evolution calculations. Attributes; ----------; dump_summary : bool; If True a summary is recorded. evo_summary : list of :class:`tslotcomp.EvoCompSummary`; Summary items are appended if dump_summary is True; at each recomputation of the evolution. dump_amps : bool; If True control amplitudes are dumped. dump_dyn_gen : bool; If True the dynamics generators (Hamiltonians) are dumped. dump_prop : bool; If True propagators are dumped. dump_prop_grad : bool; If True propagator gradients are dumped. dump_fwd_evo : bool; If True forward evolution operators are dumped. dump_onwd_evo : bool; If True onward evolution operators are dumped. dump_onto_evo : bool; If True onto (or backward) evolution operators are dumped. evo",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:13729,Testability,log,logger,13729,"_value_line(self.summary_sep)))); else:; fs.write(asbytes(""{}\n"".format(; ois.get_value_line(self.summary_sep)))). if closefs:; fs.close(); logger.info(""Optim dump summary saved to {}"".format(; self.summary_file)). if self.dump_fid_err:; if fall:; fall.write(asbytes(""Fidelity errors:\n"")); np.savetxt(fall, self.fid_err_log); else:; np.savetxt(self.fid_err_file, self.fid_err_log). if self.dump_grad_norm:; if fall:; fall.write(asbytes(""gradients norms:\n"")); np.savetxt(fall, self.grad_norm_log); else:; np.savetxt(self.grad_norm_file, self.grad_norm_log). if self.dump_grad:; g_num = 0; for grad in self.grad_log:; g_num += 1; if fall:; fall.write(asbytes(""gradients (call {}):\n"".format(g_num))); np.savetxt(fall, grad); else:; fname = ""{}-fid_err_gradients{}.{}"".format(self.fname_base,; g_num,; self.dump_file_ext); fpath = os.path.join(self.dump_dir, fname); np.savetxt(fpath, grad, delimiter=self.data_sep). if closefall:; fall.close(); logger.info(""Optim dump saved to {}"".format(f)); else:; if fall:; logger.info(""Optim dump saved to specified stream""); else:; logger.info(""Optim dump saved to {}"".format(self.dump_dir)). [docs]class DynamicsDump(Dump):; """"""; A container for dumps of dynamics data. Mainly time evolution calculations. Attributes; ----------; dump_summary : bool; If True a summary is recorded. evo_summary : list of :class:`tslotcomp.EvoCompSummary`; Summary items are appended if dump_summary is True; at each recomputation of the evolution. dump_amps : bool; If True control amplitudes are dumped. dump_dyn_gen : bool; If True the dynamics generators (Hamiltonians) are dumped. dump_prop : bool; If True propagators are dumped. dump_prop_grad : bool; If True propagator gradients are dumped. dump_fwd_evo : bool; If True forward evolution operators are dumped. dump_onwd_evo : bool; If True onward evolution operators are dumped. dump_onto_evo : bool; If True onto (or backward) evolution operators are dumped. evo_dumps : list of :class:`EvoCompDumpItem`; A new dump it",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:13789,Testability,log,logger,13789,"e(asbytes(""{}\n"".format(; ois.get_value_line(self.summary_sep)))). if closefs:; fs.close(); logger.info(""Optim dump summary saved to {}"".format(; self.summary_file)). if self.dump_fid_err:; if fall:; fall.write(asbytes(""Fidelity errors:\n"")); np.savetxt(fall, self.fid_err_log); else:; np.savetxt(self.fid_err_file, self.fid_err_log). if self.dump_grad_norm:; if fall:; fall.write(asbytes(""gradients norms:\n"")); np.savetxt(fall, self.grad_norm_log); else:; np.savetxt(self.grad_norm_file, self.grad_norm_log). if self.dump_grad:; g_num = 0; for grad in self.grad_log:; g_num += 1; if fall:; fall.write(asbytes(""gradients (call {}):\n"".format(g_num))); np.savetxt(fall, grad); else:; fname = ""{}-fid_err_gradients{}.{}"".format(self.fname_base,; g_num,; self.dump_file_ext); fpath = os.path.join(self.dump_dir, fname); np.savetxt(fpath, grad, delimiter=self.data_sep). if closefall:; fall.close(); logger.info(""Optim dump saved to {}"".format(f)); else:; if fall:; logger.info(""Optim dump saved to specified stream""); else:; logger.info(""Optim dump saved to {}"".format(self.dump_dir)). [docs]class DynamicsDump(Dump):; """"""; A container for dumps of dynamics data. Mainly time evolution calculations. Attributes; ----------; dump_summary : bool; If True a summary is recorded. evo_summary : list of :class:`tslotcomp.EvoCompSummary`; Summary items are appended if dump_summary is True; at each recomputation of the evolution. dump_amps : bool; If True control amplitudes are dumped. dump_dyn_gen : bool; If True the dynamics generators (Hamiltonians) are dumped. dump_prop : bool; If True propagators are dumped. dump_prop_grad : bool; If True propagator gradients are dumped. dump_fwd_evo : bool; If True forward evolution operators are dumped. dump_onwd_evo : bool; If True onward evolution operators are dumped. dump_onto_evo : bool; If True onto (or backward) evolution operators are dumped. evo_dumps : list of :class:`EvoCompDumpItem`; A new dump item is appended at each recomputation of the evol",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:19777,Testability,log,logger,19777,"data will go in one file.; If None is specified then type specific files will be generated in; the dump_dir. If a filehandle is specified then it must be a byte; mode file as numpy.savetxt is used, and requires this.; """"""; fall = None; # If specific file given then write everything to it; if hasattr(f, 'write'):; if not 'b' in f.mode:; raise RuntimeError(""File stream must be in binary mode""); # write all to this stream; fall = f; fs = f; closefall = False; closefs = False; elif f:; # Assume f is a filename; fall = open(f, 'wb'); fs = fall; closefs = False; closefall = True; else:; self.create_dump_dir(); closefall = False; if self.dump_summary:; fs = open(self.summary_file, 'wb'); closefs = True. if self.dump_summary:; for ecs in self.evo_summary:; if ecs.idx == 0:; fs.write(asbytes(""{}\n{}\n"".format(; ecs.get_header_line(self.summary_sep),; ecs.get_value_line(self.summary_sep)))); else:; fs.write(asbytes(""{}\n"".format(; ecs.get_value_line(self.summary_sep)))). if closefs:; fs.close(); logger.info(""Dynamics dump summary saved to {}"".format(; self.summary_file)). for di in self.evo_dumps:; di.writeout(fall). if closefall:; fall.close(); logger.info(""Dynamics dump saved to {}"".format(f)); else:; if fall:; logger.info(""Dynamics dump saved to specified stream""); else:; logger.info(""Dynamics dump saved to {}"".format(self.dump_dir)). [docs]class DumpItem:; """"""; An item in a dump list; """"""; def __init__(self):; pass. [docs]class EvoCompDumpItem(DumpItem):; """"""; A copy of all objects generated to calculate one time evolution. Note the; attributes are only set if the corresponding :class:`DynamicsDump`; ``dump_*`` attribute is set.; """"""; def __init__(self, dump):; if not isinstance(dump, DynamicsDump):; raise TypeError(""Must instantiate with {} type"".format(; DynamicsDump)); self.parent = dump; self.reset(). def reset(self):; self.idx = None; # self.num_ctrls = None; # self.num_tslots = None; self.ctrl_amps = None; self.dyn_gen = None; self.prop = None; self.prop_grad = None",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:19930,Testability,log,logger,19930," a byte; mode file as numpy.savetxt is used, and requires this.; """"""; fall = None; # If specific file given then write everything to it; if hasattr(f, 'write'):; if not 'b' in f.mode:; raise RuntimeError(""File stream must be in binary mode""); # write all to this stream; fall = f; fs = f; closefall = False; closefs = False; elif f:; # Assume f is a filename; fall = open(f, 'wb'); fs = fall; closefs = False; closefall = True; else:; self.create_dump_dir(); closefall = False; if self.dump_summary:; fs = open(self.summary_file, 'wb'); closefs = True. if self.dump_summary:; for ecs in self.evo_summary:; if ecs.idx == 0:; fs.write(asbytes(""{}\n{}\n"".format(; ecs.get_header_line(self.summary_sep),; ecs.get_value_line(self.summary_sep)))); else:; fs.write(asbytes(""{}\n"".format(; ecs.get_value_line(self.summary_sep)))). if closefs:; fs.close(); logger.info(""Dynamics dump summary saved to {}"".format(; self.summary_file)). for di in self.evo_dumps:; di.writeout(fall). if closefall:; fall.close(); logger.info(""Dynamics dump saved to {}"".format(f)); else:; if fall:; logger.info(""Dynamics dump saved to specified stream""); else:; logger.info(""Dynamics dump saved to {}"".format(self.dump_dir)). [docs]class DumpItem:; """"""; An item in a dump list; """"""; def __init__(self):; pass. [docs]class EvoCompDumpItem(DumpItem):; """"""; A copy of all objects generated to calculate one time evolution. Note the; attributes are only set if the corresponding :class:`DynamicsDump`; ``dump_*`` attribute is set.; """"""; def __init__(self, dump):; if not isinstance(dump, DynamicsDump):; raise TypeError(""Must instantiate with {} type"".format(; DynamicsDump)); self.parent = dump; self.reset(). def reset(self):; self.idx = None; # self.num_ctrls = None; # self.num_tslots = None; self.ctrl_amps = None; self.dyn_gen = None; self.prop = None; self.prop_grad = None; self.fwd_evo = None; self.onwd_evo = None; self.onto_evo = None. [docs] def writeout(self, f=None):; """""" write all the objects out to files. Parameters",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:19999,Testability,log,logger,19999,"his.; """"""; fall = None; # If specific file given then write everything to it; if hasattr(f, 'write'):; if not 'b' in f.mode:; raise RuntimeError(""File stream must be in binary mode""); # write all to this stream; fall = f; fs = f; closefall = False; closefs = False; elif f:; # Assume f is a filename; fall = open(f, 'wb'); fs = fall; closefs = False; closefall = True; else:; self.create_dump_dir(); closefall = False; if self.dump_summary:; fs = open(self.summary_file, 'wb'); closefs = True. if self.dump_summary:; for ecs in self.evo_summary:; if ecs.idx == 0:; fs.write(asbytes(""{}\n{}\n"".format(; ecs.get_header_line(self.summary_sep),; ecs.get_value_line(self.summary_sep)))); else:; fs.write(asbytes(""{}\n"".format(; ecs.get_value_line(self.summary_sep)))). if closefs:; fs.close(); logger.info(""Dynamics dump summary saved to {}"".format(; self.summary_file)). for di in self.evo_dumps:; di.writeout(fall). if closefall:; fall.close(); logger.info(""Dynamics dump saved to {}"".format(f)); else:; if fall:; logger.info(""Dynamics dump saved to specified stream""); else:; logger.info(""Dynamics dump saved to {}"".format(self.dump_dir)). [docs]class DumpItem:; """"""; An item in a dump list; """"""; def __init__(self):; pass. [docs]class EvoCompDumpItem(DumpItem):; """"""; A copy of all objects generated to calculate one time evolution. Note the; attributes are only set if the corresponding :class:`DynamicsDump`; ``dump_*`` attribute is set.; """"""; def __init__(self, dump):; if not isinstance(dump, DynamicsDump):; raise TypeError(""Must instantiate with {} type"".format(; DynamicsDump)); self.parent = dump; self.reset(). def reset(self):; self.idx = None; # self.num_ctrls = None; # self.num_tslots = None; self.ctrl_amps = None; self.dyn_gen = None; self.prop = None; self.prop_grad = None; self.fwd_evo = None; self.onwd_evo = None; self.onto_evo = None. [docs] def writeout(self, f=None):; """""" write all the objects out to files. Parameters; ----------; f : filename or filehandle; If specified then",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:20062,Testability,log,logger,20062,"then write everything to it; if hasattr(f, 'write'):; if not 'b' in f.mode:; raise RuntimeError(""File stream must be in binary mode""); # write all to this stream; fall = f; fs = f; closefall = False; closefs = False; elif f:; # Assume f is a filename; fall = open(f, 'wb'); fs = fall; closefs = False; closefall = True; else:; self.create_dump_dir(); closefall = False; if self.dump_summary:; fs = open(self.summary_file, 'wb'); closefs = True. if self.dump_summary:; for ecs in self.evo_summary:; if ecs.idx == 0:; fs.write(asbytes(""{}\n{}\n"".format(; ecs.get_header_line(self.summary_sep),; ecs.get_value_line(self.summary_sep)))); else:; fs.write(asbytes(""{}\n"".format(; ecs.get_value_line(self.summary_sep)))). if closefs:; fs.close(); logger.info(""Dynamics dump summary saved to {}"".format(; self.summary_file)). for di in self.evo_dumps:; di.writeout(fall). if closefall:; fall.close(); logger.info(""Dynamics dump saved to {}"".format(f)); else:; if fall:; logger.info(""Dynamics dump saved to specified stream""); else:; logger.info(""Dynamics dump saved to {}"".format(self.dump_dir)). [docs]class DumpItem:; """"""; An item in a dump list; """"""; def __init__(self):; pass. [docs]class EvoCompDumpItem(DumpItem):; """"""; A copy of all objects generated to calculate one time evolution. Note the; attributes are only set if the corresponding :class:`DynamicsDump`; ``dump_*`` attribute is set.; """"""; def __init__(self, dump):; if not isinstance(dump, DynamicsDump):; raise TypeError(""Must instantiate with {} type"".format(; DynamicsDump)); self.parent = dump; self.reset(). def reset(self):; self.idx = None; # self.num_ctrls = None; # self.num_tslots = None; self.ctrl_amps = None; self.dyn_gen = None; self.prop = None; self.prop_grad = None; self.fwd_evo = None; self.onwd_evo = None; self.onto_evo = None. [docs] def writeout(self, f=None):; """""" write all the objects out to files. Parameters; ----------; f : filename or filehandle; If specified then all object data will go in one file.; If None is ",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:8482,Usability,clear,clear,8482,"er.OptimIterSummary`; Summary at each iteration. dump_fid_err : bool; When True values are appended to the fid_err_log. fid_err_log : list of float; Fidelity error at each call of the fid_err_func. dump_grad_norm : bool; When True values are appended to the fid_err_log. grad_norm_log : list of float; Gradient norm at each call of the grad_norm_log. dump_grad : bool; When True values are appended to the grad_log. grad_log : list of ndarray; Gradients at each call of the fid_grad_func. """"""; def __init__(self, optim, level='SUMMARY'):; from qutip.control.optimizer import Optimizer; if not isinstance(optim, Optimizer):; raise TypeError(""Must instantiate with {} type"".format(; Optimizer)); self.parent = optim; self._level = level; self.reset(). def reset(self):; Dump.reset(self); self._apply_level(); self.iter_summary = []; self.fid_err_log = []; self.grad_norm_log = []; self.grad_log = []; self._fname_base = 'optimdump'; self._fid_err_file = None; self._grad_norm_file = None. def clear(self):; del self.iter_summary[:]; self.fid_err_log[:]; self.grad_norm_log[:]; self.grad_log[:]. @property; def dump_any(self):; """"""True if anything other than the summary is to be dumped""""""; if (self.dump_fid_err or self.dump_grad_norm or self.dump_grad):; return True; else:; return False. @property; def dump_all(self):; """"""True if everything (ignoring the summary) is to be dumped""""""; if (self.dump_fid_err and self.dump_grad_norm and self.dump_grad):; return True; else:; return False. def _apply_level(self, level=None):; if level is None:; level = self._level. if not _is_string(level):; raise ValueError(""Dump level must be a string""); level = level.upper(); if level == 'CUSTOM':; if self._level == 'CUSTOM':; # dumping level has not changed keep the same specific config; pass; else:; # Switching to custom, start from SUMMARY; level = 'SUMMARY'. if level == 'SUMMARY':; self.dump_summary = True; self.dump_fid_err = False; self.dump_grad_norm = False; self.dump_grad = False; elif level == 'FU",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dump.html:15235,Usability,clear,clear,15235,". dump_dyn_gen : bool; If True the dynamics generators (Hamiltonians) are dumped. dump_prop : bool; If True propagators are dumped. dump_prop_grad : bool; If True propagator gradients are dumped. dump_fwd_evo : bool; If True forward evolution operators are dumped. dump_onwd_evo : bool; If True onward evolution operators are dumped. dump_onto_evo : bool; If True onto (or backward) evolution operators are dumped. evo_dumps : list of :class:`EvoCompDumpItem`; A new dump item is appended at each recomputation of the evolution.; That is if any of the calculation objects are to be dumped. """"""; def __init__(self, dynamics, level='SUMMARY'):; from qutip.control.dynamics import Dynamics; if not isinstance(dynamics, Dynamics):; raise TypeError(""Must instantiate with {} type"".format(; Dynamics)); self.parent = dynamics; self._level = level; self.reset(). def reset(self):; Dump.reset(self); self._apply_level(); self.evo_dumps = []; self.evo_summary = []; self._fname_base = 'dyndump'. def clear(self):; del self.evo_dumps[:]; del self.evo_summary[:]. @property; def dump_any(self):; """"""True if any of the calculation objects are to be dumped""""""; if (self.dump_amps or; self.dump_dyn_gen or; self.dump_prop or; self.dump_prop_grad or; self.dump_fwd_evo or; self.dump_onwd_evo or; self.dump_onto_evo):; return True; else:; return False. @property; def dump_all(self):; """"""True if all of the calculation objects are to be dumped""""""; dyn = self.parent; if (self.dump_amps and; self.dump_dyn_gen and; self.dump_prop and; self.dump_prop_grad and; self.dump_fwd_evo and; (self.dump_onwd_evo) or; (self.dump_onwd_evo == dyn.fid_computer.uses_onwd_evo) and; (self.dump_onto_evo or; (self.dump_onto_evo == dyn.fid_computer.uses_onto_evo))):; return True; else:; return False. def _apply_level(self, level=None):; dyn = self.parent; if level is None:; level = self._level. if not _is_string(level):; raise ValueError(""Dump level must be a string""); level = level.upper(); if level == 'CUSTOM':; if self._level",MatchSource.WIKI,docs/4.6/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:3401,Availability,error,errors,3401,"d here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; from qutip.sparse import sp_eigs, eigh; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. def _check_ctrls_container(ctrls):; """"""; Check through the controls container.; Convert to an array if its a list of lists; return the processed container; raise type error if the container structure is invalid; """"""; if isinstance(ctrls, (list, tuple)):; # Check to see if list of lists; try:; if isinstance(ctrls[0], (list, tuple)):; ctrls_ = np.empty((len(ctrls), len(ctrls[0])), dtype=object); for i, ctrl in enumerate(ctrls):; ctrls_[i, :] = ctrl; ctrls = ctrls_; except:; pass. if isinstance(ctrls, np.ndarray):; if len(ctrls.shape) != 2:; rais",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:3411,Availability,error,errors,3411,"d here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; from qutip.sparse import sp_eigs, eigh; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. def _check_ctrls_container(ctrls):; """"""; Check through the controls container.; Convert to an array if its a list of lists; return the processed container; raise type error if the container structure is invalid; """"""; if isinstance(ctrls, (list, tuple)):; # Check to see if list of lists; try:; if isinstance(ctrls[0], (list, tuple)):; ctrls_ = np.empty((len(ctrls), len(ctrls[0])), dtype=object); for i, ctrl in enumerate(ctrls):; ctrls_[i, :] = ctrl; ctrls = ctrls_; except:; pass. if isinstance(ctrls, np.ndarray):; if len(ctrls.shape) != 2:; rais",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:4035,Availability,error,error,4035," import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; from qutip.sparse import sp_eigs, eigh; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. def _check_ctrls_container(ctrls):; """"""; Check through the controls container.; Convert to an array if its a list of lists; return the processed container; raise type error if the container structure is invalid; """"""; if isinstance(ctrls, (list, tuple)):; # Check to see if list of lists; try:; if isinstance(ctrls[0], (list, tuple)):; ctrls_ = np.empty((len(ctrls), len(ctrls[0])), dtype=object); for i, ctrl in enumerate(ctrls):; ctrls_[i, :] = ctrl; ctrls = ctrls_; except:; pass. if isinstance(ctrls, np.ndarray):; if len(ctrls.shape) != 2:; raise TypeError(""Incorrect shape for ctrl dyn gen array""); for k in range(ctrls.shape[0]):; for j in range(ctrls.shape[1]):; if not isinstance(ctrls[k, j], Qobj):; raise TypeError(""All control dyn gen must be Qobj""); elif isinstance(ctrls, (list, tuple)):; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""All control dyn gen must be Qobj""); else:; raise TypeError(""Controls list or array not set correctly""). return ctrls. def _check_drift_dyn_gen(drift):; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; r",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:7642,Availability,error,error,7642,"_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. c",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:7665,Availability,error,error,7665,"_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. c",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:30214,Availability,error,errors,30214,"be applied as dg*phase; """"""; if hasattr(self.dyn_gen_phase, 'dot'):; phased_dg = dg.dot(self._dyn_gen_phase); else:; phased_dg = dg*self._dyn_gen_phase; return phased_dg. def _create_decomp_lists(self):; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; n_ts = self.num_tslots; self._decomp_curr = [False for x in range(n_ts)]; self._prop_eigen = [object for x in range(n_ts)]; self._dyn_gen_eigenvectors = [object for x in range(n_ts)]; if self.cache_dyn_gen_eigenvectors_adj:; self._dyn_gen_eigenvectors_adj = [object for x in range(n_ts)]; self._dyn_gen_factormatrix = [object for x in range(n_ts)]. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FidelityComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; if not self._timeslots_initialized:; init_tslots = True; if init_tslots:; self.init_timeslots(); self._init_evo(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""executed with the initial control a",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:30415,Availability,error,errors,30415,"; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; n_ts = self.num_tslots; self._decomp_curr = [False for x in range(n_ts)]; self._prop_eigen = [object for x in range(n_ts)]; self._dyn_gen_eigenvectors = [object for x in range(n_ts)]; if self.cache_dyn_gen_eigenvectors_adj:; self._dyn_gen_eigenvectors_adj = [object for x in range(n_ts)]; self._dyn_gen_factormatrix = [object for x in range(n_ts)]. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FidelityComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; if not self._timeslots_initialized:; init_tslots = True; if init_tslots:; self.init_timeslots(); self._init_evo(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""executed with the initial control amplitudes.""). def get_amp_times(self):; return self.time[:self.num_tslots]. [docs] def save_amps(self, file_name=None, times=None, amps=None, verbose=False):; """"""; Save a file with the current control a",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:30608,Availability,error,errors,30608,"mp_curr = [False for x in range(n_ts)]; self._prop_eigen = [object for x in range(n_ts)]; self._dyn_gen_eigenvectors = [object for x in range(n_ts)]; if self.cache_dyn_gen_eigenvectors_adj:; self._dyn_gen_eigenvectors_adj = [object for x in range(n_ts)]; self._dyn_gen_factormatrix = [object for x in range(n_ts)]. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FidelityComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; if not self._timeslots_initialized:; init_tslots = True; if init_tslots:; self.init_timeslots(); self._init_evo(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""executed with the initial control amplitudes.""). def get_amp_times(self):; return self.time[:self.num_tslots]. [docs] def save_amps(self, file_name=None, times=None, amps=None, verbose=False):; """"""; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters; ----------; file_name : string; Name of the file; If None given the def_amps_fname attri",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:31069,Availability,error,errors,31069,"fter the configuration is complete; before any dynamics can be calculated; """"""; if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FidelityComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; if not self._timeslots_initialized:; init_tslots = True; if init_tslots:; self.init_timeslots(); self._init_evo(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""executed with the initial control amplitudes.""). def get_amp_times(self):; return self.time[:self.num_tslots]. [docs] def save_amps(self, file_name=None, times=None, amps=None, verbose=False):; """"""; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters; ----------; file_name : string; Name of the file; If None given the def_amps_fname attribuite will be used. times : List type (or string); List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes ",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:32725,Availability,error,error,32725,"; If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh_drift_attribs(); return self.dyn_shape[0]. [docs] def refresh_drift_att",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:32779,Availability,error,error,32779,"; If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh_drift_attribs(); return self.dyn_shape[0]. [docs] def refresh_drift_att",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:42879,Availability,error,errors,42879,"nge(0, self.num_tslots):; self._onto_evo_qobj.append(Qobj(self._onto_evo[k],; dims=self.sys_dims)); self._onto_evo_qobj.append(self.onto_evo_target). return self._onto_evo_qobj. [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. def _ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self._decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self._decomp_curr[k]:; self._spectral_decomp(k). def _spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def _is_unitary(self, A):; """"""; Checks whether operator A is unitary; A can be either Qobj or ndarray; """"""; if isinstance(A, Qobj):; unitary = np.allclose(np.eye(A.shape[0]), A*A.dag().full(),; atol=self.unitarity_tol); else:; unitary = np.allclose(np.eye(len(A)), A.dot(A.T.conj()),; atol=self.unitarity_tol). return unitary. def _calc_unitary_err(self, A):; if isinstance(A, Qobj):; err = np.sum(abs(np.eye(A.shape[0]) - A*A.dag().full()));",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:43328,Availability,error,errors,43328,"nian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. def _ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self._decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self._decomp_curr[k]:; self._spectral_decomp(k). def _spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def _is_unitary(self, A):; """"""; Checks whether operator A is unitary; A can be either Qobj or ndarray; """"""; if isinstance(A, Qobj):; unitary = np.allclose(np.eye(A.shape[0]), A*A.dag().full(),; atol=self.unitarity_tol); else:; unitary = np.allclose(np.eye(len(A)), A.dot(A.T.conj()),; atol=self.unitarity_tol). return unitary. def _calc_unitary_err(self, A):; if isinstance(A, Qobj):; err = np.sum(abs(np.eye(A.shape[0]) - A*A.dag().full())); else:; err = np.sum(abs(np.eye(len(A)) - A.dot(A.T.conj()))). return err. [docs] def unitarity_check(self):; """"""; Checks whether all propagators are unitary; """"""; for k in range(self.num_tslots):; if not self._is_unitary(self._prop[k]):; logger.warning(; ""Progator of timeslot {} is not unitary",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:48478,Availability,down,down,48478," calculating the propagator; gradient; """""". if self.oper_dtype == Qobj:; H = self._dyn_gen[k]; # Returns eigenvalues as array (row); # and eigenvectors as rows of an array; eig_val, eig_vec = sp_eigs(H.data, H.isherm,; sparse=self.sparse_eigen_decomp); eig_vec = eig_vec.T; if self.sparse_eigen_decomp:; # when sparse=True, sp_eigs returns an ndarray where each; # element is a sparse matrix so we convert it into a sparse; # matrix we can later pass to Qobj(...); eig_vec = sp.hstack(eig_vec). elif self.oper_dtype == np.ndarray:; H = self._dyn_gen[k]; # returns row vector of eigenvals, columns with the eigenvecs; eig_val, eig_vec = eigh(H). else:; assert False, f""Unknown oper_dtype {self.oper_dtype!r}"". # assuming H is an nxn matrix, find n; n = self.get_drift_dim(). # Calculate the propagator in the diagonalised basis; eig_val_tau = -1j*eig_val*self.tau[k]; prop_eig = np.exp(eig_val_tau). # Generate the factor matrix through the differences; # between each of the eigenvectors and the exponentiations; # create nxn matrix where each eigen val is repeated n times; # down the columns; o = np.ones([n, n]); eig_val_cols = eig_val_tau*o; # calculate all the differences by subtracting it from its transpose; eig_val_diffs = eig_val_cols - eig_val_cols.T; # repeat for the propagator; prop_eig_cols = prop_eig*o; prop_eig_diffs = prop_eig_cols - prop_eig_cols.T; # the factor matrix is the elementwise quotient of the; # differeneces between the exponentiated eigen vals and the; # differences between the eigen vals; # need to avoid division by zero that would arise due to denegerate; # eigenvalues and the diagonals; degen_mask = np.abs(eig_val_diffs) < self.fact_mat_round_prec; eig_val_diffs[degen_mask] = 1; factors = prop_eig_diffs / eig_val_diffs; # for degenerate eigenvalues the factor is just the exponent; factors[degen_mask] = prop_eig_cols[degen_mask]. # Store eigenvectors, propagator and factor matric; # for use in propagator computations; self._decomp_curr[k] = True; if isin",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:7441,Deployability,update,updated,7441,"ystems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators.",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:18540,Deployability,configurat,configuration,18540,"STOM this is equivalent to SUMMARY. It is then up; to the user to specify which operators are dumped. WARNING: FULL could; consume a lot of memory!; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.DynamicsDump):; self.dump = qtrldump.DynamicsDump(self, level=lvl); else:; self.dump.level = lvl. @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). @property; def num_tslots(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._num_tslots. @num_tslots.setter; def num_tslots(self, value):; self._num_tslots = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def evo_time(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._evo_time. @evo_time.setter; def evo_time(self, value):; self._evo_time = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def tau(s",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:30068,Deployability,configurat,configuration,30068,"ased_dg. def _apply_phase_postop(self, dg):; """"""; Apply phasing operator to dynamics generator.; This called during the propagator calculation.; In this case it will be applied as dg*phase; """"""; if hasattr(self.dyn_gen_phase, 'dot'):; phased_dg = dg.dot(self._dyn_gen_phase); else:; phased_dg = dg*self._dyn_gen_phase; return phased_dg. def _create_decomp_lists(self):; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; n_ts = self.num_tslots; self._decomp_curr = [False for x in range(n_ts)]; self._prop_eigen = [object for x in range(n_ts)]; self._dyn_gen_eigenvectors = [object for x in range(n_ts)]; if self.cache_dyn_gen_eigenvectors_adj:; self._dyn_gen_eigenvectors_adj = [object for x in range(n_ts)]; self._dyn_gen_factormatrix = [object for x in range(n_ts)]. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FidelityComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; if not self._timeslots_initialized:; init_tslots = True; if init_tslots:; self.init_timeslots(); self._init_evo(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). def check_ctrls_initialized(self):; if not ",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:42727,Deployability,update,update,42727,"_onto_evo_qobj is None:; if self.oper_dtype == Qobj:; self._onto_evo_qobj = self._onto_evo; else:; self._onto_evo_qobj = []; for k in range(0, self.num_tslots):; self._onto_evo_qobj.append(Qobj(self._onto_evo[k],; dims=self.sys_dims)); self._onto_evo_qobj.append(self.onto_evo_target). return self._onto_evo_qobj. [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. def _ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self._decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self._decomp_curr[k]:; self._spectral_decomp(k). def _spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def _is_unitary(self, A):; """"""; Checks whether operator A is unitary; A can be either Qobj or ndarray; """"""; if isinstance(A, Qobj):; unitary = np.allclose(np.eye(A.shape[0]), A*A.dag().full(),; atol=self.unitarity_tol); else:; unitary = np.allclose(np.eye(len(A)), A.dot(A.T.conj()),; atol=self.unitarity_t",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:42783,Deployability,update,update,42783,"_onto_evo_qobj is None:; if self.oper_dtype == Qobj:; self._onto_evo_qobj = self._onto_evo; else:; self._onto_evo_qobj = []; for k in range(0, self.num_tslots):; self._onto_evo_qobj.append(Qobj(self._onto_evo[k],; dims=self.sys_dims)); self._onto_evo_qobj.append(self.onto_evo_target). return self._onto_evo_qobj. [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. def _ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self._decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self._decomp_curr[k]:; self._spectral_decomp(k). def _spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def _is_unitary(self, A):; """"""; Checks whether operator A is unitary; A can be either Qobj or ndarray; """"""; if isinstance(A, Qobj):; unitary = np.allclose(np.eye(A.shape[0]), A*A.dag().full(),; atol=self.unitarity_tol); else:; unitary = np.allclose(np.eye(len(A)), A.dot(A.T.conj()),; atol=self.unitarity_t",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:45758,Deployability,configurat,configuration,45758,"ecomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes; ----------; drift_ham : Qobj; This is the drift Hamiltonian for unitary dynamics; It is mapped to drift_dyn_gen during initialize_controls. ctrl_ham : List of Qobj; These are the control Hamiltonians for unitary dynamics; It is mapped to ctrl_dyn_gen during initialize_controls. H : List of Qobj; The combined drift and control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'UNIT'; self.drift_ham = None; self.ctrl_ham = None; self.H = None; self._dyn_gen_phase = -1j; self._phase_application = 'preop'; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). # set the default fidelity computer; self.fid_computer = fidcomp.FidCompUnitary(self); # set the default propagator computer; self.prop_computer = propcomp.PropCompDiag(self). [docs] def initialize_controls(self, amplitudes, init_tslots=True):; # Either the _dyn_gen or _ham names can be used; # This assumes that one or other has been set in the configuration. self._map_dyn_gen_to_ham(); Dynamics.initialize_controls(self, amplitudes, init_tslots=init_tslots); #self.H = self._dyn_gen. def _map_dyn_gen_to_ham(self):; if self.drift_dyn_gen is None:; self.drift_dyn_gen = self.drift_ham; else:; self.drift_ham = self.drift_dyn_gen. if self.ctrl_dyn_gen is None:; self.ctrl_dyn_gen = self.ctrl_ham; else:; self.ctrl_ham = self.ctrl_dyn_gen. self._dyn_gen_mapped = True. @property; ",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:46316,Deployability,configurat,configuration,46316," These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'UNIT'; self.drift_ham = None; self.ctrl_ham = None; self.H = None; self._dyn_gen_phase = -1j; self._phase_application = 'preop'; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). # set the default fidelity computer; self.fid_computer = fidcomp.FidCompUnitary(self); # set the default propagator computer; self.prop_computer = propcomp.PropCompDiag(self). [docs] def initialize_controls(self, amplitudes, init_tslots=True):; # Either the _dyn_gen or _ham names can be used; # This assumes that one or other has been set in the configuration. self._map_dyn_gen_to_ham(); Dynamics.initialize_controls(self, amplitudes, init_tslots=init_tslots); #self.H = self._dyn_gen. def _map_dyn_gen_to_ham(self):; if self.drift_dyn_gen is None:; self.drift_dyn_gen = self.drift_ham; else:; self.drift_ham = self.drift_dyn_gen. if self.ctrl_dyn_gen is None:; self.ctrl_dyn_gen = self.ctrl_ham; else:; self.ctrl_ham = self.ctrl_dyn_gen. self._dyn_gen_mapped = True. @property; def num_ctrls(self):; if not self._dyn_gen_mapped:; self._map_dyn_gen_to_ham(); if self._num_ctrls is None:; self._num_ctrls = self._get_num_ctrls(); return self._num_ctrls. def _get_onto_evo_target(self):; """"""; Get the adjoint of the target.; Used for calculating the 'backward' evolution; """"""; if self.oper_dtype == Qobj:; self._onto_evo_target = self.target.dag(); else:; self._onto_evo_target = self._target.T.conj(); return self._onto_evo_target. def _spectral_decomp(self, k):; """"""",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:52428,Deployability,configurat,configuration,52428,"ry(; self._dyn_gen_eigenvectors_adj[k]); else:; eigvecadj_unit = None; msg = (""prop unit: {}; H herm: {}; ""; ""eigval unit: {}; eigvec unit: {}; ""; ""eigvecadj_unit: {}"".format(; prop_unit, herm, eigval_unit, eigvec_unit,; eigvecadj_unit)); logger.info(msg). [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omega : array[drift_dyn_gen.shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems. """""". def reset(self):; Dynamics.reset(self); self.id_text = 'SYMPL'; self._omega = None; self._omega_qobj = None; self._phase_application = 'postop'; self.grad_exact = True; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). @property; def omega(self):; if self._omega is None:; self._get_omega(); if self._omega_qobj is None:; self._omega_qobj = Qobj(self._omega, dims=self.dyn_dims); return self._omega_qobj. def _get_omega(self):; if self._omega is None:; n = self.get_drift_dim() // 2; omg = sympl.calc_omega(n); if self.oper_dtype == Qobj:; self._omega = Qobj(omg, dims=self.dyn_dims); self._omega_qobj = self._omega; else:; self._omega = omg; return self._omega. def _set_phase_application(self, value):; Dynamics._set_phase_application(self, value); if self._evo_initialized:; phase = self._get_dyn_gen_phase(); if phase is not None:; self._dyn_gen_phase = phase. def _get_dyn_gen_phase(self):;",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:54414,Deployability,update,updated,54414," self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). @property; def omega(self):; if self._omega is None:; self._get_omega(); if self._omega_qobj is None:; self._omega_qobj = Qobj(self._omega, dims=self.dyn_dims); return self._omega_qobj. def _get_omega(self):; if self._omega is None:; n = self.get_drift_dim() // 2; omg = sympl.calc_omega(n); if self.oper_dtype == Qobj:; self._omega = Qobj(omg, dims=self.dyn_dims); self._omega_qobj = self._omega; else:; self._omega = omg; return self._omega. def _set_phase_application(self, value):; Dynamics._set_phase_application(self, value); if self._evo_initialized:; phase = self._get_dyn_gen_phase(); if phase is not None:; self._dyn_gen_phase = phase. def _get_dyn_gen_phase(self):; if self._phase_application == 'postop':; phase = -self._get_omega(); elif self._phase_application == 'preop':; phase = self._get_omega(); elif self._phase_application == 'custom':; phase = None; # Assume phase set by user; else:; raise ValueError(""No option for phase_application ""; ""'{}'"".format(self._phase_application)); return phase. @property; def dyn_gen_phase(self):; r""""""; The phasing operator for the symplectic group generators; usually refered to as \Omega; By default this is applied as 'postop' dyn_gen*-\Omega; If phase_application is 'preop' it is applied as \Omega*dyn_gen; """"""; # Cannot be calculated until the dyn_shape is set; # that is after the drift dyn gen has been set.; if self._dyn_gen_phase is None:; self._dyn_gen_phase = self._get_dyn_gen_phase(); return self._dyn_gen_phase. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:7206,Energy Efficiency,reduce,reduce,7206,"nerators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more informatio",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:22184,Energy Efficiency,efficient,efficient,22184,"e)). if self.cache_phased_dyn_gen is None:; if self.memory_optimization > 0:; self.cache_phased_dyn_gen = False; else:; self.cache_phased_dyn_gen = True; logger.info(""phased dynamics generator caching {}"".format(; self.cache_phased_dyn_gen)). if self.cache_prop_grad is None:; if self.memory_optimization > 0:; self.cache_prop_grad = False; else:; self.cache_prop_grad = True; logger.info(""propagator gradient caching {}"".format(; self.cache_prop_grad)). if self.cache_dyn_gen_eigenvectors_adj is None:; if self.memory_optimization > 0:; self.cache_dyn_gen_eigenvectors_adj = False; else:; self.cache_dyn_gen_eigenvectors_adj = True; logger.info(""eigenvector adjoint caching {}"".format(; self.cache_dyn_gen_eigenvectors_adj)). if self.sparse_eigen_decomp is None:; if self.memory_optimization > 1:; self.sparse_eigen_decomp = True; else:; self.sparse_eigen_decomp = False; logger.info(""use sparse eigen decomp {}"".format(; self.sparse_eigen_decomp)). def _choose_oper_dtype(self):; """"""; Attempt select most efficient internal operator data type; """""". if self.memory_optimization > 0:; self.oper_dtype = Qobj; else:; # Method taken from Qobj.expm(); # if method is not explicitly given, try to make a good choice; # between sparse and dense solvers by considering the size of the; # system and the number of non-zero elements.; if self.time_depend_drift:; dg = self.drift_dyn_gen[0]; else:; dg = self.drift_dyn_gen; if self.time_depend_ctrl_dyn_gen:; ctrls = self.ctrl_dyn_gen[0, :]; else:; ctrls = self.ctrl_dyn_gen; for c in ctrls:; dg = dg + c. N = dg.data.shape[0]; n = dg.data.nnz. if N ** 2 < 100 * n:; # large number of nonzero elements, revert to dense solver; self.oper_dtype = np.ndarray; elif N > 400:; # large system, and quite sparse -> qutips sparse method; self.oper_dtype = Qobj; else:; # small system, but quite sparse -> qutips sparse/dense method; self.oper_dtype = np.ndarray. return self.oper_dtype. def _init_evo(self):; """"""; Create the container lists / arrays for the:; dynamic",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:2704,Integrability,depend,depends,2704,"ICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes that define the dynamics of the (quantum) system and target evolution; to be optimised.; The contols are also defined here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; from qutip.sparse import sp_eigs, eigh; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring)",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:5237,Integrability,message,message,5237,"enumerate(ctrls):; ctrls_[i, :] = ctrl; ctrls = ctrls_; except:; pass. if isinstance(ctrls, np.ndarray):; if len(ctrls.shape) != 2:; raise TypeError(""Incorrect shape for ctrl dyn gen array""); for k in range(ctrls.shape[0]):; for j in range(ctrls.shape[1]):; if not isinstance(ctrls[k, j], Qobj):; raise TypeError(""All control dyn gen must be Qobj""); elif isinstance(ctrls, (list, tuple)):; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""All control dyn gen must be Qobj""); else:; raise TypeError(""Controls list or array not set correctly""). return ctrls. def _check_drift_dyn_gen(drift):; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(; ""drift should be a Qobj or a list of Qobj""). warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evol",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:5325,Integrability,message,message,5325,"enumerate(ctrls):; ctrls_[i, :] = ctrl; ctrls = ctrls_; except:; pass. if isinstance(ctrls, np.ndarray):; if len(ctrls.shape) != 2:; raise TypeError(""Incorrect shape for ctrl dyn gen array""); for k in range(ctrls.shape[0]):; for j in range(ctrls.shape[1]):; if not isinstance(ctrls[k, j], Qobj):; raise TypeError(""All control dyn gen must be Qobj""); elif isinstance(ctrls, (list, tuple)):; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""All control dyn gen must be Qobj""); else:; raise TypeError(""Controls list or array not set correctly""). return ctrls. def _check_drift_dyn_gen(drift):; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(; ""drift should be a Qobj or a list of Qobj""). warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evol",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:5413,Integrability,message,message,5413,"ect shape for ctrl dyn gen array""); for k in range(ctrls.shape[0]):; for j in range(ctrls.shape[1]):; if not isinstance(ctrls[k, j], Qobj):; raise TypeError(""All control dyn gen must be Qobj""); elif isinstance(ctrls, (list, tuple)):; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""All control dyn gen must be Qobj""); else:; raise TypeError(""Controls list or array not set correctly""). return ctrls. def _check_drift_dyn_gen(drift):; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(; ""drift should be a Qobj or a list of Qobj""). warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better u",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:5488,Integrability,message,message,5488,"k, j], Qobj):; raise TypeError(""All control dyn gen must be Qobj""); elif isinstance(ctrls, (list, tuple)):; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""All control dyn gen must be Qobj""); else:; raise TypeError(""Controls list or array not set correctly""). return ctrls. def _check_drift_dyn_gen(drift):; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(; ""drift should be a Qobj or a list of Qobj""). warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output ",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:5576,Integrability,message,message,5576,"k, j], Qobj):; raise TypeError(""All control dyn gen must be Qobj""); elif isinstance(ctrls, (list, tuple)):; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""All control dyn gen must be Qobj""); else:; raise TypeError(""Controls list or array not set correctly""). return ctrls. def _check_drift_dyn_gen(drift):; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(; ""drift should be a Qobj or a list of Qobj""). warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output ",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:5664,Integrability,message,message,5664,":; if not isinstance(ctrl, Qobj):; raise TypeError(""All control dyn gen must be Qobj""); else:; raise TypeError(""Controls list or array not set correctly""). return ctrls. def _check_drift_dyn_gen(drift):; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(; ""drift should be a Qobj or a list of Qobj""). warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBU",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:31989,Integrability,message,message,31989,"s(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""executed with the initial control amplitudes.""). def get_amp_times(self):; return self.time[:self.num_tslots]. [docs] def save_amps(self, file_name=None, times=None, amps=None, verbose=False):; """"""; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters; ----------; file_name : string; Name of the file; If None given the def_amps_fname attribuite will be used. times : List type (or string); List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by t",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:13799,Modifiability,config,config,13799,"rity of the system evolution is checked at at; evolution recomputation.; level 1 checks all propagators; level 2 checks eigen basis as well; Default is 0. unitarity_tol :; Tolerance used in checking if operator is unitary; Default is 1e-10. dump : :class:`dump.DynamicsDump`; Store of historical calculation data.; Set to None (Default) for no storing of historical data; Use dumping property to set level of data dumping. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the calculations; dumping will be set to SUMMARY during init_evo if dump_to_file is True; and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; dyn_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. """"""; def __init__(self, optimconfig, params=None):; self.config = optimconfig; self.params = params; self.reset(). def reset(self):; # Link to optimiser object if self is linked to one; self.parent = None; # Main functional attributes; self.time = None; self.initial = None; self.target = None; self.ctrl_amps = None; self.initial_ctrl_scaling = 1.0; self.initial_ctrl_offset = 0.0; self.drift_dyn_gen = None; self.ctrl_dyn_gen = None; self._tau = None; self._evo_time = None; self._num_ctrls = None; self._num_tslots = None; # attributes used for processing evolution; self.memory_optimization = 0; self.oper_dtype = None; self.cache_phased_dyn_gen = None; self.cache_prop_grad = None; self.cache_dyn_gen_eigenvectors_adj = None; self.sparse_eigen_decomp = None; self.dyn_dims = None; self.dyn_shape = None; self.sys_dims = None; self.sys_shape = None; self.time_depend_drift = False; self.time_depend_ctrl_dyn_gen = False; # These internal attributes will be of the internal operator data type; # used to compute the evolution; # This will be either ndarray or Qobj; se",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:15961,Modifiability,config,config,15961,"._initial = None; self._target = None; self._onto_evo_target = None; self._dyn_gen = None; self._phased_dyn_gen = None; self._prop = None; self._prop_grad = None; self._fwd_evo = None; self._onwd_evo = None; self._onto_evo = None; # The _qobj attribs are Qobj representations of the equivalent; # internal attribute. They are only set when the extenal accessors; # are used; self._onto_evo_target_qobj = None; self._dyn_gen_qobj = None; self._prop_qobj = None; self._prop_grad_qobj = None; self._fwd_evo_qobj = None; self._onwd_evo_qobj = None; self._onto_evo_qobj = None; # Atrributes used in diagonalisation; # again in internal operator data type (see above); self._decomp_curr = None; self._prop_eigen = None; self._dyn_gen_eigenvectors = None; self._dyn_gen_eigenvectors_adj = None; self._dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.log_level = self.config.log_level; # Internal flags; self._dyn_gen_mapped = False; self._evo_initialized = False; self._timeslots_initialized = False; self._ctrls_initialized = False; self._ctrl_dyn_gen_checked = False; self._drift_dyn_gen_checked = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = None; self.dump_to_file = False. self.apply_params(). # Create the computing objects; self._create_computers(). self.clear(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:18540,Modifiability,config,configuration,18540,"STOM this is equivalent to SUMMARY. It is then up; to the user to specify which operators are dumped. WARNING: FULL could; consume a lot of memory!; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.DynamicsDump):; self.dump = qtrldump.DynamicsDump(self, level=lvl); else:; self.dump.level = lvl. @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). @property; def num_tslots(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._num_tslots. @num_tslots.setter; def num_tslots(self, value):; self._num_tslots = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def evo_time(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._evo_time. @evo_time.setter; def evo_time(self, value):; self._evo_time = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def tau(s",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:18595,Modifiability,config,config,18595," specify which operators are dumped. WARNING: FULL could; consume a lot of memory!; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.DynamicsDump):; self.dump = qtrldump.DynamicsDump(self, level=lvl); else:; self.dump.level = lvl. @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). @property; def num_tslots(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._num_tslots. @num_tslots.setter; def num_tslots(self, value):; self._num_tslots = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def evo_time(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._evo_time. @evo_time.setter; def evo_time(self, value):; self._evo_time = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def tau(self):; if not self._timeslots_initialized:; self.init_timeslots();",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:20091,Modifiability,config,config,20091,".evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). @property; def num_tslots(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._num_tslots. @num_tslots.setter; def num_tslots(self, value):; self._num_tslots = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def evo_time(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._evo_time. @evo_time.setter; def evo_time(self, value):; self._evo_time = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def tau(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._tau. @tau.setter; def tau(self, value):; self._tau = value; self.init_timeslots(). [docs] def init_timeslots(self):; """"""; Generate the timeslot duration array 'tau' based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array 'time' based on the tau values; """"""; # set the time intervals to be equal timeslices of the total if; # the have not been set already (as part of user config); if self._num_tslots is None:; self._num_tslots = DEF_NUM_TSLOTS; if self._evo_time is None:; self._evo_time = DEF_EVO_TIME. if self._tau is None:; self._tau = np.ones(self._num_tslots, dtype='f') * \; self._evo_time/self._num_tslots; else:; self._num_tslots = len(self._tau); self._evo_time = np.sum(self._tau). self.time = np.zeros(self._num_tslots+1, dtype=float); # set the cumulative time by summing the time intervals; for t in range(self._num_tslots):; self.time[t+1] = self.time[t] + self._tau[t]. self._timeslots_initialized = True. def _set_memory_optimizations(self):; """"""; Set various memory optimisation attributes based on the; memory_optimization attribute; If they have been set already, e.g. in apply_params; then they will not be overridden here; """"""; logger.info(""Setting memory optim",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:30068,Modifiability,config,configuration,30068,"ased_dg. def _apply_phase_postop(self, dg):; """"""; Apply phasing operator to dynamics generator.; This called during the propagator calculation.; In this case it will be applied as dg*phase; """"""; if hasattr(self.dyn_gen_phase, 'dot'):; phased_dg = dg.dot(self._dyn_gen_phase); else:; phased_dg = dg*self._dyn_gen_phase; return phased_dg. def _create_decomp_lists(self):; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; n_ts = self.num_tslots; self._decomp_curr = [False for x in range(n_ts)]; self._prop_eigen = [object for x in range(n_ts)]; self._dyn_gen_eigenvectors = [object for x in range(n_ts)]; if self.cache_dyn_gen_eigenvectors_adj:; self._dyn_gen_eigenvectors_adj = [object for x in range(n_ts)]; self._dyn_gen_factormatrix = [object for x in range(n_ts)]. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FidelityComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; if not self._timeslots_initialized:; init_tslots = True; if init_tslots:; self.init_timeslots(); self._init_evo(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). def check_ctrls_initialized(self):; if not ",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:45758,Modifiability,config,configuration,45758,"ecomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes; ----------; drift_ham : Qobj; This is the drift Hamiltonian for unitary dynamics; It is mapped to drift_dyn_gen during initialize_controls. ctrl_ham : List of Qobj; These are the control Hamiltonians for unitary dynamics; It is mapped to ctrl_dyn_gen during initialize_controls. H : List of Qobj; The combined drift and control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'UNIT'; self.drift_ham = None; self.ctrl_ham = None; self.H = None; self._dyn_gen_phase = -1j; self._phase_application = 'preop'; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). # set the default fidelity computer; self.fid_computer = fidcomp.FidCompUnitary(self); # set the default propagator computer; self.prop_computer = propcomp.PropCompDiag(self). [docs] def initialize_controls(self, amplitudes, init_tslots=True):; # Either the _dyn_gen or _ham names can be used; # This assumes that one or other has been set in the configuration. self._map_dyn_gen_to_ham(); Dynamics.initialize_controls(self, amplitudes, init_tslots=init_tslots); #self.H = self._dyn_gen. def _map_dyn_gen_to_ham(self):; if self.drift_dyn_gen is None:; self.drift_dyn_gen = self.drift_ham; else:; self.drift_ham = self.drift_dyn_gen. if self.ctrl_dyn_gen is None:; self.ctrl_dyn_gen = self.ctrl_ham; else:; self.ctrl_ham = self.ctrl_dyn_gen. self._dyn_gen_mapped = True. @property; ",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:45813,Modifiability,config,config,45813,"he method is taken from DYNAMO (see file header). Attributes; ----------; drift_ham : Qobj; This is the drift Hamiltonian for unitary dynamics; It is mapped to drift_dyn_gen during initialize_controls. ctrl_ham : List of Qobj; These are the control Hamiltonians for unitary dynamics; It is mapped to ctrl_dyn_gen during initialize_controls. H : List of Qobj; The combined drift and control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'UNIT'; self.drift_ham = None; self.ctrl_ham = None; self.H = None; self._dyn_gen_phase = -1j; self._phase_application = 'preop'; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). # set the default fidelity computer; self.fid_computer = fidcomp.FidCompUnitary(self); # set the default propagator computer; self.prop_computer = propcomp.PropCompDiag(self). [docs] def initialize_controls(self, amplitudes, init_tslots=True):; # Either the _dyn_gen or _ham names can be used; # This assumes that one or other has been set in the configuration. self._map_dyn_gen_to_ham(); Dynamics.initialize_controls(self, amplitudes, init_tslots=init_tslots); #self.H = self._dyn_gen. def _map_dyn_gen_to_ham(self):; if self.drift_dyn_gen is None:; self.drift_dyn_gen = self.drift_ham; else:; self.drift_ham = self.drift_dyn_gen. if self.ctrl_dyn_gen is None:; self.ctrl_dyn_gen = self.ctrl_ham; else:; self.ctrl_ham = self.ctrl_dyn_gen. self._dyn_gen_mapped = True. @property; def num_ctrls(self):; if not self._dyn_gen_mapped:; self._map_dyn_g",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:46316,Modifiability,config,configuration,46316," These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'UNIT'; self.drift_ham = None; self.ctrl_ham = None; self.H = None; self._dyn_gen_phase = -1j; self._phase_application = 'preop'; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). # set the default fidelity computer; self.fid_computer = fidcomp.FidCompUnitary(self); # set the default propagator computer; self.prop_computer = propcomp.PropCompDiag(self). [docs] def initialize_controls(self, amplitudes, init_tslots=True):; # Either the _dyn_gen or _ham names can be used; # This assumes that one or other has been set in the configuration. self._map_dyn_gen_to_ham(); Dynamics.initialize_controls(self, amplitudes, init_tslots=init_tslots); #self.H = self._dyn_gen. def _map_dyn_gen_to_ham(self):; if self.drift_dyn_gen is None:; self.drift_dyn_gen = self.drift_ham; else:; self.drift_ham = self.drift_dyn_gen. if self.ctrl_dyn_gen is None:; self.ctrl_dyn_gen = self.ctrl_ham; else:; self.ctrl_ham = self.ctrl_dyn_gen. self._dyn_gen_mapped = True. @property; def num_ctrls(self):; if not self._dyn_gen_mapped:; self._map_dyn_gen_to_ham(); if self._num_ctrls is None:; self._num_ctrls = self._get_num_ctrls(); return self._num_ctrls. def _get_onto_evo_target(self):; """"""; Get the adjoint of the target.; Used for calculating the 'backward' evolution; """"""; if self.oper_dtype == Qobj:; self._onto_evo_target = self.target.dag(); else:; self._onto_evo_target = self._target.T.conj(); return self._onto_evo_target. def _spectral_decomp(self, k):; """"""",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:52428,Modifiability,config,configuration,52428,"ry(; self._dyn_gen_eigenvectors_adj[k]); else:; eigvecadj_unit = None; msg = (""prop unit: {}; H herm: {}; ""; ""eigval unit: {}; eigvec unit: {}; ""; ""eigvecadj_unit: {}"".format(; prop_unit, herm, eigval_unit, eigvec_unit,; eigvecadj_unit)); logger.info(msg). [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omega : array[drift_dyn_gen.shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems. """""". def reset(self):; Dynamics.reset(self); self.id_text = 'SYMPL'; self._omega = None; self._omega_qobj = None; self._phase_application = 'postop'; self.grad_exact = True; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). @property; def omega(self):; if self._omega is None:; self._get_omega(); if self._omega_qobj is None:; self._omega_qobj = Qobj(self._omega, dims=self.dyn_dims); return self._omega_qobj. def _get_omega(self):; if self._omega is None:; n = self.get_drift_dim() // 2; omg = sympl.calc_omega(n); if self.oper_dtype == Qobj:; self._omega = Qobj(omg, dims=self.dyn_dims); self._omega_qobj = self._omega; else:; self._omega = omg; return self._omega. def _set_phase_application(self, value):; Dynamics._set_phase_application(self, value); if self._evo_initialized:; phase = self._get_dyn_gen_phase(); if phase is not None:; self._dyn_gen_phase = phase. def _get_dyn_gen_phase(self):;",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:52483,Modifiability,config,config,52483,"one; msg = (""prop unit: {}; H herm: {}; ""; ""eigval unit: {}; eigvec unit: {}; ""; ""eigvecadj_unit: {}"".format(; prop_unit, herm, eigval_unit, eigvec_unit,; eigvecadj_unit)); logger.info(msg). [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omega : array[drift_dyn_gen.shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems. """""". def reset(self):; Dynamics.reset(self); self.id_text = 'SYMPL'; self._omega = None; self._omega_qobj = None; self._phase_application = 'postop'; self.grad_exact = True; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). @property; def omega(self):; if self._omega is None:; self._get_omega(); if self._omega_qobj is None:; self._omega_qobj = Qobj(self._omega, dims=self.dyn_dims); return self._omega_qobj. def _get_omega(self):; if self._omega is None:; n = self.get_drift_dim() // 2; omg = sympl.calc_omega(n); if self.oper_dtype == Qobj:; self._omega = Qobj(omg, dims=self.dyn_dims); self._omega_qobj = self._omega; else:; self._omega = omg; return self._omega. def _set_phase_application(self, value):; Dynamics._set_phase_application(self, value); if self._evo_initialized:; phase = self._get_dyn_gen_phase(); if phase is not None:; self._dyn_gen_phase = phase. def _get_dyn_gen_phase(self):; if self._phase_application == 'postop':; phase = -self._get_omega(",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:6409,Performance,perform,performance,6409,"ter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot ",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:7151,Performance,perform,performance,7151,"nerators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more informatio",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:8414,Performance,perform,perform,8414,"omputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_gen : bool; If True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_grad : bool; If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: bool; If True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_opti",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:8464,Performance,perform,perform,8464,"omputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_gen : bool; If True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_grad : bool; If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: bool; If True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_opti",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:8967,Performance,cache,cache,8967," hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_gen : bool; If True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_grad : bool; If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: bool; If True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, otherwise False. num_tslots : integer; Number of timeslots (aka timeslices). num_ctrls : integer; Number of controls.; Note this is calculated as the length of ctrl_dyn_gen when first used.; And is recalculated during initialise_controls only. evo_time : float; Total time for the evolution. tau : array[num_tslots] of float; Duration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:9222,Performance,cache,cached,9222,"em directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_gen : bool; If True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_grad : bool; If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: bool; If True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, otherwise False. num_tslots : integer; Number of timeslots (aka timeslices). num_ctrls : integer; Number of controls.; Note this is calculated as the length of ctrl_dyn_gen when first used.; And is recalculated during initialise_controls only. evo_time : float; Total time for the evolution. tau : array[num_tslots] of float; Duration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots and evo_time are calculated from tau, otherwise; tau is generated from num_tslots and evo_time, that is; equal size time slices. time : array[num_tslots+1] of float; Cumulative time for the evolution, that is the time at the start; of each time slice. drift_dyn_gen : Qobj or list of Qobj; Drift or system dynamics generat",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:23930,Performance,optimiz,optimization,23930,"oper_dtype = Qobj; else:; # small system, but quite sparse -> qutips sparse/dense method; self.oper_dtype = np.ndarray. return self.oper_dtype. def _init_evo(self):; """"""; Create the container lists / arrays for the:; dynamics generations, propagators, and evolutions etc; Set the time slices and cumulative time; """"""; # check evolution operators; if not self._drift_dyn_gen_checked:; _check_drift_dyn_gen(self.drift_dyn_gen); if not self._ctrl_dyn_gen_checked:; self.ctrl_dyn_gen = _check_ctrls_container(self.ctrl_dyn_gen). if not isinstance(self.initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(self.target, Qobj):; raise TypeError(""target must be a Qobj""). self.refresh_drift_attribs(); self.sys_dims = self.initial.dims; self.sys_shape = self.initial.shape; # Set the phase application method; self._init_phase(). self._set_memory_optimizations(); if self.sparse_eigen_decomp and self.sys_shape[0] <= 2:; raise ValueError(; ""Single qubit pulse optimization dynamics cannot use sparse""; "" eigenvector decomposition because of limitations in""; "" scipy.linalg.eigsh. Pleae set sparse_eigen_decomp to False""; "" or increase the size of the system.""). n_ts = self.num_tslots; n_ctrls = self.num_ctrls; if self.oper_dtype == Qobj:; self._initial = self.initial; self._target = self.target; self._drift_dyn_gen = self.drift_dyn_gen; self._ctrl_dyn_gen = self.ctrl_dyn_gen; elif self.oper_dtype == np.ndarray:; self._initial = self.initial.full(); self._target = self.target.full(); if self.time_depend_drift:; self._drift_dyn_gen = [d.full() for d in self.drift_dyn_gen]; else:; self._drift_dyn_gen = self.drift_dyn_gen.full(); if self.time_depend_ctrl_dyn_gen:; self._ctrl_dyn_gen = np.empty([n_ts, n_ctrls], dtype=object); for k in range(n_ts):; for j in range(n_ctrls):; self._ctrl_dyn_gen[k, j] = \; self.ctrl_dyn_gen[k, j].full(); else:; self._ctrl_dyn_gen = [ctrl.full(); for ctrl in self.ctrl_dyn_gen]; else:; raise ValueError(; ""Unknown oper_dtype {!r}. The oper_dtype",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:48936,Safety,avoid,avoid,48936,"oper_dtype == np.ndarray:; H = self._dyn_gen[k]; # returns row vector of eigenvals, columns with the eigenvecs; eig_val, eig_vec = eigh(H). else:; assert False, f""Unknown oper_dtype {self.oper_dtype!r}"". # assuming H is an nxn matrix, find n; n = self.get_drift_dim(). # Calculate the propagator in the diagonalised basis; eig_val_tau = -1j*eig_val*self.tau[k]; prop_eig = np.exp(eig_val_tau). # Generate the factor matrix through the differences; # between each of the eigenvectors and the exponentiations; # create nxn matrix where each eigen val is repeated n times; # down the columns; o = np.ones([n, n]); eig_val_cols = eig_val_tau*o; # calculate all the differences by subtracting it from its transpose; eig_val_diffs = eig_val_cols - eig_val_cols.T; # repeat for the propagator; prop_eig_cols = prop_eig*o; prop_eig_diffs = prop_eig_cols - prop_eig_cols.T; # the factor matrix is the elementwise quotient of the; # differeneces between the exponentiated eigen vals and the; # differences between the eigen vals; # need to avoid division by zero that would arise due to denegerate; # eigenvalues and the diagonals; degen_mask = np.abs(eig_val_diffs) < self.fact_mat_round_prec; eig_val_diffs[degen_mask] = 1; factors = prop_eig_diffs / eig_val_diffs; # for degenerate eigenvalues the factor is just the exponent; factors[degen_mask] = prop_eig_cols[degen_mask]. # Store eigenvectors, propagator and factor matric; # for use in propagator computations; self._decomp_curr[k] = True; if isinstance(factors, np.ndarray):; self._dyn_gen_factormatrix[k] = factors; else:; self._dyn_gen_factormatrix[k] = np.array(factors). if self.oper_dtype == Qobj:; self._prop_eigen[k] = Qobj(np.diagflat(prop_eig),; dims=self.dyn_dims); self._dyn_gen_eigenvectors[k] = Qobj(eig_vec,; dims=self.dyn_dims); # The _dyn_gen_eigenvectors_adj list is not used in; # memory optimised modes; if self._dyn_gen_eigenvectors_adj is not None:; self._dyn_gen_eigenvectors_adj[k] = \; self._dyn_gen_eigenvectors[k].dag(); elif",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:6004,Security,access,access,6004,"ould be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(; ""drift should be a Qobj or a list of Qobj""). warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are th",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:15316,Security,access,accessors,15316,"self.memory_optimization = 0; self.oper_dtype = None; self.cache_phased_dyn_gen = None; self.cache_prop_grad = None; self.cache_dyn_gen_eigenvectors_adj = None; self.sparse_eigen_decomp = None; self.dyn_dims = None; self.dyn_shape = None; self.sys_dims = None; self.sys_shape = None; self.time_depend_drift = False; self.time_depend_ctrl_dyn_gen = False; # These internal attributes will be of the internal operator data type; # used to compute the evolution; # This will be either ndarray or Qobj; self._drift_dyn_gen = None; self._ctrl_dyn_gen = None; self._phased_ctrl_dyn_gen = None; self._dyn_gen_phase = None; self._phase_application = None; self._initial = None; self._target = None; self._onto_evo_target = None; self._dyn_gen = None; self._phased_dyn_gen = None; self._prop = None; self._prop_grad = None; self._fwd_evo = None; self._onwd_evo = None; self._onto_evo = None; # The _qobj attribs are Qobj representations of the equivalent; # internal attribute. They are only set when the extenal accessors; # are used; self._onto_evo_target_qobj = None; self._dyn_gen_qobj = None; self._prop_qobj = None; self._prop_grad_qobj = None; self._fwd_evo_qobj = None; self._onwd_evo_qobj = None; self._onto_evo_qobj = None; # Atrributes used in diagonalisation; # again in internal operator data type (see above); self._decomp_curr = None; self._prop_eigen = None; self._dyn_gen_eigenvectors = None; self._dyn_gen_eigenvectors_adj = None; self._dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.log_level = self.config.log_level; # Internal flags; self._dyn_gen_mapped = False; self._evo_initialized = False; self._timeslots_initialized = False; self._ctrls_initialized = False; self._ctrl_dyn_gen_checked = False; self._drift_dyn_gen_checked = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = Non",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:3276,Testability,log,logging,3276,"niel Burgarth. """"""; Classes that define the dynamics of the (quantum) system and target evolution; to be optimised.; The contols are also defined here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; from qutip.sparse import sp_eigs, eigh; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. def _check_ctrls_container(ctrls):; """"""; Check through the controls container.; Convert to an array if its a list of lists; return the processed container; raise type error if the container structure is invalid; """"""; if isinstance(ctrls, (list, tuple)):; # Check to see if list of lists; try:; if isinstance(ctrls[0], (list, tuple)):; ctrls_ = np.empty((len(ctrls), len(ctrls[0])), dtype=object); for i, ",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:3315,Testability,log,logging,3315,"amics of the (quantum) system and target evolution; to be optimised.; The contols are also defined here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; from qutip.sparse import sp_eigs, eigh; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. def _check_ctrls_container(ctrls):; """"""; Check through the controls container.; Convert to an array if its a list of lists; return the processed container; raise type error if the container structure is invalid; """"""; if isinstance(ctrls, (list, tuple)):; # Check to see if list of lists; try:; if isinstance(ctrls[0], (list, tuple)):; ctrls_ = np.empty((len(ctrls), len(ctrls[0])), dtype=object); for i, ctrl in enumerate(ctrls):; ctrls_[i, :] = ctrl; ",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:3324,Testability,log,logger,3324,"amics of the (quantum) system and target evolution; to be optimised.; The contols are also defined here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; from qutip.sparse import sp_eigs, eigh; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. def _check_ctrls_container(ctrls):; """"""; Check through the controls container.; Convert to an array if its a list of lists; return the processed container; raise type error if the container structure is invalid; """"""; if isinstance(ctrls, (list, tuple)):; # Check to see if list of lists; try:; if isinstance(ctrls[0], (list, tuple)):; ctrls_ = np.empty((len(ctrls), len(ctrls[0])), dtype=object); for i, ctrl in enumerate(ctrls):; ctrls_[i, :] = ctrl; ",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:3333,Testability,log,logging,3333,"amics of the (quantum) system and target evolution; to be optimised.; The contols are also defined here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; from qutip.sparse import sp_eigs, eigh; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. def _check_ctrls_container(ctrls):; """"""; Check through the controls container.; Convert to an array if its a list of lists; return the processed container; raise type error if the container structure is invalid; """"""; if isinstance(ctrls, (list, tuple)):; # Check to see if list of lists; try:; if isinstance(ctrls[0], (list, tuple)):; ctrls_ = np.empty((len(ctrls), len(ctrls[0])), dtype=object); for i, ctrl in enumerate(ctrls):; ctrls_[i, :] = ctrl; ",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:6571,Testability,log,logger,6571,"n warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagat",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:16987,Testability,log,logger,16987,"g_level; # Internal flags; self._dyn_gen_mapped = False; self._evo_initialized = False; self._timeslots_initialized = False; self._ctrls_initialized = False; self._ctrl_dyn_gen_checked = False; self._drift_dyn_gen_checked = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = None; self.dump_to_file = False. self.apply_params(). # Create the computing objects; self._create_computers(). self.clear(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def dumping(self):; """"""; The level of data dumping that will occur during the time evolution; calculation. - NONE : No processing data dumped (Default); - SUMMARY : A summary of each time evolution will be recorded; - FULL : All operators used or created in the calculation dumped; - CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which operators are dumped. WARNING: FULL could; consume a lot of memory!; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; se",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:17105,Testability,log,logger,17105,"s_initialized = False; self._ctrls_initialized = False; self._ctrl_dyn_gen_checked = False; self._drift_dyn_gen_checked = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = None; self.dump_to_file = False. self.apply_params(). # Create the computing objects; self._create_computers(). self.clear(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def dumping(self):; """"""; The level of data dumping that will occur during the time evolution; calculation. - NONE : No processing data dumped (Default); - SUMMARY : A summary of each time evolution will be recorded; - FULL : All operators used or created in the calculation dumped; - CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which operators are dumped. WARNING: FULL could; consume a lot of memory!; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.DynamicsDump):; self.dump = qtrldump.Dynam",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:17126,Testability,log,logger,17126,"s_initialized = False; self._ctrls_initialized = False; self._ctrl_dyn_gen_checked = False; self._drift_dyn_gen_checked = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = None; self.dump_to_file = False. self.apply_params(). # Create the computing objects; self._create_computers(). self.clear(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def dumping(self):; """"""; The level of data dumping that will occur during the time evolution; calculation. - NONE : No processing data dumped (Default); - SUMMARY : A summary of each time evolution will be recorded; - FULL : All operators used or created in the calculation dumped; - CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which operators are dumped. WARNING: FULL could; consume a lot of memory!; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.DynamicsDump):; self.dump = qtrldump.Dynam",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:17153,Testability,log,logger,17153,"_checked = False; self._drift_dyn_gen_checked = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = None; self.dump_to_file = False. self.apply_params(). # Create the computing objects; self._create_computers(). self.clear(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def dumping(self):; """"""; The level of data dumping that will occur during the time evolution; calculation. - NONE : No processing data dumped (Default); - SUMMARY : A summary of each time evolution will be recorded; - FULL : All operators used or created in the calculation dumped; - CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which operators are dumped. WARNING: FULL could; consume a lot of memory!; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.DynamicsDump):; self.dump = qtrldump.DynamicsDump(self, level=lvl); else:; self.dump.level = lvl. @property; def dum",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:20869,Testability,log,logger,20869,"u attribute is already set; in which case this step in ignored; Generate the cumulative time array 'time' based on the tau values; """"""; # set the time intervals to be equal timeslices of the total if; # the have not been set already (as part of user config); if self._num_tslots is None:; self._num_tslots = DEF_NUM_TSLOTS; if self._evo_time is None:; self._evo_time = DEF_EVO_TIME. if self._tau is None:; self._tau = np.ones(self._num_tslots, dtype='f') * \; self._evo_time/self._num_tslots; else:; self._num_tslots = len(self._tau); self._evo_time = np.sum(self._tau). self.time = np.zeros(self._num_tslots+1, dtype=float); # set the cumulative time by summing the time intervals; for t in range(self._num_tslots):; self.time[t+1] = self.time[t] + self._tau[t]. self._timeslots_initialized = True. def _set_memory_optimizations(self):; """"""; Set various memory optimisation attributes based on the; memory_optimization attribute; If they have been set already, e.g. in apply_params; then they will not be overridden here; """"""; logger.info(""Setting memory optimisations for level {}"".format(; self.memory_optimization)). if self.oper_dtype is None:; self._choose_oper_dtype(); logger.info(""Internal operator data type choosen to be {}"".format(; self.oper_dtype)); else:; logger.info(""Using operator data type {}"".format(; self.oper_dtype)). if self.cache_phased_dyn_gen is None:; if self.memory_optimization > 0:; self.cache_phased_dyn_gen = False; else:; self.cache_phased_dyn_gen = True; logger.info(""phased dynamics generator caching {}"".format(; self.cache_phased_dyn_gen)). if self.cache_prop_grad is None:; if self.memory_optimization > 0:; self.cache_prop_grad = False; else:; self.cache_prop_grad = True; logger.info(""propagator gradient caching {}"".format(; self.cache_prop_grad)). if self.cache_dyn_gen_eigenvectors_adj is None:; if self.memory_optimization > 0:; self.cache_dyn_gen_eigenvectors_adj = False; else:; self.cache_dyn_gen_eigenvectors_adj = True; logger.info(""eigenvector adjoin",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:21018,Testability,log,logger,21018,"ual timeslices of the total if; # the have not been set already (as part of user config); if self._num_tslots is None:; self._num_tslots = DEF_NUM_TSLOTS; if self._evo_time is None:; self._evo_time = DEF_EVO_TIME. if self._tau is None:; self._tau = np.ones(self._num_tslots, dtype='f') * \; self._evo_time/self._num_tslots; else:; self._num_tslots = len(self._tau); self._evo_time = np.sum(self._tau). self.time = np.zeros(self._num_tslots+1, dtype=float); # set the cumulative time by summing the time intervals; for t in range(self._num_tslots):; self.time[t+1] = self.time[t] + self._tau[t]. self._timeslots_initialized = True. def _set_memory_optimizations(self):; """"""; Set various memory optimisation attributes based on the; memory_optimization attribute; If they have been set already, e.g. in apply_params; then they will not be overridden here; """"""; logger.info(""Setting memory optimisations for level {}"".format(; self.memory_optimization)). if self.oper_dtype is None:; self._choose_oper_dtype(); logger.info(""Internal operator data type choosen to be {}"".format(; self.oper_dtype)); else:; logger.info(""Using operator data type {}"".format(; self.oper_dtype)). if self.cache_phased_dyn_gen is None:; if self.memory_optimization > 0:; self.cache_phased_dyn_gen = False; else:; self.cache_phased_dyn_gen = True; logger.info(""phased dynamics generator caching {}"".format(; self.cache_phased_dyn_gen)). if self.cache_prop_grad is None:; if self.memory_optimization > 0:; self.cache_prop_grad = False; else:; self.cache_prop_grad = True; logger.info(""propagator gradient caching {}"".format(; self.cache_prop_grad)). if self.cache_dyn_gen_eigenvectors_adj is None:; if self.memory_optimization > 0:; self.cache_dyn_gen_eigenvectors_adj = False; else:; self.cache_dyn_gen_eigenvectors_adj = True; logger.info(""eigenvector adjoint caching {}"".format(; self.cache_dyn_gen_eigenvectors_adj)). if self.sparse_eigen_decomp is None:; if self.memory_optimization > 1:; self.sparse_eigen_decomp = True; el",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:21112,Testability,log,logger,21112,"lf._num_tslots is None:; self._num_tslots = DEF_NUM_TSLOTS; if self._evo_time is None:; self._evo_time = DEF_EVO_TIME. if self._tau is None:; self._tau = np.ones(self._num_tslots, dtype='f') * \; self._evo_time/self._num_tslots; else:; self._num_tslots = len(self._tau); self._evo_time = np.sum(self._tau). self.time = np.zeros(self._num_tslots+1, dtype=float); # set the cumulative time by summing the time intervals; for t in range(self._num_tslots):; self.time[t+1] = self.time[t] + self._tau[t]. self._timeslots_initialized = True. def _set_memory_optimizations(self):; """"""; Set various memory optimisation attributes based on the; memory_optimization attribute; If they have been set already, e.g. in apply_params; then they will not be overridden here; """"""; logger.info(""Setting memory optimisations for level {}"".format(; self.memory_optimization)). if self.oper_dtype is None:; self._choose_oper_dtype(); logger.info(""Internal operator data type choosen to be {}"".format(; self.oper_dtype)); else:; logger.info(""Using operator data type {}"".format(; self.oper_dtype)). if self.cache_phased_dyn_gen is None:; if self.memory_optimization > 0:; self.cache_phased_dyn_gen = False; else:; self.cache_phased_dyn_gen = True; logger.info(""phased dynamics generator caching {}"".format(; self.cache_phased_dyn_gen)). if self.cache_prop_grad is None:; if self.memory_optimization > 0:; self.cache_prop_grad = False; else:; self.cache_prop_grad = True; logger.info(""propagator gradient caching {}"".format(; self.cache_prop_grad)). if self.cache_dyn_gen_eigenvectors_adj is None:; if self.memory_optimization > 0:; self.cache_dyn_gen_eigenvectors_adj = False; else:; self.cache_dyn_gen_eigenvectors_adj = True; logger.info(""eigenvector adjoint caching {}"".format(; self.cache_dyn_gen_eigenvectors_adj)). if self.sparse_eigen_decomp is None:; if self.memory_optimization > 1:; self.sparse_eigen_decomp = True; else:; self.sparse_eigen_decomp = False; logger.info(""use sparse eigen decomp {}"".format(; self.",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:21331,Testability,log,logger,21331,"._num_tslots; else:; self._num_tslots = len(self._tau); self._evo_time = np.sum(self._tau). self.time = np.zeros(self._num_tslots+1, dtype=float); # set the cumulative time by summing the time intervals; for t in range(self._num_tslots):; self.time[t+1] = self.time[t] + self._tau[t]. self._timeslots_initialized = True. def _set_memory_optimizations(self):; """"""; Set various memory optimisation attributes based on the; memory_optimization attribute; If they have been set already, e.g. in apply_params; then they will not be overridden here; """"""; logger.info(""Setting memory optimisations for level {}"".format(; self.memory_optimization)). if self.oper_dtype is None:; self._choose_oper_dtype(); logger.info(""Internal operator data type choosen to be {}"".format(; self.oper_dtype)); else:; logger.info(""Using operator data type {}"".format(; self.oper_dtype)). if self.cache_phased_dyn_gen is None:; if self.memory_optimization > 0:; self.cache_phased_dyn_gen = False; else:; self.cache_phased_dyn_gen = True; logger.info(""phased dynamics generator caching {}"".format(; self.cache_phased_dyn_gen)). if self.cache_prop_grad is None:; if self.memory_optimization > 0:; self.cache_prop_grad = False; else:; self.cache_prop_grad = True; logger.info(""propagator gradient caching {}"".format(; self.cache_prop_grad)). if self.cache_dyn_gen_eigenvectors_adj is None:; if self.memory_optimization > 0:; self.cache_dyn_gen_eigenvectors_adj = False; else:; self.cache_dyn_gen_eigenvectors_adj = True; logger.info(""eigenvector adjoint caching {}"".format(; self.cache_dyn_gen_eigenvectors_adj)). if self.sparse_eigen_decomp is None:; if self.memory_optimization > 1:; self.sparse_eigen_decomp = True; else:; self.sparse_eigen_decomp = False; logger.info(""use sparse eigen decomp {}"".format(; self.sparse_eigen_decomp)). def _choose_oper_dtype(self):; """"""; Attempt select most efficient internal operator data type; """""". if self.memory_optimization > 0:; self.oper_dtype = Qobj; else:; # Method taken from Qobj.ex",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:21554,Testability,log,logger,21554,"num_tslots):; self.time[t+1] = self.time[t] + self._tau[t]. self._timeslots_initialized = True. def _set_memory_optimizations(self):; """"""; Set various memory optimisation attributes based on the; memory_optimization attribute; If they have been set already, e.g. in apply_params; then they will not be overridden here; """"""; logger.info(""Setting memory optimisations for level {}"".format(; self.memory_optimization)). if self.oper_dtype is None:; self._choose_oper_dtype(); logger.info(""Internal operator data type choosen to be {}"".format(; self.oper_dtype)); else:; logger.info(""Using operator data type {}"".format(; self.oper_dtype)). if self.cache_phased_dyn_gen is None:; if self.memory_optimization > 0:; self.cache_phased_dyn_gen = False; else:; self.cache_phased_dyn_gen = True; logger.info(""phased dynamics generator caching {}"".format(; self.cache_phased_dyn_gen)). if self.cache_prop_grad is None:; if self.memory_optimization > 0:; self.cache_prop_grad = False; else:; self.cache_prop_grad = True; logger.info(""propagator gradient caching {}"".format(; self.cache_prop_grad)). if self.cache_dyn_gen_eigenvectors_adj is None:; if self.memory_optimization > 0:; self.cache_dyn_gen_eigenvectors_adj = False; else:; self.cache_dyn_gen_eigenvectors_adj = True; logger.info(""eigenvector adjoint caching {}"".format(; self.cache_dyn_gen_eigenvectors_adj)). if self.sparse_eigen_decomp is None:; if self.memory_optimization > 1:; self.sparse_eigen_decomp = True; else:; self.sparse_eigen_decomp = False; logger.info(""use sparse eigen decomp {}"".format(; self.sparse_eigen_decomp)). def _choose_oper_dtype(self):; """"""; Attempt select most efficient internal operator data type; """""". if self.memory_optimization > 0:; self.oper_dtype = Qobj; else:; # Method taken from Qobj.expm(); # if method is not explicitly given, try to make a good choice; # between sparse and dense solvers by considering the size of the; # system and the number of non-zero elements.; if self.time_depend_drift:; dg = self.drif",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:21811,Testability,log,logger,21811,"lready, e.g. in apply_params; then they will not be overridden here; """"""; logger.info(""Setting memory optimisations for level {}"".format(; self.memory_optimization)). if self.oper_dtype is None:; self._choose_oper_dtype(); logger.info(""Internal operator data type choosen to be {}"".format(; self.oper_dtype)); else:; logger.info(""Using operator data type {}"".format(; self.oper_dtype)). if self.cache_phased_dyn_gen is None:; if self.memory_optimization > 0:; self.cache_phased_dyn_gen = False; else:; self.cache_phased_dyn_gen = True; logger.info(""phased dynamics generator caching {}"".format(; self.cache_phased_dyn_gen)). if self.cache_prop_grad is None:; if self.memory_optimization > 0:; self.cache_prop_grad = False; else:; self.cache_prop_grad = True; logger.info(""propagator gradient caching {}"".format(; self.cache_prop_grad)). if self.cache_dyn_gen_eigenvectors_adj is None:; if self.memory_optimization > 0:; self.cache_dyn_gen_eigenvectors_adj = False; else:; self.cache_dyn_gen_eigenvectors_adj = True; logger.info(""eigenvector adjoint caching {}"".format(; self.cache_dyn_gen_eigenvectors_adj)). if self.sparse_eigen_decomp is None:; if self.memory_optimization > 1:; self.sparse_eigen_decomp = True; else:; self.sparse_eigen_decomp = False; logger.info(""use sparse eigen decomp {}"".format(; self.sparse_eigen_decomp)). def _choose_oper_dtype(self):; """"""; Attempt select most efficient internal operator data type; """""". if self.memory_optimization > 0:; self.oper_dtype = Qobj; else:; # Method taken from Qobj.expm(); # if method is not explicitly given, try to make a good choice; # between sparse and dense solvers by considering the size of the; # system and the number of non-zero elements.; if self.time_depend_drift:; dg = self.drift_dyn_gen[0]; else:; dg = self.drift_dyn_gen; if self.time_depend_ctrl_dyn_gen:; ctrls = self.ctrl_dyn_gen[0, :]; else:; ctrls = self.ctrl_dyn_gen; for c in ctrls:; dg = dg + c. N = dg.data.shape[0]; n = dg.data.nnz. if N ** 2 < 100 * n:; # large nu",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:22050,Testability,log,logger,22050," operator data type choosen to be {}"".format(; self.oper_dtype)); else:; logger.info(""Using operator data type {}"".format(; self.oper_dtype)). if self.cache_phased_dyn_gen is None:; if self.memory_optimization > 0:; self.cache_phased_dyn_gen = False; else:; self.cache_phased_dyn_gen = True; logger.info(""phased dynamics generator caching {}"".format(; self.cache_phased_dyn_gen)). if self.cache_prop_grad is None:; if self.memory_optimization > 0:; self.cache_prop_grad = False; else:; self.cache_prop_grad = True; logger.info(""propagator gradient caching {}"".format(; self.cache_prop_grad)). if self.cache_dyn_gen_eigenvectors_adj is None:; if self.memory_optimization > 0:; self.cache_dyn_gen_eigenvectors_adj = False; else:; self.cache_dyn_gen_eigenvectors_adj = True; logger.info(""eigenvector adjoint caching {}"".format(; self.cache_dyn_gen_eigenvectors_adj)). if self.sparse_eigen_decomp is None:; if self.memory_optimization > 1:; self.sparse_eigen_decomp = True; else:; self.sparse_eigen_decomp = False; logger.info(""use sparse eigen decomp {}"".format(; self.sparse_eigen_decomp)). def _choose_oper_dtype(self):; """"""; Attempt select most efficient internal operator data type; """""". if self.memory_optimization > 0:; self.oper_dtype = Qobj; else:; # Method taken from Qobj.expm(); # if method is not explicitly given, try to make a good choice; # between sparse and dense solvers by considering the size of the; # system and the number of non-zero elements.; if self.time_depend_drift:; dg = self.drift_dyn_gen[0]; else:; dg = self.drift_dyn_gen; if self.time_depend_ctrl_dyn_gen:; ctrls = self.ctrl_dyn_gen[0, :]; else:; ctrls = self.ctrl_dyn_gen; for c in ctrls:; dg = dg + c. N = dg.data.shape[0]; n = dg.data.nnz. if N ** 2 < 100 * n:; # large number of nonzero elements, revert to dense solver; self.oper_dtype = np.ndarray; elif N > 400:; # large system, and quite sparse -> qutips sparse method; self.oper_dtype = Qobj; else:; # small system, but quite sparse -> qutips sparse/dense meth",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:26337,Testability,log,logging,26337,"y_phase(ctrl); for ctrl in self._ctrl_dyn_gen]. self._dyn_gen = [object for x in range(self.num_tslots)]; if self.cache_phased_dyn_gen:; self._phased_dyn_gen = [object for x in range(self.num_tslots)]; self._prop = [object for x in range(self.num_tslots)]; if self.prop_computer.grad_exact and self.cache_prop_grad:; self._prop_grad = np.empty([self.num_tslots, self.num_ctrls],; dtype=object); # Time evolution operator (forward propagation); self._fwd_evo = [object for x in range(self.num_tslots+1)]; self._fwd_evo[0] = self._initial; if self.fid_computer.uses_onwd_evo:; # Time evolution operator (onward propagation); self._onwd_evo = [object for x in range(self.num_tslots)]; if self.fid_computer.uses_onto_evo:; # Onward propagation overlap with inverse target; self._onto_evo = [object for x in range(self.num_tslots+1)]; self._onto_evo[self.num_tslots] = self._get_onto_evo_target(). if isinstance(self.prop_computer, propcomp.PropCompDiag):; self._create_decomp_lists(). if (self.log_level <= logging.DEBUG; and isinstance(self, DynamicsUnitary)):; self.unitarity_check_level = 1. if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Dynamics dump will be written to:\n{}"".format(; self.dump.dump_dir)). self._evo_initialized = True. @property; def dyn_gen_phase(self):; """"""; Some op that is applied to the dyn_gen before expontiating to; get the propagator.; See `phase_application` for how this is applied; """"""; # Note that if this returns None then _apply_phase will never be; # called; return self._dyn_gen_phase. @dyn_gen_phase.setter; def dyn_gen_phase(self, value):; self._dyn_gen_phase = value. @property; def phase_application(self):; """"""; phase_application : scalar(string), default='preop'; Determines how the phase is applied to the dynamics generators. - 'preop' : P = expm(phase*dyn_gen); - 'postop' : P = expm(dyn_gen*phase); - 'custom' : Customised phase application. The 'custom' o",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:26558,Testability,log,logger,26558,"ject for x in range(self.num_tslots)]; if self.prop_computer.grad_exact and self.cache_prop_grad:; self._prop_grad = np.empty([self.num_tslots, self.num_ctrls],; dtype=object); # Time evolution operator (forward propagation); self._fwd_evo = [object for x in range(self.num_tslots+1)]; self._fwd_evo[0] = self._initial; if self.fid_computer.uses_onwd_evo:; # Time evolution operator (onward propagation); self._onwd_evo = [object for x in range(self.num_tslots)]; if self.fid_computer.uses_onto_evo:; # Onward propagation overlap with inverse target; self._onto_evo = [object for x in range(self.num_tslots+1)]; self._onto_evo[self.num_tslots] = self._get_onto_evo_target(). if isinstance(self.prop_computer, propcomp.PropCompDiag):; self._create_decomp_lists(). if (self.log_level <= logging.DEBUG; and isinstance(self, DynamicsUnitary)):; self.unitarity_check_level = 1. if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Dynamics dump will be written to:\n{}"".format(; self.dump.dump_dir)). self._evo_initialized = True. @property; def dyn_gen_phase(self):; """"""; Some op that is applied to the dyn_gen before expontiating to; get the propagator.; See `phase_application` for how this is applied; """"""; # Note that if this returns None then _apply_phase will never be; # called; return self._dyn_gen_phase. @dyn_gen_phase.setter; def dyn_gen_phase(self, value):; self._dyn_gen_phase = value. @property; def phase_application(self):; """"""; phase_application : scalar(string), default='preop'; Determines how the phase is applied to the dynamics generators. - 'preop' : P = expm(phase*dyn_gen); - 'postop' : P = expm(dyn_gen*phase); - 'custom' : Customised phase application. The 'custom' option assumes that the _apply_phase method has been; set to a custom function.; """"""; return self._phase_application. @phase_application.setter; def phase_application(self, value):; self._set_phase_application(value). ",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:32005,Testability,log,logged,32005,"s(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""executed with the initial control amplitudes.""). def get_amp_times(self):; return self.time[:self.num_tslots]. [docs] def save_amps(self, file_name=None, times=None, amps=None, verbose=False):; """"""; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters; ----------; file_name : string; Name of the file; If None given the def_amps_fname attribuite will be used. times : List type (or string); List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by t",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:32300,Testability,log,logger,32300," [docs] def save_amps(self, file_name=None, times=None, amps=None, verbose=False):; """"""; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters; ----------; file_name : string; Name of the file; If None given the def_amps_fname attribuite will be used. times : List type (or string); List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.co",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:32639,Testability,log,logger,32639,"e (or string); List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this return",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:32718,Testability,log,logger,32718," each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:33062,Testability,log,logging,33062,"= True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh_drift_attribs(); return self.dyn_shape[0]. [docs] def refresh_drift_attribs(self):; """"""Reset the dyn_shape, dyn_dims and time_depend_drift attribs"""""". if isinstance(self.drift_dyn_gen, (list, tuple)):; d0 = self.drift_dyn_gen[0]; self.time_depend_drift = True; else:; d0 = self.drift_dyn_gen; self.time_depend_drift = False. if not isinstance(d0, Qobj):; raise TypeError(""U",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:33086,Testability,log,logger,33086,"s None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh_drift_attribs(); return self.dyn_shape[0]. [docs] def refresh_drift_attribs(self):; """"""Reset the dyn_shape, dyn_dims and time_depend_drift attribs"""""". if isinstance(self.drift_dyn_gen, (list, tuple)):; d0 = self.drift_dyn_gen[0]; self.time_depend_drift = True; else:; d0 = self.drift_dyn_gen; self.time_depend_drift = False. if not isinstance(d0, Qobj):; raise TypeError(""Unable to determine dri",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:33093,Testability,log,log,33093," = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh_drift_attribs(); return self.dyn_shape[0]. [docs] def refresh_drift_attribs(self):; """"""Reset the dyn_shape, dyn_dims and time_depend_drift attribs"""""". if isinstance(self.drift_dyn_gen, (list, tuple)):; d0 = self.drift_dyn_gen[0]; self.time_depend_drift = True; else:; d0 = self.drift_dyn_gen; self.time_depend_drift = False. if not isinstance(d0, Qobj):; raise TypeError(""Unable to determine drift attributes, "";",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:33097,Testability,log,logging,33097," = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh_drift_attribs(); return self.dyn_shape[0]. [docs] def refresh_drift_attribs(self):; """"""Reset the dyn_shape, dyn_dims and time_depend_drift attribs"""""". if isinstance(self.drift_dyn_gen, (list, tuple)):; d0 = self.drift_dyn_gen[0]; self.time_depend_drift = True; else:; d0 = self.drift_dyn_gen; self.time_depend_drift = False. if not isinstance(d0, Qobj):; raise TypeError(""Unable to determine drift attributes, "";",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:36387,Testability,assert,assert,36387," [self.sys_dims[1], self.sys_dims[0]]; self._onto_evo_target_qobj = Qobj(self._onto_evo_target,; dims=rev_dims). return self._onto_evo_target_qobj. def get_owd_evo_target(self):; _func_deprecation(""'get_owd_evo_target' has been replaced by ""; ""'onto_evo_target' property""); return self.onto_evo_target. def _get_onto_evo_target(self):; """"""; Get the inverse of the target.; Used for calculating the 'onto target' evolution; This is actually only relevant for unitary dynamics where; the target.dag() is what is required; However, for completeness, in general the inverse of the target; operator is is required; For state-to-state, the bra corresponding to the is required ket; """"""; if self.target.shape[0] == self.target.shape[1]:; #Target is operator; targ = la.inv(self.target.full()); if self.oper_dtype == Qobj:; rev_dims = [self.target.dims[1], self.target.dims[0]]; self._onto_evo_target = Qobj(targ, dims=rev_dims); elif self.oper_dtype == np.ndarray:; self._onto_evo_target = targ; else:; assert False, f""Unknown oper_dtype {self.oper_dtype!r}""; else:; if self.oper_dtype == Qobj:; self._onto_evo_target = self.target.dag(); elif self.oper_dtype == np.ndarray:; self._onto_evo_target = self.target.dag().full(); else:; assert False, f""Unknown oper_dtype {self.oper_dtype!r}"". return self._onto_evo_target. [docs] def combine_dyn_gen(self, k):; """"""; Computes the dynamics generator for a given timeslot; The is the combined Hamiltion for unitary systems; """"""; _func_deprecation(""'combine_dyn_gen' has been replaced by ""; ""'_combine_dyn_gen'""); self._combine_dyn_gen(k); return self._dyn_gen(k). def _combine_dyn_gen(self, k):; """"""; Computes the dynamics generator for a given timeslot; The is the combined Hamiltion for unitary systems; Also applies the phase (if any required by the propagation); """"""; if self.time_depend_drift:; dg = self._drift_dyn_gen[k]; else:; dg = self._drift_dyn_gen; for j in range(self._num_ctrls):; if self.time_depend_ctrl_dyn_gen:; dg = dg + self.ctrl_amps[k, j]*se",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:36617,Testability,assert,assert,36617," ""; ""'onto_evo_target' property""); return self.onto_evo_target. def _get_onto_evo_target(self):; """"""; Get the inverse of the target.; Used for calculating the 'onto target' evolution; This is actually only relevant for unitary dynamics where; the target.dag() is what is required; However, for completeness, in general the inverse of the target; operator is is required; For state-to-state, the bra corresponding to the is required ket; """"""; if self.target.shape[0] == self.target.shape[1]:; #Target is operator; targ = la.inv(self.target.full()); if self.oper_dtype == Qobj:; rev_dims = [self.target.dims[1], self.target.dims[0]]; self._onto_evo_target = Qobj(targ, dims=rev_dims); elif self.oper_dtype == np.ndarray:; self._onto_evo_target = targ; else:; assert False, f""Unknown oper_dtype {self.oper_dtype!r}""; else:; if self.oper_dtype == Qobj:; self._onto_evo_target = self.target.dag(); elif self.oper_dtype == np.ndarray:; self._onto_evo_target = self.target.dag().full(); else:; assert False, f""Unknown oper_dtype {self.oper_dtype!r}"". return self._onto_evo_target. [docs] def combine_dyn_gen(self, k):; """"""; Computes the dynamics generator for a given timeslot; The is the combined Hamiltion for unitary systems; """"""; _func_deprecation(""'combine_dyn_gen' has been replaced by ""; ""'_combine_dyn_gen'""); self._combine_dyn_gen(k); return self._dyn_gen(k). def _combine_dyn_gen(self, k):; """"""; Computes the dynamics generator for a given timeslot; The is the combined Hamiltion for unitary systems; Also applies the phase (if any required by the propagation); """"""; if self.time_depend_drift:; dg = self._drift_dyn_gen[k]; else:; dg = self._drift_dyn_gen; for j in range(self._num_ctrls):; if self.time_depend_ctrl_dyn_gen:; dg = dg + self.ctrl_amps[k, j]*self._ctrl_dyn_gen[k, j]; else:; dg = dg + self.ctrl_amps[k, j]*self._ctrl_dyn_gen[j]. self._dyn_gen[k] = dg; if self.cache_phased_dyn_gen:; self._phased_dyn_gen[k] = self._apply_phase(dg). [docs] def get_dyn_gen(self, k):; """"""; Get the com",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:42431,Testability,log,logging,42431,"._onwd_evo_qobj. @property; def evo_t2targ(self):; _attrib_deprecation(; ""'evo_t2targ' has been replaced by '_onto_evo'""); return self._onto_evo. @property; def onto_evo(self):; """"""; List of evolution operators (Qobj) from the initial to the given; timeslot; """"""; if self._onto_evo is not None:; if self._onto_evo_qobj is None:; if self.oper_dtype == Qobj:; self._onto_evo_qobj = self._onto_evo; else:; self._onto_evo_qobj = []; for k in range(0, self.num_tslots):; self._onto_evo_qobj.append(Qobj(self._onto_evo[k],; dims=self.sys_dims)); self._onto_evo_qobj.append(self.onto_evo_target). return self._onto_evo_qobj. [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. def _ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self._decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self._decomp_curr[k]:; self._spectral_decomp(k). def _spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:42455,Testability,log,logger,42455,"erty; def evo_t2targ(self):; _attrib_deprecation(; ""'evo_t2targ' has been replaced by '_onto_evo'""); return self._onto_evo. @property; def onto_evo(self):; """"""; List of evolution operators (Qobj) from the initial to the given; timeslot; """"""; if self._onto_evo is not None:; if self._onto_evo_qobj is None:; if self.oper_dtype == Qobj:; self._onto_evo_qobj = self._onto_evo; else:; self._onto_evo_qobj = []; for k in range(0, self.num_tslots):; self._onto_evo_qobj.append(Qobj(self._onto_evo[k],; dims=self.sys_dims)); self._onto_evo_qobj.append(self.onto_evo_target). return self._onto_evo_qobj. [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. def _ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self._decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self._decomp_curr[k]:; self._spectral_decomp(k). def _spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def _is_unitary(self, A):",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:42462,Testability,log,log,42462,"rg(self):; _attrib_deprecation(; ""'evo_t2targ' has been replaced by '_onto_evo'""); return self._onto_evo. @property; def onto_evo(self):; """"""; List of evolution operators (Qobj) from the initial to the given; timeslot; """"""; if self._onto_evo is not None:; if self._onto_evo_qobj is None:; if self.oper_dtype == Qobj:; self._onto_evo_qobj = self._onto_evo; else:; self._onto_evo_qobj = []; for k in range(0, self.num_tslots):; self._onto_evo_qobj.append(Qobj(self._onto_evo[k],; dims=self.sys_dims)); self._onto_evo_qobj.append(self.onto_evo_target). return self._onto_evo_qobj. [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. def _ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self._decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self._decomp_curr[k]:; self._spectral_decomp(k). def _spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def _is_unitary(self, A):; """"""; Checks whe",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:42466,Testability,log,logging,42466,"rg(self):; _attrib_deprecation(; ""'evo_t2targ' has been replaced by '_onto_evo'""); return self._onto_evo. @property; def onto_evo(self):; """"""; List of evolution operators (Qobj) from the initial to the given; timeslot; """"""; if self._onto_evo is not None:; if self._onto_evo_qobj is None:; if self.oper_dtype == Qobj:; self._onto_evo_qobj = self._onto_evo; else:; self._onto_evo_qobj = []; for k in range(0, self.num_tslots):; self._onto_evo_qobj.append(Qobj(self._onto_evo[k],; dims=self.sys_dims)); self._onto_evo_qobj.append(self.onto_evo_target). return self._onto_evo_qobj. [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. def _ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self._decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self._decomp_curr[k]:; self._spectral_decomp(k). def _spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def _is_unitary(self, A):; """"""; Checks whe",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:44107,Testability,log,logger,44107,"f eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def _is_unitary(self, A):; """"""; Checks whether operator A is unitary; A can be either Qobj or ndarray; """"""; if isinstance(A, Qobj):; unitary = np.allclose(np.eye(A.shape[0]), A*A.dag().full(),; atol=self.unitarity_tol); else:; unitary = np.allclose(np.eye(len(A)), A.dot(A.T.conj()),; atol=self.unitarity_tol). return unitary. def _calc_unitary_err(self, A):; if isinstance(A, Qobj):; err = np.sum(abs(np.eye(A.shape[0]) - A*A.dag().full())); else:; err = np.sum(abs(np.eye(len(A)) - A.dot(A.T.conj()))). return err. [docs] def unitarity_check(self):; """"""; Checks whether all propagators are unitary; """"""; for k in range(self.num_tslots):; if not self._is_unitary(self._prop[k]):; logger.warning(; ""Progator of timeslot {} is not unitary"".format(k)). [docs]class DynamicsGenMat(Dynamics):; """"""; This sub class can be used for any system where no additional; operator is applied to the dynamics generator before calculating; the propagator, e.g. classical dynamics, Lindbladian; """"""; def reset(self):; Dynamics.reset(self); self.id_text = 'GEN_MAT'; self.apply_params(). [docs]class DynamicsUnitary(Dynamics):; """"""; This is the subclass to use for systems with dynamics described by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes; ----------; drift_ham : Qobj; This is the drift Hamiltonian for unitary dynamics; It is mapped to drift_dyn_gen during initialize_controls. ctrl_ham : List of Qobj; These are the control Hamiltonians for unitary dynamics; It is",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:48053,Testability,assert,assert,48053,"obj:; self._onto_evo_target = self.target.dag(); else:; self._onto_evo_target = self._target.T.conj(); return self._onto_evo_target. def _spectral_decomp(self, k):; """"""; Calculates the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; """""". if self.oper_dtype == Qobj:; H = self._dyn_gen[k]; # Returns eigenvalues as array (row); # and eigenvectors as rows of an array; eig_val, eig_vec = sp_eigs(H.data, H.isherm,; sparse=self.sparse_eigen_decomp); eig_vec = eig_vec.T; if self.sparse_eigen_decomp:; # when sparse=True, sp_eigs returns an ndarray where each; # element is a sparse matrix so we convert it into a sparse; # matrix we can later pass to Qobj(...); eig_vec = sp.hstack(eig_vec). elif self.oper_dtype == np.ndarray:; H = self._dyn_gen[k]; # returns row vector of eigenvals, columns with the eigenvecs; eig_val, eig_vec = eigh(H). else:; assert False, f""Unknown oper_dtype {self.oper_dtype!r}"". # assuming H is an nxn matrix, find n; n = self.get_drift_dim(). # Calculate the propagator in the diagonalised basis; eig_val_tau = -1j*eig_val*self.tau[k]; prop_eig = np.exp(eig_val_tau). # Generate the factor matrix through the differences; # between each of the eigenvectors and the exponentiations; # create nxn matrix where each eigen val is repeated n times; # down the columns; o = np.ones([n, n]); eig_val_cols = eig_val_tau*o; # calculate all the differences by subtracting it from its transpose; eig_val_diffs = eig_val_cols - eig_val_cols.T; # repeat for the propagator; prop_eig_cols = prop_eig*o; prop_eig_diffs = prop_eig_cols - prop_eig_cols.T; # the factor matrix is the elementwise quotient of the; # differeneces between the exponentiated eigen vals and the; # differences between the eigen vals; # need to avoid division by zero that would arise due to denegerate; # eigenvalues and the diagonals; degen_mask = np.abs(eig_val_diffs) < self.",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:50238,Testability,assert,assert,50238,"eig_cols[degen_mask]. # Store eigenvectors, propagator and factor matric; # for use in propagator computations; self._decomp_curr[k] = True; if isinstance(factors, np.ndarray):; self._dyn_gen_factormatrix[k] = factors; else:; self._dyn_gen_factormatrix[k] = np.array(factors). if self.oper_dtype == Qobj:; self._prop_eigen[k] = Qobj(np.diagflat(prop_eig),; dims=self.dyn_dims); self._dyn_gen_eigenvectors[k] = Qobj(eig_vec,; dims=self.dyn_dims); # The _dyn_gen_eigenvectors_adj list is not used in; # memory optimised modes; if self._dyn_gen_eigenvectors_adj is not None:; self._dyn_gen_eigenvectors_adj[k] = \; self._dyn_gen_eigenvectors[k].dag(); elif self.oper_dtype == np.ndarray:; self._prop_eigen[k] = np.diagflat(prop_eig); self._dyn_gen_eigenvectors[k] = eig_vec; # The _dyn_gen_eigenvectors_adj list is not used in; # memory optimised modes; if self._dyn_gen_eigenvectors_adj is not None:; self._dyn_gen_eigenvectors_adj[k] = \; self._dyn_gen_eigenvectors[k].conj().T; else:; assert False, f""Unknown oper_dtype {self.oper_dtype!r}"". def _get_dyn_gen_eigenvectors_adj(self, k):; # The _dyn_gen_eigenvectors_adj list is not used in; # memory optimised modes; if self._dyn_gen_eigenvectors_adj is not None:; return self._dyn_gen_eigenvectors_adj[k]; else:; if self.oper_dtype == Qobj:; return self._dyn_gen_eigenvectors[k].dag(); else:; return self._dyn_gen_eigenvectors[k].conj().T. [docs] def check_unitarity(self):; """"""; Checks whether all propagators are unitary; For propagators found not to be unitary, the potential underlying; causes are investigated.; """"""; for k in range(self.num_tslots):; prop_unit = self._is_unitary(self._prop[k]); if not prop_unit:; logger.warning(; ""Progator of timeslot {} is not unitary"".format(k)); if not prop_unit or self.unitarity_check_level > 1:; # Check Hamiltonian; H = self._dyn_gen[k]; if isinstance(H, Qobj):; herm = H.isherm; else:; diff = np.abs(H.T.conj() - H); herm = False if np.any(diff > settings.atol) else True; eigval_unit = self._is_unitar",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:50923,Testability,log,logger,50923,".oper_dtype == np.ndarray:; self._prop_eigen[k] = np.diagflat(prop_eig); self._dyn_gen_eigenvectors[k] = eig_vec; # The _dyn_gen_eigenvectors_adj list is not used in; # memory optimised modes; if self._dyn_gen_eigenvectors_adj is not None:; self._dyn_gen_eigenvectors_adj[k] = \; self._dyn_gen_eigenvectors[k].conj().T; else:; assert False, f""Unknown oper_dtype {self.oper_dtype!r}"". def _get_dyn_gen_eigenvectors_adj(self, k):; # The _dyn_gen_eigenvectors_adj list is not used in; # memory optimised modes; if self._dyn_gen_eigenvectors_adj is not None:; return self._dyn_gen_eigenvectors_adj[k]; else:; if self.oper_dtype == Qobj:; return self._dyn_gen_eigenvectors[k].dag(); else:; return self._dyn_gen_eigenvectors[k].conj().T. [docs] def check_unitarity(self):; """"""; Checks whether all propagators are unitary; For propagators found not to be unitary, the potential underlying; causes are investigated.; """"""; for k in range(self.num_tslots):; prop_unit = self._is_unitary(self._prop[k]); if not prop_unit:; logger.warning(; ""Progator of timeslot {} is not unitary"".format(k)); if not prop_unit or self.unitarity_check_level > 1:; # Check Hamiltonian; H = self._dyn_gen[k]; if isinstance(H, Qobj):; herm = H.isherm; else:; diff = np.abs(H.T.conj() - H); herm = False if np.any(diff > settings.atol) else True; eigval_unit = self._is_unitary(self._prop_eigen[k]); eigvec_unit = self._is_unitary(self._dyn_gen_eigenvectors[k]); if self._dyn_gen_eigenvectors_adj is not None:; eigvecadj_unit = self._is_unitary(; self._dyn_gen_eigenvectors_adj[k]); else:; eigvecadj_unit = None; msg = (""prop unit: {}; H herm: {}; ""; ""eigval unit: {}; eigvec unit: {}; ""; ""eigvecadj_unit: {}"".format(; prop_unit, herm, eigval_unit, eigvec_unit,; eigvecadj_unit)); logger.info(msg). [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omeg",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:51659,Testability,log,logger,51659,"rs[k].conj().T. [docs] def check_unitarity(self):; """"""; Checks whether all propagators are unitary; For propagators found not to be unitary, the potential underlying; causes are investigated.; """"""; for k in range(self.num_tslots):; prop_unit = self._is_unitary(self._prop[k]); if not prop_unit:; logger.warning(; ""Progator of timeslot {} is not unitary"".format(k)); if not prop_unit or self.unitarity_check_level > 1:; # Check Hamiltonian; H = self._dyn_gen[k]; if isinstance(H, Qobj):; herm = H.isherm; else:; diff = np.abs(H.T.conj() - H); herm = False if np.any(diff > settings.atol) else True; eigval_unit = self._is_unitary(self._prop_eigen[k]); eigvec_unit = self._is_unitary(self._dyn_gen_eigenvectors[k]); if self._dyn_gen_eigenvectors_adj is not None:; eigvecadj_unit = self._is_unitary(; self._dyn_gen_eigenvectors_adj[k]); else:; eigvecadj_unit = None; msg = (""prop unit: {}; H herm: {}; ""; ""eigval unit: {}; eigvec unit: {}; ""; ""eigvecadj_unit: {}"".format(; prop_unit, herm, eigval_unit, eigvec_unit,; eigvecadj_unit)); logger.info(msg). [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omega : array[drift_dyn_gen.shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems. """""". def reset(self):; Dynamics.reset(self); self.id_text = 'SYMPL'; self._omega = None; self._omega_qobj = None; self._phase_application = 'postop'; self.grad_exact = True; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdat",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:5152,Usability,simpl,simplefilter,5152,"enumerate(ctrls):; ctrls_[i, :] = ctrl; ctrls = ctrls_; except:; pass. if isinstance(ctrls, np.ndarray):; if len(ctrls.shape) != 2:; raise TypeError(""Incorrect shape for ctrl dyn gen array""); for k in range(ctrls.shape[0]):; for j in range(ctrls.shape[1]):; if not isinstance(ctrls[k, j], Qobj):; raise TypeError(""All control dyn gen must be Qobj""); elif isinstance(ctrls, (list, tuple)):; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""All control dyn gen must be Qobj""); else:; raise TypeError(""Controls list or array not set correctly""). return ctrls. def _check_drift_dyn_gen(drift):; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(; ""drift should be a Qobj or a list of Qobj""). warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evol",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:16426,Usability,clear,clear,16426,"_prop_grad_qobj = None; self._fwd_evo_qobj = None; self._onwd_evo_qobj = None; self._onto_evo_qobj = None; # Atrributes used in diagonalisation; # again in internal operator data type (see above); self._decomp_curr = None; self._prop_eigen = None; self._dyn_gen_eigenvectors = None; self._dyn_gen_eigenvectors_adj = None; self._dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.log_level = self.config.log_level; # Internal flags; self._dyn_gen_mapped = False; self._evo_initialized = False; self._timeslots_initialized = False; self._ctrls_initialized = False; self._ctrl_dyn_gen_checked = False; self._drift_dyn_gen_checked = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = None; self.dump_to_file = False. self.apply_params(). # Create the computing objects; self._create_computers(). self.clear(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def dumping(self):; """"""; The level of data dumping that will occur during the time evolution; calculation. - NONE : No processing data dumped (Default); - SUMMARY : A summary of each time evolution will be recorded; - FULL : All operators used ",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:18860,Usability,clear,clear,18860,"ring(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.DynamicsDump):; self.dump = qtrldump.DynamicsDump(self, level=lvl); else:; self.dump.level = lvl. @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). @property; def num_tslots(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._num_tslots. @num_tslots.setter; def num_tslots(self, value):; self._num_tslots = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def evo_time(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._evo_time. @evo_time.setter; def evo_time(self, value):; self._evo_time = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def tau(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._tau. @tau.setter; def tau(self, value):; self._tau = value; self.init_timeslots(). [docs] def init_timeslots(self):; """"""; Generate the timeslot duration array 'tau' based on the evo_time; and num_tslots attributes, unless the tau attribute is already set",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:18976,Usability,clear,clear,18976,"None; else:; if not isinstance(self.dump, qtrldump.DynamicsDump):; self.dump = qtrldump.DynamicsDump(self, level=lvl); else:; self.dump.level = lvl. @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). @property; def num_tslots(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._num_tslots. @num_tslots.setter; def num_tslots(self, value):; self._num_tslots = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def evo_time(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._evo_time. @evo_time.setter; def evo_time(self, value):; self._evo_time = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def tau(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._tau. @tau.setter; def tau(self, value):; self._tau = value; self.init_timeslots(). [docs] def init_timeslots(self):; """"""; Generate the timeslot duration array 'tau' based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array 'time' based on the tau values; """"""; # s",MatchSource.WIKI,docs/4.6/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:2345,Availability,error,error,2345," NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue ",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:2392,Availability,error,error,2392," NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue ",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:3230,Availability,error,errors,3230,"h University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and c",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:3240,Availability,error,errors,3240,"h University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and c",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:5445,Availability,error,error,5445,"-----; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_norm : float; Normalisation constant. fid_norm_func : function; Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func : function; Used to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evo : boolean; flag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_f",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:5761,Availability,error,error,5761,"ed.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_norm : float; Normalisation constant. fid_norm_func : function; Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func : function; Used to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evo : boolean; flag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_curre",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:5879,Availability,error,error,5879,"_norm : float; Normalisation constant. fid_norm_func : function; Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func : function; Used to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evo : boolean; flag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object ",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:7854,Availability,error,errors,7854,"lse; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); return self.uses_onwd_evo. @uses_evo_t2end.setter; def uses_evo_t2end(self, value):; _attrib_deprecati",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:7914,Availability,error,error,7914,"the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); return self.uses_onwd_evo. @uses_evo_t2end.setter; def uses_evo_t2end(self, value):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); self.uses_onwd_evo = value. @property; def use",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:8082,Availability,error,error,8082," created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); return self.uses_onwd_evo. @uses_evo_t2end.setter; def uses_evo_t2end(self, value):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); self.uses_onwd_evo = value. @property; def uses_evo_t2targ(self):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); return self.uses_onto_evo. @uses_evo_t2targ.setter; def uses_evo_t2targ(self, value):; _attrib_deprecation(",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:8205,Availability,error,errors,8205," created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); return self.uses_onwd_evo. @uses_evo_t2end.setter; def uses_evo_t2end(self, value):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); self.uses_onwd_evo = value. @property; def uses_evo_t2targ(self):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); return self.uses_onto_evo. @uses_evo_t2targ.setter; def uses_evo_t2targ(self, value):; _attrib_deprecation(",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:8267,Availability,error,error,8267,"elf.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); return self.uses_onwd_evo. @uses_evo_t2end.setter; def uses_evo_t2end(self, value):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); self.uses_onwd_evo = value. @property; def uses_evo_t2targ(self):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); return self.uses_onto_evo. @uses_evo_t2targ.setter; def uses_evo_t2targ(self, value):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); self.uses_onto_evo = value. [docs]class FidCompUnitary(FidelityComputer):; """"""; Comput",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:9259,Availability,error,error,9259,"etting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); return self.uses_onwd_evo. @uses_evo_t2end.setter; def uses_evo_t2end(self, value):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); self.uses_onwd_evo = value. @property; def uses_evo_t2targ(self):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); return self.uses_onto_evo. @uses_evo_t2targ.setter; def uses_evo_t2targ(self, value):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); self.uses_onto_evo = value. [docs]class FidCompUnitary(FidelityComputer):; """"""; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes; ----------; phase_option : string; determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'UNIT'; self.uses_onto_evo = True; self._init_phase_option('PSU'); self.apply_params(). [docs] def clear(self):; FidelityComputer.clear(self); self.fidelity_prenorm = None; self.fidelity_prenorm_current = False. [docs] def set_phase_option(self, phase_option=None):; """"""; Deprecate",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:11055,Availability,error,errors,11055," self.apply_params(). [docs] def clear(self):; FidelityComputer.clear(self); self.fidelity_prenorm = None; self.fidelity_prenorm_current = False. [docs] def set_phase_option(self, phase_option=None):; """"""; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important; """"""; _func_deprecation(""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to None""; "" for this FidelityComputer.""); else:; raise errors.UsageError(; ""No option for phase_option '{}'"".format(value)); ; [docs] def init_comp(self):; """"""; Check configuration and initialise the normalisation; """"""; if self.fid_norm_func is None or self.grad_norm_func is None:; raise errors.UsageError(""The phase_option must be be set""; ""for this fidelity computer""); self.init_normalization(). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; FidelityComputer.flag_system_changed(self); # Flag the fidelity (prenormalisation) value as needing calculation; self.fidelity_prenorm_current = False. [docs] def init_normalization(self):; """"""; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; ",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:11156,Availability,error,errors,11156,"ty_prenorm_current = False. [docs] def set_phase_option(self, phase_option=None):; """"""; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important; """"""; _func_deprecation(""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to None""; "" for this FidelityComputer.""); else:; raise errors.UsageError(; ""No option for phase_option '{}'"".format(value)); ; [docs] def init_comp(self):; """"""; Check configuration and initialise the normalisation; """"""; if self.fid_norm_func is None or self.grad_norm_func is None:; raise errors.UsageError(""The phase_option must be be set""; ""for this fidelity computer""); self.init_normalization(). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; FidelityComputer.flag_system_changed(self); # Flag the fidelity (prenormalisation) value as needing calculation; self.fidelity_prenorm_current = False. [docs] def init_normalization(self):; """"""; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation functio",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:11390,Availability,error,errors,11390,"""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to None""; "" for this FidelityComputer.""); else:; raise errors.UsageError(; ""No option for phase_option '{}'"".format(value)); ; [docs] def init_comp(self):; """"""; Check configuration and initialise the normalisation; """"""; if self.fid_norm_func is None or self.grad_norm_func is None:; raise errors.UsageError(""The phase_option must be be set""; ""for this fidelity computer""); self.init_normalization(). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; FidelityComputer.flag_system_changed(self); # Flag the fidelity (prenormalisation) value as needing calculation; self.fidelity_prenorm_current = False. [docs] def init_normalization(self):; """"""; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected; """"""; dyn = self.parent; self.dimensional_norm = 1.0; self.dimensional_norm = \; self.fid_norm_func(dyn.target.dag()*dyn.target). [do",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:13730,Availability,error,error,13730," np.real(norm) / self.dimensional_norm. [docs] def normalize_gradient_SU(self, grad):; """"""; Normalise the gradient matrix passed as grad; This SU version respects global phase; """"""; grad_normalized = np.real(grad) / self.dimensional_norm. return grad_normalized. [docs] def normalize_PSU(self, A):; """""". """"""; try:; if A.shape[0] == A.shape[1]:; # input is an operator (Qobj, array, sparse etc), so; norm = _trace(A); else:; raise TypeError(""Cannot compute trace (not square)""); except:; # assume input is already scalar and hence assumed; # to be the prenormalised scalar value, e.g. fidelity; norm = A; return np.abs(norm) / self.dimensional_norm. [docs] def normalize_gradient_PSU(self, grad):; """"""; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase; """"""; fid_pn = self.get_fidelity_prenorm(); grad_normalized = np.real(grad * np.exp(-1j * np.angle(fid_pn)) /; self.dimensional_norm); return grad_normalized. [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; return np.abs(1 - self.get_fidelity()). [docs] def get_fidelity(self):; """"""; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_e",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:15103,Availability,error,error,15103,"er.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_e",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:16114,Availability,error,error,16114," in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:17322,Availability,error,error,17322,"eslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd_evo)); grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiff(FidelityComputer):; """"""; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityCom",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:17402,Availability,error,error,17402,"eslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd_evo)); grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiff(FidelityComputer):; """"""; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityCom",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:17897,Availability,error,error,17897,"range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd_evo)); grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiff(FidelityComputer):; """"""; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; G",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:17988,Availability,error,error,17988," _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd_evo)); grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiff(FidelityComputer):; """"""; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:18361,Availability,error,errors,18361,"stem dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error u",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:18906,Availability,error,error,18906,"rror calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.deb",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:19348,Availability,error,error,19348,"idelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:19912,Availability,error,error,19912,"or in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplit",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:20060,Availability,error,error,20060,"level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero a",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:20593,Availability,error,error,20593,"o_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:20859,Availability,error,error,20859," = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1]*evo_grad; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; g = -2*self.scale_factor*np.real(; (evo_f_diff.dag()*evo_grad).tr()); else:; evo_grad = dyn._get_prop_grad(k, j).dot(fwd_ev",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:23039,Availability,error,error,23039,"s.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiffApprox(FidCompTraceDiff):; """"""; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes; ----------; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude; ; """"""; [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_final_eps; fid_err_eps = self.scale_factor*np.real(_trace(; evo_f",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:2673,Deployability,configurat,configuration,2673,"QUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue depr",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:6236,Deployability,configurat,configuration,6236,"Computer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.pa",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:7624,Deployability,configurat,configuration,7624,"self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'use",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:11268,Deployability,configurat,configuration,11268," Phase options are; SU - global phase important; PSU - global phase is not important; """"""; _func_deprecation(""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to None""; "" for this FidelityComputer.""); else:; raise errors.UsageError(; ""No option for phase_option '{}'"".format(value)); ; [docs] def init_comp(self):; """"""; Check configuration and initialise the normalisation; """"""; if self.fid_norm_func is None or self.grad_norm_func is None:; raise errors.UsageError(""The phase_option must be be set""; ""for this fidelity computer""); self.init_normalization(). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; FidelityComputer.flag_system_changed(self); # Flag the fidelity (prenormalisation) value as needing calculation; self.fidelity_prenorm_current = False. [docs] def init_normalization(self):; """"""; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected; """"""; dyn = self.parent; ",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:15229,Deployability,update,updates,15229,"er.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_e",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:18564,Deployability,configurat,configuration,18564,"tance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:20186,Deployability,update,updates,20186,"level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero a",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:24508,Deployability,update,updated,24508,"; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_final_eps; fid_err_eps = self.scale_factor*np.real(_trace(; evo_f_diff_eps.conj().T.dot(evo_f_diff_eps))). g = (fid_err_eps - curr_fid_err)/self.epsilon; if np.isnan(g):; g = np.Inf. grad[k, j] = g. if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st. return grad. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:2560,Energy Efficiency,efficient,efficient,2560,"TORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, st",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:3342,Integrability,message,message,3342,"delity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the m",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:3430,Integrability,message,message,3430,"delity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the m",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:3518,Integrability,message,message,3518,"mics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; i",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:3593,Integrability,message,message,3593,"imple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or ab",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:3681,Integrability,message,message,3681,"imple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or ab",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:3769,Integrability,message,message,3769,"delity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimension",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:3843,Integrability,wrap,wrapper,3843,"delity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimension",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:2673,Modifiability,config,configuration,2673,"QUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue depr",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:6236,Modifiability,config,configuration,6236,"Computer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.pa",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:7624,Modifiability,config,configuration,7624,"self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'use",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:11268,Modifiability,config,configuration,11268," Phase options are; SU - global phase important; PSU - global phase is not important; """"""; _func_deprecation(""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to None""; "" for this FidelityComputer.""); else:; raise errors.UsageError(; ""No option for phase_option '{}'"".format(value)); ; [docs] def init_comp(self):; """"""; Check configuration and initialise the normalisation; """"""; if self.fid_norm_func is None or self.grad_norm_func is None:; raise errors.UsageError(""The phase_option must be be set""; ""for this fidelity computer""); self.init_normalization(). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; FidelityComputer.flag_system_changed(self); # Flag the fidelity (prenormalisation) value as needing calculation; self.fidelity_prenorm_current = False. [docs] def init_normalization(self):; """"""; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected; """"""; dyn = self.parent; ",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:13974,Modifiability,config,config,13974,"""""""; grad_normalized = np.real(grad) / self.dimensional_norm. return grad_normalized. [docs] def normalize_PSU(self, A):; """""". """"""; try:; if A.shape[0] == A.shape[1]:; # input is an operator (Qobj, array, sparse etc), so; norm = _trace(A); else:; raise TypeError(""Cannot compute trace (not square)""); except:; # assume input is already scalar and hence assumed; # to be the prenormalised scalar value, e.g. fidelity; norm = A; return np.abs(norm) / self.dimensional_norm. [docs] def normalize_gradient_PSU(self, grad):; """"""; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase; """"""; fid_pn = self.get_fidelity_prenorm(); grad_normalized = np.real(grad * np.exp(-1j * np.angle(fid_pn)) /; self.dimensional_norm); return grad_normalized. [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; return np.abs(1 - self.get_fidelity()). [docs] def get_fidelity(self):; """"""; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; ",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:18564,Modifiability,config,configuration,18564,"tance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:14398,Performance,cache,cached,14398,"ensional_norm. [docs] def normalize_gradient_PSU(self, grad):; """"""; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase; """"""; fid_pn = self.get_fidelity_prenorm(); grad_normalized = np.real(grad * np.exp(-1j * np.angle(fid_pn)) /; self.dimensional_norm); return grad_normalized. [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; return np.abs(1 - self.get_fidelity()). [docs] def get_fidelity(self):; """"""; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_pre",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:15163,Performance,cache,cached,15163,"er.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_e",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:20120,Performance,cache,cached,20120,"level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero a",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:19466,Safety,avoid,avoids,19466,"params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(se",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:21685,Safety,avoid,avoids,21685,"ent norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1]*evo_grad; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; g = -2*self.scale_factor*np.real(; (evo_f_diff.dag()*evo_grad).tr()); else:; evo_grad = dyn._get_prop_grad(k, j).dot(fwd_evo); if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1].dot(evo_grad); g = -2*self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_grad))); if np.isnan(g):; g = np.Inf. grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiffApprox(FidCompTraceDiff):; """"""; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes; ----------; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude; ; """"""; [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of func",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:23729,Safety,avoid,avoids,23729,"; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_final_eps; fid_err_eps = self.scale_factor*np.real(_trace(; evo_f_diff_eps.conj().T.dot(evo_f_diff_eps))). g = (fid_err_eps - curr_fid_err)/self.epsilon; if np.isnan(g):; g = np.Inf. grad[k, j] = g. if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st. return grad. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:3105,Testability,log,logging,3105,"#########. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]cla",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:3144,Testability,log,logging,3144,"@email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class ",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:3153,Testability,log,logger,3153,"@email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class ",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:3162,Testability,log,logging,3162,"@email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class ",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:4484,Testability,log,logger,4484,"e function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_norm : float; Normalisation constant. fid_norm_func : function; Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func : function; Used to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evo : boolean; flag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity er",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:7361,Testability,log,logger,7361," self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have b",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:7482,Testability,log,logger,7482,"unc = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """,MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:7503,Testability,log,logger,7503,"unc = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """,MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:7530,Testability,log,logger,7530,"pply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculatin",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:14137,Testability,log,logging,14137,"A); else:; raise TypeError(""Cannot compute trace (not square)""); except:; # assume input is already scalar and hence assumed; # to be the prenormalised scalar value, e.g. fidelity; norm = A; return np.abs(norm) / self.dimensional_norm. [docs] def normalize_gradient_PSU(self, grad):; """"""; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase; """"""; fid_pn = self.get_fidelity_prenorm(); grad_normalized = np.real(grad * np.exp(-1j * np.angle(fid_pn)) /; self.dimensional_norm); return grad_normalized. [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; return np.abs(1 - self.get_fidelity()). [docs] def get_fidelity(self):; """"""; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrl",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:14153,Testability,log,logger,14153,"ypeError(""Cannot compute trace (not square)""); except:; # assume input is already scalar and hence assumed; # to be the prenormalised scalar value, e.g. fidelity; norm = A; return np.abs(norm) / self.dimensional_norm. [docs] def normalize_gradient_PSU(self, grad):; """"""; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase; """"""; fid_pn = self.get_fidelity_prenorm(); grad_normalized = np.real(grad * np.exp(-1j * np.angle(fid_pn)) /; self.dimensional_norm); return grad_normalized. [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; return np.abs(1 - self.get_fidelity()). [docs] def get_fidelity(self):; """"""; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The grad",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:14882,Testability,log,logging,14882,"alue; The normalisation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:14898,Testability,log,logger,14898,"ation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; i",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:15408,Testability,log,logging,15408," because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; co",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:15432,Testability,log,logger,15432," the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:15439,Testability,log,log,15439,"ulation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients ",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:15443,Testability,log,logging,15443,"ulation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients ",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:16035,Testability,log,logging,16035,"_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_e",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:16059,Testability,log,logger,16059," Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:16066,Testability,log,log,16066,"lised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.do",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:16070,Testability,log,logging,16070,"lised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.do",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:16189,Testability,log,logging,16189," requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd_evo)); grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradien",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:16205,Testability,log,logger,16205,"le times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd_evo)); grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; ti",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:18761,Testability,log,logging,18761,"an dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:18777,Testability,log,logger,18777,"erik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not ",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:19123,Testability,log,logging,19123," the drift, when the Dynamics are initialised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are c",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:19147,Testability,log,logger,19147,"ynamics are initialised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:19154,Testability,log,log,19154,"lised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutli",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:19158,Testability,log,logging,19158,"lised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutli",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:19873,Testability,log,logging,19873,"_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error functi",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:19889,Testability,log,logger,19889,"Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each ti",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:20525,Testability,log,logging,20525," Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._ge",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:20549,Testability,log,logger,20549," self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:20556,Testability,log,log,20556,"*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_t",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:20560,Testability,log,logging,20560,"*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_t",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:20668,Testability,log,logging,20668,"; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1]*evo_grad; # Note that the value should have not imagnary part, so; # u",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:20684,Testability,log,logger,20684,").T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1]*evo_grad; # Note that the value should have not imagnary part, so; # using np.real, just",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:22990,Testability,log,logging,22990," if np.isnan(g):; g = np.Inf. grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiffApprox(FidCompTraceDiff):; """"""; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes; ----------; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude; ; """"""; [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dy",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:23006,Testability,log,logger,23006,"g = np.Inf. grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiffApprox(FidCompTraceDiff):; """"""; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes; ----------; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude; ; """"""; [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_fi",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:2666,Usability,simpl,simple,2666,"QUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue depr",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:3257,Usability,simpl,simplefilter,3257,"delity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the m",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:6260,Usability,clear,clear,6260,"Computer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.pa",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:6543,Usability,clear,clear,6543,"lag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(l",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:6563,Usability,clear,clear,6563,"r are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initia",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:6582,Usability,clear,clear,6582,"r are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initia",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:10066,Usability,clear,clear,10066,"e):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); self.uses_onto_evo = value. [docs]class FidCompUnitary(FidelityComputer):; """"""; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes; ----------; phase_option : string; determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'UNIT'; self.uses_onto_evo = True; self._init_phase_option('PSU'); self.apply_params(). [docs] def clear(self):; FidelityComputer.clear(self); self.fidelity_prenorm = None; self.fidelity_prenorm_current = False. [docs] def set_phase_option(self, phase_option=None):; """"""; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important; """"""; _func_deprecation(""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""ph",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:10097,Usability,clear,clear,10097,"es_evo_t2targ' has been replaced by 'uses_onto_evo'""); self.uses_onto_evo = value. [docs]class FidCompUnitary(FidelityComputer):; """"""; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes; ----------; phase_option : string; determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'UNIT'; self.uses_onto_evo = True; self._init_phase_option('PSU'); self.apply_params(). [docs] def clear(self):; FidelityComputer.clear(self); self.fidelity_prenorm = None; self.fidelity_prenorm_current = False. [docs] def set_phase_option(self, phase_option=None):; """"""; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important; """"""; _func_deprecation(""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to No",MatchSource.WIKI,docs/4.6/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:2672,Availability,error,error,2672,"OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes here are expected to implement a run_optimization function; that will use some method for optimising the control pulse, as defined; by the control amplitudes. The system that the pulse acts upon are defined; by the Dynamics object that must be passed in the instantiation. The methods are typically N dimensional function optimisers that; find the minima of a fidelity error function. Note the number of variables; for the fidelity function is the number of control timeslots,; i.e. n_ctrls x Ntimeslots; The methods will call functions on the Dynamics.fid_computer object,; one or many times per interation,; to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:. BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm. This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFG",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:2933,Availability,error,error,2933,"CE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes here are expected to implement a run_optimization function; that will use some method for optimising the control pulse, as defined; by the control amplitudes. The system that the pulse acts upon are defined; by the Dynamics object that must be passed in the instantiation. The methods are typically N dimensional function optimisers that; find the minima of a fidelity error function. Note the number of variables; for the fidelity function is the number of control timeslots,; i.e. n_ctrls x Ntimeslots; The methods will call functions on the Dynamics.fid_computer object,; one or many times per interation,; to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:. BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm. This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS. This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wr",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:4231,Availability,error,error,4231,"ar from SciPy.optimize; The two methods implemented are:. BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm. This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS. This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import functools; import numpy as np; import timeit; import warnings; from packaging.version import parse as _parse_version; import scipy; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. # Older versions of SciPy use the method numpy.ndarray.tostring(), which has; # been deprecated since Numpy 1.19 in favour of the identical-in-all-but-name; # tobytes() method. This is simply ",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:4884,Availability,error,errors,4884,"f L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import functools; import numpy as np; import timeit; import warnings; from packaging.version import parse as _parse_version; import scipy; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. # Older versions of SciPy use the method numpy.ndarray.tostring(), which has; # been deprecated since Numpy 1.19 in favour of the identical-in-all-but-name; # tobytes() method. This is simply a deprecated call in SciPy, there's nothing; # we or our users can do about it, and the function shouldn't actually be; # removed from Numpy until at least 1.22, by which point we'll have been able; # to drop support for SciPy 1.4.; if _parse_version(scipy.__version__) < _parse_version(""1.5""):; @functools.wraps(spopt.fmin_l_bfgs_b); def fmin_l_bfgs_b(*args, **kwargs):; with warnings.catch_warnings():; message = r""tostring\(\) is deprecated\. Use tobytes\(\) instead\.""; warnings.filterwarnings(""ignore"", message=message,; category=DeprecationWarning); return spopt.fmin_l_bfgs_b(*args, **kwargs); else:; fmin_l_bfgs_b = spopt.fmin_l_bfgs_b. def _is_string(var):; try:; if isins",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:4894,Availability,error,errors,4894,"f L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import functools; import numpy as np; import timeit; import warnings; from packaging.version import parse as _parse_version; import scipy; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. # Older versions of SciPy use the method numpy.ndarray.tostring(), which has; # been deprecated since Numpy 1.19 in favour of the identical-in-all-but-name; # tobytes() method. This is simply a deprecated call in SciPy, there's nothing; # we or our users can do about it, and the function shouldn't actually be; # removed from Numpy until at least 1.22, by which point we'll have been able; # to drop support for SciPy 1.4.; if _parse_version(scipy.__version__) < _parse_version(""1.5""):; @functools.wraps(spopt.fmin_l_bfgs_b); def fmin_l_bfgs_b(*args, **kwargs):; with warnings.catch_warnings():; message = r""tostring\(\) is deprecated\. Use tobytes\(\) instead\.""; warnings.filterwarnings(""ignore"", message=message,; category=DeprecationWarning); return spopt.fmin_l_bfgs_b(*args, **kwargs); else:; fmin_l_bfgs_b = spopt.fmin_l_bfgs_b. def _is_string(var):; try:; if isins",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:7589,Availability,error,error,7589,"ging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; Options that are specific to the pulse optim algorithm ``alg``. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params : Dictionary; Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad : bool; If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; ",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:14220,Availability,error,errors,14220,"mp:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.evo_full_initial = self.dynamics.full_evo.copy(); result.time = self.dynamics.time.copy(); result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:14362,Availability,error,errors,14362,"dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.evo_full_initial = self.dynamics.full_evo.copy(); result.time = self.dynamics.time.copy(); result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_opt",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:14561,Availability,error,errors,14561,"al_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.evo_full_initial = self.dynamics.full_evo.copy(); result.time = self.dynamics.time.copy(); result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_options(self):; """"""; Creates the method_options dictionary for the scipy.optimize.minimize; function based on the attributes of this object and the; termination_conditions; It assumes that apply_met",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:14616,Availability,error,error,14616,"result.initial_amps = self.dynamics.ctrl_amps.copy(); result.evo_full_initial = self.dynamics.full_evo.copy(); result.time = self.dynamics.time.copy(); result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_options(self):; """"""; Creates the method_options dictionary for the scipy.optimize.minimize; function based on the attributes of this object and the; termination_conditions; It assumes that apply_method_params has already been run and; hence the method_o",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:14622,Availability,toler,tolerance,14622,"result.initial_amps = self.dynamics.ctrl_amps.copy(); result.evo_full_initial = self.dynamics.full_evo.copy(); result.time = self.dynamics.time.copy(); result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_options(self):; """"""; Creates the method_options dictionary for the scipy.optimize.minimize; function based on the attributes of this object and the; termination_conditions; It assumes that apply_method_params has already been run and; hence the method_o",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:18061,Availability,error,error,18061,"; if hasattr(self.termination_conditions, key):; setattr(self.termination_conditions, key, val); else:; unused_params[key] = val. if len(unused_params) > 0:; if not isinstance(self.method_options, dict):; self.method_options = unused_params; else:; self.method_options.update(unused_params). def _build_bounds_list(self):; cfg = self.config; dyn = self.dynamics; n_ctrls = dyn.num_ctrls; self.bounds = []; for t in range(dyn.num_tslots):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.append((lb, ub)). [docs] def run_optimization(self, term_conds=None):; """"""; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient. The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_condition",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:20429,Availability,error,errors,20429,"bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_grad:; jac=None; else:; jac=self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""minimise '{}' method"").format(self.alg, self.method); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error a",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:21422,Availability,error,error,21422,"cept errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_call",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:21799,Availability,error,error,21799,"t; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:22115,Availability,error,error,22115,"te for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:22571,Availability,error,errors,22571,"e minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not N",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:22665,Availability,error,errors,22665,"as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= loggi",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:22796,Availability,error,error,22796,"hey have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].c",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:24392,Availability,error,errors,24392," explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_r",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:25086,Availability,error,errors,25086,".num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:25438,Availability,error,errors,25438,"id_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:25528,Availability,error,errors,25528,", *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.s",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:25628,Availability,error,errors,25628,"s has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.stats.calculate(); result.stats = copy.copy(self.stats). [docs]class OptimizerBFGS(Optimizer):; ",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:25728,Availability,error,errors,25728," logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.stats.calculate(); result.stats = copy.copy(self.stats). [docs]class OptimizerBFGS(Optimizer):; """"""; Implements the run_optimization method using the BFGS algorithm; """"""; def reset(self):; Optimize",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:26861,Availability,error,error,26861," the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.stats.calculate(); result.stats = copy.copy(self.stats). [docs]class OptimizerBFGS(Optimizer):; """"""; Implements the run_optimization method using the BFGS algorithm; """"""; def reset(self):; Optimizer.reset(self); self.id_text = 'BFGS'. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. if self.approx_grad:; fpri",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:28781,Availability,error,errors,28781,"_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_bfgs' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). result = self._create_result(); try:; optim_var_vals, cost, grad, invHess, nFCalls, nGCalls, warn = \; spopt.fmin_bfgs(self.fid_err_func_wrapper,; self.optim_var_vals,; fprime=fprime,; # approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; gtol=term_conds.min_gradient_norm,; maxiter=term_conds.max_iterations,; full_output=True, disp=True). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); if warn == 1:; result.max_iter_exceeded = True; result.termination_reason = ""Iteration count limit reached""; elif warn == 2:; result.grad_norm_min_reached = True; result.termination_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """""";",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:30548,Availability,error,error,30548," term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.co",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:33527,Availability,error,errors,33527," else:; m = 10. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_l_bfgs_b' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg); try:; optim_var_vals, fid, res_dict = fmin_l_bfgs_b(; self.fid_err_func_wrapper, self.optim_var_vals,; fprime=fprime,; approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; bounds=self.bounds, m=m, factr=factr,; pgtol=term_conds.min_gradient_norm,; disp=self.msg_level,; maxfun=term_conds.max_fid_func_calls,; maxiter=term_conds.max_iterations). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); warn = res_dict['warnflag']; if warn == 0:; result.grad_norm_min_reached = True; result.termination_reason = ""function converged""; elif warn == 1:; result.max_iter_exceeded = True; result.termination_reason = (""Iteration or fidelity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerCrab(Optimizer):; """"""; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients. AJGP ToDo: Add citation here; """""". def reset(self):; Optimizer.reset(self); self.id_text = 'CRAB'; self.num_optim_vars = 0. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:34004,Availability,error,error,34004,"fun=term_conds.max_fid_func_calls,; maxiter=term_conds.max_iterations). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); warn = res_dict['warnflag']; if warn == 0:; result.grad_norm_min_reached = True; result.termination_reason = ""function converged""; elif warn == 1:; result.max_iter_exceeded = True; result.termination_reason = (""Iteration or fidelity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerCrab(Optimizer):; """"""; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients. AJGP ToDo: Add citation here; """""". def reset(self):; Optimizer.reset(self); self.id_text = 'CRAB'; self.num_optim_vars = 0. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_vars = 0; pulse_gen_valid = True; # check the pulse generators match the ctrls; # (in terms of number); # and count the number of parameters; if self.pulse_generator is None:; pulse_gen_valid = False; err_msg = ""pulse_generator attribute is None""; elif not isinstance(self.pulse_generator, collections.abc.Iterable):; pulse_gen_valid = False; err_msg = ""pulse_generator is not iterable"". elif len(self.pulse_generator) != dyn.num_ctrls:; pulse_gen_valid = False; err_msg = (""the number of pulse gen",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:35434,Availability,error,errors,35434,"guration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_vars = 0; pulse_gen_valid = True; # check the pulse generators match the ctrls; # (in terms of number); # and count the number of parameters; if self.pulse_generator is None:; pulse_gen_valid = False; err_msg = ""pulse_generator attribute is None""; elif not isinstance(self.pulse_generator, collections.abc.Iterable):; pulse_gen_valid = False; err_msg = ""pulse_generator is not iterable"". elif len(self.pulse_generator) != dyn.num_ctrls:; pulse_gen_valid = False; err_msg = (""the number of pulse generators {} does not equal ""; ""the number of controls {}"".format(; len(self.pulse_generator), dyn.num_ctrls)). if pulse_gen_valid:; for p_gen in self.pulse_generator:; if not isinstance(p_gen, pulsegen.PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p_gen.num_optim_vars. if not pulse_gen_valid:; raise errors.UsageError(; ""The pulse_generator attribute must be set to a list of ""; ""PulseGenCrab - one for each control. Here "" + err_msg). def _build_bounds_list(self):; """"""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:37398,Availability,error,error,37398,"ies. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1]_, [2]_.; It uses the ``scipy.optimize.fmin`` function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB. References; ----------; .. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011).; .. [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or t",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:37996,Availability,error,error,37996,"j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1]_, [2]_.; It uses the ``scipy.optimize.fmin`` function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB. References; ----------; .. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011).; .. [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). #print(""Initial values:\n{}"".format(self.optim_var_vals)); st_time = timeit.default_timer(); self.wall_time_op",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:40282,Availability,toler,tolerance,40282,"ogger.info(""Optimising pulse(s) using {} with ""; ""'fmin' (Nelder-Mead) method"".format(self.alg)). try:; ret = spopt.fmin(; self.fid_err_func_wrapper, self.optim_var_vals,; xtol=self.xtol, ftol=self.ftol,; maxiter=term_conds.max_iterations,; maxfun=term_conds.max_fid_func_calls,; full_output=True, disp=self.disp_conv_msg,; retall=self.record_iteration_steps,; callback=self.iter_step_callback_func). final_param_vals = ret[0]; num_iter = ret[2]; warn_flag = ret[4]; if self.record_iteration_steps:; self.iteration_steps = ret[5]; amps = self._get_ctrl_amps(final_param_vals); dyn.update_ctrl_amps(amps). # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != num_iter:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, num_iter,; self.method)); result.num_iter = num_iter; if warn_flag == 0:; result.termination_reason = \; ""Function converged (within tolerance)""; elif warn_flag == 1:; result.termination_reason = \; ""Maximum number of function evaluations reached""; result.max_fid_func_exceeded = True; elif warn_flag == 2:; result.termination_reason = \; ""Maximum number of iterations reached""; result.max_iter_exceeded = True; else:; result.termination_reason = \; ""Unknown (warn_flag={})"".format(warn_flag). except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimIterSummary(qtrldump.DumpSummaryItem):; """"""A summary of the most recent iteration of the pulse optimisation. Attributes; ----------; iter_num : int; Iteration number of the pulse optimisation. fid_func_call_num : int; Fidelity function call number of the pulse optimisation. grad_func_call_num : int; Gradient function call number of the pulse optimisation. fid_err : float; Fidelity error. grad_norm ",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:40650,Availability,error,errors,40650,"lf.iter_step_callback_func). final_param_vals = ret[0]; num_iter = ret[2]; warn_flag = ret[4]; if self.record_iteration_steps:; self.iteration_steps = ret[5]; amps = self._get_ctrl_amps(final_param_vals); dyn.update_ctrl_amps(amps). # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != num_iter:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, num_iter,; self.method)); result.num_iter = num_iter; if warn_flag == 0:; result.termination_reason = \; ""Function converged (within tolerance)""; elif warn_flag == 1:; result.termination_reason = \; ""Maximum number of function evaluations reached""; result.max_fid_func_exceeded = True; elif warn_flag == 2:; result.termination_reason = \; ""Maximum number of iterations reached""; result.max_iter_exceeded = True; else:; result.termination_reason = \; ""Unknown (warn_flag={})"".format(warn_flag). except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimIterSummary(qtrldump.DumpSummaryItem):; """"""A summary of the most recent iteration of the pulse optimisation. Attributes; ----------; iter_num : int; Iteration number of the pulse optimisation. fid_func_call_num : int; Fidelity function call number of the pulse optimisation. grad_func_call_num : int; Gradient function call number of the pulse optimisation. fid_err : float; Fidelity error. grad_norm : float; fidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_time : float; Time spent computing the pulse optimisation so far; (in seconds of elapsed time); """"""; # Note there is some duplication here with Optimizer attributes; # this exists solely to be copied into the summary dump; min_col_width = 11; summary_property_",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:41260,Availability,error,error,41260,"= \; ""Function converged (within tolerance)""; elif warn_flag == 1:; result.termination_reason = \; ""Maximum number of function evaluations reached""; result.max_fid_func_exceeded = True; elif warn_flag == 2:; result.termination_reason = \; ""Maximum number of iterations reached""; result.max_iter_exceeded = True; else:; result.termination_reason = \; ""Unknown (warn_flag={})"".format(warn_flag). except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimIterSummary(qtrldump.DumpSummaryItem):; """"""A summary of the most recent iteration of the pulse optimisation. Attributes; ----------; iter_num : int; Iteration number of the pulse optimisation. fid_func_call_num : int; Fidelity function call number of the pulse optimisation. grad_func_call_num : int; Gradient function call number of the pulse optimisation. fid_err : float; Fidelity error. grad_norm : float; fidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_time : float; Time spent computing the pulse optimisation so far; (in seconds of elapsed time); """"""; # Note there is some duplication here with Optimizer attributes; # this exists solely to be copied into the summary dump; min_col_width = 11; summary_property_names = (; ""idx"", ""iter_num"", ""fid_func_call_num"", ""grad_func_call_num"",; ""fid_err"", ""grad_norm"", ""wall_time""; ). summary_property_fmt_type = (; 'd', 'd', 'd', 'd',; 'g', 'g', 'g'; ). summary_property_fmt_prec = (; 0, 0, 0, 0,; 4, 4, 2; ). def __init__(self):; self.reset(). def reset(self):; qtrldump.DumpSummaryItem.reset(self); self.iter_num = None; self.fid_func_call_num = None; self.grad_func_call_num = None; self.fid_err = None; self.grad_norm = None; self.wall_time = 0.0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ah",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:6372,Deployability,configurat,configuration,6372,"ble; # to drop support for SciPy 1.4.; if _parse_version(scipy.__version__) < _parse_version(""1.5""):; @functools.wraps(spopt.fmin_l_bfgs_b); def fmin_l_bfgs_b(*args, **kwargs):; with warnings.catch_warnings():; message = r""tostring\(\) is deprecated\. Use tobytes\(\) instead\.""; warnings.filterwarnings(""ignore"", message=message,; category=DeprecationWarning); return spopt.fmin_l_bfgs_b(*args, **kwargs); else:; fmin_l_bfgs_b = spopt.fmin_l_bfgs_b. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses. This class implements the fidelity,; gradient and interation callback functions. All subclass objects must be; initialised with a. - ``OptimConfig`` instance - various configuration options; - ``Dynamics`` instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; Options that are specific to the pulse optim algorithm ``alg``. disp_conv_msg : bool; Set true to display a convergenc",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:9006,Deployability,configurat,configuration,9006,"lled; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics : Dynamics (subclass instance); describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be s",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:14017,Deployability,configurat,configuration,14017,".upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.OptimDump):; self.dump = qtrldump.OptimDump(self, level=lvl); else:; self.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.evo_full_initial = self.dynamics.full_evo.copy(); result.time = self.dynamics.time.copy(); result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping ",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:17357,Deployability,update,update,17357,"_gradient_norm > 0 and not 'gtol' in mo:; mo['gtol'] = tc.min_gradient_norm; if not 'disp' in mo:; mo['disp'] = self.disp_conv_msg. return mo. [docs] def apply_method_params(self, params=None):; """"""; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function; """"""; if not params:; params = self.method_params. if isinstance(params, dict):; self.method_params = params; unused_params = {}; for key in params:; val = params[key]; if hasattr(self, key):; setattr(self, key, val); if hasattr(self.termination_conditions, key):; setattr(self.termination_conditions, key, val); else:; unused_params[key] = val. if len(unused_params) > 0:; if not isinstance(self.method_options, dict):; self.method_options = unused_params; else:; self.method_options.update(unused_params). def _build_bounds_list(self):; cfg = self.config; dyn = self.dynamics; n_ctrls = dyn.num_ctrls; self.bounds = []; for t in range(dyn.num_tslots):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.append((lb, ub)). [docs] def run_optimization(self, term_conds=None):; """"""; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum ",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:21741,Deployability,update,update,21741,"es; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_gra",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:21947,Deployability,update,update,21947,"; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradi",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:23159,Deployability,update,update,23159,"um_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. i",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:23493,Deployability,update,update,23493,"fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReach",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:25123,Deployability,update,update,25123,"d_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_c",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:26411,Deployability,update,update,26411,"sinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.stats.calculate(); result.stats = copy.copy(self.stats). [docs]class OptimizerBFGS(Optimizer):; """"""; Implements the run_optimization method using the BFGS algorithm; """"""; def reset(self):; Optimizer.reset(self); self.id_text = 'BFGS'. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelit",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:29761,Deployability,configurat,configuration,29761,"ion_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisa",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:34416,Deployability,configurat,configuration,34416,"elity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerCrab(Optimizer):; """"""; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients. AJGP ToDo: Add citation here; """""". def reset(self):; Optimizer.reset(self); self.id_text = 'CRAB'; self.num_optim_vars = 0. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_vars = 0; pulse_gen_valid = True; # check the pulse generators match the ctrls; # (in terms of number); # and count the number of parameters; if self.pulse_generator is None:; pulse_gen_valid = False; err_msg = ""pulse_generator attribute is None""; elif not isinstance(self.pulse_generator, collections.abc.Iterable):; pulse_gen_valid = False; err_msg = ""pulse_generator is not iterable"". elif len(self.pulse_generator) != dyn.num_ctrls:; pulse_gen_valid = False; err_msg = (""the number of pulse generators {} does not equal ""; ""the number of controls {}"".format(; len(self.pulse_generator), dyn.num_ctrls)). if pulse_gen_valid:; for p_gen in self.pulse_generator:; if not isinstance(p_gen, pulsegen.PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p",MatchSource.WIKI,docs/4.6/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html
