id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:20256,Performance,optimiz,optimization,20256,"port the specification of ghost atoms. Certain internal coordinates such ; as torsions become poorly defined when they contain near-linear bends. ; An internal error `AlgError` may be raised in such cases. Optking will avoid such; coordinates when choosing an initial coordinate system; however, they may arise in the course; of an optimization. In such cases, try restarting from the most recent geometry.; Alternatively, setting |optking__opt_coordinates| to cartesian will avoid any internal; coordinate difficulties altogether. These coordinate changes can be automatically; performed by turning |optking__dynamic_level| to 1. .. warning:: In some cases, such as the coordinate issues described above, optking will reset to maintain; a consistent history. If an error occurs in Psi4 due to |optking__geom_maxiter| being exceeded but; the final step report indicates that optking has not taken |optking__geom_maxiter| steps, such a ; reset has occured. Inspection will show that the step counter was reset to 1 somewhere in the; optimization. .. index:: ; pair: geometry optimization; convergence criteria. Convergence Criteria; ^^^^^^^^^^^^^^^^^^^^. Optking monitors five quantities to evaluate the progress of a geometry ; optimization. These are (with their keywords) the change in energy ; (|optking__max_energy_g_convergence|), the maximum element of ; the gradient (|optking__max_force_g_convergence|), the root-mean-square ; of the gradient (|optking__rms_force_g_convergence|), the maximum element; of displacement (|optking__max_disp_g_convergence|), and the ; root-mean-square of displacement (|optking__rms_disp_g_convergence|), ; all in internal coordinates and atomic units. Usually, these options will not ; be set directly. Primary control for geometry convergence lies with the keyword ; |optking__g_convergence| which sets the aforementioned in accordance ; with Table :ref:`Geometry Convergence <table:optkingconv>`. |; |. .. _`table:optkingconv`:. .. table:: Summary of sets of ",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:20298,Performance,optimiz,optimization,20298,"torsions become poorly defined when they contain near-linear bends. ; An internal error `AlgError` may be raised in such cases. Optking will avoid such; coordinates when choosing an initial coordinate system; however, they may arise in the course; of an optimization. In such cases, try restarting from the most recent geometry.; Alternatively, setting |optking__opt_coordinates| to cartesian will avoid any internal; coordinate difficulties altogether. These coordinate changes can be automatically; performed by turning |optking__dynamic_level| to 1. .. warning:: In some cases, such as the coordinate issues described above, optking will reset to maintain; a consistent history. If an error occurs in Psi4 due to |optking__geom_maxiter| being exceeded but; the final step report indicates that optking has not taken |optking__geom_maxiter| steps, such a ; reset has occured. Inspection will show that the step counter was reset to 1 somewhere in the; optimization. .. index:: ; pair: geometry optimization; convergence criteria. Convergence Criteria; ^^^^^^^^^^^^^^^^^^^^. Optking monitors five quantities to evaluate the progress of a geometry ; optimization. These are (with their keywords) the change in energy ; (|optking__max_energy_g_convergence|), the maximum element of ; the gradient (|optking__max_force_g_convergence|), the root-mean-square ; of the gradient (|optking__rms_force_g_convergence|), the maximum element; of displacement (|optking__max_disp_g_convergence|), and the ; root-mean-square of displacement (|optking__rms_disp_g_convergence|), ; all in internal coordinates and atomic units. Usually, these options will not ; be set directly. Primary control for geometry convergence lies with the keyword ; |optking__g_convergence| which sets the aforementioned in accordance ; with Table :ref:`Geometry Convergence <table:optkingconv>`. |; |. .. _`table:optkingconv`:. .. table:: Summary of sets of geometry optimization criteria available in |PSIfour|. +-----------------------",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:20452,Performance,optimiz,optimization,20452,"h cases. Optking will avoid such; coordinates when choosing an initial coordinate system; however, they may arise in the course; of an optimization. In such cases, try restarting from the most recent geometry.; Alternatively, setting |optking__opt_coordinates| to cartesian will avoid any internal; coordinate difficulties altogether. These coordinate changes can be automatically; performed by turning |optking__dynamic_level| to 1. .. warning:: In some cases, such as the coordinate issues described above, optking will reset to maintain; a consistent history. If an error occurs in Psi4 due to |optking__geom_maxiter| being exceeded but; the final step report indicates that optking has not taken |optking__geom_maxiter| steps, such a ; reset has occured. Inspection will show that the step counter was reset to 1 somewhere in the; optimization. .. index:: ; pair: geometry optimization; convergence criteria. Convergence Criteria; ^^^^^^^^^^^^^^^^^^^^. Optking monitors five quantities to evaluate the progress of a geometry ; optimization. These are (with their keywords) the change in energy ; (|optking__max_energy_g_convergence|), the maximum element of ; the gradient (|optking__max_force_g_convergence|), the root-mean-square ; of the gradient (|optking__rms_force_g_convergence|), the maximum element; of displacement (|optking__max_disp_g_convergence|), and the ; root-mean-square of displacement (|optking__rms_disp_g_convergence|), ; all in internal coordinates and atomic units. Usually, these options will not ; be set directly. Primary control for geometry convergence lies with the keyword ; |optking__g_convergence| which sets the aforementioned in accordance ; with Table :ref:`Geometry Convergence <table:optkingconv>`. |; |. .. _`table:optkingconv`:. .. table:: Summary of sets of geometry optimization criteria available in |PSIfour|. +-----------------------------+----------------------------+----------------------------+----------------------------+------------------------",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:21233,Performance,optimiz,optimization,21233," somewhere in the; optimization. .. index:: ; pair: geometry optimization; convergence criteria. Convergence Criteria; ^^^^^^^^^^^^^^^^^^^^. Optking monitors five quantities to evaluate the progress of a geometry ; optimization. These are (with their keywords) the change in energy ; (|optking__max_energy_g_convergence|), the maximum element of ; the gradient (|optking__max_force_g_convergence|), the root-mean-square ; of the gradient (|optking__rms_force_g_convergence|), the maximum element; of displacement (|optking__max_disp_g_convergence|), and the ; root-mean-square of displacement (|optking__rms_disp_g_convergence|), ; all in internal coordinates and atomic units. Usually, these options will not ; be set directly. Primary control for geometry convergence lies with the keyword ; |optking__g_convergence| which sets the aforementioned in accordance ; with Table :ref:`Geometry Convergence <table:optkingconv>`. |; |. .. _`table:optkingconv`:. .. table:: Summary of sets of geometry optimization criteria available in |PSIfour|. +-----------------------------+----------------------------+----------------------------+----------------------------+----------------------------+----------------------------+; | |optking__g_convergence| | Max Energy | Max Force | RMS Force | Max Disp | RMS Disp |; +=============================+============================+============================+============================+============================+============================+; | NWCHEM_LOOSE [#fd]_ | | :math:`4.5 \times 10^{-3}` | :math:`3.0 \times 10^{-3}` | :math:`5.4 \times 10^{-3}` | :math:`3.6 \times 10^{-3}` |; +-----------------------------+----------------------------+----------------------------+----------------------------+----------------------------+----------------------------+; | GAU_LOOSE [#ff]_ | | :math:`2.5 \times 10^{-3}` | :math:`1.7 \times 10^{-3}` | :math:`1.0 \times 10^{-2}` | :math:`6.7 \times 10^{-3}` |; +-----------------------------+---------------------",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:26181,Performance,optimiz,optimization,26181,".; .. [#ff] Normal convergence achieved when all four criteria (**Max Force**, **RMS Force**,; **Max Disp**, and **RMS Disp**) are fulfilled. To help with flat ; potential surfaces, alternate convergence achieved when 100\ :math:`\times`\ *rms force* is less ; than **RMS Force** criterion.; .. [#fg] Compensates for difficulties in converging geometry optmizations of supermolecular complexes ; tightly, where large *rms disp* and *max disp* may result from flat potential surfaces even when; *max force* and/or *rms force* are small. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by |optking__g_convergence|.; Note that this revokes the special convergence arrangements detailed in notes [#fe]_ and [#ff]_ ; and instead requires all active criteria to be fulfilled to ; achieve convergence. To avoid this revokation, turn on keyword |optking__flexible_g_convergence|. .. index::; pair: geometry optimization; output. Interface to GeomeTRIC; ^^^^^^^^^^^^^^^^^^^^^^. The GeomeTRIC optimizer developed by Wang and Song [Wang:2016:214108]_ may be used in place of; Psi4's native Optking optimizer. GeomeTRIC uses a translation-rotation-internal coordinate (TRIC); system that works well for optimizing geometries of systems containing noncovalent interactions. Use of the GeomeTRIC optimizer is specified with the ``engine`` argument to; :py:func:`~psi4.driver.optimize`. The optimization will respect the keywords |optking__g_convergence|; and |optking__geom_maxiter|. Any other GeomeTRIC-specific options (including constraints); may be specified with the ``optimizer_keywords`` argument to :py:func:`~psi4.driver.optimize`.; Constraints may be placed on cartesian coordinates, bonds, angles, and dihedrals, and they can be; used to either freeze a coordinate or set it to a specific value. See the `GeomeTRIC github; <https://github.com/leeping/geomeTRIC>`_ ; for more information on keywords a",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:26265,Performance,optimiz,optimizer,26265,"illed. To help with flat ; potential surfaces, alternate convergence achieved when 100\ :math:`\times`\ *rms force* is less ; than **RMS Force** criterion.; .. [#fg] Compensates for difficulties in converging geometry optmizations of supermolecular complexes ; tightly, where large *rms disp* and *max disp* may result from flat potential surfaces even when; *max force* and/or *rms force* are small. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by |optking__g_convergence|.; Note that this revokes the special convergence arrangements detailed in notes [#fe]_ and [#ff]_ ; and instead requires all active criteria to be fulfilled to ; achieve convergence. To avoid this revokation, turn on keyword |optking__flexible_g_convergence|. .. index::; pair: geometry optimization; output. Interface to GeomeTRIC; ^^^^^^^^^^^^^^^^^^^^^^. The GeomeTRIC optimizer developed by Wang and Song [Wang:2016:214108]_ may be used in place of; Psi4's native Optking optimizer. GeomeTRIC uses a translation-rotation-internal coordinate (TRIC); system that works well for optimizing geometries of systems containing noncovalent interactions. Use of the GeomeTRIC optimizer is specified with the ``engine`` argument to; :py:func:`~psi4.driver.optimize`. The optimization will respect the keywords |optking__g_convergence|; and |optking__geom_maxiter|. Any other GeomeTRIC-specific options (including constraints); may be specified with the ``optimizer_keywords`` argument to :py:func:`~psi4.driver.optimize`.; Constraints may be placed on cartesian coordinates, bonds, angles, and dihedrals, and they can be; used to either freeze a coordinate or set it to a specific value. See the `GeomeTRIC github; <https://github.com/leeping/geomeTRIC>`_ ; for more information on keywords and JSON specification of constraints. * Optimize the water molecule using GeomeTRIC::. molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. s",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:26369,Performance,optimiz,optimizer,26369,"illed. To help with flat ; potential surfaces, alternate convergence achieved when 100\ :math:`\times`\ *rms force* is less ; than **RMS Force** criterion.; .. [#fg] Compensates for difficulties in converging geometry optmizations of supermolecular complexes ; tightly, where large *rms disp* and *max disp* may result from flat potential surfaces even when; *max force* and/or *rms force* are small. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by |optking__g_convergence|.; Note that this revokes the special convergence arrangements detailed in notes [#fe]_ and [#ff]_ ; and instead requires all active criteria to be fulfilled to ; achieve convergence. To avoid this revokation, turn on keyword |optking__flexible_g_convergence|. .. index::; pair: geometry optimization; output. Interface to GeomeTRIC; ^^^^^^^^^^^^^^^^^^^^^^. The GeomeTRIC optimizer developed by Wang and Song [Wang:2016:214108]_ may be used in place of; Psi4's native Optking optimizer. GeomeTRIC uses a translation-rotation-internal coordinate (TRIC); system that works well for optimizing geometries of systems containing noncovalent interactions. Use of the GeomeTRIC optimizer is specified with the ``engine`` argument to; :py:func:`~psi4.driver.optimize`. The optimization will respect the keywords |optking__g_convergence|; and |optking__geom_maxiter|. Any other GeomeTRIC-specific options (including constraints); may be specified with the ``optimizer_keywords`` argument to :py:func:`~psi4.driver.optimize`.; Constraints may be placed on cartesian coordinates, bonds, angles, and dihedrals, and they can be; used to either freeze a coordinate or set it to a specific value. See the `GeomeTRIC github; <https://github.com/leeping/geomeTRIC>`_ ; for more information on keywords and JSON specification of constraints. * Optimize the water molecule using GeomeTRIC::. molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. s",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:26473,Performance,optimiz,optimizing,26473,"riterion.; .. [#fg] Compensates for difficulties in converging geometry optmizations of supermolecular complexes ; tightly, where large *rms disp* and *max disp* may result from flat potential surfaces even when; *max force* and/or *rms force* are small. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by |optking__g_convergence|.; Note that this revokes the special convergence arrangements detailed in notes [#fe]_ and [#ff]_ ; and instead requires all active criteria to be fulfilled to ; achieve convergence. To avoid this revokation, turn on keyword |optking__flexible_g_convergence|. .. index::; pair: geometry optimization; output. Interface to GeomeTRIC; ^^^^^^^^^^^^^^^^^^^^^^. The GeomeTRIC optimizer developed by Wang and Song [Wang:2016:214108]_ may be used in place of; Psi4's native Optking optimizer. GeomeTRIC uses a translation-rotation-internal coordinate (TRIC); system that works well for optimizing geometries of systems containing noncovalent interactions. Use of the GeomeTRIC optimizer is specified with the ``engine`` argument to; :py:func:`~psi4.driver.optimize`. The optimization will respect the keywords |optking__g_convergence|; and |optking__geom_maxiter|. Any other GeomeTRIC-specific options (including constraints); may be specified with the ``optimizer_keywords`` argument to :py:func:`~psi4.driver.optimize`.; Constraints may be placed on cartesian coordinates, bonds, angles, and dihedrals, and they can be; used to either freeze a coordinate or set it to a specific value. See the `GeomeTRIC github; <https://github.com/leeping/geomeTRIC>`_ ; for more information on keywords and JSON specification of constraints. * Optimize the water molecule using GeomeTRIC::. molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. optimize('hf/cc-pvdz', engine='geometric'). * Optimize the water molecule using GeomeTRIC, with one of th",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:26564,Performance,optimiz,optimizer,26564," large *rms disp* and *max disp* may result from flat potential surfaces even when; *max force* and/or *rms force* are small. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by |optking__g_convergence|.; Note that this revokes the special convergence arrangements detailed in notes [#fe]_ and [#ff]_ ; and instead requires all active criteria to be fulfilled to ; achieve convergence. To avoid this revokation, turn on keyword |optking__flexible_g_convergence|. .. index::; pair: geometry optimization; output. Interface to GeomeTRIC; ^^^^^^^^^^^^^^^^^^^^^^. The GeomeTRIC optimizer developed by Wang and Song [Wang:2016:214108]_ may be used in place of; Psi4's native Optking optimizer. GeomeTRIC uses a translation-rotation-internal coordinate (TRIC); system that works well for optimizing geometries of systems containing noncovalent interactions. Use of the GeomeTRIC optimizer is specified with the ``engine`` argument to; :py:func:`~psi4.driver.optimize`. The optimization will respect the keywords |optking__g_convergence|; and |optking__geom_maxiter|. Any other GeomeTRIC-specific options (including constraints); may be specified with the ``optimizer_keywords`` argument to :py:func:`~psi4.driver.optimize`.; Constraints may be placed on cartesian coordinates, bonds, angles, and dihedrals, and they can be; used to either freeze a coordinate or set it to a specific value. See the `GeomeTRIC github; <https://github.com/leeping/geomeTRIC>`_ ; for more information on keywords and JSON specification of constraints. * Optimize the water molecule using GeomeTRIC::. molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. optimize('hf/cc-pvdz', engine='geometric'). * Optimize the water molecule using GeomeTRIC, with one of the two OH bonds constrained to 2.0 au; and the HOH angle constrained to 104.5 degrees::. molecule h2o {; O; H 1 1.0; H 1 1.0 2 16",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:26643,Performance,optimiz,optimize,26643,"tial surfaces even when; *max force* and/or *rms force* are small. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by |optking__g_convergence|.; Note that this revokes the special convergence arrangements detailed in notes [#fe]_ and [#ff]_ ; and instead requires all active criteria to be fulfilled to ; achieve convergence. To avoid this revokation, turn on keyword |optking__flexible_g_convergence|. .. index::; pair: geometry optimization; output. Interface to GeomeTRIC; ^^^^^^^^^^^^^^^^^^^^^^. The GeomeTRIC optimizer developed by Wang and Song [Wang:2016:214108]_ may be used in place of; Psi4's native Optking optimizer. GeomeTRIC uses a translation-rotation-internal coordinate (TRIC); system that works well for optimizing geometries of systems containing noncovalent interactions. Use of the GeomeTRIC optimizer is specified with the ``engine`` argument to; :py:func:`~psi4.driver.optimize`. The optimization will respect the keywords |optking__g_convergence|; and |optking__geom_maxiter|. Any other GeomeTRIC-specific options (including constraints); may be specified with the ``optimizer_keywords`` argument to :py:func:`~psi4.driver.optimize`.; Constraints may be placed on cartesian coordinates, bonds, angles, and dihedrals, and they can be; used to either freeze a coordinate or set it to a specific value. See the `GeomeTRIC github; <https://github.com/leeping/geomeTRIC>`_ ; for more information on keywords and JSON specification of constraints. * Optimize the water molecule using GeomeTRIC::. molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. optimize('hf/cc-pvdz', engine='geometric'). * Optimize the water molecule using GeomeTRIC, with one of the two OH bonds constrained to 2.0 au; and the HOH angle constrained to 104.5 degrees::. molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. geometric",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:26658,Performance,optimiz,optimization,26658,"* are small. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by |optking__g_convergence|.; Note that this revokes the special convergence arrangements detailed in notes [#fe]_ and [#ff]_ ; and instead requires all active criteria to be fulfilled to ; achieve convergence. To avoid this revokation, turn on keyword |optking__flexible_g_convergence|. .. index::; pair: geometry optimization; output. Interface to GeomeTRIC; ^^^^^^^^^^^^^^^^^^^^^^. The GeomeTRIC optimizer developed by Wang and Song [Wang:2016:214108]_ may be used in place of; Psi4's native Optking optimizer. GeomeTRIC uses a translation-rotation-internal coordinate (TRIC); system that works well for optimizing geometries of systems containing noncovalent interactions. Use of the GeomeTRIC optimizer is specified with the ``engine`` argument to; :py:func:`~psi4.driver.optimize`. The optimization will respect the keywords |optking__g_convergence|; and |optking__geom_maxiter|. Any other GeomeTRIC-specific options (including constraints); may be specified with the ``optimizer_keywords`` argument to :py:func:`~psi4.driver.optimize`.; Constraints may be placed on cartesian coordinates, bonds, angles, and dihedrals, and they can be; used to either freeze a coordinate or set it to a specific value. See the `GeomeTRIC github; <https://github.com/leeping/geomeTRIC>`_ ; for more information on keywords and JSON specification of constraints. * Optimize the water molecule using GeomeTRIC::. molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. optimize('hf/cc-pvdz', engine='geometric'). * Optimize the water molecule using GeomeTRIC, with one of the two OH bonds constrained to 2.0 au; and the HOH angle constrained to 104.5 degrees::. molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = { ; 'coordsys' : 'tric',; 'constraints' : ",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:26898,Performance,optimiz,optimize,26898,"at this revokes the special convergence arrangements detailed in notes [#fe]_ and [#ff]_ ; and instead requires all active criteria to be fulfilled to ; achieve convergence. To avoid this revokation, turn on keyword |optking__flexible_g_convergence|. .. index::; pair: geometry optimization; output. Interface to GeomeTRIC; ^^^^^^^^^^^^^^^^^^^^^^. The GeomeTRIC optimizer developed by Wang and Song [Wang:2016:214108]_ may be used in place of; Psi4's native Optking optimizer. GeomeTRIC uses a translation-rotation-internal coordinate (TRIC); system that works well for optimizing geometries of systems containing noncovalent interactions. Use of the GeomeTRIC optimizer is specified with the ``engine`` argument to; :py:func:`~psi4.driver.optimize`. The optimization will respect the keywords |optking__g_convergence|; and |optking__geom_maxiter|. Any other GeomeTRIC-specific options (including constraints); may be specified with the ``optimizer_keywords`` argument to :py:func:`~psi4.driver.optimize`.; Constraints may be placed on cartesian coordinates, bonds, angles, and dihedrals, and they can be; used to either freeze a coordinate or set it to a specific value. See the `GeomeTRIC github; <https://github.com/leeping/geomeTRIC>`_ ; for more information on keywords and JSON specification of constraints. * Optimize the water molecule using GeomeTRIC::. molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. optimize('hf/cc-pvdz', engine='geometric'). * Optimize the water molecule using GeomeTRIC, with one of the two OH bonds constrained to 2.0 au; and the HOH angle constrained to 104.5 degrees::. molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = { ; 'coordsys' : 'tric',; 'constraints' : { ; 'set' : [{'type' : 'distance',; 'indices' : [0, 1], ; 'value' : 2.0 },; {'type' : 'angle',; 'indices' : [1, 0, 2], ; 'value' : 104.5 }]; } ; } . optimize('hf/cc-pvdz', engine='geometric', optimizer",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:27356,Performance,optimiz,optimize,27356,"r. GeomeTRIC uses a translation-rotation-internal coordinate (TRIC); system that works well for optimizing geometries of systems containing noncovalent interactions. Use of the GeomeTRIC optimizer is specified with the ``engine`` argument to; :py:func:`~psi4.driver.optimize`. The optimization will respect the keywords |optking__g_convergence|; and |optking__geom_maxiter|. Any other GeomeTRIC-specific options (including constraints); may be specified with the ``optimizer_keywords`` argument to :py:func:`~psi4.driver.optimize`.; Constraints may be placed on cartesian coordinates, bonds, angles, and dihedrals, and they can be; used to either freeze a coordinate or set it to a specific value. See the `GeomeTRIC github; <https://github.com/leeping/geomeTRIC>`_ ; for more information on keywords and JSON specification of constraints. * Optimize the water molecule using GeomeTRIC::. molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. optimize('hf/cc-pvdz', engine='geometric'). * Optimize the water molecule using GeomeTRIC, with one of the two OH bonds constrained to 2.0 au; and the HOH angle constrained to 104.5 degrees::. molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = { ; 'coordsys' : 'tric',; 'constraints' : { ; 'set' : [{'type' : 'distance',; 'indices' : [0, 1], ; 'value' : 2.0 },; {'type' : 'angle',; 'indices' : [1, 0, 2], ; 'value' : 104.5 }]; } ; } . optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords). * Optimize the benzene/water dimer using GeomeTRIC, with the 6 carbon atoms of benzene frozen in ; place::. molecule h2o {; C 0.833 1.221 -0.504; H 1.482 2.086 -0.518; C 1.379 -0.055 -0.486; H 2.453 -0.184 -0.483; C 0.546 -1.167 -0.474; H 0.971 -2.162 -0.466; C -0.833 -1.001 -0.475; H -1.482 -1.867 -0.468; C -1.379 0.275 -0.490; H -2.453 0.404 -0.491; C -0.546 1.386 -0.506; H -0.971 2.381 -0.524; --; O 0.000 0.147 3.265; H 0.000 -0.505 2.5",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:27851,Performance,optimiz,optimize,27851,"driver.optimize`.; Constraints may be placed on cartesian coordinates, bonds, angles, and dihedrals, and they can be; used to either freeze a coordinate or set it to a specific value. See the `GeomeTRIC github; <https://github.com/leeping/geomeTRIC>`_ ; for more information on keywords and JSON specification of constraints. * Optimize the water molecule using GeomeTRIC::. molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. optimize('hf/cc-pvdz', engine='geometric'). * Optimize the water molecule using GeomeTRIC, with one of the two OH bonds constrained to 2.0 au; and the HOH angle constrained to 104.5 degrees::. molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = { ; 'coordsys' : 'tric',; 'constraints' : { ; 'set' : [{'type' : 'distance',; 'indices' : [0, 1], ; 'value' : 2.0 },; {'type' : 'angle',; 'indices' : [1, 0, 2], ; 'value' : 104.5 }]; } ; } . optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords). * Optimize the benzene/water dimer using GeomeTRIC, with the 6 carbon atoms of benzene frozen in ; place::. molecule h2o {; C 0.833 1.221 -0.504; H 1.482 2.086 -0.518; C 1.379 -0.055 -0.486; H 2.453 -0.184 -0.483; C 0.546 -1.167 -0.474; H 0.971 -2.162 -0.466; C -0.833 -1.001 -0.475; H -1.482 -1.867 -0.468; C -1.379 0.275 -0.490; H -2.453 0.404 -0.491; C -0.546 1.386 -0.506; H -0.971 2.381 -0.524; --; O 0.000 0.147 3.265; H 0.000 -0.505 2.581; H 0.000 0.965 2.790; no_com; no_reorient; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = { ; 'coordsys' : 'tric',; 'constraints' : { ; 'freeze' : [{'type' : 'xyz',; 'indices' : [0, 2, 4, 6, 8, 10]}]; } ; } . optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords). Output; ^^^^^^. The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (``~``). This produces a table like the one below that shows; for each iter",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:28608,Performance,optimiz,optimize,28608,"_keywords = { ; 'coordsys' : 'tric',; 'constraints' : { ; 'set' : [{'type' : 'distance',; 'indices' : [0, 1], ; 'value' : 2.0 },; {'type' : 'angle',; 'indices' : [1, 0, 2], ; 'value' : 104.5 }]; } ; } . optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords). * Optimize the benzene/water dimer using GeomeTRIC, with the 6 carbon atoms of benzene frozen in ; place::. molecule h2o {; C 0.833 1.221 -0.504; H 1.482 2.086 -0.518; C 1.379 -0.055 -0.486; H 2.453 -0.184 -0.483; C 0.546 -1.167 -0.474; H 0.971 -2.162 -0.466; C -0.833 -1.001 -0.475; H -1.482 -1.867 -0.468; C -1.379 0.275 -0.490; H -2.453 0.404 -0.491; C -0.546 1.386 -0.506; H -0.971 2.381 -0.524; --; O 0.000 0.147 3.265; H 0.000 -0.505 2.581; H 0.000 0.965 2.790; no_com; no_reorient; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = { ; 'coordsys' : 'tric',; 'constraints' : { ; 'freeze' : [{'type' : 'xyz',; 'indices' : [0, 2, 4, 6, 8, 10]}]; } ; } . optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords). Output; ^^^^^^. The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (``~``). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (``*``), active and unfulfilled ( ), or inactive (``o``). ::. --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-0",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:28734,Performance,optimiz,optimization,28734,"e' : 2.0 },; {'type' : 'angle',; 'indices' : [1, 0, 2], ; 'value' : 104.5 }]; } ; } . optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords). * Optimize the benzene/water dimer using GeomeTRIC, with the 6 carbon atoms of benzene frozen in ; place::. molecule h2o {; C 0.833 1.221 -0.504; H 1.482 2.086 -0.518; C 1.379 -0.055 -0.486; H 2.453 -0.184 -0.483; C 0.546 -1.167 -0.474; H 0.971 -2.162 -0.466; C -0.833 -1.001 -0.475; H -1.482 -1.867 -0.468; C -1.379 0.275 -0.490; H -2.453 0.404 -0.491; C -0.546 1.386 -0.506; H -0.971 2.381 -0.524; --; O 0.000 0.147 3.265; H 0.000 -0.505 2.581; H 0.000 0.965 2.790; no_com; no_reorient; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = { ; 'coordsys' : 'tric',; 'constraints' : { ; 'freeze' : [{'type' : 'xyz',; 'indices' : [0, 2, 4, 6, 8, 10]}]; } ; } . optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords). Output; ^^^^^^. The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (``~``). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (``*``), active and unfulfilled ( ), or inactive (``o``). ::. --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:29960,Performance,optimiz,optimizations,29960,"-0.505 2.581; H 0.000 0.965 2.790; no_com; no_reorient; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = { ; 'coordsys' : 'tric',; 'constraints' : { ; 'freeze' : [{'type' : 'xyz',; 'indices' : [0, 2, 4, 6, 8, 10]}]; } ; } . optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords). Output; ^^^^^^. The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (``~``). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (``*``), active and unfulfilled ( ), or inactive (``o``). ::. --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix :ref:`apdx:optking`. Information on the Psithon function that drives geometry optimizations is provided; at :py:func:`~psi4.driver.optimize`. Important User Changes from cpp-optking; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * `FIXED_COORD` keywords have been generalized to `RANGED_COORD` e.g. |optking__ranged_distance|. * Detailed optimization is now printed through the python logging system. If more information about; the optimization is needed. Please see `\<output_name\>.log`; ",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:30013,Performance,optimiz,optimize,30013,"-0.505 2.581; H 0.000 0.965 2.790; no_com; no_reorient; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = { ; 'coordsys' : 'tric',; 'constraints' : { ; 'freeze' : [{'type' : 'xyz',; 'indices' : [0, 2, 4, 6, 8, 10]}]; } ; } . optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords). Output; ^^^^^^. The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (``~``). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (``*``), active and unfulfilled ( ), or inactive (``o``). ::. --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix :ref:`apdx:optking`. Information on the Psithon function that drives geometry optimizations is provided; at :py:func:`~psi4.driver.optimize`. Important User Changes from cpp-optking; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * `FIXED_COORD` keywords have been generalized to `RANGED_COORD` e.g. |optking__ranged_distance|. * Detailed optimization is now printed through the python logging system. If more information about; the optimization is needed. Please see `\<output_name\>.log`; ",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:30215,Performance,optimiz,optimization,30215,"-0.505 2.581; H 0.000 0.965 2.790; no_com; no_reorient; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = { ; 'coordsys' : 'tric',; 'constraints' : { ; 'freeze' : [{'type' : 'xyz',; 'indices' : [0, 2, 4, 6, 8, 10]}]; } ; } . optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords). Output; ^^^^^^. The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (``~``). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (``*``), active and unfulfilled ( ), or inactive (``o``). ::. --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix :ref:`apdx:optking`. Information on the Psithon function that drives geometry optimizations is provided; at :py:func:`~psi4.driver.optimize`. Important User Changes from cpp-optking; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * `FIXED_COORD` keywords have been generalized to `RANGED_COORD` e.g. |optking__ranged_distance|. * Detailed optimization is now printed through the python logging system. If more information about; the optimization is needed. Please see `\<output_name\>.log`; ",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:30309,Performance,optimiz,optimization,30309,"-0.505 2.581; H 0.000 0.965 2.790; no_com; no_reorient; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = { ; 'coordsys' : 'tric',; 'constraints' : { ; 'freeze' : [{'type' : 'xyz',; 'indices' : [0, 2, 4, 6, 8, 10]}]; } ; } . optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords). Output; ^^^^^^. The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (``~``). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (``*``), active and unfulfilled ( ), or inactive (``o``). ::. --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix :ref:`apdx:optking`. Information on the Psithon function that drives geometry optimizations is provided; at :py:func:`~psi4.driver.optimize`. Important User Changes from cpp-optking; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * `FIXED_COORD` keywords have been generalized to `RANGED_COORD` e.g. |optking__ranged_distance|. * Detailed optimization is now printed through the python logging system. If more information about; the optimization is needed. Please see `\<output_name\>.log`; ",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:1701,Safety,redund,redundant,1701,"Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index::; single: geometry optimization, optimization. .. _`sec:optking`:. Geometry Optimization; =====================. .. codeauthor:: Rollin A. King and Alexander G. Heide; .. sectionauthor:: Rollin A. King, Alexander G. Heide, and Lori A. Burns. *Module:* :ref:`Keywords <apdx:optking>`, `OPTKING <https://github.com/psi-rking/optking>`_. |PSIfour| carries out molecular optimizations using a Python module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives |w---w| both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, an RFO step with trust radius scaling, and the BFGS Hessian update. The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49]_.; The general approach employed in this code; is similar to the ""model Hessian plus RF method"" described and tested by Bakken and; Helgaker [Bakken:2002:9160]_. However, for separated; fragments, we have chosen not to employ their ""extra-redundant"" coordinates. The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; |optking__covalent_connect|. If the user finds that some; connectivity is lacking by default, then this value may be increased. .. warning:: The selection of a Z-matrix input, and in particular the inclusion; of dummy atoms, has no effect on the behavior of the optimizer, which begins; from a Cartesian",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:1865,Safety,redund,redundant,1865," # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index::; single: geometry optimization, optimization. .. _`sec:optking`:. Geometry Optimization; =====================. .. codeauthor:: Rollin A. King and Alexander G. Heide; .. sectionauthor:: Rollin A. King, Alexander G. Heide, and Lori A. Burns. *Module:* :ref:`Keywords <apdx:optking>`, `OPTKING <https://github.com/psi-rking/optking>`_. |PSIfour| carries out molecular optimizations using a Python module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives |w---w| both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, an RFO step with trust radius scaling, and the BFGS Hessian update. The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49]_.; The general approach employed in this code; is similar to the ""model Hessian plus RF method"" described and tested by Bakken and; Helgaker [Bakken:2002:9160]_. However, for separated; fragments, we have chosen not to employ their ""extra-redundant"" coordinates. The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; |optking__covalent_connect|. If the user finds that some; connectivity is lacking by default, then this value may be increased. .. warning:: The selection of a Z-matrix input, and in particular the inclusion; of dummy atoms, has no effect on the behavior of the optimizer, which begins; from a Cartesian representation of the system. .. _DimerIntro:. Presently, by default, separate fragments are bonded by the; nearest atoms, and the whole syst",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:2166,Safety,redund,redundant,2166,"Geometry Optimization; =====================. .. codeauthor:: Rollin A. King and Alexander G. Heide; .. sectionauthor:: Rollin A. King, Alexander G. Heide, and Lori A. Burns. *Module:* :ref:`Keywords <apdx:optking>`, `OPTKING <https://github.com/psi-rking/optking>`_. |PSIfour| carries out molecular optimizations using a Python module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives |w---w| both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, an RFO step with trust radius scaling, and the BFGS Hessian update. The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49]_.; The general approach employed in this code; is similar to the ""model Hessian plus RF method"" described and tested by Bakken and; Helgaker [Bakken:2002:9160]_. However, for separated; fragments, we have chosen not to employ their ""extra-redundant"" coordinates. The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; |optking__covalent_connect|. If the user finds that some; connectivity is lacking by default, then this value may be increased. .. warning:: The selection of a Z-matrix input, and in particular the inclusion; of dummy atoms, has no effect on the behavior of the optimizer, which begins; from a Cartesian representation of the system. .. _DimerIntro:. Presently, by default, separate fragments are bonded by the; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option |optking__frag_mode|, fragments; may instead be related by a minimal set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:18637,Safety,detect,detected,18637,"""Frozen"": [""theta_A"", ""theta_B"", ""tau"", ""phi_A"", ""phi_B""],; }""""""; ; set {; basis 6-31+G ; frag_mode MULTI; interfrag_coords $MTdimer ; }. optimize(""mp2""). Dealing with problematic optimizations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. * As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary. * |optking__dynamic_level| allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the dynamic level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps. * The developers have found the |optking__opt_coordinates| set to ""BOTH"" which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long 'arms' or floppy portions of a molecule poorly; described by local internals. * Optking does support the specification of ghost atoms. Certain internal coordinates such ; as torsions become poorly defined when they contain near-linear bends. ; An internal error `AlgError` may be raised in such cases. Optking will avoid such; coordinates when choosing an initial coordinate system; however, they may arise in the course; of an optimization. In such cases, try restarting from the most recent geometry.; Alternatively, setting |o",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:19025,Safety,redund,redundant,19025,", the following suggestions are made. * As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary. * |optking__dynamic_level| allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the dynamic level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps. * The developers have found the |optking__opt_coordinates| set to ""BOTH"" which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long 'arms' or floppy portions of a molecule poorly; described by local internals. * Optking does support the specification of ghost atoms. Certain internal coordinates such ; as torsions become poorly defined when they contain near-linear bends. ; An internal error `AlgError` may be raised in such cases. Optking will avoid such; coordinates when choosing an initial coordinate system; however, they may arise in the course; of an optimization. In such cases, try restarting from the most recent geometry.; Alternatively, setting |optking__opt_coordinates| to cartesian will avoid any internal; coordinate difficulties altogether. These coordinate changes can be automatically; performed by turning |optking__dynamic_level| to 1. .. warning:: In some cases, such as the coordinate issues described above, optking will reset to maintain; a consistent history. If an error occurs in Psi4 due to |optking__geom_maxiter| being exceeded but; the ",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:19443,Safety,avoid,avoid,19443,"s that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the dynamic level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps. * The developers have found the |optking__opt_coordinates| set to ""BOTH"" which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long 'arms' or floppy portions of a molecule poorly; described by local internals. * Optking does support the specification of ghost atoms. Certain internal coordinates such ; as torsions become poorly defined when they contain near-linear bends. ; An internal error `AlgError` may be raised in such cases. Optking will avoid such; coordinates when choosing an initial coordinate system; however, they may arise in the course; of an optimization. In such cases, try restarting from the most recent geometry.; Alternatively, setting |optking__opt_coordinates| to cartesian will avoid any internal; coordinate difficulties altogether. These coordinate changes can be automatically; performed by turning |optking__dynamic_level| to 1. .. warning:: In some cases, such as the coordinate issues described above, optking will reset to maintain; a consistent history. If an error occurs in Psi4 due to |optking__geom_maxiter| being exceeded but; the final step report indicates that optking has not taken |optking__geom_maxiter| steps, such a ; reset has occured. Inspection will show that the step counter was reset to 1 somewhere in the; optimization. .. index:: ; pair: geometry optimization; convergence criteria. Convergence Criteria; ^^^^^^^^^^^^^^^^^^^^. Optking monitors five quantities to evaluate the progress of a geometry ; optimization. These are (with their keywords) t",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:19700,Safety,avoid,avoid,19700,"ral forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps. * The developers have found the |optking__opt_coordinates| set to ""BOTH"" which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long 'arms' or floppy portions of a molecule poorly; described by local internals. * Optking does support the specification of ghost atoms. Certain internal coordinates such ; as torsions become poorly defined when they contain near-linear bends. ; An internal error `AlgError` may be raised in such cases. Optking will avoid such; coordinates when choosing an initial coordinate system; however, they may arise in the course; of an optimization. In such cases, try restarting from the most recent geometry.; Alternatively, setting |optking__opt_coordinates| to cartesian will avoid any internal; coordinate difficulties altogether. These coordinate changes can be automatically; performed by turning |optking__dynamic_level| to 1. .. warning:: In some cases, such as the coordinate issues described above, optking will reset to maintain; a consistent history. If an error occurs in Psi4 due to |optking__geom_maxiter| being exceeded but; the final step report indicates that optking has not taken |optking__geom_maxiter| steps, such a ; reset has occured. Inspection will show that the step counter was reset to 1 somewhere in the; optimization. .. index:: ; pair: geometry optimization; convergence criteria. Convergence Criteria; ^^^^^^^^^^^^^^^^^^^^. Optking monitors five quantities to evaluate the progress of a geometry ; optimization. These are (with their keywords) the change in energy ; (|optking__max_energy_g_convergence|), the maximum element of ; the gradient (|optking__max_force_g_convergence|), the root-mean-square ; of the gradient (|optking__rms_for",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:26080,Safety,avoid,avoid,26080,"x Force** and one of **Max Energy** or **Max Disp** are fulfilled.; .. [#ff] Normal convergence achieved when all four criteria (**Max Force**, **RMS Force**,; **Max Disp**, and **RMS Disp**) are fulfilled. To help with flat ; potential surfaces, alternate convergence achieved when 100\ :math:`\times`\ *rms force* is less ; than **RMS Force** criterion.; .. [#fg] Compensates for difficulties in converging geometry optmizations of supermolecular complexes ; tightly, where large *rms disp* and *max disp* may result from flat potential surfaces even when; *max force* and/or *rms force* are small. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by |optking__g_convergence|.; Note that this revokes the special convergence arrangements detailed in notes [#fe]_ and [#ff]_ ; and instead requires all active criteria to be fulfilled to ; achieve convergence. To avoid this revokation, turn on keyword |optking__flexible_g_convergence|. .. index::; pair: geometry optimization; output. Interface to GeomeTRIC; ^^^^^^^^^^^^^^^^^^^^^^. The GeomeTRIC optimizer developed by Wang and Song [Wang:2016:214108]_ may be used in place of; Psi4's native Optking optimizer. GeomeTRIC uses a translation-rotation-internal coordinate (TRIC); system that works well for optimizing geometries of systems containing noncovalent interactions. Use of the GeomeTRIC optimizer is specified with the ``engine`` argument to; :py:func:`~psi4.driver.optimize`. The optimization will respect the keywords |optking__g_convergence|; and |optking__geom_maxiter|. Any other GeomeTRIC-specific options (including constraints); may be specified with the ``optimizer_keywords`` argument to :py:func:`~psi4.driver.optimize`.; Constraints may be placed on cartesian coordinates, bonds, angles, and dihedrals, and they can be; used to either freeze a coordinate or set it to a specific value. See the `GeomeTRIC github; <https://gith",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:2037,Testability,test,tested,2037,"ENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index::; single: geometry optimization, optimization. .. _`sec:optking`:. Geometry Optimization; =====================. .. codeauthor:: Rollin A. King and Alexander G. Heide; .. sectionauthor:: Rollin A. King, Alexander G. Heide, and Lori A. Burns. *Module:* :ref:`Keywords <apdx:optking>`, `OPTKING <https://github.com/psi-rking/optking>`_. |PSIfour| carries out molecular optimizations using a Python module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives |w---w| both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, an RFO step with trust radius scaling, and the BFGS Hessian update. The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49]_.; The general approach employed in this code; is similar to the ""model Hessian plus RF method"" described and tested by Bakken and; Helgaker [Bakken:2002:9160]_. However, for separated; fragments, we have chosen not to employ their ""extra-redundant"" coordinates. The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; |optking__covalent_connect|. If the user finds that some; connectivity is lacking by default, then this value may be increased. .. warning:: The selection of a Z-matrix input, and in particular the inclusion; of dummy atoms, has no effect on the behavior of the optimizer, which begins; from a Cartesian representation of the system. .. _DimerIntro:. Presently, by default, separate fragments are bonded by the; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option |optking__frag_mode|, fragments; may instead be related by a minimal set of ",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:2317,Testability,test,testing,2317,"ING <https://github.com/psi-rking/optking>`_. |PSIfour| carries out molecular optimizations using a Python module called; optking. The optking program takes as input nuclear gradients and,; optionally, nuclear second derivatives |w---w| both in Cartesian coordinates.; The default minimization algorithm employs an empirical model Hessian,; redundant internal coordinates, an RFO step with trust radius scaling, and the BFGS Hessian update. The principal literature references include the introduction of redundant; internal coordinates by Peng et al. [Peng:1996:49]_.; The general approach employed in this code; is similar to the ""model Hessian plus RF method"" described and tested by Bakken and; Helgaker [Bakken:2002:9160]_. However, for separated; fragments, we have chosen not to employ their ""extra-redundant"" coordinates. The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; |optking__covalent_connect|. If the user finds that some; connectivity is lacking by default, then this value may be increased. .. warning:: The selection of a Z-matrix input, and in particular the inclusion; of dummy atoms, has no effect on the behavior of the optimizer, which begins; from a Cartesian representation of the system. .. _DimerIntro:. Presently, by default, separate fragments are bonded by the; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option |optking__frag_mode|, fragments; may instead be related by a minimal set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default) or linear combinations of atomic positions; (automatic use of principal axes is under development).; These `dimer coordinates` can be directly specified through |optking__interfrag_coords|); See `here <DimerSecti",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:18333,Testability,test,test,18333," -6.368443 -0.968607 3.273516; nocom; unit angstrom; }; ; # Create a python dictionary and convert to string for pass through to optking; MTdimer = """"""{; ""Natoms per frag"": [12, 16],; ""A Frag"": 1,; ""A Ref Atoms"": [[1, 3, 4, 6, 8], [8], [11]],; ""A Label"": ""methylthiophene"",; ""B Frag"": 2,; ""B Ref Atoms"": [[13, 14, 15, 16, 17, 18], [13], [15]],; ""B Label"": ""tyrosine"",; ""Frozen"": [""theta_A"", ""theta_B"", ""tau"", ""phi_A"", ""phi_B""],; }""""""; ; set {; basis 6-31+G ; frag_mode MULTI; interfrag_coords $MTdimer ; }. optimize(""mp2""). Dealing with problematic optimizations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. * As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary. * |optking__dynamic_level| allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the dynamic level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps. * The developers have found the |optking__opt_coordinates| set to ""BOTH"" which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long 'arms' or floppy portions of a molecule poorly; described by local internals. * Optking does support the specification of ghost atoms. Certain internal coordina",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:30262,Testability,log,logging,30262,"-0.505 2.581; H 0.000 0.965 2.790; no_com; no_reorient; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = { ; 'coordsys' : 'tric',; 'constraints' : { ; 'freeze' : [{'type' : 'xyz',; 'indices' : [0, 2, 4, 6, 8, 10]}]; } ; } . optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords). Output; ^^^^^^. The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (``~``). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (``*``), active and unfulfilled ( ), or inactive (``o``). ::. --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix :ref:`apdx:optking`. Information on the Psithon function that drives geometry optimizations is provided; at :py:func:`~psi4.driver.optimize`. Important User Changes from cpp-optking; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * `FIXED_COORD` keywords have been generalized to `RANGED_COORD` e.g. |optking__ranged_distance|. * Detailed optimization is now printed through the python logging system. If more information about; the optimization is needed. Please see `\<output_name\>.log`; ",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:30361,Testability,log,log,30361,"-0.505 2.581; H 0.000 0.965 2.790; no_com; no_reorient; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = { ; 'coordsys' : 'tric',; 'constraints' : { ; 'freeze' : [{'type' : 'xyz',; 'indices' : [0, 2, 4, 6, 8, 10]}]; } ; } . optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords). Output; ^^^^^^. The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (``~``). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (``*``), active and unfulfilled ( ), or inactive (``o``). ::. --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix :ref:`apdx:optking`. Information on the Psithon function that drives geometry optimizations is provided; at :py:func:`~psi4.driver.optimize`. Important User Changes from cpp-optking; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * `FIXED_COORD` keywords have been generalized to `RANGED_COORD` e.g. |optking__ranged_distance|. * Detailed optimization is now printed through the python logging system. If more information about; the optimization is needed. Please see `\<output_name\>.log`; ",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst:5131,Usability,simpl,simple,5131,"eps::. set step_type nr; optimize('scf'). * Optimize using finite differences of energies instead of gradients::. optimize('scf', dertype='energy'). * Optimize while limiting the initial step size to 0.1 au::. set intrafrag_step_limit 0.1; optimize('scf'). * Optimize while always limiting the step size to 0.1 au:. .. code-block:: none. set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). * Optimize while calculating the Hessian at every step:. .. code-block:: none. set full_hess_every 1; optimize('scf'). .. code-block:: none; ; import optking; . Hessian; ^^^^^^^. If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333]_ and Fischer and Almlof; [Fischer:1992:9770]_.; Either of these or a simple diagonal Hessian may be selected using the ; |optking__intrafrag_hess| keyword. All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC]_ and Bofill [Bofill:1994:1]_. The Hessian may be computed during an optimization using the ; |optking__full_hess_every| keyword. .. index:: ; pair: geometry optimization; transition state; pair: geometry optimization; IRC; single: geometry optimization; constrained. Transition States and Reaction Paths; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * Calculate a starting Hessian and optimize the ""transition state"" of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails)::. molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). * At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum::. molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.39",MatchSource.DOCS,doc/sphinxman/source/optking.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/optking.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst:1871,Availability,down,downloads,1871," with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index:: PCMSolver, PCM, continuum solvation. .. _`sec:pcmsolver`:. Interface to PCMSolver by R. Di Remigio; =======================================. .. codeauthor:: Roberto Di Remigio, T. Daniel Crawford, Andrew C. Simmonett; .. sectionauthor:: Roberto Di Remigio. *Module:* :ref:`Keywords <apdx:pcm>`, :ref:`PSI Variables <apdx:pcm_psivar>`, :source:`PCMSolver <psi4/src/psi4/libpsipcm/>`. .. image:: https://img.shields.io/badge/home-PCMSolver-5077AB.svg; :target: https://github.com/PCMSolver/pcmsolver. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: http://pcmsolver.readthedocs.io/en/latest/. |PSIfour| contains code to interface to the PCMSolver library developed; by R. Di Remigio and L. Frediani.; The PCMSolver library requires no additional licence, downloads, or; configuration. The library allows for calculations in solution with the; polarizable continuum model (PCM), a continuum solvation model [Tomasi:2005:2999]_. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/pcmsolver/badges/version.svg; :target: https://anaconda.org/psi4/pcmsolver. * PCMSolver is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the |PSIfour| binary, PCMSolver has already been installed alongside. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; PCMSolver can be obtained through ``conda install pcmsolver -c psi4``.; Then enable it as a feature with :makevar:`ENABLE_PCMSolver`,; hint its location with :makevar:`CMAKE_PREFIX_PATH`,; and rebuild |PSIfour| to detect PCMSolver and activate dependent code. .. * Previous bullet had details. To build |PSIfour| from source and use; .. p",MatchSource.DOCS,doc/sphinxman/source/pcmsolver.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst:2213,Availability,avail,available,2213,"T. Daniel Crawford, Andrew C. Simmonett; .. sectionauthor:: Roberto Di Remigio. *Module:* :ref:`Keywords <apdx:pcm>`, :ref:`PSI Variables <apdx:pcm_psivar>`, :source:`PCMSolver <psi4/src/psi4/libpsipcm/>`. .. image:: https://img.shields.io/badge/home-PCMSolver-5077AB.svg; :target: https://github.com/PCMSolver/pcmsolver. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: http://pcmsolver.readthedocs.io/en/latest/. |PSIfour| contains code to interface to the PCMSolver library developed; by R. Di Remigio and L. Frediani.; The PCMSolver library requires no additional licence, downloads, or; configuration. The library allows for calculations in solution with the; polarizable continuum model (PCM), a continuum solvation model [Tomasi:2005:2999]_. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/pcmsolver/badges/version.svg; :target: https://anaconda.org/psi4/pcmsolver. * PCMSolver is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the |PSIfour| binary, PCMSolver has already been installed alongside. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; PCMSolver can be obtained through ``conda install pcmsolver -c psi4``.; Then enable it as a feature with :makevar:`ENABLE_PCMSolver`,; hint its location with :makevar:`CMAKE_PREFIX_PATH`,; and rebuild |PSIfour| to detect PCMSolver and activate dependent code. .. * Previous bullet had details. To build |PSIfour| from source and use; .. pcmsolver from conda without thinking, consult. * To remove a conda installation, ``conda remove pcmsolver``. **Source**. * .. image:: https://img.shields.io/github/tag/PCMSolver/pcmsolver.svg?maxAge=2592000; :target: https://github.com/PCMSolver/pcmsolver. * If using |PSIfour| built from source and you want PCMSolver built from; from source also,; enable it as a feature with :makevar:`ENAB",MatchSource.DOCS,doc/sphinxman/source/pcmsolver.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst:4759,Availability,avail,available,4759,"based on a domain decomposition approach; [Cances:2013:054111]_ making it linear scaling.; For more details about ddx see the :ref:`section on ddx <sec:ddx>`. Using PCMsolver is achieved instead by setting |globals__pcm| ``true`` in your input file.; |Psifour| understands the additional option |pcm__pcm_scf_type| with possible values ``total``; (the default) or ``separate``.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging. For the calculation of vertical excitation energies with PCM non-equilibrium solvation should be included with: ::. pcm = {; Medium {; Nonequilibrium = True; }; }. .. note:: At present PCM can only be used for energy calculations with SCF; wavefunctions and CC wavefunctions in the PTE approximation [Cammi:2009:164104]_.; All ERI algorithms (``PK``, ``OUT_OF_CORE``, ``DIRECT``, ``DF``, ``CD``) are supported. .. note:: linear response calculations (static polarisabilities, TD-SCF) are supported for RHF/UHF if available. .. warning:: The PCMSolver library **cannot** exploit molecular point group symmetry. .. warning:: ROHF with PCM is known **not to work**. See `issue #999 on GitHub <https://github.com/psi4/psi4/issues/999>`_.; For the adventurous, a fix is available in `pull request #953 on GitHub <https://github.com/psi4/psi4/pull/953>`_. .. warning:: Analytic gradients and Hessians **are not** available with PCM. Finite differences will be used; regardless of the ``dertype`` passed to the ``optimize`` function.; See :srcsample:`pcmsolver/opt-fd` for a sample input. The PCM model and molecular cavity are specified in a ``pcm`` section that has; to be explicitly typed in by the user. This additional section follows a syntax; that is slightly different from that of |Psifour| and is fully documented; `here <http://pcmsolver.readthedocs.io/en/latest/users/input.html>`_. A typical input for a Hartree--Fock calculation with PCM would look like the fol",MatchSource.DOCS,doc/sphinxman/source/pcmsolver.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst:5011,Availability,avail,available,5011,"ype| with possible values ``total``; (the default) or ``separate``.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging. For the calculation of vertical excitation energies with PCM non-equilibrium solvation should be included with: ::. pcm = {; Medium {; Nonequilibrium = True; }; }. .. note:: At present PCM can only be used for energy calculations with SCF; wavefunctions and CC wavefunctions in the PTE approximation [Cammi:2009:164104]_.; All ERI algorithms (``PK``, ``OUT_OF_CORE``, ``DIRECT``, ``DF``, ``CD``) are supported. .. note:: linear response calculations (static polarisabilities, TD-SCF) are supported for RHF/UHF if available. .. warning:: The PCMSolver library **cannot** exploit molecular point group symmetry. .. warning:: ROHF with PCM is known **not to work**. See `issue #999 on GitHub <https://github.com/psi4/psi4/issues/999>`_.; For the adventurous, a fix is available in `pull request #953 on GitHub <https://github.com/psi4/psi4/pull/953>`_. .. warning:: Analytic gradients and Hessians **are not** available with PCM. Finite differences will be used; regardless of the ``dertype`` passed to the ``optimize`` function.; See :srcsample:`pcmsolver/opt-fd` for a sample input. The PCM model and molecular cavity are specified in a ``pcm`` section that has; to be explicitly typed in by the user. This additional section follows a syntax; that is slightly different from that of |Psifour| and is fully documented; `here <http://pcmsolver.readthedocs.io/en/latest/users/input.html>`_. A typical input for a Hartree--Fock calculation with PCM would look like the following: ::. molecule NH3 {; symmetry c1; N -0.0000000001 -0.1040380466 0.0000000000; H -0.9015844116 0.4818470201 -1.5615900098; H -0.9015844116 0.4818470201 1.5615900098; H 1.8031688251 0.4818470204 0.0000000000; units bohr; no_reorient; no_com; }. set {; basis STO-3G; scf_type pk; pcm true; pcm_scf_type tot",MatchSource.DOCS,doc/sphinxman/source/pcmsolver.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst:5153,Availability,avail,available,5153," nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging. For the calculation of vertical excitation energies with PCM non-equilibrium solvation should be included with: ::. pcm = {; Medium {; Nonequilibrium = True; }; }. .. note:: At present PCM can only be used for energy calculations with SCF; wavefunctions and CC wavefunctions in the PTE approximation [Cammi:2009:164104]_.; All ERI algorithms (``PK``, ``OUT_OF_CORE``, ``DIRECT``, ``DF``, ``CD``) are supported. .. note:: linear response calculations (static polarisabilities, TD-SCF) are supported for RHF/UHF if available. .. warning:: The PCMSolver library **cannot** exploit molecular point group symmetry. .. warning:: ROHF with PCM is known **not to work**. See `issue #999 on GitHub <https://github.com/psi4/psi4/issues/999>`_.; For the adventurous, a fix is available in `pull request #953 on GitHub <https://github.com/psi4/psi4/pull/953>`_. .. warning:: Analytic gradients and Hessians **are not** available with PCM. Finite differences will be used; regardless of the ``dertype`` passed to the ``optimize`` function.; See :srcsample:`pcmsolver/opt-fd` for a sample input. The PCM model and molecular cavity are specified in a ``pcm`` section that has; to be explicitly typed in by the user. This additional section follows a syntax; that is slightly different from that of |Psifour| and is fully documented; `here <http://pcmsolver.readthedocs.io/en/latest/users/input.html>`_. A typical input for a Hartree--Fock calculation with PCM would look like the following: ::. molecule NH3 {; symmetry c1; N -0.0000000001 -0.1040380466 0.0000000000; H -0.9015844116 0.4818470201 -1.5615900098; H -0.9015844116 0.4818470201 1.5615900098; H 1.8031688251 0.4818470204 0.0000000000; units bohr; no_reorient; no_com; }. set {; basis STO-3G; scf_type pk; pcm true; pcm_scf_type total; }. pcm = {; Units = Angstrom; Medium {; SolverType = IEFPCM; Solvent = Water; }. Cavity {; RadiiSet = UFF; ",MatchSource.DOCS,doc/sphinxman/source/pcmsolver.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst:1886,Deployability,configurat,configuration,1886," with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index:: PCMSolver, PCM, continuum solvation. .. _`sec:pcmsolver`:. Interface to PCMSolver by R. Di Remigio; =======================================. .. codeauthor:: Roberto Di Remigio, T. Daniel Crawford, Andrew C. Simmonett; .. sectionauthor:: Roberto Di Remigio. *Module:* :ref:`Keywords <apdx:pcm>`, :ref:`PSI Variables <apdx:pcm_psivar>`, :source:`PCMSolver <psi4/src/psi4/libpsipcm/>`. .. image:: https://img.shields.io/badge/home-PCMSolver-5077AB.svg; :target: https://github.com/PCMSolver/pcmsolver. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: http://pcmsolver.readthedocs.io/en/latest/. |PSIfour| contains code to interface to the PCMSolver library developed; by R. Di Remigio and L. Frediani.; The PCMSolver library requires no additional licence, downloads, or; configuration. The library allows for calculations in solution with the; polarizable continuum model (PCM), a continuum solvation model [Tomasi:2005:2999]_. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/pcmsolver/badges/version.svg; :target: https://anaconda.org/psi4/pcmsolver. * PCMSolver is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the |PSIfour| binary, PCMSolver has already been installed alongside. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; PCMSolver can be obtained through ``conda install pcmsolver -c psi4``.; Then enable it as a feature with :makevar:`ENABLE_PCMSolver`,; hint its location with :makevar:`CMAKE_PREFIX_PATH`,; and rebuild |PSIfour| to detect PCMSolver and activate dependent code. .. * Previous bullet had details. To build |PSIfour| from source and use; .. p",MatchSource.DOCS,doc/sphinxman/source/pcmsolver.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst:2363,Deployability,install,installed,2363,"f:`Keywords <apdx:pcm>`, :ref:`PSI Variables <apdx:pcm_psivar>`, :source:`PCMSolver <psi4/src/psi4/libpsipcm/>`. .. image:: https://img.shields.io/badge/home-PCMSolver-5077AB.svg; :target: https://github.com/PCMSolver/pcmsolver. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: http://pcmsolver.readthedocs.io/en/latest/. |PSIfour| contains code to interface to the PCMSolver library developed; by R. Di Remigio and L. Frediani.; The PCMSolver library requires no additional licence, downloads, or; configuration. The library allows for calculations in solution with the; polarizable continuum model (PCM), a continuum solvation model [Tomasi:2005:2999]_. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/pcmsolver/badges/version.svg; :target: https://anaconda.org/psi4/pcmsolver. * PCMSolver is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the |PSIfour| binary, PCMSolver has already been installed alongside. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; PCMSolver can be obtained through ``conda install pcmsolver -c psi4``.; Then enable it as a feature with :makevar:`ENABLE_PCMSolver`,; hint its location with :makevar:`CMAKE_PREFIX_PATH`,; and rebuild |PSIfour| to detect PCMSolver and activate dependent code. .. * Previous bullet had details. To build |PSIfour| from source and use; .. pcmsolver from conda without thinking, consult. * To remove a conda installation, ``conda remove pcmsolver``. **Source**. * .. image:: https://img.shields.io/github/tag/PCMSolver/pcmsolver.svg?maxAge=2592000; :target: https://github.com/PCMSolver/pcmsolver. * If using |PSIfour| built from source and you want PCMSolver built from; from source also,; enable it as a feature with :makevar:`ENABLE_PCMSolver`,; and let the build system fetch and build it and activate dependent code. .. i",MatchSource.DOCS,doc/sphinxman/source/pcmsolver.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst:2468,Deployability,install,installed,2468,"io/badge/home-PCMSolver-5077AB.svg; :target: https://github.com/PCMSolver/pcmsolver. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: http://pcmsolver.readthedocs.io/en/latest/. |PSIfour| contains code to interface to the PCMSolver library developed; by R. Di Remigio and L. Frediani.; The PCMSolver library requires no additional licence, downloads, or; configuration. The library allows for calculations in solution with the; polarizable continuum model (PCM), a continuum solvation model [Tomasi:2005:2999]_. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/pcmsolver/badges/version.svg; :target: https://anaconda.org/psi4/pcmsolver. * PCMSolver is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the |PSIfour| binary, PCMSolver has already been installed alongside. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; PCMSolver can be obtained through ``conda install pcmsolver -c psi4``.; Then enable it as a feature with :makevar:`ENABLE_PCMSolver`,; hint its location with :makevar:`CMAKE_PREFIX_PATH`,; and rebuild |PSIfour| to detect PCMSolver and activate dependent code. .. * Previous bullet had details. To build |PSIfour| from source and use; .. pcmsolver from conda without thinking, consult. * To remove a conda installation, ``conda remove pcmsolver``. **Source**. * .. image:: https://img.shields.io/github/tag/PCMSolver/pcmsolver.svg?maxAge=2592000; :target: https://github.com/PCMSolver/pcmsolver. * If using |PSIfour| built from source and you want PCMSolver built from; from source also,; enable it as a feature with :makevar:`ENABLE_PCMSolver`,; and let the build system fetch and build it and activate dependent code. .. index:: PCM; Using PCM. .. _`sec:usingPCM`:. Using the polarizable continuum model; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. The inclusion of a PCM",MatchSource.DOCS,doc/sphinxman/source/pcmsolver.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst:2562,Deployability,install,install,2562,"io/badge/home-PCMSolver-5077AB.svg; :target: https://github.com/PCMSolver/pcmsolver. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: http://pcmsolver.readthedocs.io/en/latest/. |PSIfour| contains code to interface to the PCMSolver library developed; by R. Di Remigio and L. Frediani.; The PCMSolver library requires no additional licence, downloads, or; configuration. The library allows for calculations in solution with the; polarizable continuum model (PCM), a continuum solvation model [Tomasi:2005:2999]_. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/pcmsolver/badges/version.svg; :target: https://anaconda.org/psi4/pcmsolver. * PCMSolver is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the |PSIfour| binary, PCMSolver has already been installed alongside. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; PCMSolver can be obtained through ``conda install pcmsolver -c psi4``.; Then enable it as a feature with :makevar:`ENABLE_PCMSolver`,; hint its location with :makevar:`CMAKE_PREFIX_PATH`,; and rebuild |PSIfour| to detect PCMSolver and activate dependent code. .. * Previous bullet had details. To build |PSIfour| from source and use; .. pcmsolver from conda without thinking, consult. * To remove a conda installation, ``conda remove pcmsolver``. **Source**. * .. image:: https://img.shields.io/github/tag/PCMSolver/pcmsolver.svg?maxAge=2592000; :target: https://github.com/PCMSolver/pcmsolver. * If using |PSIfour| built from source and you want PCMSolver built from; from source also,; enable it as a feature with :makevar:`ENABLE_PCMSolver`,; and let the build system fetch and build it and activate dependent code. .. index:: PCM; Using PCM. .. _`sec:usingPCM`:. Using the polarizable continuum model; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. The inclusion of a PCM",MatchSource.DOCS,doc/sphinxman/source/pcmsolver.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst:2925,Deployability,install,installation,2925,"s in solution with the; polarizable continuum model (PCM), a continuum solvation model [Tomasi:2005:2999]_. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/pcmsolver/badges/version.svg; :target: https://anaconda.org/psi4/pcmsolver. * PCMSolver is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the |PSIfour| binary, PCMSolver has already been installed alongside. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; PCMSolver can be obtained through ``conda install pcmsolver -c psi4``.; Then enable it as a feature with :makevar:`ENABLE_PCMSolver`,; hint its location with :makevar:`CMAKE_PREFIX_PATH`,; and rebuild |PSIfour| to detect PCMSolver and activate dependent code. .. * Previous bullet had details. To build |PSIfour| from source and use; .. pcmsolver from conda without thinking, consult. * To remove a conda installation, ``conda remove pcmsolver``. **Source**. * .. image:: https://img.shields.io/github/tag/PCMSolver/pcmsolver.svg?maxAge=2592000; :target: https://github.com/PCMSolver/pcmsolver. * If using |PSIfour| built from source and you want PCMSolver built from; from source also,; enable it as a feature with :makevar:`ENABLE_PCMSolver`,; and let the build system fetch and build it and activate dependent code. .. index:: PCM; Using PCM. .. _`sec:usingPCM`:. Using the polarizable continuum model; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. The inclusion of a PCM description of the solvent into your calculation; can be achieved in two ways in |PSIfour|, using either the PCMSolver or ddx package.; PCMSolver is based on a boundary-element discretisation [Cances:1998:309]_,; while ddx is based on a domain decomposition approach; [Cances:2013:054111]_ making it linear scaling.; For more details about ddx see the :ref:`section on ddx <sec:ddx>`. Using PCMsolver is achieved instead by setting |globals__pcm| ",MatchSource.DOCS,doc/sphinxman/source/pcmsolver.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst:7291,Deployability,install,installation,7291,"pk; pcm true; pcm_scf_type total; }. pcm = {; Units = Angstrom; Medium {; SolverType = IEFPCM; Solvent = Water; }. Cavity {; RadiiSet = UFF; Type = GePol; Scaling = False; Area = 0.3; Mode = Implicit; }; }. More examples can be found in the directories with PCM tests; :srcsample:`pcmsolver/ccsd-pte`,; :srcsample:`pcmsolver/scf`,; :srcsample:`pcmsolver/opt-fd`,; :srcsample:`pcmsolver/dft`, and; :srcsample:`pcmsolver/dipole`. Keywords for PCMSolver; ~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/globals__pcm.rst; .. include:: autodir_options_c/pcm__pcm_scf_type.rst; .. include:: autodir_options_c/pcm__pcm_cc_type.rst. .. _`cmake:pcmsolver`:. How to configure PCMSolver for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling). * Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) PCMSolver. * Upstream Dependencies |w---w| PCMSolver |dr| Fortran, zlib. **CMake Variables**. * :makevar:`ENABLE_PCMSolver` |w---w| CMake variable toggling whether Psi4 builds with PCMSolver; * :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing ``include/PCMSolver/pcmsolver.h``; * :makevar:`PCMSolver_DIR` |w---w| CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing ``share/cmake/PCMSolver/PCMSolverConfig.cmake``; * :makevar:`CMAKE_DISABLE_FIND_PACKAGE_PCMSolver` |w---w| CMake variable to force internal build of PCMSolver instead of detecting pre-built; * :makevar:`CMAKE_INSIST_FIND_PACKAGE_PCMSolver` |w---w| CMake variable to force detecting pre-built PCMSolver and not falling back on internal build. **Examples**. A. Build bundled. .. code-block:: bash. >>> cmake -DENABLE_PCMSolver=ON. B. Build *without* PCMSolver. .. code-block:: bash. >>> cmake. ",MatchSource.DOCS,doc/sphinxman/source/pcmsolver.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst:7468,Deployability,install,installation,7468,"pk; pcm true; pcm_scf_type total; }. pcm = {; Units = Angstrom; Medium {; SolverType = IEFPCM; Solvent = Water; }. Cavity {; RadiiSet = UFF; Type = GePol; Scaling = False; Area = 0.3; Mode = Implicit; }; }. More examples can be found in the directories with PCM tests; :srcsample:`pcmsolver/ccsd-pte`,; :srcsample:`pcmsolver/scf`,; :srcsample:`pcmsolver/opt-fd`,; :srcsample:`pcmsolver/dft`, and; :srcsample:`pcmsolver/dipole`. Keywords for PCMSolver; ~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/globals__pcm.rst; .. include:: autodir_options_c/pcm__pcm_scf_type.rst; .. include:: autodir_options_c/pcm__pcm_cc_type.rst. .. _`cmake:pcmsolver`:. How to configure PCMSolver for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling). * Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) PCMSolver. * Upstream Dependencies |w---w| PCMSolver |dr| Fortran, zlib. **CMake Variables**. * :makevar:`ENABLE_PCMSolver` |w---w| CMake variable toggling whether Psi4 builds with PCMSolver; * :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing ``include/PCMSolver/pcmsolver.h``; * :makevar:`PCMSolver_DIR` |w---w| CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing ``share/cmake/PCMSolver/PCMSolverConfig.cmake``; * :makevar:`CMAKE_DISABLE_FIND_PACKAGE_PCMSolver` |w---w| CMake variable to force internal build of PCMSolver instead of detecting pre-built; * :makevar:`CMAKE_INSIST_FIND_PACKAGE_PCMSolver` |w---w| CMake variable to force detecting pre-built PCMSolver and not falling back on internal build. **Examples**. A. Build bundled. .. code-block:: bash. >>> cmake -DENABLE_PCMSolver=ON. B. Build *without* PCMSolver. .. code-block:: bash. >>> cmake. ",MatchSource.DOCS,doc/sphinxman/source/pcmsolver.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst:4202,Energy Efficiency,charge,charges,4202,"rce and you want PCMSolver built from; from source also,; enable it as a feature with :makevar:`ENABLE_PCMSolver`,; and let the build system fetch and build it and activate dependent code. .. index:: PCM; Using PCM. .. _`sec:usingPCM`:. Using the polarizable continuum model; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. The inclusion of a PCM description of the solvent into your calculation; can be achieved in two ways in |PSIfour|, using either the PCMSolver or ddx package.; PCMSolver is based on a boundary-element discretisation [Cances:1998:309]_,; while ddx is based on a domain decomposition approach; [Cances:2013:054111]_ making it linear scaling.; For more details about ddx see the :ref:`section on ddx <sec:ddx>`. Using PCMsolver is achieved instead by setting |globals__pcm| ``true`` in your input file.; |Psifour| understands the additional option |pcm__pcm_scf_type| with possible values ``total``; (the default) or ``separate``.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging. For the calculation of vertical excitation energies with PCM non-equilibrium solvation should be included with: ::. pcm = {; Medium {; Nonequilibrium = True; }; }. .. note:: At present PCM can only be used for energy calculations with SCF; wavefunctions and CC wavefunctions in the PTE approximation [Cammi:2009:164104]_.; All ERI algorithms (``PK``, ``OUT_OF_CORE``, ``DIRECT``, ``DF``, ``CD``) are supported. .. note:: linear response calculations (static polarisabilities, TD-SCF) are supported for RHF/UHF if available. .. warning:: The PCMSolver library **cannot** exploit molecular point group symmetry. .. warning:: ROHF with PCM is known **not to work**. See `issue #999 on GitHub <https://github.com/psi4/psi4/issues/999>`_.; For the adventurous, a fix is available in `pull request #953 on GitHub <https://github.com/psi4/psi4/pull/953>`_. .. warning:: Analytic gradients and Hessians **are not*",MatchSource.DOCS,doc/sphinxman/source/pcmsolver.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst:4456,Energy Efficiency,energy,energy,4456,"escription of the solvent into your calculation; can be achieved in two ways in |PSIfour|, using either the PCMSolver or ddx package.; PCMSolver is based on a boundary-element discretisation [Cances:1998:309]_,; while ddx is based on a domain decomposition approach; [Cances:2013:054111]_ making it linear scaling.; For more details about ddx see the :ref:`section on ddx <sec:ddx>`. Using PCMsolver is achieved instead by setting |globals__pcm| ``true`` in your input file.; |Psifour| understands the additional option |pcm__pcm_scf_type| with possible values ``total``; (the default) or ``separate``.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging. For the calculation of vertical excitation energies with PCM non-equilibrium solvation should be included with: ::. pcm = {; Medium {; Nonequilibrium = True; }; }. .. note:: At present PCM can only be used for energy calculations with SCF; wavefunctions and CC wavefunctions in the PTE approximation [Cammi:2009:164104]_.; All ERI algorithms (``PK``, ``OUT_OF_CORE``, ``DIRECT``, ``DF``, ``CD``) are supported. .. note:: linear response calculations (static polarisabilities, TD-SCF) are supported for RHF/UHF if available. .. warning:: The PCMSolver library **cannot** exploit molecular point group symmetry. .. warning:: ROHF with PCM is known **not to work**. See `issue #999 on GitHub <https://github.com/psi4/psi4/issues/999>`_.; For the adventurous, a fix is available in `pull request #953 on GitHub <https://github.com/psi4/psi4/pull/953>`_. .. warning:: Analytic gradients and Hessians **are not** available with PCM. Finite differences will be used; regardless of the ``dertype`` passed to the ``optimize`` function.; See :srcsample:`pcmsolver/opt-fd` for a sample input. The PCM model and molecular cavity are specified in a ``pcm`` section that has; to be explicitly typed in by the user. This additional section follows a syntax; t",MatchSource.DOCS,doc/sphinxman/source/pcmsolver.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst:1736,Integrability,interface,interface,1736,"more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index:: PCMSolver, PCM, continuum solvation. .. _`sec:pcmsolver`:. Interface to PCMSolver by R. Di Remigio; =======================================. .. codeauthor:: Roberto Di Remigio, T. Daniel Crawford, Andrew C. Simmonett; .. sectionauthor:: Roberto Di Remigio. *Module:* :ref:`Keywords <apdx:pcm>`, :ref:`PSI Variables <apdx:pcm_psivar>`, :source:`PCMSolver <psi4/src/psi4/libpsipcm/>`. .. image:: https://img.shields.io/badge/home-PCMSolver-5077AB.svg; :target: https://github.com/PCMSolver/pcmsolver. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: http://pcmsolver.readthedocs.io/en/latest/. |PSIfour| contains code to interface to the PCMSolver library developed; by R. Di Remigio and L. Frediani.; The PCMSolver library requires no additional licence, downloads, or; configuration. The library allows for calculations in solution with the; polarizable continuum model (PCM), a continuum solvation model [Tomasi:2005:2999]_. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/pcmsolver/badges/version.svg; :target: https://anaconda.org/psi4/pcmsolver. * PCMSolver is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the |PSIfour| binary, PCMSolver has already been installed alongside. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; PCMSolver can be obtained through ``conda install pcmsolver -c psi4``.; Then enable it as a feature with :makevar:`ENABLE_PCMSolver`,; hint its location with :makevar:`CMAKE_PREFIX_PATH`,; and rebuild |PSIfour| to detect PCMSolv",MatchSource.DOCS,doc/sphinxman/source/pcmsolver.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst:2764,Integrability,depend,dependent,2764,"adthedocs.io/en/latest/. |PSIfour| contains code to interface to the PCMSolver library developed; by R. Di Remigio and L. Frediani.; The PCMSolver library requires no additional licence, downloads, or; configuration. The library allows for calculations in solution with the; polarizable continuum model (PCM), a continuum solvation model [Tomasi:2005:2999]_. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/pcmsolver/badges/version.svg; :target: https://anaconda.org/psi4/pcmsolver. * PCMSolver is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the |PSIfour| binary, PCMSolver has already been installed alongside. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; PCMSolver can be obtained through ``conda install pcmsolver -c psi4``.; Then enable it as a feature with :makevar:`ENABLE_PCMSolver`,; hint its location with :makevar:`CMAKE_PREFIX_PATH`,; and rebuild |PSIfour| to detect PCMSolver and activate dependent code. .. * Previous bullet had details. To build |PSIfour| from source and use; .. pcmsolver from conda without thinking, consult. * To remove a conda installation, ``conda remove pcmsolver``. **Source**. * .. image:: https://img.shields.io/github/tag/PCMSolver/pcmsolver.svg?maxAge=2592000; :target: https://github.com/PCMSolver/pcmsolver. * If using |PSIfour| built from source and you want PCMSolver built from; from source also,; enable it as a feature with :makevar:`ENABLE_PCMSolver`,; and let the build system fetch and build it and activate dependent code. .. index:: PCM; Using PCM. .. _`sec:usingPCM`:. Using the polarizable continuum model; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. The inclusion of a PCM description of the solvent into your calculation; can be achieved in two ways in |PSIfour|, using either the PCMSolver or ddx package.; PCMSolver is based on a boundary-element discretisation [Canc",MatchSource.DOCS,doc/sphinxman/source/pcmsolver.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst:3323,Integrability,depend,dependent,3323,"a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the |PSIfour| binary, PCMSolver has already been installed alongside. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; PCMSolver can be obtained through ``conda install pcmsolver -c psi4``.; Then enable it as a feature with :makevar:`ENABLE_PCMSolver`,; hint its location with :makevar:`CMAKE_PREFIX_PATH`,; and rebuild |PSIfour| to detect PCMSolver and activate dependent code. .. * Previous bullet had details. To build |PSIfour| from source and use; .. pcmsolver from conda without thinking, consult. * To remove a conda installation, ``conda remove pcmsolver``. **Source**. * .. image:: https://img.shields.io/github/tag/PCMSolver/pcmsolver.svg?maxAge=2592000; :target: https://github.com/PCMSolver/pcmsolver. * If using |PSIfour| built from source and you want PCMSolver built from; from source also,; enable it as a feature with :makevar:`ENABLE_PCMSolver`,; and let the build system fetch and build it and activate dependent code. .. index:: PCM; Using PCM. .. _`sec:usingPCM`:. Using the polarizable continuum model; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. The inclusion of a PCM description of the solvent into your calculation; can be achieved in two ways in |PSIfour|, using either the PCMSolver or ddx package.; PCMSolver is based on a boundary-element discretisation [Cances:1998:309]_,; while ddx is based on a domain decomposition approach; [Cances:2013:054111]_ making it linear scaling.; For more details about ddx see the :ref:`section on ddx <sec:ddx>`. Using PCMsolver is achieved instead by setting |globals__pcm| ``true`` in your input file.; |Psifour| understands the additional option |pcm__pcm_scf_type| with possible values ``total``; (the default) or ``separate``.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly us",MatchSource.DOCS,doc/sphinxman/source/pcmsolver.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst:7239,Integrability,depend,dependencies,7239,"pk; pcm true; pcm_scf_type total; }. pcm = {; Units = Angstrom; Medium {; SolverType = IEFPCM; Solvent = Water; }. Cavity {; RadiiSet = UFF; Type = GePol; Scaling = False; Area = 0.3; Mode = Implicit; }; }. More examples can be found in the directories with PCM tests; :srcsample:`pcmsolver/ccsd-pte`,; :srcsample:`pcmsolver/scf`,; :srcsample:`pcmsolver/opt-fd`,; :srcsample:`pcmsolver/dft`, and; :srcsample:`pcmsolver/dipole`. Keywords for PCMSolver; ~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/globals__pcm.rst; .. include:: autodir_options_c/pcm__pcm_scf_type.rst; .. include:: autodir_options_c/pcm__pcm_cc_type.rst. .. _`cmake:pcmsolver`:. How to configure PCMSolver for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling). * Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) PCMSolver. * Upstream Dependencies |w---w| PCMSolver |dr| Fortran, zlib. **CMake Variables**. * :makevar:`ENABLE_PCMSolver` |w---w| CMake variable toggling whether Psi4 builds with PCMSolver; * :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing ``include/PCMSolver/pcmsolver.h``; * :makevar:`PCMSolver_DIR` |w---w| CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing ``share/cmake/PCMSolver/PCMSolverConfig.cmake``; * :makevar:`CMAKE_DISABLE_FIND_PACKAGE_PCMSolver` |w---w| CMake variable to force internal build of PCMSolver instead of detecting pre-built; * :makevar:`CMAKE_INSIST_FIND_PACKAGE_PCMSolver` |w---w| CMake variable to force detecting pre-built PCMSolver and not falling back on internal build. **Examples**. A. Build bundled. .. code-block:: bash. >>> cmake -DENABLE_PCMSolver=ON. B. Build *without* PCMSolver. .. code-block:: bash. >>> cmake. ",MatchSource.DOCS,doc/sphinxman/source/pcmsolver.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst:1886,Modifiability,config,configuration,1886," with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index:: PCMSolver, PCM, continuum solvation. .. _`sec:pcmsolver`:. Interface to PCMSolver by R. Di Remigio; =======================================. .. codeauthor:: Roberto Di Remigio, T. Daniel Crawford, Andrew C. Simmonett; .. sectionauthor:: Roberto Di Remigio. *Module:* :ref:`Keywords <apdx:pcm>`, :ref:`PSI Variables <apdx:pcm_psivar>`, :source:`PCMSolver <psi4/src/psi4/libpsipcm/>`. .. image:: https://img.shields.io/badge/home-PCMSolver-5077AB.svg; :target: https://github.com/PCMSolver/pcmsolver. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: http://pcmsolver.readthedocs.io/en/latest/. |PSIfour| contains code to interface to the PCMSolver library developed; by R. Di Remigio and L. Frediani.; The PCMSolver library requires no additional licence, downloads, or; configuration. The library allows for calculations in solution with the; polarizable continuum model (PCM), a continuum solvation model [Tomasi:2005:2999]_. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/pcmsolver/badges/version.svg; :target: https://anaconda.org/psi4/pcmsolver. * PCMSolver is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the |PSIfour| binary, PCMSolver has already been installed alongside. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; PCMSolver can be obtained through ``conda install pcmsolver -c psi4``.; Then enable it as a feature with :makevar:`ENABLE_PCMSolver`,; hint its location with :makevar:`CMAKE_PREFIX_PATH`,; and rebuild |PSIfour| to detect PCMSolver and activate dependent code. .. * Previous bullet had details. To build |PSIfour| from source and use; .. p",MatchSource.DOCS,doc/sphinxman/source/pcmsolver.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst:6657,Modifiability,config,configure,6657,"d look like the following: ::. molecule NH3 {; symmetry c1; N -0.0000000001 -0.1040380466 0.0000000000; H -0.9015844116 0.4818470201 -1.5615900098; H -0.9015844116 0.4818470201 1.5615900098; H 1.8031688251 0.4818470204 0.0000000000; units bohr; no_reorient; no_com; }. set {; basis STO-3G; scf_type pk; pcm true; pcm_scf_type total; }. pcm = {; Units = Angstrom; Medium {; SolverType = IEFPCM; Solvent = Water; }. Cavity {; RadiiSet = UFF; Type = GePol; Scaling = False; Area = 0.3; Mode = Implicit; }; }. More examples can be found in the directories with PCM tests; :srcsample:`pcmsolver/ccsd-pte`,; :srcsample:`pcmsolver/scf`,; :srcsample:`pcmsolver/opt-fd`,; :srcsample:`pcmsolver/dft`, and; :srcsample:`pcmsolver/dipole`. Keywords for PCMSolver; ~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/globals__pcm.rst; .. include:: autodir_options_c/pcm__pcm_scf_type.rst; .. include:: autodir_options_c/pcm__pcm_cc_type.rst. .. _`cmake:pcmsolver`:. How to configure PCMSolver for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling). * Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) PCMSolver. * Upstream Dependencies |w---w| PCMSolver |dr| Fortran, zlib. **CMake Variables**. * :makevar:`ENABLE_PCMSolver` |w---w| CMake variable toggling whether Psi4 builds with PCMSolver; * :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing ``include/PCMSolver/pcmsolver.h``; * :makevar:`PCMSolver_DIR` |w---w| CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing ``share/cmake/PCMSolver/PCMSolverConfig.cmake``; * :makevar:`CMAKE_DISABLE_FIND_PACKAGE_PCMSolver` |w---w| CMake variable to force internal build of PCMSolver instead of detecting pre-built; * ",MatchSource.DOCS,doc/sphinxman/source/pcmsolver.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst:7099,Modifiability,variab,variable,7099,"pk; pcm true; pcm_scf_type total; }. pcm = {; Units = Angstrom; Medium {; SolverType = IEFPCM; Solvent = Water; }. Cavity {; RadiiSet = UFF; Type = GePol; Scaling = False; Area = 0.3; Mode = Implicit; }; }. More examples can be found in the directories with PCM tests; :srcsample:`pcmsolver/ccsd-pte`,; :srcsample:`pcmsolver/scf`,; :srcsample:`pcmsolver/opt-fd`,; :srcsample:`pcmsolver/dft`, and; :srcsample:`pcmsolver/dipole`. Keywords for PCMSolver; ~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/globals__pcm.rst; .. include:: autodir_options_c/pcm__pcm_scf_type.rst; .. include:: autodir_options_c/pcm__pcm_cc_type.rst. .. _`cmake:pcmsolver`:. How to configure PCMSolver for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling). * Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) PCMSolver. * Upstream Dependencies |w---w| PCMSolver |dr| Fortran, zlib. **CMake Variables**. * :makevar:`ENABLE_PCMSolver` |w---w| CMake variable toggling whether Psi4 builds with PCMSolver; * :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing ``include/PCMSolver/pcmsolver.h``; * :makevar:`PCMSolver_DIR` |w---w| CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing ``share/cmake/PCMSolver/PCMSolverConfig.cmake``; * :makevar:`CMAKE_DISABLE_FIND_PACKAGE_PCMSolver` |w---w| CMake variable to force internal build of PCMSolver instead of detecting pre-built; * :makevar:`CMAKE_INSIST_FIND_PACKAGE_PCMSolver` |w---w| CMake variable to force detecting pre-built PCMSolver and not falling back on internal build. **Examples**. A. Build bundled. .. code-block:: bash. >>> cmake -DENABLE_PCMSolver=ON. B. Build *without* PCMSolver. .. code-block:: bash. >>> cmake. ",MatchSource.DOCS,doc/sphinxman/source/pcmsolver.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst:7203,Modifiability,variab,variable,7203,"pk; pcm true; pcm_scf_type total; }. pcm = {; Units = Angstrom; Medium {; SolverType = IEFPCM; Solvent = Water; }. Cavity {; RadiiSet = UFF; Type = GePol; Scaling = False; Area = 0.3; Mode = Implicit; }; }. More examples can be found in the directories with PCM tests; :srcsample:`pcmsolver/ccsd-pte`,; :srcsample:`pcmsolver/scf`,; :srcsample:`pcmsolver/opt-fd`,; :srcsample:`pcmsolver/dft`, and; :srcsample:`pcmsolver/dipole`. Keywords for PCMSolver; ~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/globals__pcm.rst; .. include:: autodir_options_c/pcm__pcm_scf_type.rst; .. include:: autodir_options_c/pcm__pcm_cc_type.rst. .. _`cmake:pcmsolver`:. How to configure PCMSolver for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling). * Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) PCMSolver. * Upstream Dependencies |w---w| PCMSolver |dr| Fortran, zlib. **CMake Variables**. * :makevar:`ENABLE_PCMSolver` |w---w| CMake variable toggling whether Psi4 builds with PCMSolver; * :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing ``include/PCMSolver/pcmsolver.h``; * :makevar:`PCMSolver_DIR` |w---w| CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing ``share/cmake/PCMSolver/PCMSolverConfig.cmake``; * :makevar:`CMAKE_DISABLE_FIND_PACKAGE_PCMSolver` |w---w| CMake variable to force internal build of PCMSolver instead of detecting pre-built; * :makevar:`CMAKE_INSIST_FIND_PACKAGE_PCMSolver` |w---w| CMake variable to force detecting pre-built PCMSolver and not falling back on internal build. **Examples**. A. Build bundled. .. code-block:: bash. >>> cmake -DENABLE_PCMSolver=ON. B. Build *without* PCMSolver. .. code-block:: bash. >>> cmake. ",MatchSource.DOCS,doc/sphinxman/source/pcmsolver.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst:7401,Modifiability,variab,variable,7401,"pk; pcm true; pcm_scf_type total; }. pcm = {; Units = Angstrom; Medium {; SolverType = IEFPCM; Solvent = Water; }. Cavity {; RadiiSet = UFF; Type = GePol; Scaling = False; Area = 0.3; Mode = Implicit; }; }. More examples can be found in the directories with PCM tests; :srcsample:`pcmsolver/ccsd-pte`,; :srcsample:`pcmsolver/scf`,; :srcsample:`pcmsolver/opt-fd`,; :srcsample:`pcmsolver/dft`, and; :srcsample:`pcmsolver/dipole`. Keywords for PCMSolver; ~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/globals__pcm.rst; .. include:: autodir_options_c/pcm__pcm_scf_type.rst; .. include:: autodir_options_c/pcm__pcm_cc_type.rst. .. _`cmake:pcmsolver`:. How to configure PCMSolver for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling). * Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) PCMSolver. * Upstream Dependencies |w---w| PCMSolver |dr| Fortran, zlib. **CMake Variables**. * :makevar:`ENABLE_PCMSolver` |w---w| CMake variable toggling whether Psi4 builds with PCMSolver; * :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing ``include/PCMSolver/pcmsolver.h``; * :makevar:`PCMSolver_DIR` |w---w| CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing ``share/cmake/PCMSolver/PCMSolverConfig.cmake``; * :makevar:`CMAKE_DISABLE_FIND_PACKAGE_PCMSolver` |w---w| CMake variable to force internal build of PCMSolver instead of detecting pre-built; * :makevar:`CMAKE_INSIST_FIND_PACKAGE_PCMSolver` |w---w| CMake variable to force detecting pre-built PCMSolver and not falling back on internal build. **Examples**. A. Build bundled. .. code-block:: bash. >>> cmake -DENABLE_PCMSolver=ON. B. Build *without* PCMSolver. .. code-block:: bash. >>> cmake. ",MatchSource.DOCS,doc/sphinxman/source/pcmsolver.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst:7615,Modifiability,variab,variable,7615,"pk; pcm true; pcm_scf_type total; }. pcm = {; Units = Angstrom; Medium {; SolverType = IEFPCM; Solvent = Water; }. Cavity {; RadiiSet = UFF; Type = GePol; Scaling = False; Area = 0.3; Mode = Implicit; }; }. More examples can be found in the directories with PCM tests; :srcsample:`pcmsolver/ccsd-pte`,; :srcsample:`pcmsolver/scf`,; :srcsample:`pcmsolver/opt-fd`,; :srcsample:`pcmsolver/dft`, and; :srcsample:`pcmsolver/dipole`. Keywords for PCMSolver; ~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/globals__pcm.rst; .. include:: autodir_options_c/pcm__pcm_scf_type.rst; .. include:: autodir_options_c/pcm__pcm_cc_type.rst. .. _`cmake:pcmsolver`:. How to configure PCMSolver for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling). * Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) PCMSolver. * Upstream Dependencies |w---w| PCMSolver |dr| Fortran, zlib. **CMake Variables**. * :makevar:`ENABLE_PCMSolver` |w---w| CMake variable toggling whether Psi4 builds with PCMSolver; * :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing ``include/PCMSolver/pcmsolver.h``; * :makevar:`PCMSolver_DIR` |w---w| CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing ``share/cmake/PCMSolver/PCMSolverConfig.cmake``; * :makevar:`CMAKE_DISABLE_FIND_PACKAGE_PCMSolver` |w---w| CMake variable to force internal build of PCMSolver instead of detecting pre-built; * :makevar:`CMAKE_INSIST_FIND_PACKAGE_PCMSolver` |w---w| CMake variable to force detecting pre-built PCMSolver and not falling back on internal build. **Examples**. A. Build bundled. .. code-block:: bash. >>> cmake -DENABLE_PCMSolver=ON. B. Build *without* PCMSolver. .. code-block:: bash. >>> cmake. ",MatchSource.DOCS,doc/sphinxman/source/pcmsolver.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst:7756,Modifiability,variab,variable,7756,"pk; pcm true; pcm_scf_type total; }. pcm = {; Units = Angstrom; Medium {; SolverType = IEFPCM; Solvent = Water; }. Cavity {; RadiiSet = UFF; Type = GePol; Scaling = False; Area = 0.3; Mode = Implicit; }; }. More examples can be found in the directories with PCM tests; :srcsample:`pcmsolver/ccsd-pte`,; :srcsample:`pcmsolver/scf`,; :srcsample:`pcmsolver/opt-fd`,; :srcsample:`pcmsolver/dft`, and; :srcsample:`pcmsolver/dipole`. Keywords for PCMSolver; ~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/globals__pcm.rst; .. include:: autodir_options_c/pcm__pcm_scf_type.rst; .. include:: autodir_options_c/pcm__pcm_cc_type.rst. .. _`cmake:pcmsolver`:. How to configure PCMSolver for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling). * Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) PCMSolver. * Upstream Dependencies |w---w| PCMSolver |dr| Fortran, zlib. **CMake Variables**. * :makevar:`ENABLE_PCMSolver` |w---w| CMake variable toggling whether Psi4 builds with PCMSolver; * :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing ``include/PCMSolver/pcmsolver.h``; * :makevar:`PCMSolver_DIR` |w---w| CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing ``share/cmake/PCMSolver/PCMSolverConfig.cmake``; * :makevar:`CMAKE_DISABLE_FIND_PACKAGE_PCMSolver` |w---w| CMake variable to force internal build of PCMSolver instead of detecting pre-built; * :makevar:`CMAKE_INSIST_FIND_PACKAGE_PCMSolver` |w---w| CMake variable to force detecting pre-built PCMSolver and not falling back on internal build. **Examples**. A. Build bundled. .. code-block:: bash. >>> cmake -DENABLE_PCMSolver=ON. B. Build *without* PCMSolver. .. code-block:: bash. >>> cmake. ",MatchSource.DOCS,doc/sphinxman/source/pcmsolver.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst:5252,Performance,optimiz,optimize,5252,"y useful for debugging. For the calculation of vertical excitation energies with PCM non-equilibrium solvation should be included with: ::. pcm = {; Medium {; Nonequilibrium = True; }; }. .. note:: At present PCM can only be used for energy calculations with SCF; wavefunctions and CC wavefunctions in the PTE approximation [Cammi:2009:164104]_.; All ERI algorithms (``PK``, ``OUT_OF_CORE``, ``DIRECT``, ``DF``, ``CD``) are supported. .. note:: linear response calculations (static polarisabilities, TD-SCF) are supported for RHF/UHF if available. .. warning:: The PCMSolver library **cannot** exploit molecular point group symmetry. .. warning:: ROHF with PCM is known **not to work**. See `issue #999 on GitHub <https://github.com/psi4/psi4/issues/999>`_.; For the adventurous, a fix is available in `pull request #953 on GitHub <https://github.com/psi4/psi4/pull/953>`_. .. warning:: Analytic gradients and Hessians **are not** available with PCM. Finite differences will be used; regardless of the ``dertype`` passed to the ``optimize`` function.; See :srcsample:`pcmsolver/opt-fd` for a sample input. The PCM model and molecular cavity are specified in a ``pcm`` section that has; to be explicitly typed in by the user. This additional section follows a syntax; that is slightly different from that of |Psifour| and is fully documented; `here <http://pcmsolver.readthedocs.io/en/latest/users/input.html>`_. A typical input for a Hartree--Fock calculation with PCM would look like the following: ::. molecule NH3 {; symmetry c1; N -0.0000000001 -0.1040380466 0.0000000000; H -0.9015844116 0.4818470201 -1.5615900098; H -0.9015844116 0.4818470201 1.5615900098; H 1.8031688251 0.4818470204 0.0000000000; units bohr; no_reorient; no_com; }. set {; basis STO-3G; scf_type pk; pcm true; pcm_scf_type total; }. pcm = {; Units = Angstrom; Medium {; SolverType = IEFPCM; Solvent = Water; }. Cavity {; RadiiSet = UFF; Type = GePol; Scaling = False; Area = 0.3; Mode = Implicit; }; }. More examples can be ",MatchSource.DOCS,doc/sphinxman/source/pcmsolver.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst:2734,Safety,detect,detect,2734,"adthedocs.io/en/latest/. |PSIfour| contains code to interface to the PCMSolver library developed; by R. Di Remigio and L. Frediani.; The PCMSolver library requires no additional licence, downloads, or; configuration. The library allows for calculations in solution with the; polarizable continuum model (PCM), a continuum solvation model [Tomasi:2005:2999]_. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/pcmsolver/badges/version.svg; :target: https://anaconda.org/psi4/pcmsolver. * PCMSolver is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the |PSIfour| binary, PCMSolver has already been installed alongside. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; PCMSolver can be obtained through ``conda install pcmsolver -c psi4``.; Then enable it as a feature with :makevar:`ENABLE_PCMSolver`,; hint its location with :makevar:`CMAKE_PREFIX_PATH`,; and rebuild |PSIfour| to detect PCMSolver and activate dependent code. .. * Previous bullet had details. To build |PSIfour| from source and use; .. pcmsolver from conda without thinking, consult. * To remove a conda installation, ``conda remove pcmsolver``. **Source**. * .. image:: https://img.shields.io/github/tag/PCMSolver/pcmsolver.svg?maxAge=2592000; :target: https://github.com/PCMSolver/pcmsolver. * If using |PSIfour| built from source and you want PCMSolver built from; from source also,; enable it as a feature with :makevar:`ENABLE_PCMSolver`,; and let the build system fetch and build it and activate dependent code. .. index:: PCM; Using PCM. .. _`sec:usingPCM`:. Using the polarizable continuum model; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. The inclusion of a PCM description of the solvent into your calculation; can be achieved in two ways in |PSIfour|, using either the PCMSolver or ddx package.; PCMSolver is based on a boundary-element discretisation [Canc",MatchSource.DOCS,doc/sphinxman/source/pcmsolver.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst:7672,Safety,detect,detecting,7672,"pk; pcm true; pcm_scf_type total; }. pcm = {; Units = Angstrom; Medium {; SolverType = IEFPCM; Solvent = Water; }. Cavity {; RadiiSet = UFF; Type = GePol; Scaling = False; Area = 0.3; Mode = Implicit; }; }. More examples can be found in the directories with PCM tests; :srcsample:`pcmsolver/ccsd-pte`,; :srcsample:`pcmsolver/scf`,; :srcsample:`pcmsolver/opt-fd`,; :srcsample:`pcmsolver/dft`, and; :srcsample:`pcmsolver/dipole`. Keywords for PCMSolver; ~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/globals__pcm.rst; .. include:: autodir_options_c/pcm__pcm_scf_type.rst; .. include:: autodir_options_c/pcm__pcm_cc_type.rst. .. _`cmake:pcmsolver`:. How to configure PCMSolver for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling). * Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) PCMSolver. * Upstream Dependencies |w---w| PCMSolver |dr| Fortran, zlib. **CMake Variables**. * :makevar:`ENABLE_PCMSolver` |w---w| CMake variable toggling whether Psi4 builds with PCMSolver; * :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing ``include/PCMSolver/pcmsolver.h``; * :makevar:`PCMSolver_DIR` |w---w| CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing ``share/cmake/PCMSolver/PCMSolverConfig.cmake``; * :makevar:`CMAKE_DISABLE_FIND_PACKAGE_PCMSolver` |w---w| CMake variable to force internal build of PCMSolver instead of detecting pre-built; * :makevar:`CMAKE_INSIST_FIND_PACKAGE_PCMSolver` |w---w| CMake variable to force detecting pre-built PCMSolver and not falling back on internal build. **Examples**. A. Build bundled. .. code-block:: bash. >>> cmake -DENABLE_PCMSolver=ON. B. Build *without* PCMSolver. .. code-block:: bash. >>> cmake. ",MatchSource.DOCS,doc/sphinxman/source/pcmsolver.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst:7774,Safety,detect,detecting,7774,"pk; pcm true; pcm_scf_type total; }. pcm = {; Units = Angstrom; Medium {; SolverType = IEFPCM; Solvent = Water; }. Cavity {; RadiiSet = UFF; Type = GePol; Scaling = False; Area = 0.3; Mode = Implicit; }; }. More examples can be found in the directories with PCM tests; :srcsample:`pcmsolver/ccsd-pte`,; :srcsample:`pcmsolver/scf`,; :srcsample:`pcmsolver/opt-fd`,; :srcsample:`pcmsolver/dft`, and; :srcsample:`pcmsolver/dipole`. Keywords for PCMSolver; ~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/globals__pcm.rst; .. include:: autodir_options_c/pcm__pcm_scf_type.rst; .. include:: autodir_options_c/pcm__pcm_cc_type.rst. .. _`cmake:pcmsolver`:. How to configure PCMSolver for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling). * Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) PCMSolver. * Upstream Dependencies |w---w| PCMSolver |dr| Fortran, zlib. **CMake Variables**. * :makevar:`ENABLE_PCMSolver` |w---w| CMake variable toggling whether Psi4 builds with PCMSolver; * :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directory containing ``include/PCMSolver/pcmsolver.h``; * :makevar:`PCMSolver_DIR` |w---w| CMake variable to specify where pre-built PCMSolver can be found. Set to installation directory containing ``share/cmake/PCMSolver/PCMSolverConfig.cmake``; * :makevar:`CMAKE_DISABLE_FIND_PACKAGE_PCMSolver` |w---w| CMake variable to force internal build of PCMSolver instead of detecting pre-built; * :makevar:`CMAKE_INSIST_FIND_PACKAGE_PCMSolver` |w---w| CMake variable to force detecting pre-built PCMSolver and not falling back on internal build. **Examples**. A. Build bundled. .. code-block:: bash. >>> cmake -DENABLE_PCMSolver=ON. B. Build *without* PCMSolver. .. code-block:: bash. >>> cmake. ",MatchSource.DOCS,doc/sphinxman/source/pcmsolver.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst:6256,Testability,test,tests,6256,"r a sample input. The PCM model and molecular cavity are specified in a ``pcm`` section that has; to be explicitly typed in by the user. This additional section follows a syntax; that is slightly different from that of |Psifour| and is fully documented; `here <http://pcmsolver.readthedocs.io/en/latest/users/input.html>`_. A typical input for a Hartree--Fock calculation with PCM would look like the following: ::. molecule NH3 {; symmetry c1; N -0.0000000001 -0.1040380466 0.0000000000; H -0.9015844116 0.4818470201 -1.5615900098; H -0.9015844116 0.4818470201 1.5615900098; H 1.8031688251 0.4818470204 0.0000000000; units bohr; no_reorient; no_com; }. set {; basis STO-3G; scf_type pk; pcm true; pcm_scf_type total; }. pcm = {; Units = Angstrom; Medium {; SolverType = IEFPCM; Solvent = Water; }. Cavity {; RadiiSet = UFF; Type = GePol; Scaling = False; Area = 0.3; Mode = Implicit; }; }. More examples can be found in the directories with PCM tests; :srcsample:`pcmsolver/ccsd-pte`,; :srcsample:`pcmsolver/scf`,; :srcsample:`pcmsolver/opt-fd`,; :srcsample:`pcmsolver/dft`, and; :srcsample:`pcmsolver/dipole`. Keywords for PCMSolver; ~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/globals__pcm.rst; .. include:: autodir_options_c/pcm__pcm_scf_type.rst; .. include:: autodir_options_c/pcm__pcm_cc_type.rst. .. _`cmake:pcmsolver`:. How to configure PCMSolver for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling). * Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) PCMSolver. * Upstream Dependencies |w---w| PCMSolver |dr| Fortran, zlib. **CMake Variables**. * :makevar:`ENABLE_PCMSolver` |w---w| CMake variable toggling whether Psi4 builds with PCMSolver; * :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For PCMSolver, set to an installation directo",MatchSource.DOCS,doc/sphinxman/source/pcmsolver.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pcmsolver.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pep0001.rst:3164,Availability,down,down,3164,"|. Presently, topics are brought up on e-mail threads (where; discussion is very temporally localized and not everyone is aware of it; unless cc'd), are brought up at workshops (where people may be absent, no; record is left, and not everyone may have prepared a position on the; topic), or agreed between a couple people over g-chat (others remain; unaware of plans), or planned by someone (who may not have committed those; plans to a ticket or who wants general approval before restructuring the; code). Path of a PsiPEP; ----------------. * Someone creates a file ``doc/sphinxman/source/pepXXXX.rst`` modeled; on :source:`doc/sphinxman/source/pep0000model.rst` and adds; it to ``STATICDOC`` in :source:`doc/sphinxman/CMakeLists.txt`. The file; should have header fields modeled on another PsiPEP and a discussion of; the proposed change or practice. * Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out and the (possibly edited); results be pasted into the bottom of the reST file once the furor dies; down. * Comments can be simple statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history). * Once there's agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include; -------------------------. * **Best practices or re-vamped best practices** . Practices can be easily linked- or referred-to by number and can be; tagged as obsolete by a single label change months later. * **Request/present viewpoint on organization**. Draw attention to organization needed in code outside one's area of; expertise. Request interface for some structure (*e.g.*, gradients) or; viewpoints on how that interface will behave to ensure compatibility.; Offer philosophy on how processes/definitions should be. *",MatchSource.DOCS,doc/sphinxman/source/pep0001.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pep0001.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pep0001.rst:2063,Integrability,protocol,protocol,2063,"=========================; PEP1: Proposing PsiPEP for |PSIfour|; ====================================. :PEP: 1; :Title: Proposing PsiPEP for |PSIfour|; :Last-Modified: 04-Jul-2012; :Author: Lori Burns; :Content-Type: text/x-rst; :Created: 04-Jul-2012. .. comment :Version: <version string>; .. comment * BDFL-Delegate: <PEP czar's real name>; .. comment * Discussions-To: <email address>; .. comment Status: <Draft | Active | Accepted | Deferred | Rejected |; .. comment Withdrawn | Final | Superseded>; .. comment Type: <Standards Track | Informational | Process>; .. comment * Requires: <pep numbers>; .. comment * Python-Version: <version number>; .. comment Post-History: <dates of postings to python-list and python-dev>; .. comment * Replaces: <pep number>; .. comment * Superseded-By: <pep number>; .. comment * Resolution: <url>. This document proposes using a (much more informal) version of Python's; PEP (Python Enhancement Proposal `PEP1; <https://www.python.org/dev/peps/pep-0001/>`_) protocol to organize; |PSIfour|. Presently, topics are brought up on e-mail threads (where; discussion is very temporally localized and not everyone is aware of it; unless cc'd), are brought up at workshops (where people may be absent, no; record is left, and not everyone may have prepared a position on the; topic), or agreed between a couple people over g-chat (others remain; unaware of plans), or planned by someone (who may not have committed those; plans to a ticket or who wants general approval before restructuring the; code). Path of a PsiPEP; ----------------. * Someone creates a file ``doc/sphinxman/source/pepXXXX.rst`` modeled; on :source:`doc/sphinxman/source/pep0000model.rst` and adds; it to ``STATICDOC`` in :source:`doc/sphinxman/CMakeLists.txt`. The file; should have header fields modeled on another PsiPEP and a discussion of; the proposed change or practice. * Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out a",MatchSource.DOCS,doc/sphinxman/source/pep0001.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pep0001.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pep0001.rst:3912,Integrability,interface,interface,3912,"phinxman/source/pepXXXX.rst`` modeled; on :source:`doc/sphinxman/source/pep0000model.rst` and adds; it to ``STATICDOC`` in :source:`doc/sphinxman/CMakeLists.txt`. The file; should have header fields modeled on another PsiPEP and a discussion of; the proposed change or practice. * Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out and the (possibly edited); results be pasted into the bottom of the reST file once the furor dies; down. * Comments can be simple statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history). * Once there's agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include; -------------------------. * **Best practices or re-vamped best practices** . Practices can be easily linked- or referred-to by number and can be; tagged as obsolete by a single label change months later. * **Request/present viewpoint on organization**. Draw attention to organization needed in code outside one's area of; expertise. Request interface for some structure (*e.g.*, gradients) or; viewpoints on how that interface will behave to ensure compatibility.; Offer philosophy on how processes/definitions should be. * **Fair Warning: Proposal to change things up**. Announce plans to re-organize code structure or how something is; handled. List goals (may be conflicting) and how proposed scheme best; satisfies them. PsiPEP allows discussion before roll-out in case; proposal has deleterious side-effects. The contrast between a PsiPEP and a ticket is that for the latter, there's; no question of whether the task is to be done as described. Comments; --------. 04-Jul-2012, LAB. .. comment This is an example comment that refers to :ref:`sec:pep1` and a trac ticket :trac:`#221`. . ----. ",MatchSource.DOCS,doc/sphinxman/source/pep0001.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pep0001.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pep0001.rst:3988,Integrability,interface,interface,3988,"phinxman/source/pepXXXX.rst`` modeled; on :source:`doc/sphinxman/source/pep0000model.rst` and adds; it to ``STATICDOC`` in :source:`doc/sphinxman/CMakeLists.txt`. The file; should have header fields modeled on another PsiPEP and a discussion of; the proposed change or practice. * Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out and the (possibly edited); results be pasted into the bottom of the reST file once the furor dies; down. * Comments can be simple statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history). * Once there's agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include; -------------------------. * **Best practices or re-vamped best practices** . Practices can be easily linked- or referred-to by number and can be; tagged as obsolete by a single label change months later. * **Request/present viewpoint on organization**. Draw attention to organization needed in code outside one's area of; expertise. Request interface for some structure (*e.g.*, gradients) or; viewpoints on how that interface will behave to ensure compatibility.; Offer philosophy on how processes/definitions should be. * **Fair Warning: Proposal to change things up**. Announce plans to re-organize code structure or how something is; handled. List goals (may be conflicting) and how proposed scheme best; satisfies them. PsiPEP allows discussion before roll-out in case; proposal has deleterious side-effects. The contrast between a PsiPEP and a ticket is that for the latter, there's; no question of whether the task is to be done as described. Comments; --------. 04-Jul-2012, LAB. .. comment This is an example comment that refers to :ref:`sec:pep1` and a trac ticket :trac:`#221`. . ----. ",MatchSource.DOCS,doc/sphinxman/source/pep0001.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pep0001.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pep0001.rst:3188,Usability,simpl,simple,3188,"brought up at workshops (where people may be absent, no; record is left, and not everyone may have prepared a position on the; topic), or agreed between a couple people over g-chat (others remain; unaware of plans), or planned by someone (who may not have committed those; plans to a ticket or who wants general approval before restructuring the; code). Path of a PsiPEP; ----------------. * Someone creates a file ``doc/sphinxman/source/pepXXXX.rst`` modeled; on :source:`doc/sphinxman/source/pep0000model.rst` and adds; it to ``STATICDOC`` in :source:`doc/sphinxman/CMakeLists.txt`. The file; should have header fields modeled on another PsiPEP and a discussion of; the proposed change or practice. * Anyone can comment by adding sections to the bottom of the reST file.; Alternatively, e-mail discussions can go out and the (possibly edited); results be pasted into the bottom of the reST file once the furor dies; down. * Comments can be simple statements of agreement (useful for gauging; consensus), notation of possible problems, proposed re-writes of the; proposal, etc. Only the original author or his designate should change; the main body of the PsiPEP (to maintain a history). * Once there's agreement, file can be stamped final and be placed into; effect. (Yes, this is very vague.). Roles of a PsiPEP Include; -------------------------. * **Best practices or re-vamped best practices** . Practices can be easily linked- or referred-to by number and can be; tagged as obsolete by a single label change months later. * **Request/present viewpoint on organization**. Draw attention to organization needed in code outside one's area of; expertise. Request interface for some structure (*e.g.*, gradients) or; viewpoints on how that interface will behave to ensure compatibility.; Offer philosophy on how processes/definitions should be. * **Fair Warning: Proposal to change things up**. Announce plans to re-organize code structure or how something is; handled. List goals (may be conflictin",MatchSource.DOCS,doc/sphinxman/source/pep0001.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/pep0001.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:3349,Availability,avail,available,3349,"he; plugin. In this example, a directory named myplugin will be created.; All you need to do is ``cd`` into the directory, use |PSIfour| to generate; a Makefile, and type make. Then execute ``psi4`` in the directory on the; default input file. .. code-block:: bash. >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. |PSIfour| comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs::. >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. .. >>> psi4 --plugin-name myplugin --plugin-template ambit. .. Several stable sample plugin directories are available to consult in the; .. :source:`plugins` directory. Other plugin directories can be used as models; .. but are in active development. For documentation on plugin modules, see; .. :ref:`Available Plugins <sec:availablePlugins>`.; .. ; .. * :source:`plugins/aointegrals/aointegrals.cc` ; .. An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; .. ; .. * :source:`plugins/backtrans/backtrans.cc` ; .. A test of the one- and two-particle density matrix backtransformation code.; .. ; .. * :source:`plugins/mointegrals/mointegrals.cc` ; .. An example that uses the LibTrans library to generate and print MO basis integrals.; .. ; .. * :source:`plugins/mollerplesset2/mp2.cc` ; .. A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; .. ; .. * :source:`plugins/sointegrals/sointegrals.cc` ; .. An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. .. _`sec:condaplugins`:.",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:3566,Availability,avail,availablePlugins,3566,"the; default input file. .. code-block:: bash. >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. |PSIfour| comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs::. >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. .. >>> psi4 --plugin-name myplugin --plugin-template ambit. .. Several stable sample plugin directories are available to consult in the; .. :source:`plugins` directory. Other plugin directories can be used as models; .. but are in active development. For documentation on plugin modules, see; .. :ref:`Available Plugins <sec:availablePlugins>`.; .. ; .. * :source:`plugins/aointegrals/aointegrals.cc` ; .. An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; .. ; .. * :source:`plugins/backtrans/backtrans.cc` ; .. A test of the one- and two-particle density matrix backtransformation code.; .. ; .. * :source:`plugins/mointegrals/mointegrals.cc` ; .. An example that uses the LibTrans library to generate and print MO basis integrals.; .. ; .. * :source:`plugins/mollerplesset2/mp2.cc` ; .. A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; .. ; .. * :source:`plugins/sointegrals/sointegrals.cc` ; .. An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. .. _`sec:condaplugins`:. Creating a New Plugin Using a Conda Pre-compiled Binary; -------------------------------------------------------. .. # prepare; .. >>> bash; .. >>> export PATH=$PSI4CONDA/bin:$PATH # usually already done from psi4 insta",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:5325,Availability,echo,echo,5325,"ns`:. Creating a New Plugin Using a Conda Pre-compiled Binary; -------------------------------------------------------. .. # prepare; .. >>> bash; .. >>> export PATH=$PSI4CONDA/bin:$PATH # usually already done from psi4 installation; .. >>> cd ""$(dirname $(which psi4))""/.. # move into distribution/environment directory, $PSI4CONDA; .. >>> conda install gcc # install compilers into expected place. |PSIfour| plugins can also be created using Conda for both |PSIfour|; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the ``gcc``; compiler installed alongside ``psi4`` itself in the Conda distribution; or environment (below, ``$PSI4CONDA``). On Mac, one must use; ``libc++.so`` (*not* ``libstdc++.so``), and this can be accomplished by; installing XCode from the App Store that provides ``clang`` and; ``clang++`` compilers. * Check environment:. .. code-block:: bash. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. * Create and compile plugin:. .. code-block:: bash. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $P",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:9222,Availability,avail,available,9222,"AKE_PREFIX_PATH`` part) *and* telling it to; do an in-source build (the ``.`` part). Then just run ``make`` in; your plugin directory. After any change to the plugin C++ code,; ``make`` must be run in the plugin directory to recompile the; ``myplugin.so`` executable, but recompiling the main |PSIfour| code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here. * **input.dat** |w---w| Sample input file for the plugin.; Since the ``__init__.py`` file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in :envvar:`PYTHONPATH`,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating :envvar:`PSIPATH`. Then,; the plugin can be loaded as ``import myplugin`` and executed as; ``energy('myplugin')``. Any other Python functions are also available from; the input file, *e.g.* ``myplugin.testfunction()``, note the namespace; protection. * **pymodule.py** |w---w| Python component of the plugin.; By encoding the sequence of |PSIfour| module; calls needed to run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won't; need editing unless additional Python files are added to the plugin; directory (add additional lines to the ``# Load Python modules`` section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the ``# Load C++ plugin`` section). .. comment as m",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:10916,Availability,avail,availablePlugins,10916,"o run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won't; need editing unless additional Python files are added to the plugin; directory (add additional lines to the ``# Load Python modules`` section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the ``# Load C++ plugin`` section). .. comment as modeled in :source:`tests/plugin_libcim/__init__.py`). .. literalinclude:: @SFNX_INCLUDE@psi4/share/psi4/plugin/__init__.py.template. * **doc.rst** |w---w| Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, *etc.*. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the ``.. comment``; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the |PSIfour|; documentation, along with any docstrings to Python functions, and the C++; keywords block in the ``myplugin.cc`` file. See :ref:`sec:documentation`; for building documentation. .. and :ref:`Available Plugins <sec:availablePlugins>`; .. for this file's final destination. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded. To create a purely Python plugin, create a new plugin directory, then; remove the ``Makefile`` and ``myplugin.cc`` files and; erase the shared object loading portion of ``__init__.py``. Create as many .py; files as necessary (registering each one in ``__init__.py``), use; ``input.dat`` as a model for loading the plugin, no recompile ever; necessary. ",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:11054,Availability,error,errors,11054,"o run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won't; need editing unless additional Python files are added to the plugin; directory (add additional lines to the ``# Load Python modules`` section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the ``# Load C++ plugin`` section). .. comment as modeled in :source:`tests/plugin_libcim/__init__.py`). .. literalinclude:: @SFNX_INCLUDE@psi4/share/psi4/plugin/__init__.py.template. * **doc.rst** |w---w| Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, *etc.*. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the ``.. comment``; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the |PSIfour|; documentation, along with any docstrings to Python functions, and the C++; keywords block in the ``myplugin.cc`` file. See :ref:`sec:documentation`; for building documentation. .. and :ref:`Available Plugins <sec:availablePlugins>`; .. for this file's final destination. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded. To create a purely Python plugin, create a new plugin directory, then; remove the ``Makefile`` and ``myplugin.cc`` files and; erase the shared object loading portion of ``__init__.py``. Create as many .py; files as necessary (registering each one in ``__init__.py``), use; ``input.dat`` as a model for loading the plugin, no recompile ever; necessary. ",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:4556,Deployability,install,installation,4556," see; .. :ref:`Available Plugins <sec:availablePlugins>`.; .. ; .. * :source:`plugins/aointegrals/aointegrals.cc` ; .. An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; .. ; .. * :source:`plugins/backtrans/backtrans.cc` ; .. A test of the one- and two-particle density matrix backtransformation code.; .. ; .. * :source:`plugins/mointegrals/mointegrals.cc` ; .. An example that uses the LibTrans library to generate and print MO basis integrals.; .. ; .. * :source:`plugins/mollerplesset2/mp2.cc` ; .. A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; .. ; .. * :source:`plugins/sointegrals/sointegrals.cc` ; .. An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. .. _`sec:condaplugins`:. Creating a New Plugin Using a Conda Pre-compiled Binary; -------------------------------------------------------. .. # prepare; .. >>> bash; .. >>> export PATH=$PSI4CONDA/bin:$PATH # usually already done from psi4 installation; .. >>> cd ""$(dirname $(which psi4))""/.. # move into distribution/environment directory, $PSI4CONDA; .. >>> conda install gcc # install compilers into expected place. |PSIfour| plugins can also be created using Conda for both |PSIfour|; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the ``gcc``; compiler installed alongside ``psi4`` itself in the Conda distribution; or environment (below, ``$PSI4CONDA``). On Mac, one must use; ``libc++.so`` (*not* ``libstdc++.so``), and this can be accomplished by; installing XCode from the App Store that provides ``clang`` and; ``clang++`` compilers. * Check environment:. .. code-block:: bash. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> whi",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:4683,Deployability,install,install,4683,"d print AO basis (no symmetry) integrals.; .. ; .. * :source:`plugins/backtrans/backtrans.cc` ; .. A test of the one- and two-particle density matrix backtransformation code.; .. ; .. * :source:`plugins/mointegrals/mointegrals.cc` ; .. An example that uses the LibTrans library to generate and print MO basis integrals.; .. ; .. * :source:`plugins/mollerplesset2/mp2.cc` ; .. A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; .. ; .. * :source:`plugins/sointegrals/sointegrals.cc` ; .. An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. .. _`sec:condaplugins`:. Creating a New Plugin Using a Conda Pre-compiled Binary; -------------------------------------------------------. .. # prepare; .. >>> bash; .. >>> export PATH=$PSI4CONDA/bin:$PATH # usually already done from psi4 installation; .. >>> cd ""$(dirname $(which psi4))""/.. # move into distribution/environment directory, $PSI4CONDA; .. >>> conda install gcc # install compilers into expected place. |PSIfour| plugins can also be created using Conda for both |PSIfour|; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the ``gcc``; compiler installed alongside ``psi4`` itself in the Conda distribution; or environment (below, ``$PSI4CONDA``). On Mac, one must use; ``libc++.so`` (*not* ``libstdc++.so``), and this can be accomplished by; installing XCode from the App Store that provides ``clang`` and; ``clang++`` compilers. * Check environment:. .. code-block:: bash. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4COND",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:4697,Deployability,install,install,4697,"d print AO basis (no symmetry) integrals.; .. ; .. * :source:`plugins/backtrans/backtrans.cc` ; .. A test of the one- and two-particle density matrix backtransformation code.; .. ; .. * :source:`plugins/mointegrals/mointegrals.cc` ; .. An example that uses the LibTrans library to generate and print MO basis integrals.; .. ; .. * :source:`plugins/mollerplesset2/mp2.cc` ; .. A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; .. ; .. * :source:`plugins/sointegrals/sointegrals.cc` ; .. An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. .. _`sec:condaplugins`:. Creating a New Plugin Using a Conda Pre-compiled Binary; -------------------------------------------------------. .. # prepare; .. >>> bash; .. >>> export PATH=$PSI4CONDA/bin:$PATH # usually already done from psi4 installation; .. >>> cd ""$(dirname $(which psi4))""/.. # move into distribution/environment directory, $PSI4CONDA; .. >>> conda install gcc # install compilers into expected place. |PSIfour| plugins can also be created using Conda for both |PSIfour|; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the ``gcc``; compiler installed alongside ``psi4`` itself in the Conda distribution; or environment (below, ``$PSI4CONDA``). On Mac, one must use; ``libc++.so`` (*not* ``libstdc++.so``), and this can be accomplished by; installing XCode from the App Store that provides ``clang`` and; ``clang++`` compilers. * Check environment:. .. code-block:: bash. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4COND",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:4915,Deployability,install,installed,4915,".cc` ; .. An example that uses the LibTrans library to generate and print MO basis integrals.; .. ; .. * :source:`plugins/mollerplesset2/mp2.cc` ; .. A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; .. ; .. * :source:`plugins/sointegrals/sointegrals.cc` ; .. An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. .. _`sec:condaplugins`:. Creating a New Plugin Using a Conda Pre-compiled Binary; -------------------------------------------------------. .. # prepare; .. >>> bash; .. >>> export PATH=$PSI4CONDA/bin:$PATH # usually already done from psi4 installation; .. >>> cd ""$(dirname $(which psi4))""/.. # move into distribution/environment directory, $PSI4CONDA; .. >>> conda install gcc # install compilers into expected place. |PSIfour| plugins can also be created using Conda for both |PSIfour|; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the ``gcc``; compiler installed alongside ``psi4`` itself in the Conda distribution; or environment (below, ``$PSI4CONDA``). On Mac, one must use; ``libc++.so`` (*not* ``libstdc++.so``), and this can be accomplished by; installing XCode from the App Store that provides ``clang`` and; ``clang++`` compilers. * Check environment:. .. code-block:: bash. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. * Create and compile plugin:. .. code-block:: bash. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plu",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:5113,Deployability,install,installing,5113,"shell MP2 energies.; .. ; .. * :source:`plugins/sointegrals/sointegrals.cc` ; .. An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. .. _`sec:condaplugins`:. Creating a New Plugin Using a Conda Pre-compiled Binary; -------------------------------------------------------. .. # prepare; .. >>> bash; .. >>> export PATH=$PSI4CONDA/bin:$PATH # usually already done from psi4 installation; .. >>> cd ""$(dirname $(which psi4))""/.. # move into distribution/environment directory, $PSI4CONDA; .. >>> conda install gcc # install compilers into expected place. |PSIfour| plugins can also be created using Conda for both |PSIfour|; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the ``gcc``; compiler installed alongside ``psi4`` itself in the Conda distribution; or environment (below, ``$PSI4CONDA``). On Mac, one must use; ``libc++.so`` (*not* ``libstdc++.so``), and this can be accomplished by; installing XCode from the App Store that provides ``clang`` and; ``clang++`` compilers. * Check environment:. .. code-block:: bash. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. * Create and compile plugin:. .. code-block:: bash. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:5743,Deployability,install,install,5743,"o expected place. |PSIfour| plugins can also be created using Conda for both |PSIfour|; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the ``gcc``; compiler installed alongside ``psi4`` itself in the Conda distribution; or environment (below, ``$PSI4CONDA``). On Mac, one must use; ``libc++.so`` (*not* ``libstdc++.so``), and this can be accomplished by; installing XCode from the App Store that provides ``clang`` and; ``clang++`` compilers. * Check environment:. .. code-block:: bash. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. * Create and compile plugin:. .. code-block:: bash. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:7668,Deployability,install,installation,7668,"ng 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in ``$PATH`` or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory; ---------------------------. In addition to the main ``myplugin.cc`` file, a fresh plugin directory contains the following files. * **CMakeLists.txt** |w---w| CMake file governing project *plugin*.; The plugin source and CMakeLists.txt is independent of platform; and |PSIfour| installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; |PSIfour| installation. Run ``psi4 --plugin-compile`` to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent |PSIfour|; (the ``-C psi4PluginCache`` part) which in turn can be overridden; by passing ``-Doption=value`` commands to ``cmake`` *and* pointing; toward a particular |PSIfour| (and probably pybind11) library to; link against (the ``CMAKE_PREFIX_PATH`` part) *and* telling it to; do an in-source build (the ``.`` part). Then just run ``make`` in; your plugin directory. After any change to the plugin C++ code,; ``make`` must be run in the plugin directory to recompile the; ``myplugin.so`` executable, but recompiling the main |PSIfour| code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libra",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:7798,Deployability,install,installation,7798,"sr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in ``$PATH`` or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory; ---------------------------. In addition to the main ``myplugin.cc`` file, a fresh plugin directory contains the following files. * **CMakeLists.txt** |w---w| CMake file governing project *plugin*.; The plugin source and CMakeLists.txt is independent of platform; and |PSIfour| installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; |PSIfour| installation. Run ``psi4 --plugin-compile`` to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent |PSIfour|; (the ``-C psi4PluginCache`` part) which in turn can be overridden; by passing ``-Doption=value`` commands to ``cmake`` *and* pointing; toward a particular |PSIfour| (and probably pybind11) library to; link against (the ``CMAKE_PREFIX_PATH`` part) *and* telling it to; do an in-source build (the ``.`` part). Then just run ``make`` in; your plugin directory. After any change to the plugin C++ code,; ``make`` must be run in the plugin directory to recompile the; ``myplugin.so`` executable, but recompiling the main |PSIfour| code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here. * **input.dat** |w---w| Sample input file for the plugin.; Since the ``__",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:9164,Energy Efficiency,energy,energy,9164,"rd a particular |PSIfour| (and probably pybind11) library to; link against (the ``CMAKE_PREFIX_PATH`` part) *and* telling it to; do an in-source build (the ``.`` part). Then just run ``make`` in; your plugin directory. After any change to the plugin C++ code,; ``make`` must be run in the plugin directory to recompile the; ``myplugin.so`` executable, but recompiling the main |PSIfour| code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here. * **input.dat** |w---w| Sample input file for the plugin.; Since the ``__init__.py`` file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in :envvar:`PYTHONPATH`,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating :envvar:`PSIPATH`. Then,; the plugin can be loaded as ``import myplugin`` and executed as; ``energy('myplugin')``. Any other Python functions are also available from; the input file, *e.g.* ``myplugin.testfunction()``, note the namespace; protection. * **pymodule.py** |w---w| Python component of the plugin.; By encoding the sequence of |PSIfour| module; calls needed to run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won't; need editing unless additional Python files are added to the plugin; directory (add additional lines to the ``# Load Python modules`` section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to ",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:9593,Energy Efficiency,energy,energy,9593,"onal external libraries, add that; information here. * **input.dat** |w---w| Sample input file for the plugin.; Since the ``__init__.py`` file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in :envvar:`PYTHONPATH`,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating :envvar:`PSIPATH`. Then,; the plugin can be loaded as ``import myplugin`` and executed as; ``energy('myplugin')``. Any other Python functions are also available from; the input file, *e.g.* ``myplugin.testfunction()``, note the namespace; protection. * **pymodule.py** |w---w| Python component of the plugin.; By encoding the sequence of |PSIfour| module; calls needed to run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won't; need editing unless additional Python files are added to the plugin; directory (add additional lines to the ``# Load Python modules`` section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the ``# Load C++ plugin`` section). .. comment as modeled in :source:`tests/plugin_libcim/__init__.py`). .. literalinclude:: @SFNX_INCLUDE@psi4/share/psi4/plugin/__init__.py.template. * **doc.rst** |w---w| Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, *etc.*. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the ``.. comment``; text and build Sphinx documentation for samples of linking key",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:9635,Energy Efficiency,energy,energy,9635,"onal external libraries, add that; information here. * **input.dat** |w---w| Sample input file for the plugin.; Since the ``__init__.py`` file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in :envvar:`PYTHONPATH`,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating :envvar:`PSIPATH`. Then,; the plugin can be loaded as ``import myplugin`` and executed as; ``energy('myplugin')``. Any other Python functions are also available from; the input file, *e.g.* ``myplugin.testfunction()``, note the namespace; protection. * **pymodule.py** |w---w| Python component of the plugin.; By encoding the sequence of |PSIfour| module; calls needed to run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won't; need editing unless additional Python files are added to the plugin; directory (add additional lines to the ``# Load Python modules`` section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the ``# Load C++ plugin`` section). .. comment as modeled in :source:`tests/plugin_libcim/__init__.py`). .. literalinclude:: @SFNX_INCLUDE@psi4/share/psi4/plugin/__init__.py.template. * **doc.rst** |w---w| Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, *etc.*. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the ``.. comment``; text and build Sphinx documentation for samples of linking key",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:6924,Integrability,depend,dependencies,6924,"as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in ``$PATH`` or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory; ---------------------------. In addition to the main ``myplugin.cc`` file, a fresh plugin directory contains the following files. * **CMakeLists.txt** |w---w| CMake file governing project *plugin*.; The plugin source and CMakeLists.txt is independent of platform; and |PSIfour| installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; |PSIfour| installation. Run ``psi4 --plugin-compile`` to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and o",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:10041,Integrability,depend,depends,10041,"ONPATH`,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating :envvar:`PSIPATH`. Then,; the plugin can be loaded as ``import myplugin`` and executed as; ``energy('myplugin')``. Any other Python functions are also available from; the input file, *e.g.* ``myplugin.testfunction()``, note the namespace; protection. * **pymodule.py** |w---w| Python component of the plugin.; By encoding the sequence of |PSIfour| module; calls needed to run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won't; need editing unless additional Python files are added to the plugin; directory (add additional lines to the ``# Load Python modules`` section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the ``# Load C++ plugin`` section). .. comment as modeled in :source:`tests/plugin_libcim/__init__.py`). .. literalinclude:: @SFNX_INCLUDE@psi4/share/psi4/plugin/__init__.py.template. * **doc.rst** |w---w| Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, *etc.*. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the ``.. comment``; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the |PSIfour|; documentation, along with any docstrings to Python functions, and the C++; keywords block in the ``myplugin.cc`` file. See :ref:`sec:documentation`; for building documentation. .. and :ref:`Available Plugins <sec:availablePlugins>`; .. for this file's",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:1070,Modifiability,plugin,plugins,1070,"istry software package; .. #; .. # Copyright (c) 2007-2023 The Psi4 Developers.; .. #; .. # The copyrights for code used from other parties are included in; .. # the corresponding files.; .. #; .. # This file is part of Psi4.; .. #; .. # Psi4 is free software; you can redistribute it and/or modify; .. # it under the terms of the GNU Lesser General Public License as published by; .. # the Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:plugins`:. Creating New Plugins; ====================. Modular Approach to Development; -------------------------------. It is slightly cumbersome to the development cycle to recompile |PSIfour|; every time a change is made to the C++ code.; It's also daunting to new developers if they're required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, |PSIfour| now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi's vast library. The plugins can be loaded at; run-time from any location. .. _`sec:newplugins`:. Creating a New Plugin; ---------------------. |PSIfour| can create basic plugins for you and automatically tailor them; to your compilation environment. To cr",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:1658,Modifiability,plugin,plugin,1658,".. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:plugins`:. Creating New Plugins; ====================. Modular Approach to Development; -------------------------------. It is slightly cumbersome to the development cycle to recompile |PSIfour|; every time a change is made to the C++ code.; It's also daunting to new developers if they're required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, |PSIfour| now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi's vast library. The plugins can be loaded at; run-time from any location. .. _`sec:newplugins`:. Creating a New Plugin; ---------------------. |PSIfour| can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing ``myplugin`` with the name of your great code.; If the name you provide is not valid, |PSIfour| will complain. >>> psi4 --plugin-name myplugin. |PSIfour| will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is ``cd`` into the directory, use |PSIfour| to generate; a Makefile, and type make. Then execute ``psi4`` in the directory on the; default input file. .. code-block:: bash. >>> cd myplugin; >>> `psi4 --p",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:1837,Modifiability,plugin,plugins,1837,"h Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:plugins`:. Creating New Plugins; ====================. Modular Approach to Development; -------------------------------. It is slightly cumbersome to the development cycle to recompile |PSIfour|; every time a change is made to the C++ code.; It's also daunting to new developers if they're required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, |PSIfour| now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi's vast library. The plugins can be loaded at; run-time from any location. .. _`sec:newplugins`:. Creating a New Plugin; ---------------------. |PSIfour| can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing ``myplugin`` with the name of your great code.; If the name you provide is not valid, |PSIfour| will complain. >>> psi4 --plugin-name myplugin. |PSIfour| will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is ``cd`` into the directory, use |PSIfour| to generate; a Makefile, and type make. Then execute ``psi4`` in the directory on the; default input file. .. code-block:: bash. >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. |PSIfour| comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:1987,Modifiability,plugin,plugins,1987,"; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:plugins`:. Creating New Plugins; ====================. Modular Approach to Development; -------------------------------. It is slightly cumbersome to the development cycle to recompile |PSIfour|; every time a change is made to the C++ code.; It's also daunting to new developers if they're required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, |PSIfour| now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi's vast library. The plugins can be loaded at; run-time from any location. .. _`sec:newplugins`:. Creating a New Plugin; ---------------------. |PSIfour| can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing ``myplugin`` with the name of your great code.; If the name you provide is not valid, |PSIfour| will complain. >>> psi4 --plugin-name myplugin. |PSIfour| will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is ``cd`` into the directory, use |PSIfour| to generate; a Makefile, and type make. Then execute ``psi4`` in the directory on the; default input file. .. code-block:: bash. >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. |PSIfour| comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs::. >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:2085,Modifiability,plugin,plugin,2085,"===. Modular Approach to Development; -------------------------------. It is slightly cumbersome to the development cycle to recompile |PSIfour|; every time a change is made to the C++ code.; It's also daunting to new developers if they're required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, |PSIfour| now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi's vast library. The plugins can be loaded at; run-time from any location. .. _`sec:newplugins`:. Creating a New Plugin; ---------------------. |PSIfour| can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing ``myplugin`` with the name of your great code.; If the name you provide is not valid, |PSIfour| will complain. >>> psi4 --plugin-name myplugin. |PSIfour| will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is ``cd`` into the directory, use |PSIfour| to generate; a Makefile, and type make. Then execute ``psi4`` in the directory on the; default input file. .. code-block:: bash. >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. |PSIfour| comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs::. >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavef",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:2250,Modifiability,plugin,plugin-name,2250," |PSIfour|; every time a change is made to the C++ code.; It's also daunting to new developers if they're required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, |PSIfour| now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi's vast library. The plugins can be loaded at; run-time from any location. .. _`sec:newplugins`:. Creating a New Plugin; ---------------------. |PSIfour| can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing ``myplugin`` with the name of your great code.; If the name you provide is not valid, |PSIfour| will complain. >>> psi4 --plugin-name myplugin. |PSIfour| will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is ``cd`` into the directory, use |PSIfour| to generate; a Makefile, and type make. Then execute ``psi4`` in the directory on the; default input file. .. code-block:: bash. >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. |PSIfour| comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs::. >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. .. >>> psi4 --",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:2345,Modifiability,plugin,plugin,2345," It's also daunting to new developers if they're required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, |PSIfour| now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi's vast library. The plugins can be loaded at; run-time from any location. .. _`sec:newplugins`:. Creating a New Plugin; ---------------------. |PSIfour| can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing ``myplugin`` with the name of your great code.; If the name you provide is not valid, |PSIfour| will complain. >>> psi4 --plugin-name myplugin. |PSIfour| will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is ``cd`` into the directory, use |PSIfour| to generate; a Makefile, and type make. Then execute ``psi4`` in the directory on the; default input file. .. code-block:: bash. >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. |PSIfour| comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs::. >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. .. >>> psi4 --plugin-name myplugin --plugin-template ambit. .. Several ",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:2636,Modifiability,plugin,plugin-compile,2636," now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi's vast library. The plugins can be loaded at; run-time from any location. .. _`sec:newplugins`:. Creating a New Plugin; ---------------------. |PSIfour| can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing ``myplugin`` with the name of your great code.; If the name you provide is not valid, |PSIfour| will complain. >>> psi4 --plugin-name myplugin. |PSIfour| will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is ``cd`` into the directory, use |PSIfour| to generate; a Makefile, and type make. Then execute ``psi4`` in the directory on the; default input file. .. code-block:: bash. >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. |PSIfour| comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs::. >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. .. >>> psi4 --plugin-name myplugin --plugin-template ambit. .. Several stable sample plugin directories are available to consult in the; .. :source:`plugins` directory. Other plugin directories can be used as models; .. but are in active development. For documentation on plugin modules, see; .. :ref:`Available Plugins <sec:availablePlugins>`.; .. ; .. * :source:`plugins/aointegrals/aointegrals.c",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:2887,Modifiability,plugin,plugin-name,2887,"ironment. To create a basic plugin, run the; following while replacing ``myplugin`` with the name of your great code.; If the name you provide is not valid, |PSIfour| will complain. >>> psi4 --plugin-name myplugin. |PSIfour| will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is ``cd`` into the directory, use |PSIfour| to generate; a Makefile, and type make. Then execute ``psi4`` in the directory on the; default input file. .. code-block:: bash. >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. |PSIfour| comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs::. >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. .. >>> psi4 --plugin-name myplugin --plugin-template ambit. .. Several stable sample plugin directories are available to consult in the; .. :source:`plugins` directory. Other plugin directories can be used as models; .. but are in active development. For documentation on plugin modules, see; .. :ref:`Available Plugins <sec:availablePlugins>`.; .. ; .. * :source:`plugins/aointegrals/aointegrals.cc` ; .. An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; .. ; .. * :source:`plugins/backtrans/backtrans.cc` ; .. A test of the one- and two-particle density matrix backtransformation code.; .. ; .. * :source:`plugins/mointegrals/mointegrals.cc` ; .. An example that uses the LibTrans library to generate and print MO basis integrals.; .. ; .. * :source:`plugins/mollerp",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:2910,Modifiability,plugin,plugin-template,2910,"ironment. To create a basic plugin, run the; following while replacing ``myplugin`` with the name of your great code.; If the name you provide is not valid, |PSIfour| will complain. >>> psi4 --plugin-name myplugin. |PSIfour| will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is ``cd`` into the directory, use |PSIfour| to generate; a Makefile, and type make. Then execute ``psi4`` in the directory on the; default input file. .. code-block:: bash. >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. |PSIfour| comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs::. >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. .. >>> psi4 --plugin-name myplugin --plugin-template ambit. .. Several stable sample plugin directories are available to consult in the; .. :source:`plugins` directory. Other plugin directories can be used as models; .. but are in active development. For documentation on plugin modules, see; .. :ref:`Available Plugins <sec:availablePlugins>`.; .. ; .. * :source:`plugins/aointegrals/aointegrals.cc` ; .. An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; .. ; .. * :source:`plugins/backtrans/backtrans.cc` ; .. A test of the one- and two-particle density matrix backtransformation code.; .. ; .. * :source:`plugins/mointegrals/mointegrals.cc` ; .. An example that uses the LibTrans library to generate and print MO basis integrals.; .. ; .. * :source:`plugins/mollerp",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:2950,Modifiability,plugin,plugin-name,2950,"ironment. To create a basic plugin, run the; following while replacing ``myplugin`` with the name of your great code.; If the name you provide is not valid, |PSIfour| will complain. >>> psi4 --plugin-name myplugin. |PSIfour| will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is ``cd`` into the directory, use |PSIfour| to generate; a Makefile, and type make. Then execute ``psi4`` in the directory on the; default input file. .. code-block:: bash. >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. |PSIfour| comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs::. >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. .. >>> psi4 --plugin-name myplugin --plugin-template ambit. .. Several stable sample plugin directories are available to consult in the; .. :source:`plugins` directory. Other plugin directories can be used as models; .. but are in active development. For documentation on plugin modules, see; .. :ref:`Available Plugins <sec:availablePlugins>`.; .. ; .. * :source:`plugins/aointegrals/aointegrals.cc` ; .. An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; .. ; .. * :source:`plugins/backtrans/backtrans.cc` ; .. A test of the one- and two-particle density matrix backtransformation code.; .. ; .. * :source:`plugins/mointegrals/mointegrals.cc` ; .. An example that uses the LibTrans library to generate and print MO basis integrals.; .. ; .. * :source:`plugins/mollerp",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:2973,Modifiability,plugin,plugin-template,2973,"ironment. To create a basic plugin, run the; following while replacing ``myplugin`` with the name of your great code.; If the name you provide is not valid, |PSIfour| will complain. >>> psi4 --plugin-name myplugin. |PSIfour| will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is ``cd`` into the directory, use |PSIfour| to generate; a Makefile, and type make. Then execute ``psi4`` in the directory on the; default input file. .. code-block:: bash. >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. |PSIfour| comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs::. >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. .. >>> psi4 --plugin-name myplugin --plugin-template ambit. .. Several stable sample plugin directories are available to consult in the; .. :source:`plugins` directory. Other plugin directories can be used as models; .. but are in active development. For documentation on plugin modules, see; .. :ref:`Available Plugins <sec:availablePlugins>`.; .. ; .. * :source:`plugins/aointegrals/aointegrals.cc` ; .. An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; .. ; .. * :source:`plugins/backtrans/backtrans.cc` ; .. A test of the one- and two-particle density matrix backtransformation code.; .. ; .. * :source:`plugins/mointegrals/mointegrals.cc` ; .. An example that uses the LibTrans library to generate and print MO basis integrals.; .. ; .. * :source:`plugins/mollerp",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:3013,Modifiability,plugin,plugin-name,3013,"ironment. To create a basic plugin, run the; following while replacing ``myplugin`` with the name of your great code.; If the name you provide is not valid, |PSIfour| will complain. >>> psi4 --plugin-name myplugin. |PSIfour| will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is ``cd`` into the directory, use |PSIfour| to generate; a Makefile, and type make. Then execute ``psi4`` in the directory on the; default input file. .. code-block:: bash. >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. |PSIfour| comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs::. >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. .. >>> psi4 --plugin-name myplugin --plugin-template ambit. .. Several stable sample plugin directories are available to consult in the; .. :source:`plugins` directory. Other plugin directories can be used as models; .. but are in active development. For documentation on plugin modules, see; .. :ref:`Available Plugins <sec:availablePlugins>`.; .. ; .. * :source:`plugins/aointegrals/aointegrals.cc` ; .. An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; .. ; .. * :source:`plugins/backtrans/backtrans.cc` ; .. A test of the one- and two-particle density matrix backtransformation code.; .. ; .. * :source:`plugins/mointegrals/mointegrals.cc` ; .. An example that uses the LibTrans library to generate and print MO basis integrals.; .. ; .. * :source:`plugins/mollerp",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:3036,Modifiability,plugin,plugin-template,3036,"ironment. To create a basic plugin, run the; following while replacing ``myplugin`` with the name of your great code.; If the name you provide is not valid, |PSIfour| will complain. >>> psi4 --plugin-name myplugin. |PSIfour| will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is ``cd`` into the directory, use |PSIfour| to generate; a Makefile, and type make. Then execute ``psi4`` in the directory on the; default input file. .. code-block:: bash. >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. |PSIfour| comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs::. >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. .. >>> psi4 --plugin-name myplugin --plugin-template ambit. .. Several stable sample plugin directories are available to consult in the; .. :source:`plugins` directory. Other plugin directories can be used as models; .. but are in active development. For documentation on plugin modules, see; .. :ref:`Available Plugins <sec:availablePlugins>`.; .. ; .. * :source:`plugins/aointegrals/aointegrals.cc` ; .. An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; .. ; .. * :source:`plugins/backtrans/backtrans.cc` ; .. A test of the one- and two-particle density matrix backtransformation code.; .. ; .. * :source:`plugins/mointegrals/mointegrals.cc` ; .. An example that uses the LibTrans library to generate and print MO basis integrals.; .. ; .. * :source:`plugins/mollerp",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:3076,Modifiability,plugin,plugin-name,3076,"ironment. To create a basic plugin, run the; following while replacing ``myplugin`` with the name of your great code.; If the name you provide is not valid, |PSIfour| will complain. >>> psi4 --plugin-name myplugin. |PSIfour| will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is ``cd`` into the directory, use |PSIfour| to generate; a Makefile, and type make. Then execute ``psi4`` in the directory on the; default input file. .. code-block:: bash. >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. |PSIfour| comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs::. >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. .. >>> psi4 --plugin-name myplugin --plugin-template ambit. .. Several stable sample plugin directories are available to consult in the; .. :source:`plugins` directory. Other plugin directories can be used as models; .. but are in active development. For documentation on plugin modules, see; .. :ref:`Available Plugins <sec:availablePlugins>`.; .. ; .. * :source:`plugins/aointegrals/aointegrals.cc` ; .. An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; .. ; .. * :source:`plugins/backtrans/backtrans.cc` ; .. A test of the one- and two-particle density matrix backtransformation code.; .. ; .. * :source:`plugins/mointegrals/mointegrals.cc` ; .. An example that uses the LibTrans library to generate and print MO basis integrals.; .. ; .. * :source:`plugins/mollerp",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:3099,Modifiability,plugin,plugin-template,3099,"ironment. To create a basic plugin, run the; following while replacing ``myplugin`` with the name of your great code.; If the name you provide is not valid, |PSIfour| will complain. >>> psi4 --plugin-name myplugin. |PSIfour| will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is ``cd`` into the directory, use |PSIfour| to generate; a Makefile, and type make. Then execute ``psi4`` in the directory on the; default input file. .. code-block:: bash. >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. |PSIfour| comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs::. >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. .. >>> psi4 --plugin-name myplugin --plugin-template ambit. .. Several stable sample plugin directories are available to consult in the; .. :source:`plugins` directory. Other plugin directories can be used as models; .. but are in active development. For documentation on plugin modules, see; .. :ref:`Available Plugins <sec:availablePlugins>`.; .. ; .. * :source:`plugins/aointegrals/aointegrals.cc` ; .. An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; .. ; .. * :source:`plugins/backtrans/backtrans.cc` ; .. A test of the one- and two-particle density matrix backtransformation code.; .. ; .. * :source:`plugins/mointegrals/mointegrals.cc` ; .. An example that uses the LibTrans library to generate and print MO basis integrals.; .. ; .. * :source:`plugins/mollerp",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:3140,Modifiability,plugin,plugin-name,3140,"ironment. To create a basic plugin, run the; following while replacing ``myplugin`` with the name of your great code.; If the name you provide is not valid, |PSIfour| will complain. >>> psi4 --plugin-name myplugin. |PSIfour| will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is ``cd`` into the directory, use |PSIfour| to generate; a Makefile, and type make. Then execute ``psi4`` in the directory on the; default input file. .. code-block:: bash. >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. |PSIfour| comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs::. >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. .. >>> psi4 --plugin-name myplugin --plugin-template ambit. .. Several stable sample plugin directories are available to consult in the; .. :source:`plugins` directory. Other plugin directories can be used as models; .. but are in active development. For documentation on plugin modules, see; .. :ref:`Available Plugins <sec:availablePlugins>`.; .. ; .. * :source:`plugins/aointegrals/aointegrals.cc` ; .. An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; .. ; .. * :source:`plugins/backtrans/backtrans.cc` ; .. A test of the one- and two-particle density matrix backtransformation code.; .. ; .. * :source:`plugins/mointegrals/mointegrals.cc` ; .. An example that uses the LibTrans library to generate and print MO basis integrals.; .. ; .. * :source:`plugins/mollerp",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:3163,Modifiability,plugin,plugin-template,3163,"ironment. To create a basic plugin, run the; following while replacing ``myplugin`` with the name of your great code.; If the name you provide is not valid, |PSIfour| will complain. >>> psi4 --plugin-name myplugin. |PSIfour| will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is ``cd`` into the directory, use |PSIfour| to generate; a Makefile, and type make. Then execute ``psi4`` in the directory on the; default input file. .. code-block:: bash. >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. |PSIfour| comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs::. >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. .. >>> psi4 --plugin-name myplugin --plugin-template ambit. .. Several stable sample plugin directories are available to consult in the; .. :source:`plugins` directory. Other plugin directories can be used as models; .. but are in active development. For documentation on plugin modules, see; .. :ref:`Available Plugins <sec:availablePlugins>`.; .. ; .. * :source:`plugins/aointegrals/aointegrals.cc` ; .. An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; .. ; .. * :source:`plugins/backtrans/backtrans.cc` ; .. A test of the one- and two-particle density matrix backtransformation code.; .. ; .. * :source:`plugins/mointegrals/mointegrals.cc` ; .. An example that uses the LibTrans library to generate and print MO basis integrals.; .. ; .. * :source:`plugins/mollerp",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:3195,Modifiability,plugin,plugin-name,3195,"ironment. To create a basic plugin, run the; following while replacing ``myplugin`` with the name of your great code.; If the name you provide is not valid, |PSIfour| will complain. >>> psi4 --plugin-name myplugin. |PSIfour| will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is ``cd`` into the directory, use |PSIfour| to generate; a Makefile, and type make. Then execute ``psi4`` in the directory on the; default input file. .. code-block:: bash. >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. |PSIfour| comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs::. >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. .. >>> psi4 --plugin-name myplugin --plugin-template ambit. .. Several stable sample plugin directories are available to consult in the; .. :source:`plugins` directory. Other plugin directories can be used as models; .. but are in active development. For documentation on plugin modules, see; .. :ref:`Available Plugins <sec:availablePlugins>`.; .. ; .. * :source:`plugins/aointegrals/aointegrals.cc` ; .. An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; .. ; .. * :source:`plugins/backtrans/backtrans.cc` ; .. A test of the one- and two-particle density matrix backtransformation code.; .. ; .. * :source:`plugins/mointegrals/mointegrals.cc` ; .. An example that uses the LibTrans library to generate and print MO basis integrals.; .. ; .. * :source:`plugins/mollerp",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:3218,Modifiability,plugin,plugin-template,3218,"ironment. To create a basic plugin, run the; following while replacing ``myplugin`` with the name of your great code.; If the name you provide is not valid, |PSIfour| will complain. >>> psi4 --plugin-name myplugin. |PSIfour| will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is ``cd`` into the directory, use |PSIfour| to generate; a Makefile, and type make. Then execute ``psi4`` in the directory on the; default input file. .. code-block:: bash. >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. |PSIfour| comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs::. >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. .. >>> psi4 --plugin-name myplugin --plugin-template ambit. .. Several stable sample plugin directories are available to consult in the; .. :source:`plugins` directory. Other plugin directories can be used as models; .. but are in active development. For documentation on plugin modules, see; .. :ref:`Available Plugins <sec:availablePlugins>`.; .. ; .. * :source:`plugins/aointegrals/aointegrals.cc` ; .. An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; .. ; .. * :source:`plugins/backtrans/backtrans.cc` ; .. A test of the one- and two-particle density matrix backtransformation code.; .. ; .. * :source:`plugins/mointegrals/mointegrals.cc` ; .. An example that uses the LibTrans library to generate and print MO basis integrals.; .. ; .. * :source:`plugins/mollerp",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:3255,Modifiability,plugin,plugin-name,3255," |PSIfour| will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is ``cd`` into the directory, use |PSIfour| to generate; a Makefile, and type make. Then execute ``psi4`` in the directory on the; default input file. .. code-block:: bash. >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. |PSIfour| comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs::. >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. .. >>> psi4 --plugin-name myplugin --plugin-template ambit. .. Several stable sample plugin directories are available to consult in the; .. :source:`plugins` directory. Other plugin directories can be used as models; .. but are in active development. For documentation on plugin modules, see; .. :ref:`Available Plugins <sec:availablePlugins>`.; .. ; .. * :source:`plugins/aointegrals/aointegrals.cc` ; .. An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; .. ; .. * :source:`plugins/backtrans/backtrans.cc` ; .. A test of the one- and two-particle density matrix backtransformation code.; .. ; .. * :source:`plugins/mointegrals/mointegrals.cc` ; .. An example that uses the LibTrans library to generate and print MO basis integrals.; .. ; .. * :source:`plugins/mollerplesset2/mp2.cc` ; .. A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; .. ; .. * :source:`plugins/sointegrals/sointegrals.cc` ; .. An example that uses the LibMints library to generate a",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:3278,Modifiability,plugin,plugin-template,3278," |PSIfour| will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is ``cd`` into the directory, use |PSIfour| to generate; a Makefile, and type make. Then execute ``psi4`` in the directory on the; default input file. .. code-block:: bash. >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. |PSIfour| comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs::. >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. .. >>> psi4 --plugin-name myplugin --plugin-template ambit. .. Several stable sample plugin directories are available to consult in the; .. :source:`plugins` directory. Other plugin directories can be used as models; .. but are in active development. For documentation on plugin modules, see; .. :ref:`Available Plugins <sec:availablePlugins>`.; .. ; .. * :source:`plugins/aointegrals/aointegrals.cc` ; .. An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; .. ; .. * :source:`plugins/backtrans/backtrans.cc` ; .. A test of the one- and two-particle density matrix backtransformation code.; .. ; .. * :source:`plugins/mointegrals/mointegrals.cc` ; .. An example that uses the LibTrans library to generate and print MO basis integrals.; .. ; .. * :source:`plugins/mollerplesset2/mp2.cc` ; .. A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; .. ; .. * :source:`plugins/sointegrals/sointegrals.cc` ; .. An example that uses the LibMints library to generate a",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:3326,Modifiability,plugin,plugin,3326,"he; plugin. In this example, a directory named myplugin will be created.; All you need to do is ``cd`` into the directory, use |PSIfour| to generate; a Makefile, and type make. Then execute ``psi4`` in the directory on the; default input file. .. code-block:: bash. >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. |PSIfour| comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs::. >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. .. >>> psi4 --plugin-name myplugin --plugin-template ambit. .. Several stable sample plugin directories are available to consult in the; .. :source:`plugins` directory. Other plugin directories can be used as models; .. but are in active development. For documentation on plugin modules, see; .. :ref:`Available Plugins <sec:availablePlugins>`.; .. ; .. * :source:`plugins/aointegrals/aointegrals.cc` ; .. An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; .. ; .. * :source:`plugins/backtrans/backtrans.cc` ; .. A test of the one- and two-particle density matrix backtransformation code.; .. ; .. * :source:`plugins/mointegrals/mointegrals.cc` ; .. An example that uses the LibTrans library to generate and print MO basis integrals.; .. ; .. * :source:`plugins/mollerplesset2/mp2.cc` ; .. A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; .. ; .. * :source:`plugins/sointegrals/sointegrals.cc` ; .. An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. .. _`sec:condaplugins`:.",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:3390,Modifiability,plugin,plugins,3390,"in will be created.; All you need to do is ``cd`` into the directory, use |PSIfour| to generate; a Makefile, and type make. Then execute ``psi4`` in the directory on the; default input file. .. code-block:: bash. >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. |PSIfour| comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs::. >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. .. >>> psi4 --plugin-name myplugin --plugin-template ambit. .. Several stable sample plugin directories are available to consult in the; .. :source:`plugins` directory. Other plugin directories can be used as models; .. but are in active development. For documentation on plugin modules, see; .. :ref:`Available Plugins <sec:availablePlugins>`.; .. ; .. * :source:`plugins/aointegrals/aointegrals.cc` ; .. An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; .. ; .. * :source:`plugins/backtrans/backtrans.cc` ; .. A test of the one- and two-particle density matrix backtransformation code.; .. ; .. * :source:`plugins/mointegrals/mointegrals.cc` ; .. An example that uses the LibTrans library to generate and print MO basis integrals.; .. ; .. * :source:`plugins/mollerplesset2/mp2.cc` ; .. A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; .. ; .. * :source:`plugins/sointegrals/sointegrals.cc` ; .. An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. .. _`sec:condaplugins`:. Creating a New Plugin Using a Conda Pre-compiled Bina",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:3416,Modifiability,plugin,plugin,3416,"is ``cd`` into the directory, use |PSIfour| to generate; a Makefile, and type make. Then execute ``psi4`` in the directory on the; default input file. .. code-block:: bash. >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. |PSIfour| comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs::. >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. .. >>> psi4 --plugin-name myplugin --plugin-template ambit. .. Several stable sample plugin directories are available to consult in the; .. :source:`plugins` directory. Other plugin directories can be used as models; .. but are in active development. For documentation on plugin modules, see; .. :ref:`Available Plugins <sec:availablePlugins>`.; .. ; .. * :source:`plugins/aointegrals/aointegrals.cc` ; .. An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; .. ; .. * :source:`plugins/backtrans/backtrans.cc` ; .. A test of the one- and two-particle density matrix backtransformation code.; .. ; .. * :source:`plugins/mointegrals/mointegrals.cc` ; .. An example that uses the LibTrans library to generate and print MO basis integrals.; .. ; .. * :source:`plugins/mollerplesset2/mp2.cc` ; .. A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; .. ; .. * :source:`plugins/sointegrals/sointegrals.cc` ; .. An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. .. _`sec:condaplugins`:. Creating a New Plugin Using a Conda Pre-compiled Binary; -----------------------------------",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:3513,Modifiability,plugin,plugin,3513,"ake. Then execute ``psi4`` in the directory on the; default input file. .. code-block:: bash. >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. |PSIfour| comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs::. >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. .. >>> psi4 --plugin-name myplugin --plugin-template ambit. .. Several stable sample plugin directories are available to consult in the; .. :source:`plugins` directory. Other plugin directories can be used as models; .. but are in active development. For documentation on plugin modules, see; .. :ref:`Available Plugins <sec:availablePlugins>`.; .. ; .. * :source:`plugins/aointegrals/aointegrals.cc` ; .. An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; .. ; .. * :source:`plugins/backtrans/backtrans.cc` ; .. A test of the one- and two-particle density matrix backtransformation code.; .. ; .. * :source:`plugins/mointegrals/mointegrals.cc` ; .. An example that uses the LibTrans library to generate and print MO basis integrals.; .. ; .. * :source:`plugins/mollerplesset2/mp2.cc` ; .. A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; .. ; .. * :source:`plugins/sointegrals/sointegrals.cc` ; .. An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. .. _`sec:condaplugins`:. Creating a New Plugin Using a Conda Pre-compiled Binary; -------------------------------------------------------. .. # prepare; .. >>> bash; .. >>> export PATH=$PSI4CONDA/",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:3606,Modifiability,plugin,plugins,3606,"plugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. |PSIfour| comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs::. >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. .. >>> psi4 --plugin-name myplugin --plugin-template ambit. .. Several stable sample plugin directories are available to consult in the; .. :source:`plugins` directory. Other plugin directories can be used as models; .. but are in active development. For documentation on plugin modules, see; .. :ref:`Available Plugins <sec:availablePlugins>`.; .. ; .. * :source:`plugins/aointegrals/aointegrals.cc` ; .. An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; .. ; .. * :source:`plugins/backtrans/backtrans.cc` ; .. A test of the one- and two-particle density matrix backtransformation code.; .. ; .. * :source:`plugins/mointegrals/mointegrals.cc` ; .. An example that uses the LibTrans library to generate and print MO basis integrals.; .. ; .. * :source:`plugins/mollerplesset2/mp2.cc` ; .. A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; .. ; .. * :source:`plugins/sointegrals/sointegrals.cc` ; .. An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. .. _`sec:condaplugins`:. Creating a New Plugin Using a Conda Pre-compiled Binary; -------------------------------------------------------. .. # prepare; .. >>> bash; .. >>> export PATH=$PSI4CONDA/bin:$PATH # usually already done from psi4 installation; .. >>> cd ""$(dirname $(which psi4))""/.. # move",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:3765,Modifiability,plugin,plugins,3765,"hat demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets your needs::. >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. .. >>> psi4 --plugin-name myplugin --plugin-template ambit. .. Several stable sample plugin directories are available to consult in the; .. :source:`plugins` directory. Other plugin directories can be used as models; .. but are in active development. For documentation on plugin modules, see; .. :ref:`Available Plugins <sec:availablePlugins>`.; .. ; .. * :source:`plugins/aointegrals/aointegrals.cc` ; .. An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; .. ; .. * :source:`plugins/backtrans/backtrans.cc` ; .. A test of the one- and two-particle density matrix backtransformation code.; .. ; .. * :source:`plugins/mointegrals/mointegrals.cc` ; .. An example that uses the LibTrans library to generate and print MO basis integrals.; .. ; .. * :source:`plugins/mollerplesset2/mp2.cc` ; .. A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; .. ; .. * :source:`plugins/sointegrals/sointegrals.cc` ; .. An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. .. _`sec:condaplugins`:. Creating a New Plugin Using a Conda Pre-compiled Binary; -------------------------------------------------------. .. # prepare; .. >>> bash; .. >>> export PATH=$PSI4CONDA/bin:$PATH # usually already done from psi4 installation; .. >>> cd ""$(dirname $(which psi4))""/.. # move into distribution/environment directory, $PSI4CONDA; .. >>> conda install gcc # install compilers into expected place. |PSIfour| plugins can also be created",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:3898,Modifiability,plugin,plugins,3898,"--plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. .. >>> psi4 --plugin-name myplugin --plugin-template ambit. .. Several stable sample plugin directories are available to consult in the; .. :source:`plugins` directory. Other plugin directories can be used as models; .. but are in active development. For documentation on plugin modules, see; .. :ref:`Available Plugins <sec:availablePlugins>`.; .. ; .. * :source:`plugins/aointegrals/aointegrals.cc` ; .. An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; .. ; .. * :source:`plugins/backtrans/backtrans.cc` ; .. A test of the one- and two-particle density matrix backtransformation code.; .. ; .. * :source:`plugins/mointegrals/mointegrals.cc` ; .. An example that uses the LibTrans library to generate and print MO basis integrals.; .. ; .. * :source:`plugins/mollerplesset2/mp2.cc` ; .. A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; .. ; .. * :source:`plugins/sointegrals/sointegrals.cc` ; .. An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. .. _`sec:condaplugins`:. Creating a New Plugin Using a Conda Pre-compiled Binary; -------------------------------------------------------. .. # prepare; .. >>> bash; .. >>> export PATH=$PSI4CONDA/bin:$PATH # usually already done from psi4 installation; .. >>> cd ""$(dirname $(which psi4))""/.. # move into distribution/environment directory, $PSI4CONDA; .. >>> conda install gcc # install compilers into expected place. |PSIfour| plugins can also be created using Conda for both |PSIfour|; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the ``gcc``; co",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:4043,Modifiability,plugin,plugins,4043,"e sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. .. >>> psi4 --plugin-name myplugin --plugin-template ambit. .. Several stable sample plugin directories are available to consult in the; .. :source:`plugins` directory. Other plugin directories can be used as models; .. but are in active development. For documentation on plugin modules, see; .. :ref:`Available Plugins <sec:availablePlugins>`.; .. ; .. * :source:`plugins/aointegrals/aointegrals.cc` ; .. An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; .. ; .. * :source:`plugins/backtrans/backtrans.cc` ; .. A test of the one- and two-particle density matrix backtransformation code.; .. ; .. * :source:`plugins/mointegrals/mointegrals.cc` ; .. An example that uses the LibTrans library to generate and print MO basis integrals.; .. ; .. * :source:`plugins/mollerplesset2/mp2.cc` ; .. A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; .. ; .. * :source:`plugins/sointegrals/sointegrals.cc` ; .. An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. .. _`sec:condaplugins`:. Creating a New Plugin Using a Conda Pre-compiled Binary; -------------------------------------------------------. .. # prepare; .. >>> bash; .. >>> export PATH=$PSI4CONDA/bin:$PATH # usually already done from psi4 installation; .. >>> cd ""$(dirname $(which psi4))""/.. # move into distribution/environment directory, $PSI4CONDA; .. >>> conda install gcc # install compilers into expected place. |PSIfour| plugins can also be created using Conda for both |PSIfour|; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the ``gcc``; compiler installed alongside ``psi4`` itself in the Conda distribution; or environment (below, ``$PSI4CONDA``). On Mac, one must use; ``libc++.so",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:4081,Modifiability,plugin,plugin,4081,"avefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. .. >>> psi4 --plugin-name myplugin --plugin-template ambit. .. Several stable sample plugin directories are available to consult in the; .. :source:`plugins` directory. Other plugin directories can be used as models; .. but are in active development. For documentation on plugin modules, see; .. :ref:`Available Plugins <sec:availablePlugins>`.; .. ; .. * :source:`plugins/aointegrals/aointegrals.cc` ; .. An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; .. ; .. * :source:`plugins/backtrans/backtrans.cc` ; .. A test of the one- and two-particle density matrix backtransformation code.; .. ; .. * :source:`plugins/mointegrals/mointegrals.cc` ; .. An example that uses the LibTrans library to generate and print MO basis integrals.; .. ; .. * :source:`plugins/mollerplesset2/mp2.cc` ; .. A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; .. ; .. * :source:`plugins/sointegrals/sointegrals.cc` ; .. An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. .. _`sec:condaplugins`:. Creating a New Plugin Using a Conda Pre-compiled Binary; -------------------------------------------------------. .. # prepare; .. >>> bash; .. >>> export PATH=$PSI4CONDA/bin:$PATH # usually already done from psi4 installation; .. >>> cd ""$(dirname $(which psi4))""/.. # move into distribution/environment directory, $PSI4CONDA; .. >>> conda install gcc # install compilers into expected place. |PSIfour| plugins can also be created using Conda for both |PSIfour|; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the ``gcc``; compiler installed alongside ``psi4`` itself in the Conda distribution; or environment (below, ``$PSI4CONDA``). On Mac, one must use; ``libc++.so`` (*not* ``libstdc++.so``), and this can be accomplished by; inst",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:4176,Modifiability,plugin,plugins,4176,"> psi4 --plugin-name myplugin --plugin-template dfmp2. .. >>> psi4 --plugin-name myplugin --plugin-template ambit. .. Several stable sample plugin directories are available to consult in the; .. :source:`plugins` directory. Other plugin directories can be used as models; .. but are in active development. For documentation on plugin modules, see; .. :ref:`Available Plugins <sec:availablePlugins>`.; .. ; .. * :source:`plugins/aointegrals/aointegrals.cc` ; .. An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; .. ; .. * :source:`plugins/backtrans/backtrans.cc` ; .. A test of the one- and two-particle density matrix backtransformation code.; .. ; .. * :source:`plugins/mointegrals/mointegrals.cc` ; .. An example that uses the LibTrans library to generate and print MO basis integrals.; .. ; .. * :source:`plugins/mollerplesset2/mp2.cc` ; .. A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; .. ; .. * :source:`plugins/sointegrals/sointegrals.cc` ; .. An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. .. _`sec:condaplugins`:. Creating a New Plugin Using a Conda Pre-compiled Binary; -------------------------------------------------------. .. # prepare; .. >>> bash; .. >>> export PATH=$PSI4CONDA/bin:$PATH # usually already done from psi4 installation; .. >>> cd ""$(dirname $(which psi4))""/.. # move into distribution/environment directory, $PSI4CONDA; .. >>> conda install gcc # install compilers into expected place. |PSIfour| plugins can also be created using Conda for both |PSIfour|; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the ``gcc``; compiler installed alongside ``psi4`` itself in the Conda distribution; or environment (below, ``$PSI4CONDA``). On Mac, one must use; ``libc++.so`` (*not* ``libstdc++.so``), and this can be accomplished by; installing XCode from the App Store that provides ``clang`` and; ``clang+",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:4746,Modifiability,plugin,plugins,4746,"rans.cc` ; .. A test of the one- and two-particle density matrix backtransformation code.; .. ; .. * :source:`plugins/mointegrals/mointegrals.cc` ; .. An example that uses the LibTrans library to generate and print MO basis integrals.; .. ; .. * :source:`plugins/mollerplesset2/mp2.cc` ; .. A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; .. ; .. * :source:`plugins/sointegrals/sointegrals.cc` ; .. An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. .. _`sec:condaplugins`:. Creating a New Plugin Using a Conda Pre-compiled Binary; -------------------------------------------------------. .. # prepare; .. >>> bash; .. >>> export PATH=$PSI4CONDA/bin:$PATH # usually already done from psi4 installation; .. >>> cd ""$(dirname $(which psi4))""/.. # move into distribution/environment directory, $PSI4CONDA; .. >>> conda install gcc # install compilers into expected place. |PSIfour| plugins can also be created using Conda for both |PSIfour|; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the ``gcc``; compiler installed alongside ``psi4`` itself in the Conda distribution; or environment (below, ``$PSI4CONDA``). On Mac, one must use; ``libc++.so`` (*not* ``libstdc++.so``), and this can be accomplished by; installing XCode from the App Store that provides ``clang`` and; ``clang++`` compilers. * Check environment:. .. code-block:: bash. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. * Create and compile plugin:",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:5781,Modifiability,plugin,plugin,5781,"using Conda for both |PSIfour|; binary and development environment. On Linux (or Ubuntu shell on Windows), one can use the ``gcc``; compiler installed alongside ``psi4`` itself in the Conda distribution; or environment (below, ``$PSI4CONDA``). On Mac, one must use; ``libc++.so`` (*not* ``libstdc++.so``), and this can be accomplished by; installing XCode from the App Store that provides ``clang`` and; ``clang++`` compilers. * Check environment:. .. code-block:: bash. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. * Create and compile plugin:. .. code-block:: bash. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ ",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:5823,Modifiability,plugin,plugin-name,5823,"or Ubuntu shell on Windows), one can use the ``gcc``; compiler installed alongside ``psi4`` itself in the Conda distribution; or environment (below, ``$PSI4CONDA``). On Mac, one must use; ``libc++.so`` (*not* ``libstdc++.so``), and this can be accomplished by; installing XCode from the App Store that provides ``clang`` and; ``clang++`` compilers. * Check environment:. .. code-block:: bash. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. * Create and compile plugin:. .. code-block:: bash. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplu",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:5926,Modifiability,plugin,plugin,5926," ``psi4`` itself in the Conda distribution; or environment (below, ``$PSI4CONDA``). On Mac, one must use; ``libc++.so`` (*not* ``libstdc++.so``), and this can be accomplished by; installing XCode from the App Store that provides ``clang`` and; ``clang++`` compilers. * Check environment:. .. code-block:: bash. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. * Create and compile plugin:. .. code-block:: bash. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencie",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:6015,Modifiability,plugin,plugin,6015,". On Mac, one must use; ``libc++.so`` (*not* ``libstdc++.so``), and this can be accomplished by; installing XCode from the App Store that provides ``clang`` and; ``clang++`` compilers. * Check environment:. .. code-block:: bash. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. * Create and compile plugin:. .. code-block:: bash. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plug",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:6051,Modifiability,plugin,plugin,6051,"`libstdc++.so``), and this can be accomplished by; installing XCode from the App Store that provides ``clang`` and; ``clang++`` compilers. * Check environment:. .. code-block:: bash. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. * Create and compile plugin:. .. code-block:: bash. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testp",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:6090,Modifiability,config,configure,6090,"clang`` and; ``clang++`` compilers. * Check environment:. .. code-block:: bash. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. * Create and compile plugin:. .. code-block:: bash. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:6147,Modifiability,plugin,plugin-compile,6147,"clang`` and; ``clang++`` compilers. * Check environment:. .. code-block:: bash. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. * Create and compile plugin:. .. code-block:: bash. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:6504,Modifiability,plugin,plugin-compile,6504,"n/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. * Create and compile plugin:. .. code-block:: bash. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in ``$PATH`` or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory; ---------------------------. In addition to the main ``myplugin.cc`` file, a fresh plugin directory contains the followi",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:6872,Modifiability,plugin,plugin,6872,"asic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in ``$PATH`` or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory; ---------------------------. In addition to the main ``myplugin.cc`` file, a fresh plugin directory contains the following files. * **CMakeLists.txt** |w---w| CMake file governing project *plugin*.; The plugin source and CMakeLists.txt is independent of platform; and |PSIfour| installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; |PSIfour| installation. Run ``psi4 --plugin-compile`` to get a command; to execute to gener",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:7012,Modifiability,plugin,plugin,7012,", plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in ``$PATH`` or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory; ---------------------------. In addition to the main ``myplugin.cc`` file, a fresh plugin directory contains the following files. * **CMakeLists.txt** |w---w| CMake file governing project *plugin*.; The plugin source and CMakeLists.txt is independent of platform; and |PSIfour| installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; |PSIfour| installation. Run ``psi4 --plugin-compile`` to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent |PSIfour|; (the ``-C psi4Pl",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:7323,Modifiability,plugin,plugins,7323,"identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in ``$PATH`` or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory; ---------------------------. In addition to the main ``myplugin.cc`` file, a fresh plugin directory contains the following files. * **CMakeLists.txt** |w---w| CMake file governing project *plugin*.; The plugin source and CMakeLists.txt is independent of platform; and |PSIfour| installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; |PSIfour| installation. Run ``psi4 --plugin-compile`` to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent |PSIfour|; (the ``-C psi4PluginCache`` part) which in turn can be overridden; by passing ``-Doption=value`` commands to ``cmake`` *and* pointing; toward a particular |PSIfour| (and probably pybind11) library to; link against (the ``CMAKE_PREFIX_PATH`` part) *and* telling it to; do an",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:7473,Modifiability,plugin,plugin,7473,"ugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in ``$PATH`` or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory; ---------------------------. In addition to the main ``myplugin.cc`` file, a fresh plugin directory contains the following files. * **CMakeLists.txt** |w---w| CMake file governing project *plugin*.; The plugin source and CMakeLists.txt is independent of platform; and |PSIfour| installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; |PSIfour| installation. Run ``psi4 --plugin-compile`` to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent |PSIfour|; (the ``-C psi4PluginCache`` part) which in turn can be overridden; by passing ``-Doption=value`` commands to ``cmake`` *and* pointing; toward a particular |PSIfour| (and probably pybind11) library to; link against (the ``CMAKE_PREFIX_PATH`` part) *and* telling it to; do an in-source build (the ``.`` part). Then just run ``make`` in; your plugin directory. After any change to the plugin C++ code,; ``make`` must be run in the plugin directory to recompile the; ``myplugin.so`` executable",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:7579,Modifiability,plugin,plugin,7579,"NDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in ``$PATH`` or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory; ---------------------------. In addition to the main ``myplugin.cc`` file, a fresh plugin directory contains the following files. * **CMakeLists.txt** |w---w| CMake file governing project *plugin*.; The plugin source and CMakeLists.txt is independent of platform; and |PSIfour| installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; |PSIfour| installation. Run ``psi4 --plugin-compile`` to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent |PSIfour|; (the ``-C psi4PluginCache`` part) which in turn can be overridden; by passing ``-Doption=value`` commands to ``cmake`` *and* pointing; toward a particular |PSIfour| (and probably pybind11) library to; link against (the ``CMAKE_PREFIX_PATH`` part) *and* telling it to; do an in-source build (the ``.`` part). Then just run ``make`` in; your plugin directory. After any change to the plugin C++ code,; ``make`` must be run in the plugin directory to recompile the; ``myplugin.so`` executable, but recompiling the main |PSIfour| code; is not necessary. Should you ad",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:7593,Modifiability,plugin,plugin,7593," -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in ``$PATH`` or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory; ---------------------------. In addition to the main ``myplugin.cc`` file, a fresh plugin directory contains the following files. * **CMakeLists.txt** |w---w| CMake file governing project *plugin*.; The plugin source and CMakeLists.txt is independent of platform; and |PSIfour| installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; |PSIfour| installation. Run ``psi4 --plugin-compile`` to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent |PSIfour|; (the ``-C psi4PluginCache`` part) which in turn can be overridden; by passing ``-Doption=value`` commands to ``cmake`` *and* pointing; toward a particular |PSIfour| (and probably pybind11) library to; link against (the ``CMAKE_PREFIX_PATH`` part) *and* telling it to; do an in-source build (the ``.`` part). Then just run ``make`` in; your plugin directory. After any change to the plugin C++ code,; ``make`` must be run in the plugin directory to recompile the; ``myplugin.so`` executable, but recompiling the main |PSIfour| code; is not necessary. Should you add additional (non-header) files to; the plug",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:7751,Modifiability,plugin,plugin,7751,"sr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in ``$PATH`` or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory; ---------------------------. In addition to the main ``myplugin.cc`` file, a fresh plugin directory contains the following files. * **CMakeLists.txt** |w---w| CMake file governing project *plugin*.; The plugin source and CMakeLists.txt is independent of platform; and |PSIfour| installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; |PSIfour| installation. Run ``psi4 --plugin-compile`` to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent |PSIfour|; (the ``-C psi4PluginCache`` part) which in turn can be overridden; by passing ``-Doption=value`` commands to ``cmake`` *and* pointing; toward a particular |PSIfour| (and probably pybind11) library to; link against (the ``CMAKE_PREFIX_PATH`` part) *and* telling it to; do an in-source build (the ``.`` part). Then just run ``make`` in; your plugin directory. After any change to the plugin C++ code,; ``make`` must be run in the plugin directory to recompile the; ``myplugin.so`` executable, but recompiling the main |PSIfour| code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here. * **input.dat** |w---w| Sample input file for the plugin.; Since the ``__",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:7825,Modifiability,plugin,plugin-compile,7825,"gin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in ``$PATH`` or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory; ---------------------------. In addition to the main ``myplugin.cc`` file, a fresh plugin directory contains the following files. * **CMakeLists.txt** |w---w| CMake file governing project *plugin*.; The plugin source and CMakeLists.txt is independent of platform; and |PSIfour| installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; |PSIfour| installation. Run ``psi4 --plugin-compile`` to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent |PSIfour|; (the ``-C psi4PluginCache`` part) which in turn can be overridden; by passing ``-Doption=value`` commands to ``cmake`` *and* pointing; toward a particular |PSIfour| (and probably pybind11) library to; link against (the ``CMAKE_PREFIX_PATH`` part) *and* telling it to; do an in-source build (the ``.`` part). Then just run ``make`` in; your plugin directory. After any change to the plugin C++ code,; ``make`` must be run in the plugin directory to recompile the; ``myplugin.so`` executable, but recompiling the main |PSIfour| code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here. * **input.dat** |w---w| Sample input file for the plugin.; Since the ``__init__.py`` file makes the plugin directory look like a; Python module, the plugin can be treat",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:8338,Modifiability,plugin,plugin,8338," created using this procedure. Files in a Plugin Directory; ---------------------------. In addition to the main ``myplugin.cc`` file, a fresh plugin directory contains the following files. * **CMakeLists.txt** |w---w| CMake file governing project *plugin*.; The plugin source and CMakeLists.txt is independent of platform; and |PSIfour| installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; |PSIfour| installation. Run ``psi4 --plugin-compile`` to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent |PSIfour|; (the ``-C psi4PluginCache`` part) which in turn can be overridden; by passing ``-Doption=value`` commands to ``cmake`` *and* pointing; toward a particular |PSIfour| (and probably pybind11) library to; link against (the ``CMAKE_PREFIX_PATH`` part) *and* telling it to; do an in-source build (the ``.`` part). Then just run ``make`` in; your plugin directory. After any change to the plugin C++ code,; ``make`` must be run in the plugin directory to recompile the; ``myplugin.so`` executable, but recompiling the main |PSIfour| code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here. * **input.dat** |w---w| Sample input file for the plugin.; Since the ``__init__.py`` file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in :envvar:`PYTHONPATH`,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating :envvar:`PSIPATH`. Then,; the plugin can be loaded as ``import myplugin`` and executed as; ``energy('myplugin')``. Any other Python functions are also available from; the input file, *e.g.* ``myplugin.testfunction()``, note the namespace; protection. * **pymo",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:8380,Modifiability,plugin,plugin,8380,"----. In addition to the main ``myplugin.cc`` file, a fresh plugin directory contains the following files. * **CMakeLists.txt** |w---w| CMake file governing project *plugin*.; The plugin source and CMakeLists.txt is independent of platform; and |PSIfour| installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; |PSIfour| installation. Run ``psi4 --plugin-compile`` to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent |PSIfour|; (the ``-C psi4PluginCache`` part) which in turn can be overridden; by passing ``-Doption=value`` commands to ``cmake`` *and* pointing; toward a particular |PSIfour| (and probably pybind11) library to; link against (the ``CMAKE_PREFIX_PATH`` part) *and* telling it to; do an in-source build (the ``.`` part). Then just run ``make`` in; your plugin directory. After any change to the plugin C++ code,; ``make`` must be run in the plugin directory to recompile the; ``myplugin.so`` executable, but recompiling the main |PSIfour| code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here. * **input.dat** |w---w| Sample input file for the plugin.; Since the ``__init__.py`` file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in :envvar:`PYTHONPATH`,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating :envvar:`PSIPATH`. Then,; the plugin can be loaded as ``import myplugin`` and executed as; ``energy('myplugin')``. Any other Python functions are also available from; the input file, *e.g.* ``myplugin.testfunction()``, note the namespace; protection. * **pymodule.py** |w---w| Python component of the plugin.; By encoding the sequence of |PSIf",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:8426,Modifiability,plugin,plugin,8426,"----. In addition to the main ``myplugin.cc`` file, a fresh plugin directory contains the following files. * **CMakeLists.txt** |w---w| CMake file governing project *plugin*.; The plugin source and CMakeLists.txt is independent of platform; and |PSIfour| installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; |PSIfour| installation. Run ``psi4 --plugin-compile`` to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent |PSIfour|; (the ``-C psi4PluginCache`` part) which in turn can be overridden; by passing ``-Doption=value`` commands to ``cmake`` *and* pointing; toward a particular |PSIfour| (and probably pybind11) library to; link against (the ``CMAKE_PREFIX_PATH`` part) *and* telling it to; do an in-source build (the ``.`` part). Then just run ``make`` in; your plugin directory. After any change to the plugin C++ code,; ``make`` must be run in the plugin directory to recompile the; ``myplugin.so`` executable, but recompiling the main |PSIfour| code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here. * **input.dat** |w---w| Sample input file for the plugin.; Since the ``__init__.py`` file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in :envvar:`PYTHONPATH`,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating :envvar:`PSIPATH`. Then,; the plugin can be loaded as ``import myplugin`` and executed as; ``energy('myplugin')``. Any other Python functions are also available from; the input file, *e.g.* ``myplugin.testfunction()``, note the namespace; protection. * **pymodule.py** |w---w| Python component of the plugin.; By encoding the sequence of |PSIf",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:8601,Modifiability,plugin,plugin,8601,"Lists.txt is independent of platform; and |PSIfour| installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; |PSIfour| installation. Run ``psi4 --plugin-compile`` to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent |PSIfour|; (the ``-C psi4PluginCache`` part) which in turn can be overridden; by passing ``-Doption=value`` commands to ``cmake`` *and* pointing; toward a particular |PSIfour| (and probably pybind11) library to; link against (the ``CMAKE_PREFIX_PATH`` part) *and* telling it to; do an in-source build (the ``.`` part). Then just run ``make`` in; your plugin directory. After any change to the plugin C++ code,; ``make`` must be run in the plugin directory to recompile the; ``myplugin.so`` executable, but recompiling the main |PSIfour| code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here. * **input.dat** |w---w| Sample input file for the plugin.; Since the ``__init__.py`` file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in :envvar:`PYTHONPATH`,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating :envvar:`PSIPATH`. Then,; the plugin can be loaded as ``import myplugin`` and executed as; ``energy('myplugin')``. Any other Python functions are also available from; the input file, *e.g.* ``myplugin.testfunction()``, note the namespace; protection. * **pymodule.py** |w---w| Python component of the plugin.; By encoding the sequence of |PSIfour| module; calls needed to run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be a",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:8736,Modifiability,plugin,plugin,8736," to generate a Makefile for the plugin by pointing it to a specific; |PSIfour| installation. Run ``psi4 --plugin-compile`` to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent |PSIfour|; (the ``-C psi4PluginCache`` part) which in turn can be overridden; by passing ``-Doption=value`` commands to ``cmake`` *and* pointing; toward a particular |PSIfour| (and probably pybind11) library to; link against (the ``CMAKE_PREFIX_PATH`` part) *and* telling it to; do an in-source build (the ``.`` part). Then just run ``make`` in; your plugin directory. After any change to the plugin C++ code,; ``make`` must be run in the plugin directory to recompile the; ``myplugin.so`` executable, but recompiling the main |PSIfour| code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here. * **input.dat** |w---w| Sample input file for the plugin.; Since the ``__init__.py`` file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in :envvar:`PYTHONPATH`,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating :envvar:`PSIPATH`. Then,; the plugin can be loaded as ``import myplugin`` and executed as; ``energy('myplugin')``. Any other Python functions are also available from; the input file, *e.g.* ``myplugin.testfunction()``, note the namespace; protection. * **pymodule.py** |w---w| Python component of the plugin.; By encoding the sequence of |PSIfour| module; calls needed to run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:8786,Modifiability,plugin,plugin,8786,"-plugin-compile`` to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent |PSIfour|; (the ``-C psi4PluginCache`` part) which in turn can be overridden; by passing ``-Doption=value`` commands to ``cmake`` *and* pointing; toward a particular |PSIfour| (and probably pybind11) library to; link against (the ``CMAKE_PREFIX_PATH`` part) *and* telling it to; do an in-source build (the ``.`` part). Then just run ``make`` in; your plugin directory. After any change to the plugin C++ code,; ``make`` must be run in the plugin directory to recompile the; ``myplugin.so`` executable, but recompiling the main |PSIfour| code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here. * **input.dat** |w---w| Sample input file for the plugin.; Since the ``__init__.py`` file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in :envvar:`PYTHONPATH`,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating :envvar:`PSIPATH`. Then,; the plugin can be loaded as ``import myplugin`` and executed as; ``energy('myplugin')``. Any other Python functions are also available from; the input file, *e.g.* ``myplugin.testfunction()``, note the namespace; protection. * **pymodule.py** |w---w| Python component of the plugin.; By encoding the sequence of |PSIfour| module; calls needed to run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:8835,Modifiability,plugin,plugin,8835,"-plugin-compile`` to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent |PSIfour|; (the ``-C psi4PluginCache`` part) which in turn can be overridden; by passing ``-Doption=value`` commands to ``cmake`` *and* pointing; toward a particular |PSIfour| (and probably pybind11) library to; link against (the ``CMAKE_PREFIX_PATH`` part) *and* telling it to; do an in-source build (the ``.`` part). Then just run ``make`` in; your plugin directory. After any change to the plugin C++ code,; ``make`` must be run in the plugin directory to recompile the; ``myplugin.so`` executable, but recompiling the main |PSIfour| code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here. * **input.dat** |w---w| Sample input file for the plugin.; Since the ``__init__.py`` file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in :envvar:`PYTHONPATH`,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating :envvar:`PSIPATH`. Then,; the plugin can be loaded as ``import myplugin`` and executed as; ``energy('myplugin')``. Any other Python functions are also available from; the input file, *e.g.* ``myplugin.testfunction()``, note the namespace; protection. * **pymodule.py** |w---w| Python component of the plugin.; By encoding the sequence of |PSIfour| module; calls needed to run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:8904,Modifiability,plugin,plugin,8904,"ions used to build the parent |PSIfour|; (the ``-C psi4PluginCache`` part) which in turn can be overridden; by passing ``-Doption=value`` commands to ``cmake`` *and* pointing; toward a particular |PSIfour| (and probably pybind11) library to; link against (the ``CMAKE_PREFIX_PATH`` part) *and* telling it to; do an in-source build (the ``.`` part). Then just run ``make`` in; your plugin directory. After any change to the plugin C++ code,; ``make`` must be run in the plugin directory to recompile the; ``myplugin.so`` executable, but recompiling the main |PSIfour| code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here. * **input.dat** |w---w| Sample input file for the plugin.; Since the ``__init__.py`` file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in :envvar:`PYTHONPATH`,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating :envvar:`PSIPATH`. Then,; the plugin can be loaded as ``import myplugin`` and executed as; ``energy('myplugin')``. Any other Python functions are also available from; the input file, *e.g.* ``myplugin.testfunction()``, note the namespace; protection. * **pymodule.py** |w---w| Python component of the plugin.; By encoding the sequence of |PSIfour| module; calls needed to run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won't; need editing unless additional Python files are added to the plugin; direc",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:9101,Modifiability,plugin,plugin,9101,"rd a particular |PSIfour| (and probably pybind11) library to; link against (the ``CMAKE_PREFIX_PATH`` part) *and* telling it to; do an in-source build (the ``.`` part). Then just run ``make`` in; your plugin directory. After any change to the plugin C++ code,; ``make`` must be run in the plugin directory to recompile the; ``myplugin.so`` executable, but recompiling the main |PSIfour| code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here. * **input.dat** |w---w| Sample input file for the plugin.; Since the ``__init__.py`` file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in :envvar:`PYTHONPATH`,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating :envvar:`PSIPATH`. Then,; the plugin can be loaded as ``import myplugin`` and executed as; ``energy('myplugin')``. Any other Python functions are also available from; the input file, *e.g.* ``myplugin.testfunction()``, note the namespace; protection. * **pymodule.py** |w---w| Python component of the plugin.; By encoding the sequence of |PSIfour| module; calls needed to run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won't; need editing unless additional Python files are added to the plugin; directory (add additional lines to the ``# Load Python modules`` section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to ",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:9372,Modifiability,plugin,plugin,9372,"fter any change to the plugin C++ code,; ``make`` must be run in the plugin directory to recompile the; ``myplugin.so`` executable, but recompiling the main |PSIfour| code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here. * **input.dat** |w---w| Sample input file for the plugin.; Since the ``__init__.py`` file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in :envvar:`PYTHONPATH`,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating :envvar:`PSIPATH`. Then,; the plugin can be loaded as ``import myplugin`` and executed as; ``energy('myplugin')``. Any other Python functions are also available from; the input file, *e.g.* ``myplugin.testfunction()``, note the namespace; protection. * **pymodule.py** |w---w| Python component of the plugin.; By encoding the sequence of |PSIfour| module; calls needed to run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won't; need editing unless additional Python files are added to the plugin; directory (add additional lines to the ``# Load Python modules`` section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the ``# Load C++ plugin`` section). .. comment as modeled in :source:`tests/plugin_libcim/__init__.py`). .. literalinclude:: @SFNX_INCLUDE@psi4/share/psi4/plugin/__init__.py.template. * *",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:9451,Modifiability,plugin,plugin,9451,"table, but recompiling the main |PSIfour| code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here. * **input.dat** |w---w| Sample input file for the plugin.; Since the ``__init__.py`` file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in :envvar:`PYTHONPATH`,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating :envvar:`PSIPATH`. Then,; the plugin can be loaded as ``import myplugin`` and executed as; ``energy('myplugin')``. Any other Python functions are also available from; the input file, *e.g.* ``myplugin.testfunction()``, note the namespace; protection. * **pymodule.py** |w---w| Python component of the plugin.; By encoding the sequence of |PSIfour| module; calls needed to run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won't; need editing unless additional Python files are added to the plugin; directory (add additional lines to the ``# Load Python modules`` section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the ``# Load C++ plugin`` section). .. comment as modeled in :source:`tests/plugin_libcim/__init__.py`). .. literalinclude:: @SFNX_INCLUDE@psi4/share/psi4/plugin/__init__.py.template. * **doc.rst** |w---w| Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, *etc.*. Plain ",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:9512,Modifiability,plugin,plugin,9512,"table, but recompiling the main |PSIfour| code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here. * **input.dat** |w---w| Sample input file for the plugin.; Since the ``__init__.py`` file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in :envvar:`PYTHONPATH`,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating :envvar:`PSIPATH`. Then,; the plugin can be loaded as ``import myplugin`` and executed as; ``energy('myplugin')``. Any other Python functions are also available from; the input file, *e.g.* ``myplugin.testfunction()``, note the namespace; protection. * **pymodule.py** |w---w| Python component of the plugin.; By encoding the sequence of |PSIfour| module; calls needed to run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won't; need editing unless additional Python files are added to the plugin; directory (add additional lines to the ``# Load Python modules`` section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the ``# Load C++ plugin`` section). .. comment as modeled in :source:`tests/plugin_libcim/__init__.py`). .. literalinclude:: @SFNX_INCLUDE@psi4/share/psi4/plugin/__init__.py.template. * **doc.rst** |w---w| Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, *etc.*. Plain ",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:9781,Modifiability,plugin,plugin,9781,"y look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in :envvar:`PYTHONPATH`,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating :envvar:`PSIPATH`. Then,; the plugin can be loaded as ``import myplugin`` and executed as; ``energy('myplugin')``. Any other Python functions are also available from; the input file, *e.g.* ``myplugin.testfunction()``, note the namespace; protection. * **pymodule.py** |w---w| Python component of the plugin.; By encoding the sequence of |PSIfour| module; calls needed to run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won't; need editing unless additional Python files are added to the plugin; directory (add additional lines to the ``# Load Python modules`` section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the ``# Load C++ plugin`` section). .. comment as modeled in :source:`tests/plugin_libcim/__init__.py`). .. literalinclude:: @SFNX_INCLUDE@psi4/share/psi4/plugin/__init__.py.template. * **doc.rst** |w---w| Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, *etc.*. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the ``.. comment``; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the |PSIfour|; documentation, along with any docstrings to Python functions, and the C++; keywords block in the ``",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:9818,Modifiability,plugin,plugin,9818,"y look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in :envvar:`PYTHONPATH`,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating :envvar:`PSIPATH`. Then,; the plugin can be loaded as ``import myplugin`` and executed as; ``energy('myplugin')``. Any other Python functions are also available from; the input file, *e.g.* ``myplugin.testfunction()``, note the namespace; protection. * **pymodule.py** |w---w| Python component of the plugin.; By encoding the sequence of |PSIfour| module; calls needed to run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won't; need editing unless additional Python files are added to the plugin; directory (add additional lines to the ``# Load Python modules`` section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the ``# Load C++ plugin`` section). .. comment as modeled in :source:`tests/plugin_libcim/__init__.py`). .. literalinclude:: @SFNX_INCLUDE@psi4/share/psi4/plugin/__init__.py.template. * **doc.rst** |w---w| Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, *etc.*. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the ``.. comment``; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the |PSIfour|; documentation, along with any docstrings to Python functions, and the C++; keywords block in the ``",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:9944,Modifiability,plugin,plugin,9944,"ONPATH`,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating :envvar:`PSIPATH`. Then,; the plugin can be loaded as ``import myplugin`` and executed as; ``energy('myplugin')``. Any other Python functions are also available from; the input file, *e.g.* ``myplugin.testfunction()``, note the namespace; protection. * **pymodule.py** |w---w| Python component of the plugin.; By encoding the sequence of |PSIfour| module; calls needed to run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won't; need editing unless additional Python files are added to the plugin; directory (add additional lines to the ``# Load Python modules`` section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the ``# Load C++ plugin`` section). .. comment as modeled in :source:`tests/plugin_libcim/__init__.py`). .. literalinclude:: @SFNX_INCLUDE@psi4/share/psi4/plugin/__init__.py.template. * **doc.rst** |w---w| Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, *etc.*. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the ``.. comment``; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the |PSIfour|; documentation, along with any docstrings to Python functions, and the C++; keywords block in the ``myplugin.cc`` file. See :ref:`sec:documentation`; for building documentation. .. and :ref:`Available Plugins <sec:availablePlugins>`; .. for this file's",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:10034,Modifiability,plugin,plugin,10034,"ONPATH`,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating :envvar:`PSIPATH`. Then,; the plugin can be loaded as ``import myplugin`` and executed as; ``energy('myplugin')``. Any other Python functions are also available from; the input file, *e.g.* ``myplugin.testfunction()``, note the namespace; protection. * **pymodule.py** |w---w| Python component of the plugin.; By encoding the sequence of |PSIfour| module; calls needed to run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won't; need editing unless additional Python files are added to the plugin; directory (add additional lines to the ``# Load Python modules`` section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the ``# Load C++ plugin`` section). .. comment as modeled in :source:`tests/plugin_libcim/__init__.py`). .. literalinclude:: @SFNX_INCLUDE@psi4/share/psi4/plugin/__init__.py.template. * **doc.rst** |w---w| Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, *etc.*. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the ``.. comment``; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the |PSIfour|; documentation, along with any docstrings to Python functions, and the C++; keywords block in the ``myplugin.cc`` file. See :ref:`sec:documentation`; for building documentation. .. and :ref:`Available Plugins <sec:availablePlugins>`; .. for this file's",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:10071,Modifiability,plugin,plugin,10071,"port myplugin`` and executed as; ``energy('myplugin')``. Any other Python functions are also available from; the input file, *e.g.* ``myplugin.testfunction()``, note the namespace; protection. * **pymodule.py** |w---w| Python component of the plugin.; By encoding the sequence of |PSIfour| module; calls needed to run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won't; need editing unless additional Python files are added to the plugin; directory (add additional lines to the ``# Load Python modules`` section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the ``# Load C++ plugin`` section). .. comment as modeled in :source:`tests/plugin_libcim/__init__.py`). .. literalinclude:: @SFNX_INCLUDE@psi4/share/psi4/plugin/__init__.py.template. * **doc.rst** |w---w| Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, *etc.*. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the ``.. comment``; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the |PSIfour|; documentation, along with any docstrings to Python functions, and the C++; keywords block in the ``myplugin.cc`` file. See :ref:`sec:documentation`; for building documentation. .. and :ref:`Available Plugins <sec:availablePlugins>`; .. for this file's final destination. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded. To create a purely Python plugin, create",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:10149,Modifiability,plugin,plugin,10149,"port myplugin`` and executed as; ``energy('myplugin')``. Any other Python functions are also available from; the input file, *e.g.* ``myplugin.testfunction()``, note the namespace; protection. * **pymodule.py** |w---w| Python component of the plugin.; By encoding the sequence of |PSIfour| module; calls needed to run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won't; need editing unless additional Python files are added to the plugin; directory (add additional lines to the ``# Load Python modules`` section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the ``# Load C++ plugin`` section). .. comment as modeled in :source:`tests/plugin_libcim/__init__.py`). .. literalinclude:: @SFNX_INCLUDE@psi4/share/psi4/plugin/__init__.py.template. * **doc.rst** |w---w| Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, *etc.*. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the ``.. comment``; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the |PSIfour|; documentation, along with any docstrings to Python functions, and the C++; keywords block in the ``myplugin.cc`` file. See :ref:`sec:documentation`; for building documentation. .. and :ref:`Available Plugins <sec:availablePlugins>`; .. for this file's final destination. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded. To create a purely Python plugin, create",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:10187,Modifiability,plugin,plugin,10187,"port myplugin`` and executed as; ``energy('myplugin')``. Any other Python functions are also available from; the input file, *e.g.* ``myplugin.testfunction()``, note the namespace; protection. * **pymodule.py** |w---w| Python component of the plugin.; By encoding the sequence of |PSIfour| module; calls needed to run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won't; need editing unless additional Python files are added to the plugin; directory (add additional lines to the ``# Load Python modules`` section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the ``# Load C++ plugin`` section). .. comment as modeled in :source:`tests/plugin_libcim/__init__.py`). .. literalinclude:: @SFNX_INCLUDE@psi4/share/psi4/plugin/__init__.py.template. * **doc.rst** |w---w| Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, *etc.*. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the ``.. comment``; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the |PSIfour|; documentation, along with any docstrings to Python functions, and the C++; keywords block in the ``myplugin.cc`` file. See :ref:`sec:documentation`; for building documentation. .. and :ref:`Available Plugins <sec:availablePlugins>`; .. for this file's final destination. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded. To create a purely Python plugin, create",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:10325,Modifiability,plugin,plugin,10325," protection. * **pymodule.py** |w---w| Python component of the plugin.; By encoding the sequence of |PSIfour| module; calls needed to run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won't; need editing unless additional Python files are added to the plugin; directory (add additional lines to the ``# Load Python modules`` section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the ``# Load C++ plugin`` section). .. comment as modeled in :source:`tests/plugin_libcim/__init__.py`). .. literalinclude:: @SFNX_INCLUDE@psi4/share/psi4/plugin/__init__.py.template. * **doc.rst** |w---w| Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, *etc.*. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the ``.. comment``; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the |PSIfour|; documentation, along with any docstrings to Python functions, and the C++; keywords block in the ``myplugin.cc`` file. See :ref:`sec:documentation`; for building documentation. .. and :ref:`Available Plugins <sec:availablePlugins>`; .. for this file's final destination. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded. To create a purely Python plugin, create a new plugin directory, then; remove the ``Makefile`` and ``myplugin.cc`` files and; erase the shared object loading portion of ``__init__.py``. Create as many .py; files as neces",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:11019,Modifiability,plugin,plugin,11019,"o run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won't; need editing unless additional Python files are added to the plugin; directory (add additional lines to the ``# Load Python modules`` section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the ``# Load C++ plugin`` section). .. comment as modeled in :source:`tests/plugin_libcim/__init__.py`). .. literalinclude:: @SFNX_INCLUDE@psi4/share/psi4/plugin/__init__.py.template. * **doc.rst** |w---w| Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, *etc.*. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the ``.. comment``; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the |PSIfour|; documentation, along with any docstrings to Python functions, and the C++; keywords block in the ``myplugin.cc`` file. See :ref:`sec:documentation`; for building documentation. .. and :ref:`Available Plugins <sec:availablePlugins>`; .. for this file's final destination. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded. To create a purely Python plugin, create a new plugin directory, then; remove the ``Makefile`` and ``myplugin.cc`` files and; erase the shared object loading portion of ``__init__.py``. Create as many .py; files as necessary (registering each one in ``__init__.py``), use; ``input.dat`` as a model for loading the plugin, no recompile ever; necessary. ",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:11071,Modifiability,plugin,plugin,11071,"o run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won't; need editing unless additional Python files are added to the plugin; directory (add additional lines to the ``# Load Python modules`` section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the ``# Load C++ plugin`` section). .. comment as modeled in :source:`tests/plugin_libcim/__init__.py`). .. literalinclude:: @SFNX_INCLUDE@psi4/share/psi4/plugin/__init__.py.template. * **doc.rst** |w---w| Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, *etc.*. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the ``.. comment``; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the |PSIfour|; documentation, along with any docstrings to Python functions, and the C++; keywords block in the ``myplugin.cc`` file. See :ref:`sec:documentation`; for building documentation. .. and :ref:`Available Plugins <sec:availablePlugins>`; .. for this file's final destination. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded. To create a purely Python plugin, create a new plugin directory, then; remove the ``Makefile`` and ``myplugin.cc`` files and; erase the shared object loading portion of ``__init__.py``. Create as many .py; files as necessary (registering each one in ``__init__.py``), use; ``input.dat`` as a model for loading the plugin, no recompile ever; necessary. ",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:11115,Modifiability,plugin,plugin,11115,"o run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won't; need editing unless additional Python files are added to the plugin; directory (add additional lines to the ``# Load Python modules`` section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the ``# Load C++ plugin`` section). .. comment as modeled in :source:`tests/plugin_libcim/__init__.py`). .. literalinclude:: @SFNX_INCLUDE@psi4/share/psi4/plugin/__init__.py.template. * **doc.rst** |w---w| Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, *etc.*. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the ``.. comment``; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the |PSIfour|; documentation, along with any docstrings to Python functions, and the C++; keywords block in the ``myplugin.cc`` file. See :ref:`sec:documentation`; for building documentation. .. and :ref:`Available Plugins <sec:availablePlugins>`; .. for this file's final destination. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded. To create a purely Python plugin, create a new plugin directory, then; remove the ``Makefile`` and ``myplugin.cc`` files and; erase the shared object loading portion of ``__init__.py``. Create as many .py; files as necessary (registering each one in ``__init__.py``), use; ``input.dat`` as a model for loading the plugin, no recompile ever; necessary. ",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:11136,Modifiability,plugin,plugin,11136,"o run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won't; need editing unless additional Python files are added to the plugin; directory (add additional lines to the ``# Load Python modules`` section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the ``# Load C++ plugin`` section). .. comment as modeled in :source:`tests/plugin_libcim/__init__.py`). .. literalinclude:: @SFNX_INCLUDE@psi4/share/psi4/plugin/__init__.py.template. * **doc.rst** |w---w| Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, *etc.*. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the ``.. comment``; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the |PSIfour|; documentation, along with any docstrings to Python functions, and the C++; keywords block in the ``myplugin.cc`` file. See :ref:`sec:documentation`; for building documentation. .. and :ref:`Available Plugins <sec:availablePlugins>`; .. for this file's final destination. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded. To create a purely Python plugin, create a new plugin directory, then; remove the ``Makefile`` and ``myplugin.cc`` files and; erase the shared object loading portion of ``__init__.py``. Create as many .py; files as necessary (registering each one in ``__init__.py``), use; ``input.dat`` as a model for loading the plugin, no recompile ever; necessary. ",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:11403,Modifiability,plugin,plugin,11403,"o run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won't; need editing unless additional Python files are added to the plugin; directory (add additional lines to the ``# Load Python modules`` section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the ``# Load C++ plugin`` section). .. comment as modeled in :source:`tests/plugin_libcim/__init__.py`). .. literalinclude:: @SFNX_INCLUDE@psi4/share/psi4/plugin/__init__.py.template. * **doc.rst** |w---w| Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, *etc.*. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the ``.. comment``; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the |PSIfour|; documentation, along with any docstrings to Python functions, and the C++; keywords block in the ``myplugin.cc`` file. See :ref:`sec:documentation`; for building documentation. .. and :ref:`Available Plugins <sec:availablePlugins>`; .. for this file's final destination. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded. To create a purely Python plugin, create a new plugin directory, then; remove the ``Makefile`` and ``myplugin.cc`` files and; erase the shared object loading portion of ``__init__.py``. Create as many .py; files as necessary (registering each one in ``__init__.py``), use; ``input.dat`` as a model for loading the plugin, no recompile ever; necessary. ",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:1852,Performance,load,loaded,1852,"h Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:plugins`:. Creating New Plugins; ====================. Modular Approach to Development; -------------------------------. It is slightly cumbersome to the development cycle to recompile |PSIfour|; every time a change is made to the C++ code.; It's also daunting to new developers if they're required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, |PSIfour| now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi's vast library. The plugins can be loaded at; run-time from any location. .. _`sec:newplugins`:. Creating a New Plugin; ---------------------. |PSIfour| can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing ``myplugin`` with the name of your great code.; If the name you provide is not valid, |PSIfour| will complain. >>> psi4 --plugin-name myplugin. |PSIfour| will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is ``cd`` into the directory, use |PSIfour| to generate; a Makefile, and type make. Then execute ``psi4`` in the directory on the; default input file. .. code-block:: bash. >>> cd myplugin; >>> `psi4 --plugin-compile`; >>> make; >>> psi4. |PSIfour| comes with a few templates that provide an excellent starting; point. These include code that demonstrates AO, MO, and SO integrals. Use; one of the following commands that meets",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:6172,Performance,load,loading,6172,"clang`` and; ``clang++`` compilers. * Check environment:. .. code-block:: bash. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. * Create and compile plugin:. .. code-block:: bash. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:6188,Performance,cache,cache,6188,"clang`` and; ``clang++`` compilers. * Check environment:. .. code-block:: bash. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. * Create and compile plugin:. .. code-block:: bash. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:6527,Performance,load,loading,6527,"n/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. * Create and compile plugin:. .. code-block:: bash. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in ``$PATH`` or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory; ---------------------------. In addition to the main ``myplugin.cc`` file, a fresh plugin directory contains the followi",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:6543,Performance,cache,cache,6543,"n/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. * Create and compile plugin:. .. code-block:: bash. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in ``$PATH`` or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory; ---------------------------. In addition to the main ``myplugin.cc`` file, a fresh plugin directory contains the followi",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:7928,Performance,load,loading,7928,"tplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in ``$PATH`` or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory; ---------------------------. In addition to the main ``myplugin.cc`` file, a fresh plugin directory contains the following files. * **CMakeLists.txt** |w---w| CMake file governing project *plugin*.; The plugin source and CMakeLists.txt is independent of platform; and |PSIfour| installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; |PSIfour| installation. Run ``psi4 --plugin-compile`` to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent |PSIfour|; (the ``-C psi4PluginCache`` part) which in turn can be overridden; by passing ``-Doption=value`` commands to ``cmake`` *and* pointing; toward a particular |PSIfour| (and probably pybind11) library to; link against (the ``CMAKE_PREFIX_PATH`` part) *and* telling it to; do an in-source build (the ``.`` part). Then just run ``make`` in; your plugin directory. After any change to the plugin C++ code,; ``make`` must be run in the plugin directory to recompile the; ``myplugin.so`` executable, but recompiling the main |PSIfour| code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here. * **input.dat** |w---w| Sample input file for the plugin.; Since the ``__init__.py`` file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in :envvar:`PYTHONPATH`,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating :envvar:`PSIPATH`. Then,;",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:9115,Performance,load,loaded,9115,"rd a particular |PSIfour| (and probably pybind11) library to; link against (the ``CMAKE_PREFIX_PATH`` part) *and* telling it to; do an in-source build (the ``.`` part). Then just run ``make`` in; your plugin directory. After any change to the plugin C++ code,; ``make`` must be run in the plugin directory to recompile the; ``myplugin.so`` executable, but recompiling the main |PSIfour| code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here. * **input.dat** |w---w| Sample input file for the plugin.; Since the ``__init__.py`` file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in :envvar:`PYTHONPATH`,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating :envvar:`PSIPATH`. Then,; the plugin can be loaded as ``import myplugin`` and executed as; ``energy('myplugin')``. Any other Python functions are also available from; the input file, *e.g.* ``myplugin.testfunction()``, note the namespace; protection. * **pymodule.py** |w---w| Python component of the plugin.; By encoding the sequence of |PSIfour| module; calls needed to run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won't; need editing unless additional Python files are added to the plugin; directory (add additional lines to the ``# Load Python modules`` section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to ",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:11081,Performance,load,loaded,11081,"o run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won't; need editing unless additional Python files are added to the plugin; directory (add additional lines to the ``# Load Python modules`` section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the ``# Load C++ plugin`` section). .. comment as modeled in :source:`tests/plugin_libcim/__init__.py`). .. literalinclude:: @SFNX_INCLUDE@psi4/share/psi4/plugin/__init__.py.template. * **doc.rst** |w---w| Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, *etc.*. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the ``.. comment``; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the |PSIfour|; documentation, along with any docstrings to Python functions, and the C++; keywords block in the ``myplugin.cc`` file. See :ref:`sec:documentation`; for building documentation. .. and :ref:`Available Plugins <sec:availablePlugins>`; .. for this file's final destination. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded. To create a purely Python plugin, create a new plugin directory, then; remove the ``Makefile`` and ``myplugin.cc`` files and; erase the shared object loading portion of ``__init__.py``. Create as many .py; files as necessary (registering each one in ``__init__.py``), use; ``input.dat`` as a model for loading the plugin, no recompile ever; necessary. ",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:11239,Performance,load,loading,11239,"o run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won't; need editing unless additional Python files are added to the plugin; directory (add additional lines to the ``# Load Python modules`` section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the ``# Load C++ plugin`` section). .. comment as modeled in :source:`tests/plugin_libcim/__init__.py`). .. literalinclude:: @SFNX_INCLUDE@psi4/share/psi4/plugin/__init__.py.template. * **doc.rst** |w---w| Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, *etc.*. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the ``.. comment``; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the |PSIfour|; documentation, along with any docstrings to Python functions, and the C++; keywords block in the ``myplugin.cc`` file. See :ref:`sec:documentation`; for building documentation. .. and :ref:`Available Plugins <sec:availablePlugins>`; .. for this file's final destination. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded. To create a purely Python plugin, create a new plugin directory, then; remove the ``Makefile`` and ``myplugin.cc`` files and; erase the shared object loading portion of ``__init__.py``. Create as many .py; files as necessary (registering each one in ``__init__.py``), use; ``input.dat`` as a model for loading the plugin, no recompile ever; necessary. ",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:11391,Performance,load,loading,11391,"o run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won't; need editing unless additional Python files are added to the plugin; directory (add additional lines to the ``# Load Python modules`` section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the ``# Load C++ plugin`` section). .. comment as modeled in :source:`tests/plugin_libcim/__init__.py`). .. literalinclude:: @SFNX_INCLUDE@psi4/share/psi4/plugin/__init__.py.template. * **doc.rst** |w---w| Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, *etc.*. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the ``.. comment``; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the |PSIfour|; documentation, along with any docstrings to Python functions, and the C++; keywords block in the ``myplugin.cc`` file. See :ref:`sec:documentation`; for building documentation. .. and :ref:`Available Plugins <sec:availablePlugins>`; .. for this file's final destination. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded. To create a purely Python plugin, create a new plugin directory, then; remove the ``Makefile`` and ``myplugin.cc`` files and; erase the shared object loading portion of ``__init__.py``. Create as many .py; files as necessary (registering each one in ``__init__.py``), use; ``input.dat`` as a model for loading the plugin, no recompile ever; necessary. ",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:9615,Security,access,accessed,9615,"onal external libraries, add that; information here. * **input.dat** |w---w| Sample input file for the plugin.; Since the ``__init__.py`` file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in :envvar:`PYTHONPATH`,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating :envvar:`PSIPATH`. Then,; the plugin can be loaded as ``import myplugin`` and executed as; ``energy('myplugin')``. Any other Python functions are also available from; the input file, *e.g.* ``myplugin.testfunction()``, note the namespace; protection. * **pymodule.py** |w---w| Python component of the plugin.; By encoding the sequence of |PSIfour| module; calls needed to run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won't; need editing unless additional Python files are added to the plugin; directory (add additional lines to the ``# Load Python modules`` section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the ``# Load C++ plugin`` section). .. comment as modeled in :source:`tests/plugin_libcim/__init__.py`). .. literalinclude:: @SFNX_INCLUDE@psi4/share/psi4/plugin/__init__.py.template. * **doc.rst** |w---w| Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, *etc.*. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the ``.. comment``; text and build Sphinx documentation for samples of linking key",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:3804,Testability,test,test,3804,"ng commands that meets your needs::. >>> psi4 --plugin-name myplugin --plugin-template aointegrals; >>> psi4 --plugin-name myplugin --plugin-template mointegrals; >>> psi4 --plugin-name myplugin --plugin-template sointegrals; >>> psi4 --plugin-name myplugin --plugin-template wavefunction; >>> psi4 --plugin-name myplugin --plugin-template scf; >>> psi4 --plugin-name myplugin --plugin-template dfmp2. .. >>> psi4 --plugin-name myplugin --plugin-template ambit. .. Several stable sample plugin directories are available to consult in the; .. :source:`plugins` directory. Other plugin directories can be used as models; .. but are in active development. For documentation on plugin modules, see; .. :ref:`Available Plugins <sec:availablePlugins>`.; .. ; .. * :source:`plugins/aointegrals/aointegrals.cc` ; .. An example that uses the LibMints library to generate and print AO basis (no symmetry) integrals.; .. ; .. * :source:`plugins/backtrans/backtrans.cc` ; .. A test of the one- and two-particle density matrix backtransformation code.; .. ; .. * :source:`plugins/mointegrals/mointegrals.cc` ; .. An example that uses the LibTrans library to generate and print MO basis integrals.; .. ; .. * :source:`plugins/mollerplesset2/mp2.cc` ; .. A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; .. ; .. * :source:`plugins/sointegrals/sointegrals.cc` ; .. An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. .. _`sec:condaplugins`:. Creating a New Plugin Using a Conda Pre-compiled Binary; -------------------------------------------------------. .. # prepare; .. >>> bash; .. >>> export PATH=$PSI4CONDA/bin:$PATH # usually already done from psi4 installation; .. >>> cd ""$(dirname $(which psi4))""/.. # move into distribution/environment directory, $PSI4CONDA; .. >>> conda install gcc # install compilers into expected place. |PSIfour| plugins can also be created using Conda for both |PSIfour|; binary and development environmen",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:5835,Testability,test,testplugin,5835,"or Ubuntu shell on Windows), one can use the ``gcc``; compiler installed alongside ``psi4`` itself in the Conda distribution; or environment (below, ``$PSI4CONDA``). On Mac, one must use; ``libc++.so`` (*not* ``libstdc++.so``), and this can be accomplished by; installing XCode from the App Store that provides ``clang`` and; ``clang++`` compilers. * Check environment:. .. code-block:: bash. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. * Create and compile plugin:. .. code-block:: bash. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplu",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:5860,Testability,test,testplugin,5860,"or Ubuntu shell on Windows), one can use the ``gcc``; compiler installed alongside ``psi4`` itself in the Conda distribution; or environment (below, ``$PSI4CONDA``). On Mac, one must use; ``libc++.so`` (*not* ``libstdc++.so``), and this can be accomplished by; installing XCode from the App Store that provides ``clang`` and; ``clang++`` compilers. * Check environment:. .. code-block:: bash. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. * Create and compile plugin:. .. code-block:: bash. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplu",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:5943,Testability,test,testplugin,5943," ``psi4`` itself in the Conda distribution; or environment (below, ``$PSI4CONDA``). On Mac, one must use; ``libc++.so`` (*not* ``libstdc++.so``), and this can be accomplished by; installing XCode from the App Store that provides ``clang`` and; ``clang++`` compilers. * Check environment:. .. code-block:: bash. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. * Create and compile plugin:. .. code-block:: bash. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencie",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:6076,Testability,test,testplugin,6076,"`libstdc++.so``), and this can be accomplished by; installing XCode from the App Store that provides ``clang`` and; ``clang++`` compilers. * Check environment:. .. code-block:: bash. # yes, the following returns a blank line. yes, LD_LIBRARY_PATH irrelevant; >>> echo $PYTHONHOME $PYTHONPATH $DYLD_LIBRARY_PATH $PSIDATADIR. >>> which python psi4 g++ gfortran # Linux; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/gcc++; $PSI4CONDA/bin/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. * Create and compile plugin:. .. code-block:: bash. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testp",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:6480,Testability,test,testplugin,6480,"n/gfortran; >>> which python psi4 g++ gfortran clang++ # Mac; $PSI4CONDA/bin/python; $PSI4CONDA/bin/psi4; $PSI4CONDA/bin/g++; $PSI4CONDA/bin/gfortran; /usr/bin/clang++. >>> which cmake; $PSI4CONDA/bin/cmake; # if above empty, ``conda install cmake``. * Create and compile plugin:. .. code-block:: bash. >>> psi4 --plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in ``$PATH`` or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory; ---------------------------. In addition to the main ``myplugin.cc`` file, a fresh plugin directory contains the followi",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:6846,Testability,test,testplugin,6846,"-plugin-name testplugin; -- Creating ""testplugin"" with ""basic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in ``$PATH`` or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory; ---------------------------. In addition to the main ``myplugin.cc`` file, a fresh plugin directory contains the following files. * **CMakeLists.txt** |w---w| CMake file governing project *plugin*.; The plugin source and CMakeLists.txt is independent of platform; and |PSIfour| installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; |PSIfour| installation. Run ``psi4",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:6890,Testability,test,testplugin,6890,"asic"" template. -----------------; ==> Created plugin files (in testplugin as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in ``$PATH`` or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory; ---------------------------. In addition to the main ``myplugin.cc`` file, a fresh plugin directory contains the following files. * **CMakeLists.txt** |w---w| CMake file governing project *plugin*.; The plugin source and CMakeLists.txt is independent of platform; and |PSIfour| installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; |PSIfour| installation. Run ``psi4 --plugin-compile`` to get a command; to execute to gener",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:6947,Testability,test,testplugin,6947,"as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in ``$PATH`` or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory; ---------------------------. In addition to the main ``myplugin.cc`` file, a fresh plugin directory contains the following files. * **CMakeLists.txt** |w---w| CMake file governing project *plugin*.; The plugin source and CMakeLists.txt is independent of platform; and |PSIfour| installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; |PSIfour| installation. Run ``psi4 --plugin-compile`` to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and o",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:6997,Testability,test,testplugin,6997,"as basic):; __init__.py, CMakeLists.txt, doc.rst, input.dat, plugin.cc, pymodule.py. # move into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in ``$PATH`` or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory; ---------------------------. In addition to the main ``myplugin.cc`` file, a fresh plugin directory contains the following files. * **CMakeLists.txt** |w---w| CMake file governing project *plugin*.; The plugin source and CMakeLists.txt is independent of platform; and |PSIfour| installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; |PSIfour| installation. Run ``psi4 --plugin-compile`` to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and o",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:7058,Testability,test,testplugin,7058," into plugin directory; >>> cd testplugin. # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in ``$PATH`` or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory; ---------------------------. In addition to the main ``myplugin.cc`` file, a fresh plugin directory contains the following files. * **CMakeLists.txt** |w---w| CMake file governing project *plugin*.; The plugin source and CMakeLists.txt is independent of platform; and |PSIfour| installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; |PSIfour| installation. Run ``psi4 --plugin-compile`` to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent |PSIfour|; (the ``-C psi4PluginCache`` part) which in turn ",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:7093,Testability,test,testplugin,7093,". # configure using build info from parent psi4; >>> `psi4 --plugin-compile` # Linux; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is GNU 5.2.0; -- Check for working CXX compiler: $PSI4CONDA/bin/g++; -- Check for working CXX compiler: $PSI4CONDA/bin/g++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin; >>> `psi4 --plugin-compile` # Mac; loading initial cache file $PSI4CONDA/share/cmake/psi4/psi4PluginCache.cmake; -- The CXX compiler identification is AppleClang 7.0.0.7000176; -- Check for working CXX compiler: /usr/bin/clang++; -- Check for working CXX compiler: /usr/bin/clang++ -- works; ...; -- Generating done; -- Build files have been written to: testplugin. # compile the plugin to produce testplugin.so; >>> make; Scanning dependencies of target testplugin; [ 50%] Building CXX object CMakeFiles/testplugin.dir/plugin.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in ``$PATH`` or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory; ---------------------------. In addition to the main ``myplugin.cc`` file, a fresh plugin directory contains the following files. * **CMakeLists.txt** |w---w| CMake file governing project *plugin*.; The plugin source and CMakeLists.txt is independent of platform; and |PSIfour| installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; |PSIfour| installation. Run ``psi4 --plugin-compile`` to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent |PSIfour|; (the ``-C psi4PluginCache`` part) which in turn can be overridden; by passing ``-Doption=",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:9272,Testability,test,testfunction,9272,"`` part). Then just run ``make`` in; your plugin directory. After any change to the plugin C++ code,; ``make`` must be run in the plugin directory to recompile the; ``myplugin.so`` executable, but recompiling the main |PSIfour| code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here. * **input.dat** |w---w| Sample input file for the plugin.; Since the ``__init__.py`` file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in :envvar:`PYTHONPATH`,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating :envvar:`PSIPATH`. Then,; the plugin can be loaded as ``import myplugin`` and executed as; ``energy('myplugin')``. Any other Python functions are also available from; the input file, *e.g.* ``myplugin.testfunction()``, note the namespace; protection. * **pymodule.py** |w---w| Python component of the plugin.; By encoding the sequence of |PSIfour| module; calls needed to run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won't; need editing unless additional Python files are added to the plugin; directory (add additional lines to the ``# Load Python modules`` section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the ``# Load C++ plugin`` section). .. comment as modeled in :source:`tests/plugin_libcim/__init__.py`). .. literalinclude:: @S",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:10240,Testability,test,tests,10240,"the input file, *e.g.* ``myplugin.testfunction()``, note the namespace; protection. * **pymodule.py** |w---w| Python component of the plugin.; By encoding the sequence of |PSIfour| module; calls needed to run the plugin in the ``run_myplugin()`` function in this; file, the plugin is hooked into the main |PSIfour| driver function; :py:func:`~psi4.driver.energy` and so can be accessed through; ``energy('myplugin')`` in an input file. Any other Python functions can; also be placed in this file. * **__init__.py** |w---w| Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won't; need editing unless additional Python files are added to the plugin; directory (add additional lines to the ``# Load Python modules`` section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the ``# Load C++ plugin`` section). .. comment as modeled in :source:`tests/plugin_libcim/__init__.py`). .. literalinclude:: @SFNX_INCLUDE@psi4/share/psi4/plugin/__init__.py.template. * **doc.rst** |w---w| Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, *etc.*. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the ``.. comment``; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the |PSIfour|; documentation, along with any docstrings to Python functions, and the C++; keywords block in the ``myplugin.cc`` file. See :ref:`sec:documentation`; for building documentation. .. and :ref:`Available Plugins <sec:availablePlugins>`; .. for this file's final destination. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded. To create a purely Python plugin, create a new plugin directory, then; remove the ``Makefile`` and ``myplugin.cc`` files and; erase the shared object ",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst:1373,Usability,learn,learn,1373," # the Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:plugins`:. Creating New Plugins; ====================. Modular Approach to Development; -------------------------------. It is slightly cumbersome to the development cycle to recompile |PSIfour|; every time a change is made to the C++ code.; It's also daunting to new developers if they're required to; learn the structure of the source tree, executable initialization code,; and makefile systems in the existing code in order to add new features,; which was never a problem with Psi3 due to the independent; nature of the modules. To overcome these problems, |PSIfour| now has a; useful plugin feature. This allows codes to be developed as standalone; entities, which are compiled independently of the Psi source, but can; still link against Psi's vast library. The plugins can be loaded at; run-time from any location. .. _`sec:newplugins`:. Creating a New Plugin; ---------------------. |PSIfour| can create basic plugins for you and automatically tailor them; to your compilation environment. To create a basic plugin, run the; following while replacing ``myplugin`` with the name of your great code.; If the name you provide is not valid, |PSIfour| will complain. >>> psi4 --plugin-name myplugin. |PSIfour| will create a new directory with the name you specify for the; plugin. In this example, a directory named myplugin will be created.; All you need to do is ``cd`` into the dir",MatchSource.DOCS,doc/sphinxman/source/plugins.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugins.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_psi4fockci.rst:2300,Availability,down,downloaded,2300,"elds.io/badge/home-psi4fockci-5077AB.svg; :target: https://github.com/shannonhouck/psi4fockci. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: https://shannonhouck.github.io/psi4fockci/build/index.html. This plugin is an implementation of the RAS-nSF-IP/EA approach detailed ; in the paper by Houck et. al. [Houck:2019:2278]_. ; This approach handles systems with both spin and spatial degeneracies ; by combining the spin-flip (SF) [Krylov:2001:522]_; and ionization potential/electron affinity (IP/EA) [Nooijen:1995:3629]_ ; approaches. . The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization ; potential (IP), and electron affinity (EA) calculations, as well as ; combined RAS-SF-IP/EA calculations, through the DETCI (:ref:`sec:ci`) module. Installation; ~~~~~~~~~~~~. * Download the plugin from the GitHub repository:. .. code-block:: bash. >>> git clone https://github.com/shannonhouck/psi4fockci.git. * Once downloaded, the plugin can be installed as follows:. .. code-block:: bash. >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input; ~~~~~~~~~~~~. To run a CAS-nSF-IP/EA calculation, start with a molecule with the ; correct charge and multiplicity for the reference state (i.e. some ; state well-represented by a single reference). Then, run an energy ; calculation, passing in the charge and multiplicity of the ; desired state; the number of spin-flips and IP/EA will be automatically ; determined based on this input. If additional excitations outside of the ; RAS II space are desired, one can set the level of external ; excitations using the ``conf_space`` keyword. A sample input file for a RAS(h)-2SF-IP calculation is shown below:. .. code-block:: python. molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""); ; Note that for calculations involving IP/EA, inclusion of hole (for IP)",MatchSource.DOCS,doc/sphinxman/source/plugin_psi4fockci.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_psi4fockci.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_psi4fockci.rst:2330,Deployability,install,installed,2330,"elds.io/badge/home-psi4fockci-5077AB.svg; :target: https://github.com/shannonhouck/psi4fockci. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: https://shannonhouck.github.io/psi4fockci/build/index.html. This plugin is an implementation of the RAS-nSF-IP/EA approach detailed ; in the paper by Houck et. al. [Houck:2019:2278]_. ; This approach handles systems with both spin and spatial degeneracies ; by combining the spin-flip (SF) [Krylov:2001:522]_; and ionization potential/electron affinity (IP/EA) [Nooijen:1995:3629]_ ; approaches. . The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization ; potential (IP), and electron affinity (EA) calculations, as well as ; combined RAS-SF-IP/EA calculations, through the DETCI (:ref:`sec:ci`) module. Installation; ~~~~~~~~~~~~. * Download the plugin from the GitHub repository:. .. code-block:: bash. >>> git clone https://github.com/shannonhouck/psi4fockci.git. * Once downloaded, the plugin can be installed as follows:. .. code-block:: bash. >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input; ~~~~~~~~~~~~. To run a CAS-nSF-IP/EA calculation, start with a molecule with the ; correct charge and multiplicity for the reference state (i.e. some ; state well-represented by a single reference). Then, run an energy ; calculation, passing in the charge and multiplicity of the ; desired state; the number of spin-flips and IP/EA will be automatically ; determined based on this input. If additional excitations outside of the ; RAS II space are desired, one can set the level of external ; excitations using the ``conf_space`` keyword. A sample input file for a RAS(h)-2SF-IP calculation is shown below:. .. code-block:: python. molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""); ; Note that for calculations involving IP/EA, inclusion of hole (for IP)",MatchSource.DOCS,doc/sphinxman/source/plugin_psi4fockci.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_psi4fockci.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_psi4fockci.rst:2434,Deployability,install,install,2434,"4fockci. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: https://shannonhouck.github.io/psi4fockci/build/index.html. This plugin is an implementation of the RAS-nSF-IP/EA approach detailed ; in the paper by Houck et. al. [Houck:2019:2278]_. ; This approach handles systems with both spin and spatial degeneracies ; by combining the spin-flip (SF) [Krylov:2001:522]_; and ionization potential/electron affinity (IP/EA) [Nooijen:1995:3629]_ ; approaches. . The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization ; potential (IP), and electron affinity (EA) calculations, as well as ; combined RAS-SF-IP/EA calculations, through the DETCI (:ref:`sec:ci`) module. Installation; ~~~~~~~~~~~~. * Download the plugin from the GitHub repository:. .. code-block:: bash. >>> git clone https://github.com/shannonhouck/psi4fockci.git. * Once downloaded, the plugin can be installed as follows:. .. code-block:: bash. >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input; ~~~~~~~~~~~~. To run a CAS-nSF-IP/EA calculation, start with a molecule with the ; correct charge and multiplicity for the reference state (i.e. some ; state well-represented by a single reference). Then, run an energy ; calculation, passing in the charge and multiplicity of the ; desired state; the number of spin-flips and IP/EA will be automatically ; determined based on this input. If additional excitations outside of the ; RAS II space are desired, one can set the level of external ; excitations using the ``conf_space`` keyword. A sample input file for a RAS(h)-2SF-IP calculation is shown below:. .. code-block:: python. molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""); ; Note that for calculations involving IP/EA, inclusion of hole (for IP) and ; particle (for EA) excitations is strongly recommended. Additional keywords ; can",MatchSource.DOCS,doc/sphinxman/source/plugin_psi4fockci.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_psi4fockci.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_psi4fockci.rst:2549,Energy Efficiency,charge,charge,2549,"nnonhouck.github.io/psi4fockci/build/index.html. This plugin is an implementation of the RAS-nSF-IP/EA approach detailed ; in the paper by Houck et. al. [Houck:2019:2278]_. ; This approach handles systems with both spin and spatial degeneracies ; by combining the spin-flip (SF) [Krylov:2001:522]_; and ionization potential/electron affinity (IP/EA) [Nooijen:1995:3629]_ ; approaches. . The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization ; potential (IP), and electron affinity (EA) calculations, as well as ; combined RAS-SF-IP/EA calculations, through the DETCI (:ref:`sec:ci`) module. Installation; ~~~~~~~~~~~~. * Download the plugin from the GitHub repository:. .. code-block:: bash. >>> git clone https://github.com/shannonhouck/psi4fockci.git. * Once downloaded, the plugin can be installed as follows:. .. code-block:: bash. >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input; ~~~~~~~~~~~~. To run a CAS-nSF-IP/EA calculation, start with a molecule with the ; correct charge and multiplicity for the reference state (i.e. some ; state well-represented by a single reference). Then, run an energy ; calculation, passing in the charge and multiplicity of the ; desired state; the number of spin-flips and IP/EA will be automatically ; determined based on this input. If additional excitations outside of the ; RAS II space are desired, one can set the level of external ; excitations using the ``conf_space`` keyword. A sample input file for a RAS(h)-2SF-IP calculation is shown below:. .. code-block:: python. molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""); ; Note that for calculations involving IP/EA, inclusion of hole (for IP) and ; particle (for EA) excitations is strongly recommended. Additional keywords ; can be found in the documentation. This input file can be run with Psi4:. .. code-block:: bash. >>> psi4 input.dat. ",MatchSource.DOCS,doc/sphinxman/source/plugin_psi4fockci.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_psi4fockci.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_psi4fockci.rst:2670,Energy Efficiency,energy,energy,2670,"nnonhouck.github.io/psi4fockci/build/index.html. This plugin is an implementation of the RAS-nSF-IP/EA approach detailed ; in the paper by Houck et. al. [Houck:2019:2278]_. ; This approach handles systems with both spin and spatial degeneracies ; by combining the spin-flip (SF) [Krylov:2001:522]_; and ionization potential/electron affinity (IP/EA) [Nooijen:1995:3629]_ ; approaches. . The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization ; potential (IP), and electron affinity (EA) calculations, as well as ; combined RAS-SF-IP/EA calculations, through the DETCI (:ref:`sec:ci`) module. Installation; ~~~~~~~~~~~~. * Download the plugin from the GitHub repository:. .. code-block:: bash. >>> git clone https://github.com/shannonhouck/psi4fockci.git. * Once downloaded, the plugin can be installed as follows:. .. code-block:: bash. >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input; ~~~~~~~~~~~~. To run a CAS-nSF-IP/EA calculation, start with a molecule with the ; correct charge and multiplicity for the reference state (i.e. some ; state well-represented by a single reference). Then, run an energy ; calculation, passing in the charge and multiplicity of the ; desired state; the number of spin-flips and IP/EA will be automatically ; determined based on this input. If additional excitations outside of the ; RAS II space are desired, one can set the level of external ; excitations using the ``conf_space`` keyword. A sample input file for a RAS(h)-2SF-IP calculation is shown below:. .. code-block:: python. molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""); ; Note that for calculations involving IP/EA, inclusion of hole (for IP) and ; particle (for EA) excitations is strongly recommended. Additional keywords ; can be found in the documentation. This input file can be run with Psi4:. .. code-block:: bash. >>> psi4 input.dat. ",MatchSource.DOCS,doc/sphinxman/source/plugin_psi4fockci.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_psi4fockci.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_psi4fockci.rst:2707,Energy Efficiency,charge,charge,2707,"nnonhouck.github.io/psi4fockci/build/index.html. This plugin is an implementation of the RAS-nSF-IP/EA approach detailed ; in the paper by Houck et. al. [Houck:2019:2278]_. ; This approach handles systems with both spin and spatial degeneracies ; by combining the spin-flip (SF) [Krylov:2001:522]_; and ionization potential/electron affinity (IP/EA) [Nooijen:1995:3629]_ ; approaches. . The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization ; potential (IP), and electron affinity (EA) calculations, as well as ; combined RAS-SF-IP/EA calculations, through the DETCI (:ref:`sec:ci`) module. Installation; ~~~~~~~~~~~~. * Download the plugin from the GitHub repository:. .. code-block:: bash. >>> git clone https://github.com/shannonhouck/psi4fockci.git. * Once downloaded, the plugin can be installed as follows:. .. code-block:: bash. >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input; ~~~~~~~~~~~~. To run a CAS-nSF-IP/EA calculation, start with a molecule with the ; correct charge and multiplicity for the reference state (i.e. some ; state well-represented by a single reference). Then, run an energy ; calculation, passing in the charge and multiplicity of the ; desired state; the number of spin-flips and IP/EA will be automatically ; determined based on this input. If additional excitations outside of the ; RAS II space are desired, one can set the level of external ; excitations using the ``conf_space`` keyword. A sample input file for a RAS(h)-2SF-IP calculation is shown below:. .. code-block:: python. molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""); ; Note that for calculations involving IP/EA, inclusion of hole (for IP) and ; particle (for EA) excitations is strongly recommended. Additional keywords ; can be found in the documentation. This input file can be run with Psi4:. .. code-block:: bash. >>> psi4 input.dat. ",MatchSource.DOCS,doc/sphinxman/source/plugin_psi4fockci.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_psi4fockci.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_psi4fockci.rst:3178,Energy Efficiency,energy,energy,3178,"nnonhouck.github.io/psi4fockci/build/index.html. This plugin is an implementation of the RAS-nSF-IP/EA approach detailed ; in the paper by Houck et. al. [Houck:2019:2278]_. ; This approach handles systems with both spin and spatial degeneracies ; by combining the spin-flip (SF) [Krylov:2001:522]_; and ionization potential/electron affinity (IP/EA) [Nooijen:1995:3629]_ ; approaches. . The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization ; potential (IP), and electron affinity (EA) calculations, as well as ; combined RAS-SF-IP/EA calculations, through the DETCI (:ref:`sec:ci`) module. Installation; ~~~~~~~~~~~~. * Download the plugin from the GitHub repository:. .. code-block:: bash. >>> git clone https://github.com/shannonhouck/psi4fockci.git. * Once downloaded, the plugin can be installed as follows:. .. code-block:: bash. >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input; ~~~~~~~~~~~~. To run a CAS-nSF-IP/EA calculation, start with a molecule with the ; correct charge and multiplicity for the reference state (i.e. some ; state well-represented by a single reference). Then, run an energy ; calculation, passing in the charge and multiplicity of the ; desired state; the number of spin-flips and IP/EA will be automatically ; determined based on this input. If additional excitations outside of the ; RAS II space are desired, one can set the level of external ; excitations using the ``conf_space`` keyword. A sample input file for a RAS(h)-2SF-IP calculation is shown below:. .. code-block:: python. molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""); ; Note that for calculations involving IP/EA, inclusion of hole (for IP) and ; particle (for EA) excitations is strongly recommended. Additional keywords ; can be found in the documentation. This input file can be run with Psi4:. .. code-block:: bash. >>> psi4 input.dat. ",MatchSource.DOCS,doc/sphinxman/source/plugin_psi4fockci.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_psi4fockci.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_psi4fockci.rst:1576,Modifiability,plugin,plugin,1576,"ied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index:: PSI4FOCKCI. .. _`sec:fockci`:. Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; ===========================================================. .. codeauthor:: Shannon E. Houck; .. sectionauthor:: Shannon E. Houck. .. image:: https://img.shields.io/badge/home-psi4fockci-5077AB.svg; :target: https://github.com/shannonhouck/psi4fockci. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: https://shannonhouck.github.io/psi4fockci/build/index.html. This plugin is an implementation of the RAS-nSF-IP/EA approach detailed ; in the paper by Houck et. al. [Houck:2019:2278]_. ; This approach handles systems with both spin and spatial degeneracies ; by combining the spin-flip (SF) [Krylov:2001:522]_; and ionization potential/electron affinity (IP/EA) [Nooijen:1995:3629]_ ; approaches. . The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization ; potential (IP), and electron affinity (EA) calculations, as well as ; combined RAS-SF-IP/EA calculations, through the DETCI (:ref:`sec:ci`) module. Installation; ~~~~~~~~~~~~. * Download the plugin from the GitHub repository:. .. code-block:: bash. >>> git clone https://github.com/shannonhouck/psi4fockci.git. * Once downloaded, the plugin can be installed as follows:. .. code-block:: bash. >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input; ~~~~~~~~~~~~. To run a CAS-nSF-IP/EA calculation, start with a molecule with the ; correct charge and multiplicity for the reference state (i.e. some ; state well",MatchSource.DOCS,doc/sphinxman/source/plugin_psi4fockci.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_psi4fockci.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_psi4fockci.rst:1924,Modifiability,plugin,plugin,1924,". .. include:: autodoc_abbr_options_c.rst. .. index:: PSI4FOCKCI. .. _`sec:fockci`:. Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; ===========================================================. .. codeauthor:: Shannon E. Houck; .. sectionauthor:: Shannon E. Houck. .. image:: https://img.shields.io/badge/home-psi4fockci-5077AB.svg; :target: https://github.com/shannonhouck/psi4fockci. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: https://shannonhouck.github.io/psi4fockci/build/index.html. This plugin is an implementation of the RAS-nSF-IP/EA approach detailed ; in the paper by Houck et. al. [Houck:2019:2278]_. ; This approach handles systems with both spin and spatial degeneracies ; by combining the spin-flip (SF) [Krylov:2001:522]_; and ionization potential/electron affinity (IP/EA) [Nooijen:1995:3629]_ ; approaches. . The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization ; potential (IP), and electron affinity (EA) calculations, as well as ; combined RAS-SF-IP/EA calculations, through the DETCI (:ref:`sec:ci`) module. Installation; ~~~~~~~~~~~~. * Download the plugin from the GitHub repository:. .. code-block:: bash. >>> git clone https://github.com/shannonhouck/psi4fockci.git. * Once downloaded, the plugin can be installed as follows:. .. code-block:: bash. >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input; ~~~~~~~~~~~~. To run a CAS-nSF-IP/EA calculation, start with a molecule with the ; correct charge and multiplicity for the reference state (i.e. some ; state well-represented by a single reference). Then, run an energy ; calculation, passing in the charge and multiplicity of the ; desired state; the number of spin-flips and IP/EA will be automatically ; determined based on this input. If additional excitations outside of the ; RAS II space are desired, one can set the level of external ; excitations using the ``conf_space`` keyword. A sample input file fo",MatchSource.DOCS,doc/sphinxman/source/plugin_psi4fockci.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_psi4fockci.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_psi4fockci.rst:2173,Modifiability,plugin,plugin,2173,"=========================================. .. codeauthor:: Shannon E. Houck; .. sectionauthor:: Shannon E. Houck. .. image:: https://img.shields.io/badge/home-psi4fockci-5077AB.svg; :target: https://github.com/shannonhouck/psi4fockci. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: https://shannonhouck.github.io/psi4fockci/build/index.html. This plugin is an implementation of the RAS-nSF-IP/EA approach detailed ; in the paper by Houck et. al. [Houck:2019:2278]_. ; This approach handles systems with both spin and spatial degeneracies ; by combining the spin-flip (SF) [Krylov:2001:522]_; and ionization potential/electron affinity (IP/EA) [Nooijen:1995:3629]_ ; approaches. . The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization ; potential (IP), and electron affinity (EA) calculations, as well as ; combined RAS-SF-IP/EA calculations, through the DETCI (:ref:`sec:ci`) module. Installation; ~~~~~~~~~~~~. * Download the plugin from the GitHub repository:. .. code-block:: bash. >>> git clone https://github.com/shannonhouck/psi4fockci.git. * Once downloaded, the plugin can be installed as follows:. .. code-block:: bash. >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input; ~~~~~~~~~~~~. To run a CAS-nSF-IP/EA calculation, start with a molecule with the ; correct charge and multiplicity for the reference state (i.e. some ; state well-represented by a single reference). Then, run an energy ; calculation, passing in the charge and multiplicity of the ; desired state; the number of spin-flips and IP/EA will be automatically ; determined based on this input. If additional excitations outside of the ; RAS II space are desired, one can set the level of external ; excitations using the ``conf_space`` keyword. A sample input file for a RAS(h)-2SF-IP calculation is shown below:. .. code-block:: python. molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energ",MatchSource.DOCS,doc/sphinxman/source/plugin_psi4fockci.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_psi4fockci.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_psi4fockci.rst:2316,Modifiability,plugin,plugin,2316,"elds.io/badge/home-psi4fockci-5077AB.svg; :target: https://github.com/shannonhouck/psi4fockci. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: https://shannonhouck.github.io/psi4fockci/build/index.html. This plugin is an implementation of the RAS-nSF-IP/EA approach detailed ; in the paper by Houck et. al. [Houck:2019:2278]_. ; This approach handles systems with both spin and spatial degeneracies ; by combining the spin-flip (SF) [Krylov:2001:522]_; and ionization potential/electron affinity (IP/EA) [Nooijen:1995:3629]_ ; approaches. . The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization ; potential (IP), and electron affinity (EA) calculations, as well as ; combined RAS-SF-IP/EA calculations, through the DETCI (:ref:`sec:ci`) module. Installation; ~~~~~~~~~~~~. * Download the plugin from the GitHub repository:. .. code-block:: bash. >>> git clone https://github.com/shannonhouck/psi4fockci.git. * Once downloaded, the plugin can be installed as follows:. .. code-block:: bash. >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input; ~~~~~~~~~~~~. To run a CAS-nSF-IP/EA calculation, start with a molecule with the ; correct charge and multiplicity for the reference state (i.e. some ; state well-represented by a single reference). Then, run an energy ; calculation, passing in the charge and multiplicity of the ; desired state; the number of spin-flips and IP/EA will be automatically ; determined based on this input. If additional excitations outside of the ; RAS II space are desired, one can set the level of external ; excitations using the ``conf_space`` keyword. A sample input file for a RAS(h)-2SF-IP calculation is shown below:. .. code-block:: python. molecule {; 0 7; N 0.0 0.0 0.0; N 0.0 0.0 1.3; symmetry c1; }. set {; basis cc-pVDZ; }. energy('psi4fockci', new_charge=1, new_multiplicity=1, conf_space=""h""); ; Note that for calculations involving IP/EA, inclusion of hole (for IP)",MatchSource.DOCS,doc/sphinxman/source/plugin_psi4fockci.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_psi4fockci.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_psi4fockci.rst:1945,Performance,perform,perform,1945,". .. include:: autodoc_abbr_options_c.rst. .. index:: PSI4FOCKCI. .. _`sec:fockci`:. Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; ===========================================================. .. codeauthor:: Shannon E. Houck; .. sectionauthor:: Shannon E. Houck. .. image:: https://img.shields.io/badge/home-psi4fockci-5077AB.svg; :target: https://github.com/shannonhouck/psi4fockci. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: https://shannonhouck.github.io/psi4fockci/build/index.html. This plugin is an implementation of the RAS-nSF-IP/EA approach detailed ; in the paper by Houck et. al. [Houck:2019:2278]_. ; This approach handles systems with both spin and spatial degeneracies ; by combining the spin-flip (SF) [Krylov:2001:522]_; and ionization potential/electron affinity (IP/EA) [Nooijen:1995:3629]_ ; approaches. . The Psi4FockCI plugin allows one to perform spin-flip (SF), ionization ; potential (IP), and electron affinity (EA) calculations, as well as ; combined RAS-SF-IP/EA calculations, through the DETCI (:ref:`sec:ci`) module. Installation; ~~~~~~~~~~~~. * Download the plugin from the GitHub repository:. .. code-block:: bash. >>> git clone https://github.com/shannonhouck/psi4fockci.git. * Once downloaded, the plugin can be installed as follows:. .. code-block:: bash. >>> cd {top-level-psi4fockci-directory}; >>> python -m pip install . Sample Input; ~~~~~~~~~~~~. To run a CAS-nSF-IP/EA calculation, start with a molecule with the ; correct charge and multiplicity for the reference state (i.e. some ; state well-represented by a single reference). Then, run an energy ; calculation, passing in the charge and multiplicity of the ; desired state; the number of spin-flips and IP/EA will be automatically ; determined based on this input. If additional excitations outside of the ; RAS II space are desired, one can set the level of external ; excitations using the ``conf_space`` keyword. A sample input file fo",MatchSource.DOCS,doc/sphinxman/source/plugin_psi4fockci.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_psi4fockci.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst:2020,Availability,avail,available,2020,"t. .. index:: SNS-MP2. .. _`sec:snsmp2`:. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; ===============================================. .. codeauthor:: D. E. Shaw Research; .. sectionauthor:: Shannon E. Houck. .. image:: https://img.shields.io/badge/home-sns--mp2-5077AB.svg; :target: https://github.com/DEShawResearch/sns-mp2. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: https://github.com/DEShawResearch/sns-mp2/blob/master/README.md. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon ; et. al. [McGibbon:2017:161725]_. The SNS-MP2 method uses neural networking to ; improve the accuracy of MP2 (:ref:`sec:dfmp2`) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/snsmp2/badges/version.svg; :target: https://anaconda.org/psi4/snsmp2. * snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the Psi4conda installer, snsmp2 has already been installed alongside. * If using the |PSIfour| conda package, the snsmp2 conda package can; be obtained through ``conda install snsmp2 -c psi4`` or ``conda install; psi4-rt -c psi4``. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; snsmp2 can be obtained through ``conda install snsmp2 -c psi4``.; Then, hint its location with :envvar:`PYTHONPATH`. * To remove a conda installation, ``conda remove snsmp2``. **Source**. * .. image:: https://img.shields.io/github/tag/DEShawResearch/sns-mp2.svg?maxAge=2592000; :target: https://github.com/DEShawResearch/sns-mp2. * Download the plugin from the GitHub repository:. .. code-block:: bash. >>> git clone https://github.com/DEShawResearch/sns-mp2. * Once dowloaded, the plugin can be installed as outlined in the documentation:. .. code-block:: bash. >>> cd",MatchSource.DOCS,doc/sphinxman/source/plugin_snsmp2.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst:2135,Deployability,install,installer,2135,"===============================================. .. codeauthor:: D. E. Shaw Research; .. sectionauthor:: Shannon E. Houck. .. image:: https://img.shields.io/badge/home-sns--mp2-5077AB.svg; :target: https://github.com/DEShawResearch/sns-mp2. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: https://github.com/DEShawResearch/sns-mp2/blob/master/README.md. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon ; et. al. [McGibbon:2017:161725]_. The SNS-MP2 method uses neural networking to ; improve the accuracy of MP2 (:ref:`sec:dfmp2`) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/snsmp2/badges/version.svg; :target: https://anaconda.org/psi4/snsmp2. * snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the Psi4conda installer, snsmp2 has already been installed alongside. * If using the |PSIfour| conda package, the snsmp2 conda package can; be obtained through ``conda install snsmp2 -c psi4`` or ``conda install; psi4-rt -c psi4``. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; snsmp2 can be obtained through ``conda install snsmp2 -c psi4``.; Then, hint its location with :envvar:`PYTHONPATH`. * To remove a conda installation, ``conda remove snsmp2``. **Source**. * .. image:: https://img.shields.io/github/tag/DEShawResearch/sns-mp2.svg?maxAge=2592000; :target: https://github.com/DEShawResearch/sns-mp2. * Download the plugin from the GitHub repository:. .. code-block:: bash. >>> git clone https://github.com/DEShawResearch/sns-mp2. * Once dowloaded, the plugin can be installed as outlined in the documentation:. .. code-block:: bash. >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}/",MatchSource.DOCS,doc/sphinxman/source/plugin_snsmp2.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst:2170,Deployability,install,installed,2170,"===============================================. .. codeauthor:: D. E. Shaw Research; .. sectionauthor:: Shannon E. Houck. .. image:: https://img.shields.io/badge/home-sns--mp2-5077AB.svg; :target: https://github.com/DEShawResearch/sns-mp2. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: https://github.com/DEShawResearch/sns-mp2/blob/master/README.md. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon ; et. al. [McGibbon:2017:161725]_. The SNS-MP2 method uses neural networking to ; improve the accuracy of MP2 (:ref:`sec:dfmp2`) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/snsmp2/badges/version.svg; :target: https://anaconda.org/psi4/snsmp2. * snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the Psi4conda installer, snsmp2 has already been installed alongside. * If using the |PSIfour| conda package, the snsmp2 conda package can; be obtained through ``conda install snsmp2 -c psi4`` or ``conda install; psi4-rt -c psi4``. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; snsmp2 can be obtained through ``conda install snsmp2 -c psi4``.; Then, hint its location with :envvar:`PYTHONPATH`. * To remove a conda installation, ``conda remove snsmp2``. **Source**. * .. image:: https://img.shields.io/github/tag/DEShawResearch/sns-mp2.svg?maxAge=2592000; :target: https://github.com/DEShawResearch/sns-mp2. * Download the plugin from the GitHub repository:. .. code-block:: bash. >>> git clone https://github.com/DEShawResearch/sns-mp2. * Once dowloaded, the plugin can be installed as outlined in the documentation:. .. code-block:: bash. >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}/",MatchSource.DOCS,doc/sphinxman/source/plugin_snsmp2.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst:2289,Deployability,install,install,2289," .. image:: https://img.shields.io/badge/home-sns--mp2-5077AB.svg; :target: https://github.com/DEShawResearch/sns-mp2. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: https://github.com/DEShawResearch/sns-mp2/blob/master/README.md. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon ; et. al. [McGibbon:2017:161725]_. The SNS-MP2 method uses neural networking to ; improve the accuracy of MP2 (:ref:`sec:dfmp2`) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/snsmp2/badges/version.svg; :target: https://anaconda.org/psi4/snsmp2. * snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the Psi4conda installer, snsmp2 has already been installed alongside. * If using the |PSIfour| conda package, the snsmp2 conda package can; be obtained through ``conda install snsmp2 -c psi4`` or ``conda install; psi4-rt -c psi4``. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; snsmp2 can be obtained through ``conda install snsmp2 -c psi4``.; Then, hint its location with :envvar:`PYTHONPATH`. * To remove a conda installation, ``conda remove snsmp2``. **Source**. * .. image:: https://img.shields.io/github/tag/DEShawResearch/sns-mp2.svg?maxAge=2592000; :target: https://github.com/DEShawResearch/sns-mp2. * Download the plugin from the GitHub repository:. .. code-block:: bash. >>> git clone https://github.com/DEShawResearch/sns-mp2. * Once dowloaded, the plugin can be installed as outlined in the documentation:. .. code-block:: bash. >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input; ~~~~~~~~~~~~. A sample input file, adapted from the documentation, i",MatchSource.DOCS,doc/sphinxman/source/plugin_snsmp2.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst:2325,Deployability,install,install,2325," .. image:: https://img.shields.io/badge/home-sns--mp2-5077AB.svg; :target: https://github.com/DEShawResearch/sns-mp2. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: https://github.com/DEShawResearch/sns-mp2/blob/master/README.md. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon ; et. al. [McGibbon:2017:161725]_. The SNS-MP2 method uses neural networking to ; improve the accuracy of MP2 (:ref:`sec:dfmp2`) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/snsmp2/badges/version.svg; :target: https://anaconda.org/psi4/snsmp2. * snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the Psi4conda installer, snsmp2 has already been installed alongside. * If using the |PSIfour| conda package, the snsmp2 conda package can; be obtained through ``conda install snsmp2 -c psi4`` or ``conda install; psi4-rt -c psi4``. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; snsmp2 can be obtained through ``conda install snsmp2 -c psi4``.; Then, hint its location with :envvar:`PYTHONPATH`. * To remove a conda installation, ``conda remove snsmp2``. **Source**. * .. image:: https://img.shields.io/github/tag/DEShawResearch/sns-mp2.svg?maxAge=2592000; :target: https://github.com/DEShawResearch/sns-mp2. * Download the plugin from the GitHub repository:. .. code-block:: bash. >>> git clone https://github.com/DEShawResearch/sns-mp2. * Once dowloaded, the plugin can be installed as outlined in the documentation:. .. code-block:: bash. >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input; ~~~~~~~~~~~~. A sample input file, adapted from the documentation, i",MatchSource.DOCS,doc/sphinxman/source/plugin_snsmp2.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst:2437,Deployability,install,installed,2437,"ocs-latest-5077AB.svg; :target: https://github.com/DEShawResearch/sns-mp2/blob/master/README.md. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon ; et. al. [McGibbon:2017:161725]_. The SNS-MP2 method uses neural networking to ; improve the accuracy of MP2 (:ref:`sec:dfmp2`) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/snsmp2/badges/version.svg; :target: https://anaconda.org/psi4/snsmp2. * snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the Psi4conda installer, snsmp2 has already been installed alongside. * If using the |PSIfour| conda package, the snsmp2 conda package can; be obtained through ``conda install snsmp2 -c psi4`` or ``conda install; psi4-rt -c psi4``. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; snsmp2 can be obtained through ``conda install snsmp2 -c psi4``.; Then, hint its location with :envvar:`PYTHONPATH`. * To remove a conda installation, ``conda remove snsmp2``. **Source**. * .. image:: https://img.shields.io/github/tag/DEShawResearch/sns-mp2.svg?maxAge=2592000; :target: https://github.com/DEShawResearch/sns-mp2. * Download the plugin from the GitHub repository:. .. code-block:: bash. >>> git clone https://github.com/DEShawResearch/sns-mp2. * Once dowloaded, the plugin can be installed as outlined in the documentation:. .. code-block:: bash. >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input; ~~~~~~~~~~~~. A sample input file, adapted from the documentation, is shown below::. # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'); ; Note that the two monomers are separated by doub",MatchSource.DOCS,doc/sphinxman/source/plugin_snsmp2.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst:2528,Deployability,install,install,2528,"ocs-latest-5077AB.svg; :target: https://github.com/DEShawResearch/sns-mp2/blob/master/README.md. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon ; et. al. [McGibbon:2017:161725]_. The SNS-MP2 method uses neural networking to ; improve the accuracy of MP2 (:ref:`sec:dfmp2`) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/snsmp2/badges/version.svg; :target: https://anaconda.org/psi4/snsmp2. * snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the Psi4conda installer, snsmp2 has already been installed alongside. * If using the |PSIfour| conda package, the snsmp2 conda package can; be obtained through ``conda install snsmp2 -c psi4`` or ``conda install; psi4-rt -c psi4``. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; snsmp2 can be obtained through ``conda install snsmp2 -c psi4``.; Then, hint its location with :envvar:`PYTHONPATH`. * To remove a conda installation, ``conda remove snsmp2``. **Source**. * .. image:: https://img.shields.io/github/tag/DEShawResearch/sns-mp2.svg?maxAge=2592000; :target: https://github.com/DEShawResearch/sns-mp2. * Download the plugin from the GitHub repository:. .. code-block:: bash. >>> git clone https://github.com/DEShawResearch/sns-mp2. * Once dowloaded, the plugin can be installed as outlined in the documentation:. .. code-block:: bash. >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input; ~~~~~~~~~~~~. A sample input file, adapted from the documentation, is shown below::. # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'); ; Note that the two monomers are separated by doub",MatchSource.DOCS,doc/sphinxman/source/plugin_snsmp2.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst:2626,Deployability,install,installation,2626," al. [McGibbon:2017:161725]_. The SNS-MP2 method uses neural networking to ; improve the accuracy of MP2 (:ref:`sec:dfmp2`) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/snsmp2/badges/version.svg; :target: https://anaconda.org/psi4/snsmp2. * snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the Psi4conda installer, snsmp2 has already been installed alongside. * If using the |PSIfour| conda package, the snsmp2 conda package can; be obtained through ``conda install snsmp2 -c psi4`` or ``conda install; psi4-rt -c psi4``. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; snsmp2 can be obtained through ``conda install snsmp2 -c psi4``.; Then, hint its location with :envvar:`PYTHONPATH`. * To remove a conda installation, ``conda remove snsmp2``. **Source**. * .. image:: https://img.shields.io/github/tag/DEShawResearch/sns-mp2.svg?maxAge=2592000; :target: https://github.com/DEShawResearch/sns-mp2. * Download the plugin from the GitHub repository:. .. code-block:: bash. >>> git clone https://github.com/DEShawResearch/sns-mp2. * Once dowloaded, the plugin can be installed as outlined in the documentation:. .. code-block:: bash. >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input; ~~~~~~~~~~~~. A sample input file, adapted from the documentation, is shown below::. # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'); ; Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See ; :ref:`sec:tutorial_tu5` for more details on; setting up dimer molecules.) This input file can be run ",MatchSource.DOCS,doc/sphinxman/source/plugin_snsmp2.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst:2985,Deployability,install,installed,2985,"rking to ; improve the accuracy of MP2 (:ref:`sec:dfmp2`) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/snsmp2/badges/version.svg; :target: https://anaconda.org/psi4/snsmp2. * snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the Psi4conda installer, snsmp2 has already been installed alongside. * If using the |PSIfour| conda package, the snsmp2 conda package can; be obtained through ``conda install snsmp2 -c psi4`` or ``conda install; psi4-rt -c psi4``. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; snsmp2 can be obtained through ``conda install snsmp2 -c psi4``.; Then, hint its location with :envvar:`PYTHONPATH`. * To remove a conda installation, ``conda remove snsmp2``. **Source**. * .. image:: https://img.shields.io/github/tag/DEShawResearch/sns-mp2.svg?maxAge=2592000; :target: https://github.com/DEShawResearch/sns-mp2. * Download the plugin from the GitHub repository:. .. code-block:: bash. >>> git clone https://github.com/DEShawResearch/sns-mp2. * Once dowloaded, the plugin can be installed as outlined in the documentation:. .. code-block:: bash. >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input; ~~~~~~~~~~~~. A sample input file, adapted from the documentation, is shown below::. # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'); ; Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See ; :ref:`sec:tutorial_tu5` for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:. .. code-block:: bash. >>> psi4 input.dat. ",MatchSource.DOCS,doc/sphinxman/source/plugin_snsmp2.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst:3179,Deployability,install,install,3179,"rking to ; improve the accuracy of MP2 (:ref:`sec:dfmp2`) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/snsmp2/badges/version.svg; :target: https://anaconda.org/psi4/snsmp2. * snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the Psi4conda installer, snsmp2 has already been installed alongside. * If using the |PSIfour| conda package, the snsmp2 conda package can; be obtained through ``conda install snsmp2 -c psi4`` or ``conda install; psi4-rt -c psi4``. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; snsmp2 can be obtained through ``conda install snsmp2 -c psi4``.; Then, hint its location with :envvar:`PYTHONPATH`. * To remove a conda installation, ``conda remove snsmp2``. **Source**. * .. image:: https://img.shields.io/github/tag/DEShawResearch/sns-mp2.svg?maxAge=2592000; :target: https://github.com/DEShawResearch/sns-mp2. * Download the plugin from the GitHub repository:. .. code-block:: bash. >>> git clone https://github.com/DEShawResearch/sns-mp2. * Once dowloaded, the plugin can be installed as outlined in the documentation:. .. code-block:: bash. >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input; ~~~~~~~~~~~~. A sample input file, adapted from the documentation, is shown below::. # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'); ; Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See ; :ref:`sec:tutorial_tu5` for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:. .. code-block:: bash. >>> psi4 input.dat. ",MatchSource.DOCS,doc/sphinxman/source/plugin_snsmp2.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst:3238,Energy Efficiency,adapt,adapted,3238,"rking to ; improve the accuracy of MP2 (:ref:`sec:dfmp2`) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/snsmp2/badges/version.svg; :target: https://anaconda.org/psi4/snsmp2. * snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the Psi4conda installer, snsmp2 has already been installed alongside. * If using the |PSIfour| conda package, the snsmp2 conda package can; be obtained through ``conda install snsmp2 -c psi4`` or ``conda install; psi4-rt -c psi4``. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; snsmp2 can be obtained through ``conda install snsmp2 -c psi4``.; Then, hint its location with :envvar:`PYTHONPATH`. * To remove a conda installation, ``conda remove snsmp2``. **Source**. * .. image:: https://img.shields.io/github/tag/DEShawResearch/sns-mp2.svg?maxAge=2592000; :target: https://github.com/DEShawResearch/sns-mp2. * Download the plugin from the GitHub repository:. .. code-block:: bash. >>> git clone https://github.com/DEShawResearch/sns-mp2. * Once dowloaded, the plugin can be installed as outlined in the documentation:. .. code-block:: bash. >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input; ~~~~~~~~~~~~. A sample input file, adapted from the documentation, is shown below::. # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'); ; Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See ; :ref:`sec:tutorial_tu5` for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:. .. code-block:: bash. >>> psi4 input.dat. ",MatchSource.DOCS,doc/sphinxman/source/plugin_snsmp2.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst:3384,Energy Efficiency,energy,energy,3384,"rking to ; improve the accuracy of MP2 (:ref:`sec:dfmp2`) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/snsmp2/badges/version.svg; :target: https://anaconda.org/psi4/snsmp2. * snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the Psi4conda installer, snsmp2 has already been installed alongside. * If using the |PSIfour| conda package, the snsmp2 conda package can; be obtained through ``conda install snsmp2 -c psi4`` or ``conda install; psi4-rt -c psi4``. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; snsmp2 can be obtained through ``conda install snsmp2 -c psi4``.; Then, hint its location with :envvar:`PYTHONPATH`. * To remove a conda installation, ``conda remove snsmp2``. **Source**. * .. image:: https://img.shields.io/github/tag/DEShawResearch/sns-mp2.svg?maxAge=2592000; :target: https://github.com/DEShawResearch/sns-mp2. * Download the plugin from the GitHub repository:. .. code-block:: bash. >>> git clone https://github.com/DEShawResearch/sns-mp2. * Once dowloaded, the plugin can be installed as outlined in the documentation:. .. code-block:: bash. >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input; ~~~~~~~~~~~~. A sample input file, adapted from the documentation, is shown below::. # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'); ; Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See ; :ref:`sec:tutorial_tu5` for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:. .. code-block:: bash. >>> psi4 input.dat. ",MatchSource.DOCS,doc/sphinxman/source/plugin_snsmp2.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst:1554,Modifiability,plugin,plugin,1554,"RRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index:: SNS-MP2. .. _`sec:snsmp2`:. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; ===============================================. .. codeauthor:: D. E. Shaw Research; .. sectionauthor:: Shannon E. Houck. .. image:: https://img.shields.io/badge/home-sns--mp2-5077AB.svg; :target: https://github.com/DEShawResearch/sns-mp2. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: https://github.com/DEShawResearch/sns-mp2/blob/master/README.md. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon ; et. al. [McGibbon:2017:161725]_. The SNS-MP2 method uses neural networking to ; improve the accuracy of MP2 (:ref:`sec:dfmp2`) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/snsmp2/badges/version.svg; :target: https://anaconda.org/psi4/snsmp2. * snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the Psi4conda installer, snsmp2 has already been installed alongside. * If using the |PSIfour| conda package, the snsmp2 conda package can; be obtained through ``conda install snsmp2 -c psi4`` or ``conda install; psi4-rt -c psi4``. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; snsmp2 can be obtained through ``conda install snsmp2 -c psi4``.; Then, hint its location with :envvar",MatchSource.DOCS,doc/sphinxman/source/plugin_snsmp2.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst:1805,Modifiability,plugin,plugin,1805,"al Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index:: SNS-MP2. .. _`sec:snsmp2`:. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; ===============================================. .. codeauthor:: D. E. Shaw Research; .. sectionauthor:: Shannon E. Houck. .. image:: https://img.shields.io/badge/home-sns--mp2-5077AB.svg; :target: https://github.com/DEShawResearch/sns-mp2. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: https://github.com/DEShawResearch/sns-mp2/blob/master/README.md. This plugin is an implementation of the SNS-MP2 algorithm developed by McGibbon ; et. al. [McGibbon:2017:161725]_. The SNS-MP2 method uses neural networking to ; improve the accuracy of MP2 (:ref:`sec:dfmp2`) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/snsmp2/badges/version.svg; :target: https://anaconda.org/psi4/snsmp2. * snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the Psi4conda installer, snsmp2 has already been installed alongside. * If using the |PSIfour| conda package, the snsmp2 conda package can; be obtained through ``conda install snsmp2 -c psi4`` or ``conda install; psi4-rt -c psi4``. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; snsmp2 can be obtained through ``conda install snsmp2 -c psi4``.; Then, hint its location with :envvar:`PYTHONPATH`. * To remove a conda installation, ``conda remove snsmp2``. **Source**. * .. image:: https://img.shields.io/github/tag/DEShawResearch/sns-mp2.svg?maxAge=2592000; :target: https://github.com/DEShawResearch/sns-mp2. * Download",MatchSource.DOCS,doc/sphinxman/source/plugin_snsmp2.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst:2834,Modifiability,plugin,plugin,2834,"rking to ; improve the accuracy of MP2 (:ref:`sec:dfmp2`) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/snsmp2/badges/version.svg; :target: https://anaconda.org/psi4/snsmp2. * snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the Psi4conda installer, snsmp2 has already been installed alongside. * If using the |PSIfour| conda package, the snsmp2 conda package can; be obtained through ``conda install snsmp2 -c psi4`` or ``conda install; psi4-rt -c psi4``. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; snsmp2 can be obtained through ``conda install snsmp2 -c psi4``.; Then, hint its location with :envvar:`PYTHONPATH`. * To remove a conda installation, ``conda remove snsmp2``. **Source**. * .. image:: https://img.shields.io/github/tag/DEShawResearch/sns-mp2.svg?maxAge=2592000; :target: https://github.com/DEShawResearch/sns-mp2. * Download the plugin from the GitHub repository:. .. code-block:: bash. >>> git clone https://github.com/DEShawResearch/sns-mp2. * Once dowloaded, the plugin can be installed as outlined in the documentation:. .. code-block:: bash. >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input; ~~~~~~~~~~~~. A sample input file, adapted from the documentation, is shown below::. # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'); ; Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See ; :ref:`sec:tutorial_tu5` for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:. .. code-block:: bash. >>> psi4 input.dat. ",MatchSource.DOCS,doc/sphinxman/source/plugin_snsmp2.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst:2971,Modifiability,plugin,plugin,2971,"rking to ; improve the accuracy of MP2 (:ref:`sec:dfmp2`) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/snsmp2/badges/version.svg; :target: https://anaconda.org/psi4/snsmp2. * snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the Psi4conda installer, snsmp2 has already been installed alongside. * If using the |PSIfour| conda package, the snsmp2 conda package can; be obtained through ``conda install snsmp2 -c psi4`` or ``conda install; psi4-rt -c psi4``. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; snsmp2 can be obtained through ``conda install snsmp2 -c psi4``.; Then, hint its location with :envvar:`PYTHONPATH`. * To remove a conda installation, ``conda remove snsmp2``. **Source**. * .. image:: https://img.shields.io/github/tag/DEShawResearch/sns-mp2.svg?maxAge=2592000; :target: https://github.com/DEShawResearch/sns-mp2. * Download the plugin from the GitHub repository:. .. code-block:: bash. >>> git clone https://github.com/DEShawResearch/sns-mp2. * Once dowloaded, the plugin can be installed as outlined in the documentation:. .. code-block:: bash. >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input; ~~~~~~~~~~~~. A sample input file, adapted from the documentation, is shown below::. # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'); ; Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See ; :ref:`sec:tutorial_tu5` for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:. .. code-block:: bash. >>> psi4 input.dat. ",MatchSource.DOCS,doc/sphinxman/source/plugin_snsmp2.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst:3238,Modifiability,adapt,adapted,3238,"rking to ; improve the accuracy of MP2 (:ref:`sec:dfmp2`) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/snsmp2/badges/version.svg; :target: https://anaconda.org/psi4/snsmp2. * snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the Psi4conda installer, snsmp2 has already been installed alongside. * If using the |PSIfour| conda package, the snsmp2 conda package can; be obtained through ``conda install snsmp2 -c psi4`` or ``conda install; psi4-rt -c psi4``. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; snsmp2 can be obtained through ``conda install snsmp2 -c psi4``.; Then, hint its location with :envvar:`PYTHONPATH`. * To remove a conda installation, ``conda remove snsmp2``. **Source**. * .. image:: https://img.shields.io/github/tag/DEShawResearch/sns-mp2.svg?maxAge=2592000; :target: https://github.com/DEShawResearch/sns-mp2. * Download the plugin from the GitHub repository:. .. code-block:: bash. >>> git clone https://github.com/DEShawResearch/sns-mp2. * Once dowloaded, the plugin can be installed as outlined in the documentation:. .. code-block:: bash. >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input; ~~~~~~~~~~~~. A sample input file, adapted from the documentation, is shown below::. # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'); ; Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See ; :ref:`sec:tutorial_tu5` for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:. .. code-block:: bash. >>> psi4 input.dat. ",MatchSource.DOCS,doc/sphinxman/source/plugin_snsmp2.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_snsmp2.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_v2rdm_casscf.rst:1909,Availability,avail,available,1909,"e Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index::; pair: plugin; v2rdm_casscf. .. _`sec:v2rdm_casscf`:. Plugin v2rdm_casscf by A. E. DePrince; =====================================. .. codeauthor:: A. E. DePrince; .. sectionauthor:: Lori A. Burns. .. *Module:* :ref:`Keywords <apdx:pcm>`, :ref:`PSI Variables <apdx:pcm_psivar>`, :source:`PCMSolver <src/lib/libpsipcm>`. .. image:: https://img.shields.io/badge/home-v2rdm_casscf-5077AB.svg; :target: https://github.com/edeprince3/v2rdm_casscf. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: https://github.com/edeprince3/v2rdm_casscf/blob/master/README.md. A variational 2-RDM-driven CASSCF plugin to |PSIfour|. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/v2rdm_casscf/badges/version.svg; :target: https://anaconda.org/psi4/v2rdm_casscf. * v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the Psi4conda installer, v2rdm_casscf has already been installed alongside. * If using the |PSIfour| conda package, the v2rdm_casscf conda package can; be obtained through ``conda install v2rdm_casscf -c psi4`` or ``conda install; psi4-rt -c psi4``. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; v2rdm_casscf can be obtained through ``conda install v2rdm_casscf -c psi4``.; Then, hint its location with :envvar:`PYTHONPATH`. * To remove a conda installation, ``conda remove v2rdm_casscf``. **Source**. * .. image:: https://img.shields.io/github/tag/edeprince3/v2rdm_casscf.svg?maxAge=2592000; :target: https://github.com/edeprince3/v2rdm_casscf. * If using |PSIfour| built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with :envvar:`PYTHONPATH`. ",MatchSource.DOCS,doc/sphinxman/source/plugin_v2rdm_casscf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_v2rdm_casscf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_v2rdm_casscf.rst:2024,Deployability,install,installer,2024,"e Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index::; pair: plugin; v2rdm_casscf. .. _`sec:v2rdm_casscf`:. Plugin v2rdm_casscf by A. E. DePrince; =====================================. .. codeauthor:: A. E. DePrince; .. sectionauthor:: Lori A. Burns. .. *Module:* :ref:`Keywords <apdx:pcm>`, :ref:`PSI Variables <apdx:pcm_psivar>`, :source:`PCMSolver <src/lib/libpsipcm>`. .. image:: https://img.shields.io/badge/home-v2rdm_casscf-5077AB.svg; :target: https://github.com/edeprince3/v2rdm_casscf. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: https://github.com/edeprince3/v2rdm_casscf/blob/master/README.md. A variational 2-RDM-driven CASSCF plugin to |PSIfour|. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/v2rdm_casscf/badges/version.svg; :target: https://anaconda.org/psi4/v2rdm_casscf. * v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the Psi4conda installer, v2rdm_casscf has already been installed alongside. * If using the |PSIfour| conda package, the v2rdm_casscf conda package can; be obtained through ``conda install v2rdm_casscf -c psi4`` or ``conda install; psi4-rt -c psi4``. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; v2rdm_casscf can be obtained through ``conda install v2rdm_casscf -c psi4``.; Then, hint its location with :envvar:`PYTHONPATH`. * To remove a conda installation, ``conda remove v2rdm_casscf``. **Source**. * .. image:: https://img.shields.io/github/tag/edeprince3/v2rdm_casscf.svg?maxAge=2592000; :target: https://github.com/edeprince3/v2rdm_casscf. * If using |PSIfour| built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with :envvar:`PYTHONPATH`. ",MatchSource.DOCS,doc/sphinxman/source/plugin_v2rdm_casscf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_v2rdm_casscf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_v2rdm_casscf.rst:2065,Deployability,install,installed,2065,"e Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index::; pair: plugin; v2rdm_casscf. .. _`sec:v2rdm_casscf`:. Plugin v2rdm_casscf by A. E. DePrince; =====================================. .. codeauthor:: A. E. DePrince; .. sectionauthor:: Lori A. Burns. .. *Module:* :ref:`Keywords <apdx:pcm>`, :ref:`PSI Variables <apdx:pcm_psivar>`, :source:`PCMSolver <src/lib/libpsipcm>`. .. image:: https://img.shields.io/badge/home-v2rdm_casscf-5077AB.svg; :target: https://github.com/edeprince3/v2rdm_casscf. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: https://github.com/edeprince3/v2rdm_casscf/blob/master/README.md. A variational 2-RDM-driven CASSCF plugin to |PSIfour|. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/v2rdm_casscf/badges/version.svg; :target: https://anaconda.org/psi4/v2rdm_casscf. * v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the Psi4conda installer, v2rdm_casscf has already been installed alongside. * If using the |PSIfour| conda package, the v2rdm_casscf conda package can; be obtained through ``conda install v2rdm_casscf -c psi4`` or ``conda install; psi4-rt -c psi4``. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; v2rdm_casscf can be obtained through ``conda install v2rdm_casscf -c psi4``.; Then, hint its location with :envvar:`PYTHONPATH`. * To remove a conda installation, ``conda remove v2rdm_casscf``. **Source**. * .. image:: https://img.shields.io/github/tag/edeprince3/v2rdm_casscf.svg?maxAge=2592000; :target: https://github.com/edeprince3/v2rdm_casscf. * If using |PSIfour| built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with :envvar:`PYTHONPATH`. ",MatchSource.DOCS,doc/sphinxman/source/plugin_v2rdm_casscf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_v2rdm_casscf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_v2rdm_casscf.rst:2190,Deployability,install,install,2190,"e Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index::; pair: plugin; v2rdm_casscf. .. _`sec:v2rdm_casscf`:. Plugin v2rdm_casscf by A. E. DePrince; =====================================. .. codeauthor:: A. E. DePrince; .. sectionauthor:: Lori A. Burns. .. *Module:* :ref:`Keywords <apdx:pcm>`, :ref:`PSI Variables <apdx:pcm_psivar>`, :source:`PCMSolver <src/lib/libpsipcm>`. .. image:: https://img.shields.io/badge/home-v2rdm_casscf-5077AB.svg; :target: https://github.com/edeprince3/v2rdm_casscf. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: https://github.com/edeprince3/v2rdm_casscf/blob/master/README.md. A variational 2-RDM-driven CASSCF plugin to |PSIfour|. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/v2rdm_casscf/badges/version.svg; :target: https://anaconda.org/psi4/v2rdm_casscf. * v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the Psi4conda installer, v2rdm_casscf has already been installed alongside. * If using the |PSIfour| conda package, the v2rdm_casscf conda package can; be obtained through ``conda install v2rdm_casscf -c psi4`` or ``conda install; psi4-rt -c psi4``. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; v2rdm_casscf can be obtained through ``conda install v2rdm_casscf -c psi4``.; Then, hint its location with :envvar:`PYTHONPATH`. * To remove a conda installation, ``conda remove v2rdm_casscf``. **Source**. * .. image:: https://img.shields.io/github/tag/edeprince3/v2rdm_casscf.svg?maxAge=2592000; :target: https://github.com/edeprince3/v2rdm_casscf. * If using |PSIfour| built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with :envvar:`PYTHONPATH`. ",MatchSource.DOCS,doc/sphinxman/source/plugin_v2rdm_casscf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_v2rdm_casscf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_v2rdm_casscf.rst:2232,Deployability,install,install,2232,"e Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index::; pair: plugin; v2rdm_casscf. .. _`sec:v2rdm_casscf`:. Plugin v2rdm_casscf by A. E. DePrince; =====================================. .. codeauthor:: A. E. DePrince; .. sectionauthor:: Lori A. Burns. .. *Module:* :ref:`Keywords <apdx:pcm>`, :ref:`PSI Variables <apdx:pcm_psivar>`, :source:`PCMSolver <src/lib/libpsipcm>`. .. image:: https://img.shields.io/badge/home-v2rdm_casscf-5077AB.svg; :target: https://github.com/edeprince3/v2rdm_casscf. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: https://github.com/edeprince3/v2rdm_casscf/blob/master/README.md. A variational 2-RDM-driven CASSCF plugin to |PSIfour|. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/v2rdm_casscf/badges/version.svg; :target: https://anaconda.org/psi4/v2rdm_casscf. * v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the Psi4conda installer, v2rdm_casscf has already been installed alongside. * If using the |PSIfour| conda package, the v2rdm_casscf conda package can; be obtained through ``conda install v2rdm_casscf -c psi4`` or ``conda install; psi4-rt -c psi4``. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; v2rdm_casscf can be obtained through ``conda install v2rdm_casscf -c psi4``.; Then, hint its location with :envvar:`PYTHONPATH`. * To remove a conda installation, ``conda remove v2rdm_casscf``. **Source**. * .. image:: https://img.shields.io/github/tag/edeprince3/v2rdm_casscf.svg?maxAge=2592000; :target: https://github.com/edeprince3/v2rdm_casscf. * If using |PSIfour| built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with :envvar:`PYTHONPATH`. ",MatchSource.DOCS,doc/sphinxman/source/plugin_v2rdm_casscf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_v2rdm_casscf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_v2rdm_casscf.rst:2344,Deployability,install,installed,2344,"e Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index::; pair: plugin; v2rdm_casscf. .. _`sec:v2rdm_casscf`:. Plugin v2rdm_casscf by A. E. DePrince; =====================================. .. codeauthor:: A. E. DePrince; .. sectionauthor:: Lori A. Burns. .. *Module:* :ref:`Keywords <apdx:pcm>`, :ref:`PSI Variables <apdx:pcm_psivar>`, :source:`PCMSolver <src/lib/libpsipcm>`. .. image:: https://img.shields.io/badge/home-v2rdm_casscf-5077AB.svg; :target: https://github.com/edeprince3/v2rdm_casscf. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: https://github.com/edeprince3/v2rdm_casscf/blob/master/README.md. A variational 2-RDM-driven CASSCF plugin to |PSIfour|. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/v2rdm_casscf/badges/version.svg; :target: https://anaconda.org/psi4/v2rdm_casscf. * v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the Psi4conda installer, v2rdm_casscf has already been installed alongside. * If using the |PSIfour| conda package, the v2rdm_casscf conda package can; be obtained through ``conda install v2rdm_casscf -c psi4`` or ``conda install; psi4-rt -c psi4``. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; v2rdm_casscf can be obtained through ``conda install v2rdm_casscf -c psi4``.; Then, hint its location with :envvar:`PYTHONPATH`. * To remove a conda installation, ``conda remove v2rdm_casscf``. **Source**. * .. image:: https://img.shields.io/github/tag/edeprince3/v2rdm_casscf.svg?maxAge=2592000; :target: https://github.com/edeprince3/v2rdm_casscf. * If using |PSIfour| built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with :envvar:`PYTHONPATH`. ",MatchSource.DOCS,doc/sphinxman/source/plugin_v2rdm_casscf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_v2rdm_casscf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_v2rdm_casscf.rst:2441,Deployability,install,install,2441,"e Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index::; pair: plugin; v2rdm_casscf. .. _`sec:v2rdm_casscf`:. Plugin v2rdm_casscf by A. E. DePrince; =====================================. .. codeauthor:: A. E. DePrince; .. sectionauthor:: Lori A. Burns. .. *Module:* :ref:`Keywords <apdx:pcm>`, :ref:`PSI Variables <apdx:pcm_psivar>`, :source:`PCMSolver <src/lib/libpsipcm>`. .. image:: https://img.shields.io/badge/home-v2rdm_casscf-5077AB.svg; :target: https://github.com/edeprince3/v2rdm_casscf. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: https://github.com/edeprince3/v2rdm_casscf/blob/master/README.md. A variational 2-RDM-driven CASSCF plugin to |PSIfour|. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/v2rdm_casscf/badges/version.svg; :target: https://anaconda.org/psi4/v2rdm_casscf. * v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the Psi4conda installer, v2rdm_casscf has already been installed alongside. * If using the |PSIfour| conda package, the v2rdm_casscf conda package can; be obtained through ``conda install v2rdm_casscf -c psi4`` or ``conda install; psi4-rt -c psi4``. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; v2rdm_casscf can be obtained through ``conda install v2rdm_casscf -c psi4``.; Then, hint its location with :envvar:`PYTHONPATH`. * To remove a conda installation, ``conda remove v2rdm_casscf``. **Source**. * .. image:: https://img.shields.io/github/tag/edeprince3/v2rdm_casscf.svg?maxAge=2592000; :target: https://github.com/edeprince3/v2rdm_casscf. * If using |PSIfour| built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with :envvar:`PYTHONPATH`. ",MatchSource.DOCS,doc/sphinxman/source/plugin_v2rdm_casscf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_v2rdm_casscf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_v2rdm_casscf.rst:2545,Deployability,install,installation,2545,"e Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index::; pair: plugin; v2rdm_casscf. .. _`sec:v2rdm_casscf`:. Plugin v2rdm_casscf by A. E. DePrince; =====================================. .. codeauthor:: A. E. DePrince; .. sectionauthor:: Lori A. Burns. .. *Module:* :ref:`Keywords <apdx:pcm>`, :ref:`PSI Variables <apdx:pcm_psivar>`, :source:`PCMSolver <src/lib/libpsipcm>`. .. image:: https://img.shields.io/badge/home-v2rdm_casscf-5077AB.svg; :target: https://github.com/edeprince3/v2rdm_casscf. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: https://github.com/edeprince3/v2rdm_casscf/blob/master/README.md. A variational 2-RDM-driven CASSCF plugin to |PSIfour|. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/v2rdm_casscf/badges/version.svg; :target: https://anaconda.org/psi4/v2rdm_casscf. * v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the Psi4conda installer, v2rdm_casscf has already been installed alongside. * If using the |PSIfour| conda package, the v2rdm_casscf conda package can; be obtained through ``conda install v2rdm_casscf -c psi4`` or ``conda install; psi4-rt -c psi4``. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; v2rdm_casscf can be obtained through ``conda install v2rdm_casscf -c psi4``.; Then, hint its location with :envvar:`PYTHONPATH`. * To remove a conda installation, ``conda remove v2rdm_casscf``. **Source**. * .. image:: https://img.shields.io/github/tag/edeprince3/v2rdm_casscf.svg?maxAge=2592000; :target: https://github.com/edeprince3/v2rdm_casscf. * If using |PSIfour| built from source and you want v2rdm_casscf built from; from source also,; build it, then hint its location with :envvar:`PYTHONPATH`. ",MatchSource.DOCS,doc/sphinxman/source/plugin_v2rdm_casscf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_v2rdm_casscf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_v2rdm_casscf.rst:1079,Modifiability,plugin,plugin,1079,"ware package; .. #; .. # Copyright (c) 2007-2023 The Psi4 Developers.; .. #; .. # The copyrights for code used from other parties are included in; .. # the corresponding files.; .. #; .. # This file is part of Psi4.; .. #; .. # Psi4 is free software; you can redistribute it and/or modify; .. # it under the terms of the GNU Lesser General Public License as published by; .. # the Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index::; pair: plugin; v2rdm_casscf. .. _`sec:v2rdm_casscf`:. Plugin v2rdm_casscf by A. E. DePrince; =====================================. .. codeauthor:: A. E. DePrince; .. sectionauthor:: Lori A. Burns. .. *Module:* :ref:`Keywords <apdx:pcm>`, :ref:`PSI Variables <apdx:pcm_psivar>`, :source:`PCMSolver <src/lib/libpsipcm>`. .. image:: https://img.shields.io/badge/home-v2rdm_casscf-5077AB.svg; :target: https://github.com/edeprince3/v2rdm_casscf. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: https://github.com/edeprince3/v2rdm_casscf/blob/master/README.md. A variational 2-RDM-driven CASSCF plugin to |PSIfour|. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/v2rdm_casscf/badges/version.svg; :target: https://anaconda.org/psi4/v2rdm_casscf. * v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the Psi4conda installer, v2rdm_casscf has already been installed alongsi",MatchSource.DOCS,doc/sphinxman/source/plugin_v2rdm_casscf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_v2rdm_casscf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_v2rdm_casscf.rst:1709,Modifiability,plugin,plugin,1709,"e; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index::; pair: plugin; v2rdm_casscf. .. _`sec:v2rdm_casscf`:. Plugin v2rdm_casscf by A. E. DePrince; =====================================. .. codeauthor:: A. E. DePrince; .. sectionauthor:: Lori A. Burns. .. *Module:* :ref:`Keywords <apdx:pcm>`, :ref:`PSI Variables <apdx:pcm_psivar>`, :source:`PCMSolver <src/lib/libpsipcm>`. .. image:: https://img.shields.io/badge/home-v2rdm_casscf-5077AB.svg; :target: https://github.com/edeprince3/v2rdm_casscf. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: https://github.com/edeprince3/v2rdm_casscf/blob/master/README.md. A variational 2-RDM-driven CASSCF plugin to |PSIfour|. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/v2rdm_casscf/badges/version.svg; :target: https://anaconda.org/psi4/v2rdm_casscf. * v2rdm_casscf is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * If using the Psi4conda installer, v2rdm_casscf has already been installed alongside. * If using the |PSIfour| conda package, the v2rdm_casscf conda package can; be obtained through ``conda install v2rdm_casscf -c psi4`` or ``conda install; psi4-rt -c psi4``. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; v2rdm_casscf can be obtained through ``conda install v2rdm_casscf -c psi4``.; Then, hint its location with :envvar:`PYTHONPATH`. * To remove a conda installation, ``conda remove v2rdm_casscf``. **Source**. * .. image:: https://img.shields.io/github/tag/edeprince3/v2rdm_casscf.svg?maxAge=2592000; :target: ",MatchSource.DOCS,doc/sphinxman/source/plugin_v2rdm_casscf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/plugin_v2rdm_casscf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_ccenergy.rst:4124,Availability,avail,availability,4124,"---+---+---+---+---+---+---+; | ccsd | |globals__cc_type| |   |  |   |  |   |  |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | ccsd(t)\ [#e10]_ | |globals__cc_type| |   | |   | |   | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | a-ccsd(t)\ [#e11]_ | |globals__cc_type| |   | | | | | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | bccd(t) | |globals__cc_type| |   | |   | |   | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | cc3 | |globals__cc_type| |   | |   | |   | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+. .. [#e1] Algorithm type selection keyword below. Values to the right: conventional ``CV``, density-fitted ``DF``, and Cholesky-decomposed ``CD``.; .. [#e2] Active orbital values to the right: all-electron ``A`` and frozen-core ``F``.; .. [#e3] Finite difference gradients are not marked explicitly by """", but the capability can be gleaned from the energy availability.; .. [#e10] Analytic gradients for conventional all-electron RHF/UHF computations can be requested through |globals__qc_module|\ ``=ccenergy``, but their scaling is best suited to small molecules.; .. [#e11] a-CCSD(T) also known as CCSD(aT), Lambda-CCSD(T), and CCSD(T)_L",MatchSource.DOCS,doc/sphinxman/source/preview_capabilities_ccenergy.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_ccenergy.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_ccenergy.rst:4117,Energy Efficiency,energy,energy,4117,"---+---+---+---+---+---+---+; | ccsd | |globals__cc_type| |   |  |   |  |   |  |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | ccsd(t)\ [#e10]_ | |globals__cc_type| |   | |   | |   | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | a-ccsd(t)\ [#e11]_ | |globals__cc_type| |   | | | | | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | bccd(t) | |globals__cc_type| |   | |   | |   | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | cc3 | |globals__cc_type| |   | |   | |   | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+. .. [#e1] Algorithm type selection keyword below. Values to the right: conventional ``CV``, density-fitted ``DF``, and Cholesky-decomposed ``CD``.; .. [#e2] Active orbital values to the right: all-electron ``A`` and frozen-core ``F``.; .. [#e3] Finite difference gradients are not marked explicitly by """", but the capability can be gleaned from the energy availability.; .. [#e10] Analytic gradients for conventional all-electron RHF/UHF computations can be requested through |globals__qc_module|\ ``=ccenergy``, but their scaling is best suited to small molecules.; .. [#e11] a-CCSD(T) also known as CCSD(aT), Lambda-CCSD(T), and CCSD(T)_L",MatchSource.DOCS,doc/sphinxman/source/preview_capabilities_ccenergy.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_ccenergy.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_details.rst:15669,Availability,avail,availability,15669,"--+---+---+---+---+---+---+---+; | b3lyp, Hybrid DFT | .. _dd_b3lyp: |    |    |    |    | | |; | |globals__scf_type| | SCF |    |   |    |   | | |; +--------------------------+--------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | wb97x, LRC DFT | .. _dd_wb97x: |   |   |   |   | | |; | |globals__scf_type| | SCF |   |   |   |   | | |; +--------------------------+--------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | b2plyp, DH DFT\ [#d14]_ | .. _dd_b2plyp: |       | |       | | | |; | |globals__scf_type| | SCF |       | |       | | | |; +--------------------------+--------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+. .. [#d1] Algorithm type selection keyword below. Values to the right: conventional ``CV``, density-fitted ``DF``, and Cholesky-decomposed ``CD``.; .. [#d2] Active orbital values to the right: all-electron ``A`` and frozen-core ``F``.; .. [#d3] Finite difference gradients are only marked explicitly by """" for overall (not per-method) lines and when at least one case has analytic gradients implemented, but the capability can be gleaned from the energy availability.; .. [#d10] Also available for DFT references RKS/UKS; .. [#d11] Arbitrary-order *n* through DETCI is inefficient byproduct of CI; .. [#d12] Analytic gradients for conventional all-electron RHF/UHF computations can be requested through |globals__qc_module|\ ``=ccenergy``, but their scaling is best suited to small molecules.; .. [#d13] a-CCSD(T) also known as CCSD(aT), Lambda-CCSD(T), and CCSD(T)_L; .. [#d14] DH-DFT only available with DF-MP2",MatchSource.DOCS,doc/sphinxman/source/preview_capabilities_details.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_details.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_details.rst:15699,Availability,avail,available,15699,"--+---+---+---+---+---+---+---+; | b3lyp, Hybrid DFT | .. _dd_b3lyp: |    |    |    |    | | |; | |globals__scf_type| | SCF |    |   |    |   | | |; +--------------------------+--------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | wb97x, LRC DFT | .. _dd_wb97x: |   |   |   |   | | |; | |globals__scf_type| | SCF |   |   |   |   | | |; +--------------------------+--------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | b2plyp, DH DFT\ [#d14]_ | .. _dd_b2plyp: |       | |       | | | |; | |globals__scf_type| | SCF |       | |       | | | |; +--------------------------+--------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+. .. [#d1] Algorithm type selection keyword below. Values to the right: conventional ``CV``, density-fitted ``DF``, and Cholesky-decomposed ``CD``.; .. [#d2] Active orbital values to the right: all-electron ``A`` and frozen-core ``F``.; .. [#d3] Finite difference gradients are only marked explicitly by """" for overall (not per-method) lines and when at least one case has analytic gradients implemented, but the capability can be gleaned from the energy availability.; .. [#d10] Also available for DFT references RKS/UKS; .. [#d11] Arbitrary-order *n* through DETCI is inefficient byproduct of CI; .. [#d12] Analytic gradients for conventional all-electron RHF/UHF computations can be requested through |globals__qc_module|\ ``=ccenergy``, but their scaling is best suited to small molecules.; .. [#d13] a-CCSD(T) also known as CCSD(aT), Lambda-CCSD(T), and CCSD(T)_L; .. [#d14] DH-DFT only available with DF-MP2",MatchSource.DOCS,doc/sphinxman/source/preview_capabilities_details.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_details.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_details.rst:16106,Availability,avail,available,16106,"--+---+---+---+---+---+---+---+; | b3lyp, Hybrid DFT | .. _dd_b3lyp: |    |    |    |    | | |; | |globals__scf_type| | SCF |    |   |    |   | | |; +--------------------------+--------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | wb97x, LRC DFT | .. _dd_wb97x: |   |   |   |   | | |; | |globals__scf_type| | SCF |   |   |   |   | | |; +--------------------------+--------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | b2plyp, DH DFT\ [#d14]_ | .. _dd_b2plyp: |       | |       | | | |; | |globals__scf_type| | SCF |       | |       | | | |; +--------------------------+--------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+. .. [#d1] Algorithm type selection keyword below. Values to the right: conventional ``CV``, density-fitted ``DF``, and Cholesky-decomposed ``CD``.; .. [#d2] Active orbital values to the right: all-electron ``A`` and frozen-core ``F``.; .. [#d3] Finite difference gradients are only marked explicitly by """" for overall (not per-method) lines and when at least one case has analytic gradients implemented, but the capability can be gleaned from the energy availability.; .. [#d10] Also available for DFT references RKS/UKS; .. [#d11] Arbitrary-order *n* through DETCI is inefficient byproduct of CI; .. [#d12] Analytic gradients for conventional all-electron RHF/UHF computations can be requested through |globals__qc_module|\ ``=ccenergy``, but their scaling is best suited to small molecules.; .. [#d13] a-CCSD(T) also known as CCSD(aT), Lambda-CCSD(T), and CCSD(T)_L; .. [#d14] DH-DFT only available with DF-MP2",MatchSource.DOCS,doc/sphinxman/source/preview_capabilities_details.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_details.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_details.rst:15662,Energy Efficiency,energy,energy,15662,"--+---+---+---+---+---+---+---+; | b3lyp, Hybrid DFT | .. _dd_b3lyp: |    |    |    |    | | |; | |globals__scf_type| | SCF |    |   |    |   | | |; +--------------------------+--------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | wb97x, LRC DFT | .. _dd_wb97x: |   |   |   |   | | |; | |globals__scf_type| | SCF |   |   |   |   | | |; +--------------------------+--------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | b2plyp, DH DFT\ [#d14]_ | .. _dd_b2plyp: |       | |       | | | |; | |globals__scf_type| | SCF |       | |       | | | |; +--------------------------+--------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+. .. [#d1] Algorithm type selection keyword below. Values to the right: conventional ``CV``, density-fitted ``DF``, and Cholesky-decomposed ``CD``.; .. [#d2] Active orbital values to the right: all-electron ``A`` and frozen-core ``F``.; .. [#d3] Finite difference gradients are only marked explicitly by """" for overall (not per-method) lines and when at least one case has analytic gradients implemented, but the capability can be gleaned from the energy availability.; .. [#d10] Also available for DFT references RKS/UKS; .. [#d11] Arbitrary-order *n* through DETCI is inefficient byproduct of CI; .. [#d12] Analytic gradients for conventional all-electron RHF/UHF computations can be requested through |globals__qc_module|\ ``=ccenergy``, but their scaling is best suited to small molecules.; .. [#d13] a-CCSD(T) also known as CCSD(aT), Lambda-CCSD(T), and CCSD(T)_L; .. [#d14] DH-DFT only available with DF-MP2",MatchSource.DOCS,doc/sphinxman/source/preview_capabilities_details.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_details.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_dfmp2.rst:2528,Availability,avail,availability,2528," | |qc_module|\ =DFMP2 Capabilities |; + + +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; |  | |scf__reference|  | Restricted (RHF) | Unrestricted (UHF) | Restricted Open (ROHF) |; + + +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | name   |  | |energy_fn| | |gradient_fn|\ [#m3]_ | |energy_fn| | |gradient_fn|\ [#m3]_ | |energy_fn| | |gradient_fn|\ [#m3]_ |; + + +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; |  | type\ [#m1]_   | CV | DF | CD | CV | DF | CD | CV | DF | CD | CV | DF | CD | CV | DF | CD | CV | DF | CD |; + + +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; |  | |freeze_core|\ [#m2]_\ | A F A F A F | A F A F A F | A F A F A F | A F A F A F | A F A F A F | A F A F A F |; +==========================+=========================+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+; | mp2\ [#m10]_ | |globals__mp2_type| |   |   |   | |   | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+. .. [#m1] Algorithm type selection keyword below. Values to the right: conventional ``CV``, density-fitted ``DF``, and Cholesky-decomposed ``CD``.; .. [#m2] Active orbital values to the right: all-electron ``A`` and frozen-core ``F``.; .. [#m3] Finite difference gradients are not marked explicitly by """", but the capability can be gleaned from the energy availability.; .. [#m10] Also available for DFT references RKS/UKS",MatchSource.DOCS,doc/sphinxman/source/preview_capabilities_dfmp2.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_dfmp2.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_dfmp2.rst:2558,Availability,avail,available,2558," | |qc_module|\ =DFMP2 Capabilities |; + + +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; |  | |scf__reference|  | Restricted (RHF) | Unrestricted (UHF) | Restricted Open (ROHF) |; + + +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | name   |  | |energy_fn| | |gradient_fn|\ [#m3]_ | |energy_fn| | |gradient_fn|\ [#m3]_ | |energy_fn| | |gradient_fn|\ [#m3]_ |; + + +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; |  | type\ [#m1]_   | CV | DF | CD | CV | DF | CD | CV | DF | CD | CV | DF | CD | CV | DF | CD | CV | DF | CD |; + + +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; |  | |freeze_core|\ [#m2]_\ | A F A F A F | A F A F A F | A F A F A F | A F A F A F | A F A F A F | A F A F A F |; +==========================+=========================+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+; | mp2\ [#m10]_ | |globals__mp2_type| |   |   |   | |   | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+. .. [#m1] Algorithm type selection keyword below. Values to the right: conventional ``CV``, density-fitted ``DF``, and Cholesky-decomposed ``CD``.; .. [#m2] Active orbital values to the right: all-electron ``A`` and frozen-core ``F``.; .. [#m3] Finite difference gradients are not marked explicitly by """", but the capability can be gleaned from the energy availability.; .. [#m10] Also available for DFT references RKS/UKS",MatchSource.DOCS,doc/sphinxman/source/preview_capabilities_dfmp2.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_dfmp2.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_dfmp2.rst:2521,Energy Efficiency,energy,energy,2521," | |qc_module|\ =DFMP2 Capabilities |; + + +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; |  | |scf__reference|  | Restricted (RHF) | Unrestricted (UHF) | Restricted Open (ROHF) |; + + +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | name   |  | |energy_fn| | |gradient_fn|\ [#m3]_ | |energy_fn| | |gradient_fn|\ [#m3]_ | |energy_fn| | |gradient_fn|\ [#m3]_ |; + + +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; |  | type\ [#m1]_   | CV | DF | CD | CV | DF | CD | CV | DF | CD | CV | DF | CD | CV | DF | CD | CV | DF | CD |; + + +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; |  | |freeze_core|\ [#m2]_\ | A F A F A F | A F A F A F | A F A F A F | A F A F A F | A F A F A F | A F A F A F |; +==========================+=========================+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+; | mp2\ [#m10]_ | |globals__mp2_type| |   |   |   | |   | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+. .. [#m1] Algorithm type selection keyword below. Values to the right: conventional ``CV``, density-fitted ``DF``, and Cholesky-decomposed ``CD``.; .. [#m2] Active orbital values to the right: all-electron ``A`` and frozen-core ``F``.; .. [#m3] Finite difference gradients are not marked explicitly by """", but the capability can be gleaned from the energy availability.; .. [#m10] Also available for DFT references RKS/UKS",MatchSource.DOCS,doc/sphinxman/source/preview_capabilities_dfmp2.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_dfmp2.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_occ_nonoo.rst:4832,Availability,avail,availability,4832,"------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | lccd | |globals__cc_type| |       |    |       |    | | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | ccd | |globals__cc_type| |     |   |     |   | | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | ccsd | |globals__cc_type| |     |   |     |   | | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | ccsd(t) | |globals__cc_type| |     |   | | | | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | a-ccsd(t)\ [#n10]_ | |globals__cc_type| |     | | | | | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+. .. [#n1] Algorithm type selection keyword below. Values to the right: conventional ``CV``, density-fitted ``DF``, and Cholesky-decomposed ``CD``.; .. [#n2] Active orbital values to the right: all-electron ``A`` and frozen-core ``F``.; .. [#n3] Finite difference gradients are not marked explicitly by """", but the capability can be gleaned from the energy availability.; .. [#n10] a-CCSD(T) also known as CCSD(aT), Lambda-CCSD(T), and CCSD(T)_L",MatchSource.DOCS,doc/sphinxman/source/preview_capabilities_occ_nonoo.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_occ_nonoo.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_occ_nonoo.rst:4825,Energy Efficiency,energy,energy,4825,"------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | lccd | |globals__cc_type| |       |    |       |    | | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | ccd | |globals__cc_type| |     |   |     |   | | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | ccsd | |globals__cc_type| |     |   |     |   | | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | ccsd(t) | |globals__cc_type| |     |   | | | | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | a-ccsd(t)\ [#n10]_ | |globals__cc_type| |     | | | | | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+. .. [#n1] Algorithm type selection keyword below. Values to the right: conventional ``CV``, density-fitted ``DF``, and Cholesky-decomposed ``CD``.; .. [#n2] Active orbital values to the right: all-electron ``A`` and frozen-core ``F``.; .. [#n3] Finite difference gradients are not marked explicitly by """", but the capability can be gleaned from the energy availability.; .. [#n10] a-CCSD(T) also known as CCSD(aT), Lambda-CCSD(T), and CCSD(T)_L",MatchSource.DOCS,doc/sphinxman/source/preview_capabilities_occ_nonoo.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_occ_nonoo.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_occ_nonoo.rst:144,Performance,optimiz,optimized,144,".. NOTE: this file is autogenerated for preview and not used in docs directly. .. _`table:occ_stdsuite_nonoo`:. .. table:: Detailed non-orbital-optimized capabilities of the OCC module. """" runs analytically. Single underline """" is default module when |globals__qc_module| unspecified. Double underline """" is default algorithm type when type selector (e.g., |globals__cc_type|\ ) unspecified.; :align: left. +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; |  |  | |qc_module|\ =OCC Capabilities |; + + +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; |  | |scf__reference|  | Restricted (RHF) | Unrestricted (UHF) | Restricted Open (ROHF) |; + + +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | name   |  | |energy_fn| | |gradient_fn|\ [#n3]_ | |energy_fn| | |gradient_fn|\ [#n3]_ | |energy_fn| | |gradient_fn|\ [#n3]_ |; + + +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; |  | type\ [#n1]_   | CV | DF | CD | CV | DF | CD | CV | DF | CD | CV | DF | CD | CV | DF | CD | CV | DF | CD |; + + +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; |  | |freeze_core|\ [#n2]_\ | A F A F A F | A F A F A F | A F A F A F | A F A F A F | A F A F A F | A F A F A F |; +==========================+=========================+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+; | mp2 | |globals__mp2_type| |       |    |       |   ",MatchSource.DOCS,doc/sphinxman/source/preview_capabilities_occ_nonoo.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_occ_nonoo.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_occ_oo.rst:3893,Availability,avail,availability,3893,"   |    |      |    |      |    |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | omp2.5\ [#c10]_ | |globals__mp_type| |      |    |      |    |      |    |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | omp3\ [#c10]_ | |globals__mp_type| |      |    |      |    |      |    |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | oremp2\ [#c10]_ | |globals__cc_type| |      |    |      |    |      |    |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | olccd\ [#c10]_ | |globals__cc_type| |      |    |      |    |      |    |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+. .. [#c1] Algorithm type selection keyword below. Values to the right: conventional ``CV``, density-fitted ``DF``, and Cholesky-decomposed ``CD``.; .. [#c2] Active orbital values to the right: all-electron ``A`` and frozen-core ``F``.; .. [#c3] Finite difference gradients are not marked explicitly by """", but the capability can be gleaned from the energy availability.; .. [#c10] Also available for DFT references RKS/UKS",MatchSource.DOCS,doc/sphinxman/source/preview_capabilities_occ_oo.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_occ_oo.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_occ_oo.rst:3923,Availability,avail,available,3923,"   |    |      |    |      |    |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | omp2.5\ [#c10]_ | |globals__mp_type| |      |    |      |    |      |    |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | omp3\ [#c10]_ | |globals__mp_type| |      |    |      |    |      |    |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | oremp2\ [#c10]_ | |globals__cc_type| |      |    |      |    |      |    |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | olccd\ [#c10]_ | |globals__cc_type| |      |    |      |    |      |    |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+. .. [#c1] Algorithm type selection keyword below. Values to the right: conventional ``CV``, density-fitted ``DF``, and Cholesky-decomposed ``CD``.; .. [#c2] Active orbital values to the right: all-electron ``A`` and frozen-core ``F``.; .. [#c3] Finite difference gradients are not marked explicitly by """", but the capability can be gleaned from the energy availability.; .. [#c10] Also available for DFT references RKS/UKS",MatchSource.DOCS,doc/sphinxman/source/preview_capabilities_occ_oo.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_occ_oo.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_occ_oo.rst:3886,Energy Efficiency,energy,energy,3886,"   |    |      |    |      |    |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | omp2.5\ [#c10]_ | |globals__mp_type| |      |    |      |    |      |    |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | omp3\ [#c10]_ | |globals__mp_type| |      |    |      |    |      |    |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | oremp2\ [#c10]_ | |globals__cc_type| |      |    |      |    |      |    |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | olccd\ [#c10]_ | |globals__cc_type| |      |    |      |    |      |    |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+. .. [#c1] Algorithm type selection keyword below. Values to the right: conventional ``CV``, density-fitted ``DF``, and Cholesky-decomposed ``CD``.; .. [#c2] Active orbital values to the right: all-electron ``A`` and frozen-core ``F``.; .. [#c3] Finite difference gradients are not marked explicitly by """", but the capability can be gleaned from the energy availability.; .. [#c10] Also available for DFT references RKS/UKS",MatchSource.DOCS,doc/sphinxman/source/preview_capabilities_occ_oo.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_occ_oo.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_occ_oo.rst:137,Performance,optimiz,optimized,137,".. NOTE: this file is autogenerated for preview and not used in docs directly. .. _`table:occ_stdsuite_oo`:. .. table:: Detailed orbital-optimized capabilities of the OCC module. """" runs analytically. Single underline """" is default module when |globals__qc_module| unspecified. Double underline """" is default algorithm type when type selector (e.g., |globals__cc_type|\ ) unspecified.; :align: left. +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; |  |  | |qc_module|\ =OCC Capabilities |; + + +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; |  | |scf__reference|  | Restricted (RHF) | Unrestricted (UHF) | Restricted Open (ROHF) |; + + +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | name   |  | |energy_fn| | |gradient_fn|\ [#c3]_ | |energy_fn| | |gradient_fn|\ [#c3]_ | |energy_fn| | |gradient_fn|\ [#c3]_ |; + + +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; |  | type\ [#c1]_   | CV | DF | CD | CV | DF | CD | CV | DF | CD | CV | DF | CD | CV | DF | CD | CV | DF | CD |; + + +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; |  | |freeze_core|\ [#c2]_\ | A F A F A F | A F A F A F | A F A F A F | A F A F A F | A F A F A F | A F A F A F |; +==========================+=========================+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+===+; | omp2\ [#c10]_ | |globals__mp2_type| |      |    |      |  ",MatchSource.DOCS,doc/sphinxman/source/preview_capabilities_occ_oo.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_occ_oo.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_scf.rst:5043,Availability,avail,availability,5043,"lobals__scf_type| |    |   | |    |   | | | | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | b3lyp, Hybrid DFT | |globals__scf_type| |    |   | |    |   | | | | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | wb97x, LRC DFT | |globals__scf_type| |   |   | |   |   | | | | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | b2plyp, DH DFT\ [#r10]_ | |globals__scf_type| |       | | |       | | | | | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+. .. [#r1] Algorithm type selection keyword below. Values to the right: conventional ``CV``, density-fitted ``DF``, and Cholesky-decomposed ``CD``.; .. [#r2] Active orbital values to the right: all-electron ``A`` and frozen-core ``F``.; .. [#r3] Finite difference gradients are not marked explicitly by """", but the capability can be gleaned from the energy availability.; .. [#r4] Finite difference Hessians are not marked explicitly by """", but the capability can be gleaned from the gradient or energy availability.; .. [#r10] DH-DFT only available with DF-MP2",MatchSource.DOCS,doc/sphinxman/source/preview_capabilities_scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_scf.rst:5190,Availability,avail,availability,5190,"lobals__scf_type| |    |   | |    |   | | | | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | b3lyp, Hybrid DFT | |globals__scf_type| |    |   | |    |   | | | | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | wb97x, LRC DFT | |globals__scf_type| |   |   | |   |   | | | | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | b2plyp, DH DFT\ [#r10]_ | |globals__scf_type| |       | | |       | | | | | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+. .. [#r1] Algorithm type selection keyword below. Values to the right: conventional ``CV``, density-fitted ``DF``, and Cholesky-decomposed ``CD``.; .. [#r2] Active orbital values to the right: all-electron ``A`` and frozen-core ``F``.; .. [#r3] Finite difference gradients are not marked explicitly by """", but the capability can be gleaned from the energy availability.; .. [#r4] Finite difference Hessians are not marked explicitly by """", but the capability can be gleaned from the gradient or energy availability.; .. [#r10] DH-DFT only available with DF-MP2",MatchSource.DOCS,doc/sphinxman/source/preview_capabilities_scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_scf.rst:5227,Availability,avail,available,5227,"lobals__scf_type| |    |   | |    |   | | | | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | b3lyp, Hybrid DFT | |globals__scf_type| |    |   | |    |   | | | | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | wb97x, LRC DFT | |globals__scf_type| |   |   | |   |   | | | | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | b2plyp, DH DFT\ [#r10]_ | |globals__scf_type| |       | | |       | | | | | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+. .. [#r1] Algorithm type selection keyword below. Values to the right: conventional ``CV``, density-fitted ``DF``, and Cholesky-decomposed ``CD``.; .. [#r2] Active orbital values to the right: all-electron ``A`` and frozen-core ``F``.; .. [#r3] Finite difference gradients are not marked explicitly by """", but the capability can be gleaned from the energy availability.; .. [#r4] Finite difference Hessians are not marked explicitly by """", but the capability can be gleaned from the gradient or energy availability.; .. [#r10] DH-DFT only available with DF-MP2",MatchSource.DOCS,doc/sphinxman/source/preview_capabilities_scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_scf.rst:5036,Energy Efficiency,energy,energy,5036,"lobals__scf_type| |    |   | |    |   | | | | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | b3lyp, Hybrid DFT | |globals__scf_type| |    |   | |    |   | | | | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | wb97x, LRC DFT | |globals__scf_type| |   |   | |   |   | | | | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | b2plyp, DH DFT\ [#r10]_ | |globals__scf_type| |       | | |       | | | | | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+. .. [#r1] Algorithm type selection keyword below. Values to the right: conventional ``CV``, density-fitted ``DF``, and Cholesky-decomposed ``CD``.; .. [#r2] Active orbital values to the right: all-electron ``A`` and frozen-core ``F``.; .. [#r3] Finite difference gradients are not marked explicitly by """", but the capability can be gleaned from the energy availability.; .. [#r4] Finite difference Hessians are not marked explicitly by """", but the capability can be gleaned from the gradient or energy availability.; .. [#r10] DH-DFT only available with DF-MP2",MatchSource.DOCS,doc/sphinxman/source/preview_capabilities_scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_scf.rst:5183,Energy Efficiency,energy,energy,5183,"lobals__scf_type| |    |   | |    |   | | | | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | b3lyp, Hybrid DFT | |globals__scf_type| |    |   | |    |   | | | | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | wb97x, LRC DFT | |globals__scf_type| |   |   | |   |   | | | | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | b2plyp, DH DFT\ [#r10]_ | |globals__scf_type| |       | | |       | | | | | |; +--------------------------+-------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+. .. [#r1] Algorithm type selection keyword below. Values to the right: conventional ``CV``, density-fitted ``DF``, and Cholesky-decomposed ``CD``.; .. [#r2] Active orbital values to the right: all-electron ``A`` and frozen-core ``F``.; .. [#r3] Finite difference gradients are not marked explicitly by """", but the capability can be gleaned from the energy availability.; .. [#r4] Finite difference Hessians are not marked explicitly by """", but the capability can be gleaned from the gradient or energy availability.; .. [#r10] DH-DFT only available with DF-MP2",MatchSource.DOCS,doc/sphinxman/source/preview_capabilities_scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_summary.rst:13620,Availability,avail,availability,13620,"--+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | pbe, GGA DFT | .. _ss_pbe: | |globals__scf_type| |    |    |    |    | | |; +--------------------------+----------------------+--------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | b3lyp, Hybrid DFT | .. _ss_b3lyp: | |globals__scf_type| |    |    |    |    | | |; +--------------------------+----------------------+--------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | wb97x, LRC DFT | .. _ss_wb97x: | |globals__scf_type| |   |   |   |   | | |; +--------------------------+----------------------+--------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | b2plyp, DH DFT\ [#s12]_ | .. _ss_b2plyp: | |globals__scf_type| |       | |       | | | |; +--------------------------+----------------------+--------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+. .. [#s1] Algorithm type selection keyword below. Values to the right: conventional ``CV``, density-fitted ``DF``, and Cholesky-decomposed ``CD``.; .. [#s2] Active orbital values to the right: all-electron ``A`` and frozen-core ``F``.; .. [#s3] Methods with no analytic gradients do not have finite difference explicitly marked by """", but the capability can be gleaned from the energy availability.; .. [#s10] Arbitrary-order *n* through DETCI is inefficient byproduct of CI; .. [#s11] a-CCSD(T) also known as CCSD(aT), Lambda-CCSD(T), and CCSD(T)_L; .. [#s12] DH-DFT only available with DF-MP2",MatchSource.DOCS,doc/sphinxman/source/preview_capabilities_summary.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_summary.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_summary.rst:13808,Availability,avail,available,13808,"--+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | pbe, GGA DFT | .. _ss_pbe: | |globals__scf_type| |    |    |    |    | | |; +--------------------------+----------------------+--------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | b3lyp, Hybrid DFT | .. _ss_b3lyp: | |globals__scf_type| |    |    |    |    | | |; +--------------------------+----------------------+--------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | wb97x, LRC DFT | .. _ss_wb97x: | |globals__scf_type| |   |   |   |   | | |; +--------------------------+----------------------+--------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | b2plyp, DH DFT\ [#s12]_ | .. _ss_b2plyp: | |globals__scf_type| |       | |       | | | |; +--------------------------+----------------------+--------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+. .. [#s1] Algorithm type selection keyword below. Values to the right: conventional ``CV``, density-fitted ``DF``, and Cholesky-decomposed ``CD``.; .. [#s2] Active orbital values to the right: all-electron ``A`` and frozen-core ``F``.; .. [#s3] Methods with no analytic gradients do not have finite difference explicitly marked by """", but the capability can be gleaned from the energy availability.; .. [#s10] Arbitrary-order *n* through DETCI is inefficient byproduct of CI; .. [#s11] a-CCSD(T) also known as CCSD(aT), Lambda-CCSD(T), and CCSD(T)_L; .. [#s12] DH-DFT only available with DF-MP2",MatchSource.DOCS,doc/sphinxman/source/preview_capabilities_summary.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_summary.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_summary.rst:13613,Energy Efficiency,energy,energy,13613,"--+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | pbe, GGA DFT | .. _ss_pbe: | |globals__scf_type| |    |    |    |    | | |; +--------------------------+----------------------+--------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | b3lyp, Hybrid DFT | .. _ss_b3lyp: | |globals__scf_type| |    |    |    |    | | |; +--------------------------+----------------------+--------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | wb97x, LRC DFT | .. _ss_wb97x: | |globals__scf_type| |   |   |   |   | | |; +--------------------------+----------------------+--------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+; | b2plyp, DH DFT\ [#s12]_ | .. _ss_b2plyp: | |globals__scf_type| |       | |       | | | |; +--------------------------+----------------------+--------------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+. .. [#s1] Algorithm type selection keyword below. Values to the right: conventional ``CV``, density-fitted ``DF``, and Cholesky-decomposed ``CD``.; .. [#s2] Active orbital values to the right: all-electron ``A`` and frozen-core ``F``.; .. [#s3] Methods with no analytic gradients do not have finite difference explicitly marked by """", but the capability can be gleaned from the energy availability.; .. [#s10] Arbitrary-order *n* through DETCI is inefficient byproduct of CI; .. [#s11] a-CCSD(T) also known as CCSD(aT), Lambda-CCSD(T), and CCSD(T)_L; .. [#s12] DH-DFT only available with DF-MP2",MatchSource.DOCS,doc/sphinxman/source/preview_capabilities_summary.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/preview_capabilities_summary.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst:5068,Availability,avail,available,5068,"_wfn = scf_helper(name, **kwargs); ; # If the scf type is DF/CD, then the AO integrals were never written to disk; if psi4.get_option('SCF', 'SCF_TYPE') in ['DF', 'CD']:; psi4.MintsHelper(ref_wfn.basisset()).integrals(). Direct any post-scf modules to be run. ::. # include if further post-scf modules are needed; psi4.transqt2(); psi4.ccsort(); psi4.mp2(). If an :py:class:`~psi4.driver.p4util.OptionsState` object was set up, those options; need to be returned to the original user state with the following. ::. # include if optstash = OptionsState(...) was set up previously; optstash.restore(). Current best practice is to store as much as possible on the wavefunction, not in globals. The; driver should handle interactions with globals. When QCVariables are stored on the wavefunction in; the module, copy to globals with the below::. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). The function should return the wavefunction, except for rare cases like EFP where no wavefunction available.; For now, ``CURRENT ENERGY`` will be set by; :py:func:`~psi4.driver.energy`, etc. In future, this will be extracted from the wavefunction. ::. # return highest or most prominent wavefunction (like dimer for SAPT); return fnocc_wfn. Managed Methods; ---------------. There are several conditions when a method and derivative combination should be *managed*:. * when functionality overlaps between modules, a pattern is needed to; access each route through the code;. * when functionality doesn't overlap completely, a pattern is needed to apportion defaulting among; the modules, taking into account reference (RHF/UHF/ROHF), calc type (CONV/DF/CD), and possibly; |globals__freeze_core| state (AE/FC). * for higher-level derivatives, when, say, gradient functionality for mtd+ref+type+fcae doesn't; exactly match energy functionality, a pattern is needed to decide analytic vs. finite difference. * when default type is not available for a method",MatchSource.DOCS,doc/sphinxman/source/proc_py.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst:6002,Availability,avail,available,6002,"wavefunction, except for rare cases like EFP where no wavefunction available.; For now, ``CURRENT ENERGY`` will be set by; :py:func:`~psi4.driver.energy`, etc. In future, this will be extracted from the wavefunction. ::. # return highest or most prominent wavefunction (like dimer for SAPT); return fnocc_wfn. Managed Methods; ---------------. There are several conditions when a method and derivative combination should be *managed*:. * when functionality overlaps between modules, a pattern is needed to; access each route through the code;. * when functionality doesn't overlap completely, a pattern is needed to apportion defaulting among; the modules, taking into account reference (RHF/UHF/ROHF), calc type (CONV/DF/CD), and possibly; |globals__freeze_core| state (AE/FC). * for higher-level derivatives, when, say, gradient functionality for mtd+ref+type+fcae doesn't; exactly match energy functionality, a pattern is needed to decide analytic vs. finite difference. * when default type is not available for a method (e.g., CCD governed by |globals__cc_type| that; defaults to ``CONV`` but only ``DF`` and ``CD`` CCD is available), an informative error message is needed. Managed methods handle these cases through the addition of a new; keyword |globals__qc_module| and a set of type keywords analogous to; |globals__mp2_type|: |globals__mp_type|,; |globals__ci_type|, |globals__cc_type|, which can have values ``CONV``,; ``DF``, and ``CD``. These are all *global* keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We're sticking with |globals__scf_type| and; |globals__mp2_type| defaulting to ``DF``, while most everything higher defaults; to ``CONV``. (Exceptions are MP2.5 and MP3 that default to ``DF``.); In :source:`psi4/driver/procrouting/proc_table.py`, a managed method calls a; ""select"" function rather than a ""run"" function. ::. procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dct' : run",MatchSource.DOCS,doc/sphinxman/source/proc_py.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst:6128,Availability,avail,available,6128,"Y`` will be set by; :py:func:`~psi4.driver.energy`, etc. In future, this will be extracted from the wavefunction. ::. # return highest or most prominent wavefunction (like dimer for SAPT); return fnocc_wfn. Managed Methods; ---------------. There are several conditions when a method and derivative combination should be *managed*:. * when functionality overlaps between modules, a pattern is needed to; access each route through the code;. * when functionality doesn't overlap completely, a pattern is needed to apportion defaulting among; the modules, taking into account reference (RHF/UHF/ROHF), calc type (CONV/DF/CD), and possibly; |globals__freeze_core| state (AE/FC). * for higher-level derivatives, when, say, gradient functionality for mtd+ref+type+fcae doesn't; exactly match energy functionality, a pattern is needed to decide analytic vs. finite difference. * when default type is not available for a method (e.g., CCD governed by |globals__cc_type| that; defaults to ``CONV`` but only ``DF`` and ``CD`` CCD is available), an informative error message is needed. Managed methods handle these cases through the addition of a new; keyword |globals__qc_module| and a set of type keywords analogous to; |globals__mp2_type|: |globals__mp_type|,; |globals__ci_type|, |globals__cc_type|, which can have values ``CONV``,; ``DF``, and ``CD``. These are all *global* keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We're sticking with |globals__scf_type| and; |globals__mp2_type| defaulting to ``DF``, while most everything higher defaults; to ``CONV``. (Exceptions are MP2.5 and MP3 that default to ``DF``.); In :source:`psi4/driver/procrouting/proc_table.py`, a managed method calls a; ""select"" function rather than a ""run"" function. ::. procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dct' : run_dct,. Then in :source:`psi4/driver/procrouting/proc.py`, the select function runs through; reference, t",MatchSource.DOCS,doc/sphinxman/source/proc_py.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst:6155,Availability,error,error,6155,"Y`` will be set by; :py:func:`~psi4.driver.energy`, etc. In future, this will be extracted from the wavefunction. ::. # return highest or most prominent wavefunction (like dimer for SAPT); return fnocc_wfn. Managed Methods; ---------------. There are several conditions when a method and derivative combination should be *managed*:. * when functionality overlaps between modules, a pattern is needed to; access each route through the code;. * when functionality doesn't overlap completely, a pattern is needed to apportion defaulting among; the modules, taking into account reference (RHF/UHF/ROHF), calc type (CONV/DF/CD), and possibly; |globals__freeze_core| state (AE/FC). * for higher-level derivatives, when, say, gradient functionality for mtd+ref+type+fcae doesn't; exactly match energy functionality, a pattern is needed to decide analytic vs. finite difference. * when default type is not available for a method (e.g., CCD governed by |globals__cc_type| that; defaults to ``CONV`` but only ``DF`` and ``CD`` CCD is available), an informative error message is needed. Managed methods handle these cases through the addition of a new; keyword |globals__qc_module| and a set of type keywords analogous to; |globals__mp2_type|: |globals__mp_type|,; |globals__ci_type|, |globals__cc_type|, which can have values ``CONV``,; ``DF``, and ``CD``. These are all *global* keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We're sticking with |globals__scf_type| and; |globals__mp2_type| defaulting to ``DF``, while most everything higher defaults; to ``CONV``. (Exceptions are MP2.5 and MP3 that default to ``DF``.); In :source:`psi4/driver/procrouting/proc_table.py`, a managed method calls a; ""select"" function rather than a ""run"" function. ::. procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dct' : run_dct,. Then in :source:`psi4/driver/procrouting/proc.py`, the select function runs through; reference, t",MatchSource.DOCS,doc/sphinxman/source/proc_py.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst:7407,Availability,error,error,7407,"s__ci_type|, |globals__cc_type|, which can have values ``CONV``,; ``DF``, and ``CD``. These are all *global* keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We're sticking with |globals__scf_type| and; |globals__mp2_type| defaulting to ``DF``, while most everything higher defaults; to ``CONV``. (Exceptions are MP2.5 and MP3 that default to ``DF``.); In :source:`psi4/driver/procrouting/proc_table.py`, a managed method calls a; ""select"" function rather than a ""run"" function. ::. procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dct' : run_dct,. Then in :source:`psi4/driver/procrouting/proc.py`, the select function runs through; reference, type, and possibly freeze_core to specify the proc; function to call for any able, non-default module (*e.g.*, ``mtd_type ==; 'DETCI'`` ) or able, default module (*e.g.*, ``mtd_typd == ['', 'FNOCC']`` ).; Don't worry about 'else' statements as anything that falls through will be; caught and a readable error generated. ::. def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_ty",MatchSource.DOCS,doc/sphinxman/source/proc_py.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst:9105,Availability,error,error,9105,"able error generated. ::. def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever ``DO_CD``-like keywords your; module uses. At run time with a closed-shell molecule, ::. energy('mp3'). will run OCC, while ::. set qc_module fnocc; energy('mp3'). will run FNOCC mp3. A special case is DETCI that *can* run mp3, but oughtn't to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with ::. set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error ::. set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In :ref:`table:managedmethods` ""Y"" means method available in; module, ""D"" means module is default for that method, """" mean method not; available. ",MatchSource.DOCS,doc/sphinxman/source/proc_py.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst:9304,Availability,avail,available,9304,"able error generated. ::. def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever ``DO_CD``-like keywords your; module uses. At run time with a closed-shell molecule, ::. energy('mp3'). will run OCC, while ::. set qc_module fnocc; energy('mp3'). will run FNOCC mp3. A special case is DETCI that *can* run mp3, but oughtn't to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with ::. set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error ::. set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In :ref:`table:managedmethods` ""Y"" means method available in; module, ""D"" means module is default for that method, """" mean method not; available. ",MatchSource.DOCS,doc/sphinxman/source/proc_py.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst:9391,Availability,avail,available,9391,"able error generated. ::. def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever ``DO_CD``-like keywords your; module uses. At run time with a closed-shell molecule, ::. energy('mp3'). will run OCC, while ::. set qc_module fnocc; energy('mp3'). will run FNOCC mp3. A special case is DETCI that *can* run mp3, but oughtn't to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with ::. set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error ::. set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In :ref:`table:managedmethods` ""Y"" means method available in; module, ""D"" means module is default for that method, """" mean method not; available. ",MatchSource.DOCS,doc/sphinxman/source/proc_py.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst:1636,Energy Efficiency,energy,energy,1636," FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:proc_py`:. Adding Methods to Driver; ========================. ``proc.py``; -----------. Methods that are computable by only one module should be added to the ``procedures`` dictionary in; :source:`psi4/driver/procrouting/proc_table.py`; that associates method names with functions; to run them located in :source:`psi4/driver/procrouting/proc.py`. The function should start with a declaration, as below. ``methodname`` is; never seen by users, so it's good to be specific to method or module.; The function must always take as arguments ``(name, **kwargs)``. ::. # energy method; def run_methodname(name, **kwargs):. # gradient method; def run_methodname_gradient(name, **kwargs):. If the function needs to test the identity of ``name`` several times, it; can be convenient to predefine the lowercase version of the variable. The; case of all other py-side options (in kwargs) has already been handled by; :py:func:`~psi4.driver.energy()`, etc. in driver.py and need not be repeated here. ::. # include if convenient; lowername = name.lower(). # never include; kwargs = kwargs_lower(kwargs). The function often needs to set options for the; c-side modules it calls. In order that the state of the options set by the; user remains when control is returned to the user, an; :py:class:`~psi4.driver.p4util.OptionsState` object is set up. See; :ref:`sec:handlingOptions_py` for details. *All* options set by the; function need to be included here, and *only* options set by the function; should be included. Most options should be associated with a particular; module, but a few (see below) ar",MatchSource.DOCS,doc/sphinxman/source/proc_py.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst:2000,Energy Efficiency,energy,energy,2000,"CENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:proc_py`:. Adding Methods to Driver; ========================. ``proc.py``; -----------. Methods that are computable by only one module should be added to the ``procedures`` dictionary in; :source:`psi4/driver/procrouting/proc_table.py`; that associates method names with functions; to run them located in :source:`psi4/driver/procrouting/proc.py`. The function should start with a declaration, as below. ``methodname`` is; never seen by users, so it's good to be specific to method or module.; The function must always take as arguments ``(name, **kwargs)``. ::. # energy method; def run_methodname(name, **kwargs):. # gradient method; def run_methodname_gradient(name, **kwargs):. If the function needs to test the identity of ``name`` several times, it; can be convenient to predefine the lowercase version of the variable. The; case of all other py-side options (in kwargs) has already been handled by; :py:func:`~psi4.driver.energy()`, etc. in driver.py and need not be repeated here. ::. # include if convenient; lowername = name.lower(). # never include; kwargs = kwargs_lower(kwargs). The function often needs to set options for the; c-side modules it calls. In order that the state of the options set by the; user remains when control is returned to the user, an; :py:class:`~psi4.driver.p4util.OptionsState` object is set up. See; :ref:`sec:handlingOptions_py` for details. *All* options set by the; function need to be included here, and *only* options set by the function; should be included. Most options should be associated with a particular; module, but a few (see below) are given without module. ::. # include if any options set; optstash = OptionsState(; # these and other basis options should have no associated module; ['BASIS'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['PUREAM'],; ['FREEZE_CORE'],; # all others should have an associated module; ['SCF', 'SCF_TYPE'],; ['SCF', 'GUESS'],; ['DFMP2', 'MP2_OS_SCALE'],; )",MatchSource.DOCS,doc/sphinxman/source/proc_py.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst:5147,Energy Efficiency,energy,energy,5147,"ion('SCF', 'SCF_TYPE') in ['DF', 'CD']:; psi4.MintsHelper(ref_wfn.basisset()).integrals(). Direct any post-scf modules to be run. ::. # include if further post-scf modules are needed; psi4.transqt2(); psi4.ccsort(); psi4.mp2(). If an :py:class:`~psi4.driver.p4util.OptionsState` object was set up, those options; need to be returned to the original user state with the following. ::. # include if optstash = OptionsState(...) was set up previously; optstash.restore(). Current best practice is to store as much as possible on the wavefunction, not in globals. The; driver should handle interactions with globals. When QCVariables are stored on the wavefunction in; the module, copy to globals with the below::. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). The function should return the wavefunction, except for rare cases like EFP where no wavefunction available.; For now, ``CURRENT ENERGY`` will be set by; :py:func:`~psi4.driver.energy`, etc. In future, this will be extracted from the wavefunction. ::. # return highest or most prominent wavefunction (like dimer for SAPT); return fnocc_wfn. Managed Methods; ---------------. There are several conditions when a method and derivative combination should be *managed*:. * when functionality overlaps between modules, a pattern is needed to; access each route through the code;. * when functionality doesn't overlap completely, a pattern is needed to apportion defaulting among; the modules, taking into account reference (RHF/UHF/ROHF), calc type (CONV/DF/CD), and possibly; |globals__freeze_core| state (AE/FC). * for higher-level derivatives, when, say, gradient functionality for mtd+ref+type+fcae doesn't; exactly match energy functionality, a pattern is needed to decide analytic vs. finite difference. * when default type is not available for a method (e.g., CCD governed by |globals__cc_type| that; defaults to ``CONV`` but only ``DF`` and ``CD`` CCD is available), an informative",MatchSource.DOCS,doc/sphinxman/source/proc_py.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst:5891,Energy Efficiency,energy,energy,5891,"hove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). The function should return the wavefunction, except for rare cases like EFP where no wavefunction available.; For now, ``CURRENT ENERGY`` will be set by; :py:func:`~psi4.driver.energy`, etc. In future, this will be extracted from the wavefunction. ::. # return highest or most prominent wavefunction (like dimer for SAPT); return fnocc_wfn. Managed Methods; ---------------. There are several conditions when a method and derivative combination should be *managed*:. * when functionality overlaps between modules, a pattern is needed to; access each route through the code;. * when functionality doesn't overlap completely, a pattern is needed to apportion defaulting among; the modules, taking into account reference (RHF/UHF/ROHF), calc type (CONV/DF/CD), and possibly; |globals__freeze_core| state (AE/FC). * for higher-level derivatives, when, say, gradient functionality for mtd+ref+type+fcae doesn't; exactly match energy functionality, a pattern is needed to decide analytic vs. finite difference. * when default type is not available for a method (e.g., CCD governed by |globals__cc_type| that; defaults to ``CONV`` but only ``DF`` and ``CD`` CCD is available), an informative error message is needed. Managed methods handle these cases through the addition of a new; keyword |globals__qc_module| and a set of type keywords analogous to; |globals__mp2_type|: |globals__mp_type|,; |globals__ci_type|, |globals__cc_type|, which can have values ``CONV``,; ``DF``, and ``CD``. These are all *global* keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We're sticking with |globals__scf_type| and; |globals__mp2_type| defaulting to ``DF``, while most everything higher defaults; to ``CONV``. (Exceptions are MP2.5 and MP3 that default to ``DF``.); In :source:`psi4/driver/procrouting/proc_table.py`, a managed method calls ",MatchSource.DOCS,doc/sphinxman/source/proc_py.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst:6939,Energy Efficiency,energy,energy,6939,"ifference. * when default type is not available for a method (e.g., CCD governed by |globals__cc_type| that; defaults to ``CONV`` but only ``DF`` and ``CD`` CCD is available), an informative error message is needed. Managed methods handle these cases through the addition of a new; keyword |globals__qc_module| and a set of type keywords analogous to; |globals__mp2_type|: |globals__mp_type|,; |globals__ci_type|, |globals__cc_type|, which can have values ``CONV``,; ``DF``, and ``CD``. These are all *global* keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We're sticking with |globals__scf_type| and; |globals__mp2_type| defaulting to ``DF``, while most everything higher defaults; to ``CONV``. (Exceptions are MP2.5 and MP3 that default to ``DF``.); In :source:`psi4/driver/procrouting/proc_table.py`, a managed method calls a; ""select"" function rather than a ""run"" function. ::. procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dct' : run_dct,. Then in :source:`psi4/driver/procrouting/proc.py`, the select function runs through; reference, type, and possibly freeze_core to specify the proc; function to call for any able, non-default module (*e.g.*, ``mtd_type ==; 'DETCI'`` ) or able, default module (*e.g.*, ``mtd_typd == ['', 'FNOCC']`` ).; Don't worry about 'else' statements as anything that falls through will be; caught and a readable error generated. ::. def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif",MatchSource.DOCS,doc/sphinxman/source/proc_py.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst:7507,Energy Efficiency,energy,energy,7507,"shared among modules rather than (or in addition to) being used internally; by the module). We're sticking with |globals__scf_type| and; |globals__mp2_type| defaulting to ``DF``, while most everything higher defaults; to ``CONV``. (Exceptions are MP2.5 and MP3 that default to ``DF``.); In :source:`psi4/driver/procrouting/proc_table.py`, a managed method calls a; ""select"" function rather than a ""run"" function. ::. procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dct' : run_dct,. Then in :source:`psi4/driver/procrouting/proc.py`, the select function runs through; reference, type, and possibly freeze_core to specify the proc; function to call for any able, non-default module (*e.g.*, ``mtd_type ==; 'DETCI'`` ) or able, default module (*e.g.*, ``mtd_typd == ['', 'FNOCC']`` ).; Don't worry about 'else' statements as anything that falls through will be; caught and a readable error generated. ::. def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_typ",MatchSource.DOCS,doc/sphinxman/source/proc_py.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst:8766,Energy Efficiency,energy,energy,8766,"able error generated. ::. def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever ``DO_CD``-like keywords your; module uses. At run time with a closed-shell molecule, ::. energy('mp3'). will run OCC, while ::. set qc_module fnocc; energy('mp3'). will run FNOCC mp3. A special case is DETCI that *can* run mp3, but oughtn't to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with ::. set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error ::. set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In :ref:`table:managedmethods` ""Y"" means method available in; module, ""D"" means module is default for that method, """" mean method not; available. ",MatchSource.DOCS,doc/sphinxman/source/proc_py.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst:8826,Energy Efficiency,energy,energy,8826,"able error generated. ::. def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever ``DO_CD``-like keywords your; module uses. At run time with a closed-shell molecule, ::. energy('mp3'). will run OCC, while ::. set qc_module fnocc; energy('mp3'). will run FNOCC mp3. A special case is DETCI that *can* run mp3, but oughtn't to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with ::. set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error ::. set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In :ref:`table:managedmethods` ""Y"" means method available in; module, ""D"" means module is default for that method, """" mean method not; available. ",MatchSource.DOCS,doc/sphinxman/source/proc_py.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst:9065,Energy Efficiency,energy,energy,9065,"able error generated. ::. def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever ``DO_CD``-like keywords your; module uses. At run time with a closed-shell molecule, ::. energy('mp3'). will run OCC, while ::. set qc_module fnocc; energy('mp3'). will run FNOCC mp3. A special case is DETCI that *can* run mp3, but oughtn't to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with ::. set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error ::. set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In :ref:`table:managedmethods` ""Y"" means method available in; module, ""D"" means module is default for that method, """" mean method not; available. ",MatchSource.DOCS,doc/sphinxman/source/proc_py.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst:9135,Energy Efficiency,energy,energy,9135,"able error generated. ::. def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever ``DO_CD``-like keywords your; module uses. At run time with a closed-shell molecule, ::. energy('mp3'). will run OCC, while ::. set qc_module fnocc; energy('mp3'). will run FNOCC mp3. A special case is DETCI that *can* run mp3, but oughtn't to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with ::. set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error ::. set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In :ref:`table:managedmethods` ""Y"" means method available in; module, ""D"" means module is default for that method, """" mean method not; available. ",MatchSource.DOCS,doc/sphinxman/source/proc_py.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst:5520,Integrability,rout,route,5520,"he original user state with the following. ::. # include if optstash = OptionsState(...) was set up previously; optstash.restore(). Current best practice is to store as much as possible on the wavefunction, not in globals. The; driver should handle interactions with globals. When QCVariables are stored on the wavefunction in; the module, copy to globals with the below::. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). The function should return the wavefunction, except for rare cases like EFP where no wavefunction available.; For now, ``CURRENT ENERGY`` will be set by; :py:func:`~psi4.driver.energy`, etc. In future, this will be extracted from the wavefunction. ::. # return highest or most prominent wavefunction (like dimer for SAPT); return fnocc_wfn. Managed Methods; ---------------. There are several conditions when a method and derivative combination should be *managed*:. * when functionality overlaps between modules, a pattern is needed to; access each route through the code;. * when functionality doesn't overlap completely, a pattern is needed to apportion defaulting among; the modules, taking into account reference (RHF/UHF/ROHF), calc type (CONV/DF/CD), and possibly; |globals__freeze_core| state (AE/FC). * for higher-level derivatives, when, say, gradient functionality for mtd+ref+type+fcae doesn't; exactly match energy functionality, a pattern is needed to decide analytic vs. finite difference. * when default type is not available for a method (e.g., CCD governed by |globals__cc_type| that; defaults to ``CONV`` but only ``DF`` and ``CD`` CCD is available), an informative error message is needed. Managed methods handle these cases through the addition of a new; keyword |globals__qc_module| and a set of type keywords analogous to; |globals__mp2_type|: |globals__mp_type|,; |globals__ci_type|, |globals__cc_type|, which can have values ``CONV``,; ``DF``, and ``CD``. These are all *global* keywords, as the",MatchSource.DOCS,doc/sphinxman/source/proc_py.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst:6161,Integrability,message,message,6161,"Y`` will be set by; :py:func:`~psi4.driver.energy`, etc. In future, this will be extracted from the wavefunction. ::. # return highest or most prominent wavefunction (like dimer for SAPT); return fnocc_wfn. Managed Methods; ---------------. There are several conditions when a method and derivative combination should be *managed*:. * when functionality overlaps between modules, a pattern is needed to; access each route through the code;. * when functionality doesn't overlap completely, a pattern is needed to apportion defaulting among; the modules, taking into account reference (RHF/UHF/ROHF), calc type (CONV/DF/CD), and possibly; |globals__freeze_core| state (AE/FC). * for higher-level derivatives, when, say, gradient functionality for mtd+ref+type+fcae doesn't; exactly match energy functionality, a pattern is needed to decide analytic vs. finite difference. * when default type is not available for a method (e.g., CCD governed by |globals__cc_type| that; defaults to ``CONV`` but only ``DF`` and ``CD`` CCD is available), an informative error message is needed. Managed methods handle these cases through the addition of a new; keyword |globals__qc_module| and a set of type keywords analogous to; |globals__mp2_type|: |globals__mp_type|,; |globals__ci_type|, |globals__cc_type|, which can have values ``CONV``,; ``DF``, and ``CD``. These are all *global* keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We're sticking with |globals__scf_type| and; |globals__mp2_type| defaulting to ``DF``, while most everything higher defaults; to ``CONV``. (Exceptions are MP2.5 and MP3 that default to ``DF``.); In :source:`psi4/driver/procrouting/proc_table.py`, a managed method calls a; ""select"" function rather than a ""run"" function. ::. procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dct' : run_dct,. Then in :source:`psi4/driver/procrouting/proc.py`, the select function runs through; reference, t",MatchSource.DOCS,doc/sphinxman/source/proc_py.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst:1887,Modifiability,variab,variable,1887,"eneral Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:proc_py`:. Adding Methods to Driver; ========================. ``proc.py``; -----------. Methods that are computable by only one module should be added to the ``procedures`` dictionary in; :source:`psi4/driver/procrouting/proc_table.py`; that associates method names with functions; to run them located in :source:`psi4/driver/procrouting/proc.py`. The function should start with a declaration, as below. ``methodname`` is; never seen by users, so it's good to be specific to method or module.; The function must always take as arguments ``(name, **kwargs)``. ::. # energy method; def run_methodname(name, **kwargs):. # gradient method; def run_methodname_gradient(name, **kwargs):. If the function needs to test the identity of ``name`` several times, it; can be convenient to predefine the lowercase version of the variable. The; case of all other py-side options (in kwargs) has already been handled by; :py:func:`~psi4.driver.energy()`, etc. in driver.py and need not be repeated here. ::. # include if convenient; lowername = name.lower(). # never include; kwargs = kwargs_lower(kwargs). The function often needs to set options for the; c-side modules it calls. In order that the state of the options set by the; user remains when control is returned to the user, an; :py:class:`~psi4.driver.p4util.OptionsState` object is set up. See; :ref:`sec:handlingOptions_py` for details. *All* options set by the; function need to be included here, and *only* options set by the function; should be included. Most options should be associated with a particular; module, but a few (see below) are given without module. ::. # include if any options set; optstash = OptionsState(; # these and other basis options should have no associated module; ['BASIS'],; ['",MatchSource.DOCS,doc/sphinxman/source/proc_py.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst:4872,Modifiability,variab,variables,4872," ::. # Bypass the scf call if a reference wavefunction is given; ; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); ; # If the scf type is DF/CD, then the AO integrals were never written to disk; if psi4.get_option('SCF', 'SCF_TYPE') in ['DF', 'CD']:; psi4.MintsHelper(ref_wfn.basisset()).integrals(). Direct any post-scf modules to be run. ::. # include if further post-scf modules are needed; psi4.transqt2(); psi4.ccsort(); psi4.mp2(). If an :py:class:`~psi4.driver.p4util.OptionsState` object was set up, those options; need to be returned to the original user state with the following. ::. # include if optstash = OptionsState(...) was set up previously; optstash.restore(). Current best practice is to store as much as possible on the wavefunction, not in globals. The; driver should handle interactions with globals. When QCVariables are stored on the wavefunction in; the module, copy to globals with the below::. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). The function should return the wavefunction, except for rare cases like EFP where no wavefunction available.; For now, ``CURRENT ENERGY`` will be set by; :py:func:`~psi4.driver.energy`, etc. In future, this will be extracted from the wavefunction. ::. # return highest or most prominent wavefunction (like dimer for SAPT); return fnocc_wfn. Managed Methods; ---------------. There are several conditions when a method and derivative combination should be *managed*:. * when functionality overlaps between modules, a pattern is needed to; access each route through the code;. * when functionality doesn't overlap completely, a pattern is needed to apportion defaulting among; the modules, taking into account reference (RHF/UHF/ROHF), calc type (CONV/DF/CD), and possibly; |globals__freeze_core| state (AE/FC). * for higher-level derivatives, when, say, gradient functionality for mtd+ref+type+fcae doesn't; exactly match en",MatchSource.DOCS,doc/sphinxman/source/proc_py.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst:4923,Modifiability,variab,variables,4923,"rence wavefunction is given; ; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); ; # If the scf type is DF/CD, then the AO integrals were never written to disk; if psi4.get_option('SCF', 'SCF_TYPE') in ['DF', 'CD']:; psi4.MintsHelper(ref_wfn.basisset()).integrals(). Direct any post-scf modules to be run. ::. # include if further post-scf modules are needed; psi4.transqt2(); psi4.ccsort(); psi4.mp2(). If an :py:class:`~psi4.driver.p4util.OptionsState` object was set up, those options; need to be returned to the original user state with the following. ::. # include if optstash = OptionsState(...) was set up previously; optstash.restore(). Current best practice is to store as much as possible on the wavefunction, not in globals. The; driver should handle interactions with globals. When QCVariables are stored on the wavefunction in; the module, copy to globals with the below::. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). The function should return the wavefunction, except for rare cases like EFP where no wavefunction available.; For now, ``CURRENT ENERGY`` will be set by; :py:func:`~psi4.driver.energy`, etc. In future, this will be extracted from the wavefunction. ::. # return highest or most prominent wavefunction (like dimer for SAPT); return fnocc_wfn. Managed Methods; ---------------. There are several conditions when a method and derivative combination should be *managed*:. * when functionality overlaps between modules, a pattern is needed to; access each route through the code;. * when functionality doesn't overlap completely, a pattern is needed to apportion defaulting among; the modules, taking into account reference (RHF/UHF/ROHF), calc type (CONV/DF/CD), and possibly; |globals__freeze_core| state (AE/FC). * for higher-level derivatives, when, say, gradient functionality for mtd+ref+type+fcae doesn't; exactly match energy functionality, a pattern is nee",MatchSource.DOCS,doc/sphinxman/source/proc_py.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst:7555,Performance,perform,performance,7555,"shared among modules rather than (or in addition to) being used internally; by the module). We're sticking with |globals__scf_type| and; |globals__mp2_type| defaulting to ``DF``, while most everything higher defaults; to ``CONV``. (Exceptions are MP2.5 and MP3 that default to ``DF``.); In :source:`psi4/driver/procrouting/proc_table.py`, a managed method calls a; ""select"" function rather than a ""run"" function. ::. procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dct' : run_dct,. Then in :source:`psi4/driver/procrouting/proc.py`, the select function runs through; reference, type, and possibly freeze_core to specify the proc; function to call for any able, non-default module (*e.g.*, ``mtd_type ==; 'DETCI'`` ) or able, default module (*e.g.*, ``mtd_typd == ['', 'FNOCC']`` ).; Don't worry about 'else' statements as anything that falls through will be; caught and a readable error generated. ::. def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_typ",MatchSource.DOCS,doc/sphinxman/source/proc_py.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst:5508,Security,access,access,5508,"he original user state with the following. ::. # include if optstash = OptionsState(...) was set up previously; optstash.restore(). Current best practice is to store as much as possible on the wavefunction, not in globals. The; driver should handle interactions with globals. When QCVariables are stored on the wavefunction in; the module, copy to globals with the below::. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). The function should return the wavefunction, except for rare cases like EFP where no wavefunction available.; For now, ``CURRENT ENERGY`` will be set by; :py:func:`~psi4.driver.energy`, etc. In future, this will be extracted from the wavefunction. ::. # return highest or most prominent wavefunction (like dimer for SAPT); return fnocc_wfn. Managed Methods; ---------------. There are several conditions when a method and derivative combination should be *managed*:. * when functionality overlaps between modules, a pattern is needed to; access each route through the code;. * when functionality doesn't overlap completely, a pattern is needed to apportion defaulting among; the modules, taking into account reference (RHF/UHF/ROHF), calc type (CONV/DF/CD), and possibly; |globals__freeze_core| state (AE/FC). * for higher-level derivatives, when, say, gradient functionality for mtd+ref+type+fcae doesn't; exactly match energy functionality, a pattern is needed to decide analytic vs. finite difference. * when default type is not available for a method (e.g., CCD governed by |globals__cc_type| that; defaults to ``CONV`` but only ``DF`` and ``CD`` CCD is available), an informative error message is needed. Managed methods handle these cases through the addition of a new; keyword |globals__qc_module| and a set of type keywords analogous to; |globals__mp2_type|: |globals__mp_type|,; |globals__ci_type|, |globals__cc_type|, which can have values ``CONV``,; ``DF``, and ``CD``. These are all *global* keywords, as the",MatchSource.DOCS,doc/sphinxman/source/proc_py.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst:8993,Security,access,access,8993,"able error generated. ::. def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever ``DO_CD``-like keywords your; module uses. At run time with a closed-shell molecule, ::. energy('mp3'). will run OCC, while ::. set qc_module fnocc; energy('mp3'). will run FNOCC mp3. A special case is DETCI that *can* run mp3, but oughtn't to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with ::. set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error ::. set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In :ref:`table:managedmethods` ""Y"" means method available in; module, ""D"" means module is default for that method, """" mean method not; available. ",MatchSource.DOCS,doc/sphinxman/source/proc_py.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst:1778,Testability,test,test,1778,"eneral Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:proc_py`:. Adding Methods to Driver; ========================. ``proc.py``; -----------. Methods that are computable by only one module should be added to the ``procedures`` dictionary in; :source:`psi4/driver/procrouting/proc_table.py`; that associates method names with functions; to run them located in :source:`psi4/driver/procrouting/proc.py`. The function should start with a declaration, as below. ``methodname`` is; never seen by users, so it's good to be specific to method or module.; The function must always take as arguments ``(name, **kwargs)``. ::. # energy method; def run_methodname(name, **kwargs):. # gradient method; def run_methodname_gradient(name, **kwargs):. If the function needs to test the identity of ``name`` several times, it; can be convenient to predefine the lowercase version of the variable. The; case of all other py-side options (in kwargs) has already been handled by; :py:func:`~psi4.driver.energy()`, etc. in driver.py and need not be repeated here. ::. # include if convenient; lowername = name.lower(). # never include; kwargs = kwargs_lower(kwargs). The function often needs to set options for the; c-side modules it calls. In order that the state of the options set by the; user remains when control is returned to the user, an; :py:class:`~psi4.driver.p4util.OptionsState` object is set up. See; :ref:`sec:handlingOptions_py` for details. *All* options set by the; function need to be included here, and *only* options set by the function; should be included. Most options should be associated with a particular; module, but a few (see below) are given without module. ::. # include if any options set; optstash = OptionsState(; # these and other basis options should have no associated module; ['BASIS'],; ['",MatchSource.DOCS,doc/sphinxman/source/proc_py.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/proc_py.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:5902,Availability,recover,recovery,5902,"* DGER: Rank-1 update (not wrapped yet). * BLAS3. * DGEMM: General Matrix-Matrix product; * DTRMM: General Triangular Matrix-General Matrix product; * DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); * DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; * DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers; ^^^^^^^^^^^^^^^. All standard LAPACK 3.2 double precision routines are provided. LAPACK commands remain in Fortran's ""column-major"" indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using ``lda = n`` in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower triangular matrix L such; that ``L L^T = A``, but this is returned in column-major order, so the actual; recovery of the matrix A with the row-major BLAS wrappers effectively; involves ``L^T L = A``. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a ``C_``, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, ...) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is ``double**``). All routines return an int INFO w",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:6853,Availability,error,error,6853,"matrix A with the row-major BLAS wrappers effectively; involves ``L^T L = A``. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a ``C_``, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, ...) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is ``double**``). All routines return an int INFO with error and; calculation information specific to the routine, In Fortran, this is the; last argument in all LAPACK calls, but should not be provided as an; argument here. For char arguments, case is insensitive. A Cholesky; transform example is shown::. // BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h""; ; using namespace psi;; ...; int n = 100;; ; // Allocate A matrix;; double** A = block_matrix(n,n);; ; // Call the LAPACK DPOTRF to get the Cholesky factor; // Note this works in column-major order; // The result fills like:; // * * * *; // * * *; // * *; // *; // instead of the expected:; // *; // * *; // * * *; // * * * *; //; int info = C_DPOTRF('L', n, A[0], n);; ; // A bit painful, see below; fprintf(outfile, ""A:\n"");; print_mat(A,n,n,outfile);. // Block matrix should be free_blocked; free_block(A);. Important Lapack Routines; ^^^^^^^^^^^^^^^^^^^^^^^^^. * DSYEV: Eigenvalues and, optionally eigenvectors of a symmetric matrix. Eigenvectors take up to 10x longer than eigenvalues.; * DGEEV: Ei",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:9253,Availability,error,errors,9253,"er and more stable just to solve with DGETRS); * DPOTRI: Inverse, given Cholesky decomposition by DPOTRF (Warning: it's faster and more stable just to solve with DPOTRS). .. _`faq:blasmatrix`:. How to use low-level BLAS/LAPACK with ``psi4.core.Matrix``; ----------------------------------------------------------. Jet's awesome new Matrix object has a lot of simple BLAS/LAPACK built in,; but you can just as easily use the ``double***`` array underneath if you are; careful (the outer index is the submatrix for each irrep). Here's an; example:. .. code-block:: cpp. // BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // Matrix; #include ""psi4/libmints/matrix.h""; ; using namespace psi;; ...; int n = 100;; ; // Allocate A Matrix (new C1 convenience constructor);; shared_ptr<Matrix> A(new Matrix(""Still A, but way cooler"", n,n));; // Get the pointer to the 0 irrep (C1 for now, it errors if you ask for too high of an index); double** A_pointer = A->get_pointer(0);; ; // Call the LAPACK DPOTRF to get the Cholesky factor; // Note this works in column-major order; // The result fills like:; // * * * *; // * * *; // * *; // *; // instead of the expected:; // *; // * *; // * * *; // * * * *; //; int info = C_DPOTRF('L', n, A_pointer[0], n);; ; // Wow that's a lot easier; A->print();; ; // Don't free, it's shared_ptr!. .. _`faq:labas`:. How to name orbital bases (e.g., AO & SO); -----------------------------------------. Many different working bases (the internal linear algebraic basis, not the; name of the Gaussian basis) are used within |PSIfour|, each with a unique; and important purpose. It is critical to keep them all distinct to prevent; weird results from occurring. * ``AO`` (Atomic Orbitals): Cartesian Gaussians (6D, 10F, etc.),; ``(L + 1)(L + 2)/2`` functions per shell of angular momentum L. The; ordering of Cartesian exponents for a given L is given by the standard; ordering below (MATLAB code)::. ncart = (L + 1) * (L + 2) / 2;; exps = zeros(ncart,3);; index = 1;; for i = 0:L; for",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:13011,Availability,redundant,redundant,13011,"orthogonalized by; Symmetric or Canonical Orthogonalization. The number of OSOs may be; slightly smaller than the total number of USOs, due to removal of linear; dependencies via Canonical Orthogonalization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs. * ``MO`` (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. * ``LO`` (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. .. _`faq:orbdims`:. How to name orbital dimensions; ------------------------------. There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below. A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. * nao |w---w| The number of atomic orbitals in Cartesian representation.; * nso |w---w| The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; * nbf |w---w| The number of basis functions, which is the same as nso.; * nmo |w---w| The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep ",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:1584,Deployability,update,update,1584,"WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:blaslapack`:. ===========================; Linear Algebra in |PSIfour|; ===========================. .. _`faq:blaswrappers`:. How to call BLAS & LAPACK in |PSIfour|; --------------------------------------. Computational chemistry is essentially linear algebra on molecular; systems, so using stable, portable, scalable, and efficient numerical; linear algebra methods in |PSIfour| is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so |PSIfour| provides a common set of wrappers in :source:`psi4/src/psi4/libqt/qt.h` . .. warning:: Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; `psi4.core.Matrix` itself. The advice in these docs will catch up; shortly. BLAS Wrappers; ^^^^^^^^^^^^^. BLAS wrappers are currently fully supported at double precision. BLAS commands involving matrices are wrapped so as to be conventional; C-style ""row-major"" indexing, meaning that the column is the fast index; like normal. * The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:4864,Deployability,update,update,4864," block_matrix(n,n);; ; // Call the BLAS1 dot product between a and b; // n can be a ULI with the BLAS1 wrappers,; // All strides must be ints though; double dot = C_DDOT(n, a, 1, b, 1);; ; // Call the BLAS2 GEMV without transposition; // Note this works in row-major order; C_DGEMV('N', n, n, 1.0, A[0], n, a, 1, 0.0, b, 1);; ; // Call the BLAS3 GEMM without transposition; // Note this works in row-major order; C_DGEMM('N','N', n, n, n, 1.0, A[0], n, B[0], n, 0.0, C[0], n);; ; // Array's init'd with init_array must be free'd, not delete[]'d; free(a);; free(b);; ; // Block matrix should be free_blocked; free_block(A);; free_block(B);; free_block(C);. Important BLAS Routines; ^^^^^^^^^^^^^^^^^^^^^^^. * BLAS1. * DDOT: dot product; * DCOPY: efficient memory copy (with variable stride); * DAXPY: y = y + alpha*x; * DROT: Givens Rotation; * DNRM2: Vector norm square. * BLAS2. * DGEMV: General Matrix-Vector product; * DTRMV: Triangular Matrix-Vector product (2x faster, not wrapped yet); * DTRSM: Triangular Matrix-Vector solution via back substitution (just as fast as DTRMV); * DGER: Rank-1 update (not wrapped yet). * BLAS3. * DGEMM: General Matrix-Matrix product; * DTRMM: General Triangular Matrix-General Matrix product; * DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); * DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; * DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers; ^^^^^^^^^^^^^^^. All standard LAPACK 3.2 double precision routines are provided. LAPACK commands remain in Fortran's ""column-major"" indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using ``lda = n`` in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: yo",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:1394,Energy Efficiency,efficient,efficient,1394,"; .. # it under the terms of the GNU Lesser General Public License as published by; .. # the Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:blaslapack`:. ===========================; Linear Algebra in |PSIfour|; ===========================. .. _`faq:blaswrappers`:. How to call BLAS & LAPACK in |PSIfour|; --------------------------------------. Computational chemistry is essentially linear algebra on molecular; systems, so using stable, portable, scalable, and efficient numerical; linear algebra methods in |PSIfour| is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so |PSIfour| provides a common set of wrappers in :source:`psi4/src/psi4/libqt/qt.h` . .. warning:: Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; `psi4.core.Matrix` itself. The advice in these docs will catch up; shortly. BLAS Wrappers; ^^^^^^^^^^^^^. BLAS wrappers are currently fully supported at double precision. BLAS commands involving matrices are wrapped so as ",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:4512,Energy Efficiency,efficient,efficient,4512,";; ...; ; // Allocate a,b vectors; int n = 100;; double* a = init_array(n);; double* b = init_array(n);; ; // Allocate A matrix;; double** A = block_matrix(n,n);; double** B = block_matrix(n,n);; double** C = block_matrix(n,n);; ; // Call the BLAS1 dot product between a and b; // n can be a ULI with the BLAS1 wrappers,; // All strides must be ints though; double dot = C_DDOT(n, a, 1, b, 1);; ; // Call the BLAS2 GEMV without transposition; // Note this works in row-major order; C_DGEMV('N', n, n, 1.0, A[0], n, a, 1, 0.0, b, 1);; ; // Call the BLAS3 GEMM without transposition; // Note this works in row-major order; C_DGEMM('N','N', n, n, n, 1.0, A[0], n, B[0], n, 0.0, C[0], n);; ; // Array's init'd with init_array must be free'd, not delete[]'d; free(a);; free(b);; ; // Block matrix should be free_blocked; free_block(A);; free_block(B);; free_block(C);. Important BLAS Routines; ^^^^^^^^^^^^^^^^^^^^^^^. * BLAS1. * DDOT: dot product; * DCOPY: efficient memory copy (with variable stride); * DAXPY: y = y + alpha*x; * DROT: Givens Rotation; * DNRM2: Vector norm square. * BLAS2. * DGEMV: General Matrix-Vector product; * DTRMV: Triangular Matrix-Vector product (2x faster, not wrapped yet); * DTRSM: Triangular Matrix-Vector solution via back substitution (just as fast as DTRMV); * DGER: Rank-1 update (not wrapped yet). * BLAS3. * DGEMM: General Matrix-Matrix product; * DTRMM: General Triangular Matrix-General Matrix product; * DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); * DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; * DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers; ^^^^^^^^^^^^^^^. All standard LAPACK 3.2 double precision routines are provided. LAPACK commands remain in Fortran's ""column-major"" indexing, so all the; results will be tra",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:11631,Energy Efficiency,adapt,adapted,11631,"rst layer encountered, Libmints handles the transform from AO to SO; automatically. If Cartesian functions are used, the number of functions; per shell remains ``(L + 1)(L + 2)/2``, and the ordering remains the same; as above. Note that the individual functions are not normalized for; angular momentum as in most codes: the self-overlap of a |PSIfour| Cartesian D; or higher function with more than one nonzero Cartesian exponent (e.g., lx; = 1, ly = 1, lz = 0) will be less than one. If Spherical Harmonics are; used, 2L + 1 real combinations of the spherical harmonics are built from; the ``(L+1)(L+2)/2`` Cartesian Gaussians, according to H. Schlegel and M.; Frish, IJQC, 54, 83-87, 1995. Unlike Cartesian functions these functions; are all strictly normalized. Note that in |PSIfour|, the real combinations of; spherical harmonic functions (see the paragraph below Eq. 15 in the; Schlegel paper) are ordered as: 0, 1+, 1-, 2+, 2-, .... * ``USO`` (Unique Symmetry-Adapted Orbitals): Spatial symmetry-adapted; combinations of SOs, blocked according to irrep. The total number of USOs; is the same as the number of SOs, but the number of USOs within each irrep; is usually much smaller, which can lead to significant performance; improvements. Note that this basis is sometimes unfortunately referred to; as the SO basis, so it's a bit context specific. * ``OSO`` (Orthogonal Symmetry-Adapted Orbitals): USOs orthogonalized by; Symmetric or Canonical Orthogonalization. The number of OSOs may be; slightly smaller than the total number of USOs, due to removal of linear; dependencies via Canonical Orthogonalization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs. * ``MO`` (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. * ``LO`` (Localized Orbitals): Localized occupied orbitals, a differ",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:13327,Energy Efficiency,adapt,adapted,13327,"straight from USOs to MOs. * ``MO`` (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. * ``LO`` (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. .. _`faq:orbdims`:. How to name orbital dimensions; ------------------------------. There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below. A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. * nao |w---w| The number of atomic orbitals in Cartesian representation.; * nso |w---w| The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; * nbf |w---w| The number of basis functions, which is the same as nso.; * nmo |w---w| The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the stack, and is named by augmenting the name above; with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is; always the singular nirrep, and that the index variable h is always used; in a for-loop traverse of irreps. ..",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:14050,Energy Efficiency,allocate,allocated,14050,"eanings, as; detailed below. A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. * nao |w---w| The number of atomic orbitals in Cartesian representation.; * nso |w---w| The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; * nbf |w---w| The number of basis functions, which is the same as nso.; * nmo |w---w| The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the stack, and is named by augmenting the name above; with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is; always the singular nirrep, and that the index variable h is always used; in a for-loop traverse of irreps. .. _`faq:orbspaces`:. How to name orbital spaces (e.g., docc); ---------------------------------------. As with basis sets, a number of names are used to refer to refer to the; quantity of electrons, virtuals, and active sub-quantities of a |PSIfour|; calculation. All of these can be defined per irrep as above. Some common; conventions are:. * nelec |w---w| The number of electrons, rarely used due to specialization of alphas and betas or soccs and doccs.; * nalpha |w---w| The number of alpha electrons.; * nbeta |w---w| The number of beta electrons; * docc |w---w| The number of doubly-occupied orbitals; * socc |w---w| The number of singly-occupied orbitals (Almost always alpha, we don't like open-shell singlets much).; * nvir |w---w| The number of vir",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:1885,Integrability,interface,interfaces,1885,"klin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:blaslapack`:. ===========================; Linear Algebra in |PSIfour|; ===========================. .. _`faq:blaswrappers`:. How to call BLAS & LAPACK in |PSIfour|; --------------------------------------. Computational chemistry is essentially linear algebra on molecular; systems, so using stable, portable, scalable, and efficient numerical; linear algebra methods in |PSIfour| is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so |PSIfour| provides a common set of wrappers in :source:`psi4/src/psi4/libqt/qt.h` . .. warning:: Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; `psi4.core.Matrix` itself. The advice in these docs will catch up; shortly. BLAS Wrappers; ^^^^^^^^^^^^^. BLAS wrappers are currently fully supported at double precision. BLAS commands involving matrices are wrapped so as to be conventional; C-style ""row-major"" indexing, meaning that the column is the fast index; like normal. * The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. * All routines are declared in ``qt.h``. Each routine is prefixed with a; ``C_``, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (``int``, ``double``,; ",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:1965,Integrability,wrap,wrappers,1965,"klin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:blaslapack`:. ===========================; Linear Algebra in |PSIfour|; ===========================. .. _`faq:blaswrappers`:. How to call BLAS & LAPACK in |PSIfour|; --------------------------------------. Computational chemistry is essentially linear algebra on molecular; systems, so using stable, portable, scalable, and efficient numerical; linear algebra methods in |PSIfour| is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so |PSIfour| provides a common set of wrappers in :source:`psi4/src/psi4/libqt/qt.h` . .. warning:: Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; `psi4.core.Matrix` itself. The advice in these docs will catch up; shortly. BLAS Wrappers; ^^^^^^^^^^^^^. BLAS wrappers are currently fully supported at double precision. BLAS commands involving matrices are wrapped so as to be conventional; C-style ""row-major"" indexing, meaning that the column is the fast index; like normal. * The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. * All routines are declared in ``qt.h``. Each routine is prefixed with a; ``C_``, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (``int``, ``double``,; ",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:2258,Integrability,wrap,wrappers,2258,"ional chemistry is essentially linear algebra on molecular; systems, so using stable, portable, scalable, and efficient numerical; linear algebra methods in |PSIfour| is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so |PSIfour| provides a common set of wrappers in :source:`psi4/src/psi4/libqt/qt.h` . .. warning:: Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; `psi4.core.Matrix` itself. The advice in these docs will catch up; shortly. BLAS Wrappers; ^^^^^^^^^^^^^. BLAS wrappers are currently fully supported at double precision. BLAS commands involving matrices are wrapped so as to be conventional; C-style ""row-major"" indexing, meaning that the column is the fast index; like normal. * The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. * All routines are declared in ``qt.h``. Each routine is prefixed with a; ``C_``, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (``int``, ``double``,; ``unsigned long int``, ``char``, ...) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is ``double**``). BLAS1 routines occasionally; r",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:2355,Integrability,wrap,wrapped,2355,"fficient numerical; linear algebra methods in |PSIfour| is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so |PSIfour| provides a common set of wrappers in :source:`psi4/src/psi4/libqt/qt.h` . .. warning:: Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; `psi4.core.Matrix` itself. The advice in these docs will catch up; shortly. BLAS Wrappers; ^^^^^^^^^^^^^. BLAS wrappers are currently fully supported at double precision. BLAS commands involving matrices are wrapped so as to be conventional; C-style ""row-major"" indexing, meaning that the column is the fast index; like normal. * The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. * All routines are declared in ``qt.h``. Each routine is prefixed with a; ``C_``, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (``int``, ``double``,; ``unsigned long int``, ``char``, ...) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is ``double**``). BLAS1 routines occasionally; return values (DDOT for instance), BLAS2 and BLAS3 always return void.; For char arguments, case is insensitive.",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:2496,Integrability,rout,routines,2496,"ix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so |PSIfour| provides a common set of wrappers in :source:`psi4/src/psi4/libqt/qt.h` . .. warning:: Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; `psi4.core.Matrix` itself. The advice in these docs will catch up; shortly. BLAS Wrappers; ^^^^^^^^^^^^^. BLAS wrappers are currently fully supported at double precision. BLAS commands involving matrices are wrapped so as to be conventional; C-style ""row-major"" indexing, meaning that the column is the fast index; like normal. * The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. * All routines are declared in ``qt.h``. Each routine is prefixed with a; ``C_``, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (``int``, ``double``,; ``unsigned long int``, ``char``, ...) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is ``double**``). BLAS1 routines occasionally; return values (DDOT for instance), BLAS2 and BLAS3 always return void.; For char arguments, case is insensitive. A few examples are provided::. // BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h""; ; using nam",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:2509,Integrability,wrap,wrapped,2509,"ix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so |PSIfour| provides a common set of wrappers in :source:`psi4/src/psi4/libqt/qt.h` . .. warning:: Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; `psi4.core.Matrix` itself. The advice in these docs will catch up; shortly. BLAS Wrappers; ^^^^^^^^^^^^^. BLAS wrappers are currently fully supported at double precision. BLAS commands involving matrices are wrapped so as to be conventional; C-style ""row-major"" indexing, meaning that the column is the fast index; like normal. * The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. * All routines are declared in ``qt.h``. Each routine is prefixed with a; ``C_``, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (``int``, ``double``,; ``unsigned long int``, ``char``, ...) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is ``double**``). BLAS1 routines occasionally; return values (DDOT for instance), BLAS2 and BLAS3 always return void.; For char arguments, case is insensitive. A few examples are provided::. // BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h""; ; using nam",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:2723,Integrability,rout,routines,2723,"ed by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so |PSIfour| provides a common set of wrappers in :source:`psi4/src/psi4/libqt/qt.h` . .. warning:: Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; `psi4.core.Matrix` itself. The advice in these docs will catch up; shortly. BLAS Wrappers; ^^^^^^^^^^^^^. BLAS wrappers are currently fully supported at double precision. BLAS commands involving matrices are wrapped so as to be conventional; C-style ""row-major"" indexing, meaning that the column is the fast index; like normal. * The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. * All routines are declared in ``qt.h``. Each routine is prefixed with a; ``C_``, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (``int``, ``double``,; ``unsigned long int``, ``char``, ...) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is ``double**``). BLAS1 routines occasionally; return values (DDOT for instance), BLAS2 and BLAS3 always return void.; For char arguments, case is insensitive. A few examples are provided::. // BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h""; ; using namespace psi;; ...; ; // Allocate a,b vectors; int n = 100;; double* a = init_array(n);; double* b = init_array(n);; ; // Allocate A matrix;; double** A = block_matrix(n,n);; double** B = ",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:2763,Integrability,rout,routine,2763,"s differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so |PSIfour| provides a common set of wrappers in :source:`psi4/src/psi4/libqt/qt.h` . .. warning:: Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; `psi4.core.Matrix` itself. The advice in these docs will catch up; shortly. BLAS Wrappers; ^^^^^^^^^^^^^. BLAS wrappers are currently fully supported at double precision. BLAS commands involving matrices are wrapped so as to be conventional; C-style ""row-major"" indexing, meaning that the column is the fast index; like normal. * The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. * All routines are declared in ``qt.h``. Each routine is prefixed with a; ``C_``, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (``int``, ``double``,; ``unsigned long int``, ``char``, ...) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is ``double**``). BLAS1 routines occasionally; return values (DDOT for instance), BLAS2 and BLAS3 always return void.; For char arguments, case is insensitive. A few examples are provided::. // BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h""; ; using namespace psi;; ...; ; // Allocate a,b vectors; int n = 100;; double* a = init_array(n);; double* b = init_array(n);; ; // Allocate A matrix;; double** A = block_matrix(n,n);; double** B = block_matrix(n,n);; double** C = block_matrix(n,n);; ; // Call the BLAS1 dot pro",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:2844,Integrability,rout,routine,2844,"s differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so |PSIfour| provides a common set of wrappers in :source:`psi4/src/psi4/libqt/qt.h` . .. warning:: Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; `psi4.core.Matrix` itself. The advice in these docs will catch up; shortly. BLAS Wrappers; ^^^^^^^^^^^^^. BLAS wrappers are currently fully supported at double precision. BLAS commands involving matrices are wrapped so as to be conventional; C-style ""row-major"" indexing, meaning that the column is the fast index; like normal. * The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. * All routines are declared in ``qt.h``. Each routine is prefixed with a; ``C_``, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (``int``, ``double``,; ``unsigned long int``, ``char``, ...) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is ``double**``). BLAS1 routines occasionally; return values (DDOT for instance), BLAS2 and BLAS3 always return void.; For char arguments, case is insensitive. A few examples are provided::. // BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h""; ; using namespace psi;; ...; ; // Allocate a,b vectors; int n = 100;; double* a = init_array(n);; double* b = init_array(n);; ; // Allocate A matrix;; double** A = block_matrix(n,n);; double** B = block_matrix(n,n);; double** C = block_matrix(n,n);; ; // Call the BLAS1 dot pro",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:3261,Integrability,rout,routines,3261,"le precision. BLAS commands involving matrices are wrapped so as to be conventional; C-style ""row-major"" indexing, meaning that the column is the fast index; like normal. * The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. * All routines are declared in ``qt.h``. Each routine is prefixed with a; ``C_``, followed by the standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (``int``, ``double``,; ``unsigned long int``, ``char``, ...) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is ``double**``). BLAS1 routines occasionally; return values (DDOT for instance), BLAS2 and BLAS3 always return void.; For char arguments, case is insensitive. A few examples are provided::. // BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h""; ; using namespace psi;; ...; ; // Allocate a,b vectors; int n = 100;; double* a = init_array(n);; double* b = init_array(n);; ; // Allocate A matrix;; double** A = block_matrix(n,n);; double** B = block_matrix(n,n);; double** C = block_matrix(n,n);; ; // Call the BLAS1 dot product between a and b; // n can be a ULI with the BLAS1 wrappers,; // All strides must be ints though; double dot = C_DDOT(n, a, 1, b, 1);; ; // Call the BLAS2 GEMV without transposition; // Note this works in row-major order; C_DGEMV('N', n, n, 1.0, A[0], n, a, 1, 0.0, b, 1);; ; // Call the BLAS3 GEMM without transposition; // Note this works in row-major order; C_DGEMM('N','N', n, n, n, 1.0, A[0], n, B[0], n, 0.0, C[0], n);; ; // Array's init'd with init_array must be free'd, not del",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:3870,Integrability,wrap,wrappers,3870,"e standard Fortran name of the routine, in capital; letters. Input parameters of single primitives (``int``, ``double``,; ``unsigned long int``, ``char``, ...) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous; memory (as provided by block_matrix, for example), and are passed by; providing a pointer to the first double or int element of the data (this; is array[0] if array is ``double**``). BLAS1 routines occasionally; return values (DDOT for instance), BLAS2 and BLAS3 always return void.; For char arguments, case is insensitive. A few examples are provided::. // BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h""; ; using namespace psi;; ...; ; // Allocate a,b vectors; int n = 100;; double* a = init_array(n);; double* b = init_array(n);; ; // Allocate A matrix;; double** A = block_matrix(n,n);; double** B = block_matrix(n,n);; double** C = block_matrix(n,n);; ; // Call the BLAS1 dot product between a and b; // n can be a ULI with the BLAS1 wrappers,; // All strides must be ints though; double dot = C_DDOT(n, a, 1, b, 1);; ; // Call the BLAS2 GEMV without transposition; // Note this works in row-major order; C_DGEMV('N', n, n, 1.0, A[0], n, a, 1, 0.0, b, 1);; ; // Call the BLAS3 GEMM without transposition; // Note this works in row-major order; C_DGEMM('N','N', n, n, n, 1.0, A[0], n, B[0], n, 0.0, C[0], n);; ; // Array's init'd with init_array must be free'd, not delete[]'d; free(a);; free(b);; ; // Block matrix should be free_blocked; free_block(A);; free_block(B);; free_block(C);. Important BLAS Routines; ^^^^^^^^^^^^^^^^^^^^^^^. * BLAS1. * DDOT: dot product; * DCOPY: efficient memory copy (with variable stride); * DAXPY: y = y + alpha*x; * DROT: Givens Rotation; * DNRM2: Vector norm square. * BLAS2. * DGEMV: General Matrix-Vector product; * DTRMV: Triangular Matrix-Vector product (2x faster, not wrapped yet); * DTRSM: Triangular Matrix-Vector solution via back sub",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:4745,Integrability,wrap,wrapped,4745," block_matrix(n,n);; ; // Call the BLAS1 dot product between a and b; // n can be a ULI with the BLAS1 wrappers,; // All strides must be ints though; double dot = C_DDOT(n, a, 1, b, 1);; ; // Call the BLAS2 GEMV without transposition; // Note this works in row-major order; C_DGEMV('N', n, n, 1.0, A[0], n, a, 1, 0.0, b, 1);; ; // Call the BLAS3 GEMM without transposition; // Note this works in row-major order; C_DGEMM('N','N', n, n, n, 1.0, A[0], n, B[0], n, 0.0, C[0], n);; ; // Array's init'd with init_array must be free'd, not delete[]'d; free(a);; free(b);; ; // Block matrix should be free_blocked; free_block(A);; free_block(B);; free_block(C);. Important BLAS Routines; ^^^^^^^^^^^^^^^^^^^^^^^. * BLAS1. * DDOT: dot product; * DCOPY: efficient memory copy (with variable stride); * DAXPY: y = y + alpha*x; * DROT: Givens Rotation; * DNRM2: Vector norm square. * BLAS2. * DGEMV: General Matrix-Vector product; * DTRMV: Triangular Matrix-Vector product (2x faster, not wrapped yet); * DTRSM: Triangular Matrix-Vector solution via back substitution (just as fast as DTRMV); * DGER: Rank-1 update (not wrapped yet). * BLAS3. * DGEMM: General Matrix-Matrix product; * DTRMM: General Triangular Matrix-General Matrix product; * DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); * DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; * DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers; ^^^^^^^^^^^^^^^. All standard LAPACK 3.2 double precision routines are provided. LAPACK commands remain in Fortran's ""column-major"" indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using ``lda = n`` in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: yo",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:4876,Integrability,wrap,wrapped,4876," block_matrix(n,n);; ; // Call the BLAS1 dot product between a and b; // n can be a ULI with the BLAS1 wrappers,; // All strides must be ints though; double dot = C_DDOT(n, a, 1, b, 1);; ; // Call the BLAS2 GEMV without transposition; // Note this works in row-major order; C_DGEMV('N', n, n, 1.0, A[0], n, a, 1, 0.0, b, 1);; ; // Call the BLAS3 GEMM without transposition; // Note this works in row-major order; C_DGEMM('N','N', n, n, n, 1.0, A[0], n, B[0], n, 0.0, C[0], n);; ; // Array's init'd with init_array must be free'd, not delete[]'d; free(a);; free(b);; ; // Block matrix should be free_blocked; free_block(A);; free_block(B);; free_block(C);. Important BLAS Routines; ^^^^^^^^^^^^^^^^^^^^^^^. * BLAS1. * DDOT: dot product; * DCOPY: efficient memory copy (with variable stride); * DAXPY: y = y + alpha*x; * DROT: Givens Rotation; * DNRM2: Vector norm square. * BLAS2. * DGEMV: General Matrix-Vector product; * DTRMV: Triangular Matrix-Vector product (2x faster, not wrapped yet); * DTRSM: Triangular Matrix-Vector solution via back substitution (just as fast as DTRMV); * DGER: Rank-1 update (not wrapped yet). * BLAS3. * DGEMM: General Matrix-Matrix product; * DTRMM: General Triangular Matrix-General Matrix product; * DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); * DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; * DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers; ^^^^^^^^^^^^^^^. All standard LAPACK 3.2 double precision routines are provided. LAPACK commands remain in Fortran's ""column-major"" indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using ``lda = n`` in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: yo",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:5444,Integrability,rout,routines,5444,"s; ^^^^^^^^^^^^^^^^^^^^^^^. * BLAS1. * DDOT: dot product; * DCOPY: efficient memory copy (with variable stride); * DAXPY: y = y + alpha*x; * DROT: Givens Rotation; * DNRM2: Vector norm square. * BLAS2. * DGEMV: General Matrix-Vector product; * DTRMV: Triangular Matrix-Vector product (2x faster, not wrapped yet); * DTRSM: Triangular Matrix-Vector solution via back substitution (just as fast as DTRMV); * DGER: Rank-1 update (not wrapped yet). * BLAS3. * DGEMM: General Matrix-Matrix product; * DTRMM: General Triangular Matrix-General Matrix product; * DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); * DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; * DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers; ^^^^^^^^^^^^^^^. All standard LAPACK 3.2 double precision routines are provided. LAPACK commands remain in Fortran's ""column-major"" indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using ``lda = n`` in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower triangular matrix L such; that ``L L^T = A``, but this is returned in column-major order, so the actual; recovery of the matrix A with the row-major BLAS wrappers effectively; involves ``L^T L = A``. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a ``C_``, followed by the standard Fortran name of; the routine, in capital lett",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:5951,Integrability,wrap,wrappers,5951,"* DGER: Rank-1 update (not wrapped yet). * BLAS3. * DGEMM: General Matrix-Matrix product; * DTRMM: General Triangular Matrix-General Matrix product; * DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); * DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; * DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers; ^^^^^^^^^^^^^^^. All standard LAPACK 3.2 double precision routines are provided. LAPACK commands remain in Fortran's ""column-major"" indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using ``lda = n`` in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower triangular matrix L such; that ``L L^T = A``, but this is returned in column-major order, so the actual; recovery of the matrix A with the row-major BLAS wrappers effectively; involves ``L^T L = A``. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a ``C_``, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, ...) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is ``double**``). All routines return an int INFO w",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:6304,Integrability,rout,routines,6304,"faster than DGEMM, and should be used where possible. LAPACK Wrappers; ^^^^^^^^^^^^^^^. All standard LAPACK 3.2 double precision routines are provided. LAPACK commands remain in Fortran's ""column-major"" indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using ``lda = n`` in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower triangular matrix L such; that ``L L^T = A``, but this is returned in column-major order, so the actual; recovery of the matrix A with the row-major BLAS wrappers effectively; involves ``L^T L = A``. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a ``C_``, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, ...) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is ``double**``). All routines return an int INFO with error and; calculation information specific to the routine, In Fortran, this is the; last argument in all LAPACK calls, but should not be provided as an; argument here. For char arguments, case is insensitive. A Cholesky; transform example is shown::. // BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h""; ; using namespace psi;; ...; int n = 100;; ; // Allocate A matrix;; double** A = block_matrix(n,n);; ",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:6341,Integrability,rout,routine,6341,"^^^^^^^^^. All standard LAPACK 3.2 double precision routines are provided. LAPACK commands remain in Fortran's ""column-major"" indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using ``lda = n`` in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower triangular matrix L such; that ``L L^T = A``, but this is returned in column-major order, so the actual; recovery of the matrix A with the row-major BLAS wrappers effectively; involves ``L^T L = A``. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a ``C_``, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, ...) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is ``double**``). All routines return an int INFO with error and; calculation information specific to the routine, In Fortran, this is the; last argument in all LAPACK calls, but should not be provided as an; argument here. For char arguments, case is insensitive. A Cholesky; transform example is shown::. // BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h""; ; using namespace psi;; ...; int n = 100;; ; // Allocate A matrix;; double** A = block_matrix(n,n);; ; // Call the LAPACK DPOTRF to get the Cholesky factor; // Note this works i",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:6422,Integrability,rout,routine,6422,"^^^^^^^^^. All standard LAPACK 3.2 double precision routines are provided. LAPACK commands remain in Fortran's ""column-major"" indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using ``lda = n`` in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower triangular matrix L such; that ``L L^T = A``, but this is returned in column-major order, so the actual; recovery of the matrix A with the row-major BLAS wrappers effectively; involves ``L^T L = A``. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a ``C_``, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, ...) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is ``double**``). All routines return an int INFO with error and; calculation information specific to the routine, In Fortran, this is the; last argument in all LAPACK calls, but should not be provided as an; argument here. For char arguments, case is insensitive. A Cholesky; transform example is shown::. // BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h""; ; using namespace psi;; ...; int n = 100;; ; // Allocate A matrix;; double** A = block_matrix(n,n);; ; // Call the LAPACK DPOTRF to get the Cholesky factor; // Note this works i",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:6820,Integrability,rout,routines,6820,"matrix A with the row-major BLAS wrappers effectively; involves ``L^T L = A``. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a ``C_``, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, ...) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is ``double**``). All routines return an int INFO with error and; calculation information specific to the routine, In Fortran, this is the; last argument in all LAPACK calls, but should not be provided as an; argument here. For char arguments, case is insensitive. A Cholesky; transform example is shown::. // BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h""; ; using namespace psi;; ...; int n = 100;; ; // Allocate A matrix;; double** A = block_matrix(n,n);; ; // Call the LAPACK DPOTRF to get the Cholesky factor; // Note this works in column-major order; // The result fills like:; // * * * *; // * * *; // * *; // *; // instead of the expected:; // *; // * *; // * * *; // * * * *; //; int info = C_DPOTRF('L', n, A[0], n);; ; // A bit painful, see below; fprintf(outfile, ""A:\n"");; print_mat(A,n,n,outfile);. // Block matrix should be free_blocked; free_block(A);. Important Lapack Routines; ^^^^^^^^^^^^^^^^^^^^^^^^^. * DSYEV: Eigenvalues and, optionally eigenvectors of a symmetric matrix. Eigenvectors take up to 10x longer than eigenvalues.; * DGEEV: Ei",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:6904,Integrability,rout,routine,6904,"matrix A with the row-major BLAS wrappers effectively; involves ``L^T L = A``. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a ``C_``, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, ...) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is ``double**``). All routines return an int INFO with error and; calculation information specific to the routine, In Fortran, this is the; last argument in all LAPACK calls, but should not be provided as an; argument here. For char arguments, case is insensitive. A Cholesky; transform example is shown::. // BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // block_matrix, init_array; #include ""psi4/libciomr/libciomr.h""; ; using namespace psi;; ...; int n = 100;; ; // Allocate A matrix;; double** A = block_matrix(n,n);; ; // Call the LAPACK DPOTRF to get the Cholesky factor; // Note this works in column-major order; // The result fills like:; // * * * *; // * * *; // * *; // *; // instead of the expected:; // *; // * *; // * * *; // * * * *; //; int info = C_DPOTRF('L', n, A[0], n);; ; // A bit painful, see below; fprintf(outfile, ""A:\n"");; print_mat(A,n,n,outfile);. // Block matrix should be free_blocked; free_block(A);. Important Lapack Routines; ^^^^^^^^^^^^^^^^^^^^^^^^^. * DSYEV: Eigenvalues and, optionally eigenvectors of a symmetric matrix. Eigenvectors take up to 10x longer than eigenvalues.; * DGEEV: Ei",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:12200,Integrability,depend,dependencies,12200," of the spherical harmonics are built from; the ``(L+1)(L+2)/2`` Cartesian Gaussians, according to H. Schlegel and M.; Frish, IJQC, 54, 83-87, 1995. Unlike Cartesian functions these functions; are all strictly normalized. Note that in |PSIfour|, the real combinations of; spherical harmonic functions (see the paragraph below Eq. 15 in the; Schlegel paper) are ordered as: 0, 1+, 1-, 2+, 2-, .... * ``USO`` (Unique Symmetry-Adapted Orbitals): Spatial symmetry-adapted; combinations of SOs, blocked according to irrep. The total number of USOs; is the same as the number of SOs, but the number of USOs within each irrep; is usually much smaller, which can lead to significant performance; improvements. Note that this basis is sometimes unfortunately referred to; as the SO basis, so it's a bit context specific. * ``OSO`` (Orthogonal Symmetry-Adapted Orbitals): USOs orthogonalized by; Symmetric or Canonical Orthogonalization. The number of OSOs may be; slightly smaller than the total number of USOs, due to removal of linear; dependencies via Canonical Orthogonalization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs. * ``MO`` (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. * ``LO`` (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. .. _`faq:orbdims`:. How to name orbital dimensions; ------------------------------. There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below. A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 1",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:13415,Integrability,depend,dependent,13415," basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. * ``LO`` (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. .. _`faq:orbdims`:. How to name orbital dimensions; ------------------------------. There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below. A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. * nao |w---w| The number of atomic orbitals in Cartesian representation.; * nso |w---w| The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; * nbf |w---w| The number of basis functions, which is the same as nso.; * nmo |w---w| The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the stack, and is named by augmenting the name above; with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is; always the singular nirrep, and that the index variable h is always used; in a for-loop traverse of irreps. .. _`faq:orbspaces`:. How to name orbital spaces (e.g., docc); ---------------------------------------. As with basis sets, a nu",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:1370,Modifiability,portab,portable,1370,"; .. # it under the terms of the GNU Lesser General Public License as published by; .. # the Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:blaslapack`:. ===========================; Linear Algebra in |PSIfour|; ===========================. .. _`faq:blaswrappers`:. How to call BLAS & LAPACK in |PSIfour|; --------------------------------------. Computational chemistry is essentially linear algebra on molecular; systems, so using stable, portable, scalable, and efficient numerical; linear algebra methods in |PSIfour| is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so |PSIfour| provides a common set of wrappers in :source:`psi4/src/psi4/libqt/qt.h` . .. warning:: Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; `psi4.core.Matrix` itself. The advice in these docs will catch up; shortly. BLAS Wrappers; ^^^^^^^^^^^^^. BLAS wrappers are currently fully supported at double precision. BLAS commands involving matrices are wrapped so as ",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:4540,Modifiability,variab,variable,4540,";; ...; ; // Allocate a,b vectors; int n = 100;; double* a = init_array(n);; double* b = init_array(n);; ; // Allocate A matrix;; double** A = block_matrix(n,n);; double** B = block_matrix(n,n);; double** C = block_matrix(n,n);; ; // Call the BLAS1 dot product between a and b; // n can be a ULI with the BLAS1 wrappers,; // All strides must be ints though; double dot = C_DDOT(n, a, 1, b, 1);; ; // Call the BLAS2 GEMV without transposition; // Note this works in row-major order; C_DGEMV('N', n, n, 1.0, A[0], n, a, 1, 0.0, b, 1);; ; // Call the BLAS3 GEMM without transposition; // Note this works in row-major order; C_DGEMM('N','N', n, n, n, 1.0, A[0], n, B[0], n, 0.0, C[0], n);; ; // Array's init'd with init_array must be free'd, not delete[]'d; free(a);; free(b);; ; // Block matrix should be free_blocked; free_block(A);; free_block(B);; free_block(C);. Important BLAS Routines; ^^^^^^^^^^^^^^^^^^^^^^^. * BLAS1. * DDOT: dot product; * DCOPY: efficient memory copy (with variable stride); * DAXPY: y = y + alpha*x; * DROT: Givens Rotation; * DNRM2: Vector norm square. * BLAS2. * DGEMV: General Matrix-Vector product; * DTRMV: Triangular Matrix-Vector product (2x faster, not wrapped yet); * DTRSM: Triangular Matrix-Vector solution via back substitution (just as fast as DTRMV); * DGER: Rank-1 update (not wrapped yet). * BLAS3. * DGEMM: General Matrix-Matrix product; * DTRMM: General Triangular Matrix-General Matrix product; * DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); * DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; * DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers; ^^^^^^^^^^^^^^^. All standard LAPACK 3.2 double precision routines are provided. LAPACK commands remain in Fortran's ""column-major"" indexing, so all the; results will be tra",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:11631,Modifiability,adapt,adapted,11631,"rst layer encountered, Libmints handles the transform from AO to SO; automatically. If Cartesian functions are used, the number of functions; per shell remains ``(L + 1)(L + 2)/2``, and the ordering remains the same; as above. Note that the individual functions are not normalized for; angular momentum as in most codes: the self-overlap of a |PSIfour| Cartesian D; or higher function with more than one nonzero Cartesian exponent (e.g., lx; = 1, ly = 1, lz = 0) will be less than one. If Spherical Harmonics are; used, 2L + 1 real combinations of the spherical harmonics are built from; the ``(L+1)(L+2)/2`` Cartesian Gaussians, according to H. Schlegel and M.; Frish, IJQC, 54, 83-87, 1995. Unlike Cartesian functions these functions; are all strictly normalized. Note that in |PSIfour|, the real combinations of; spherical harmonic functions (see the paragraph below Eq. 15 in the; Schlegel paper) are ordered as: 0, 1+, 1-, 2+, 2-, .... * ``USO`` (Unique Symmetry-Adapted Orbitals): Spatial symmetry-adapted; combinations of SOs, blocked according to irrep. The total number of USOs; is the same as the number of SOs, but the number of USOs within each irrep; is usually much smaller, which can lead to significant performance; improvements. Note that this basis is sometimes unfortunately referred to; as the SO basis, so it's a bit context specific. * ``OSO`` (Orthogonal Symmetry-Adapted Orbitals): USOs orthogonalized by; Symmetric or Canonical Orthogonalization. The number of OSOs may be; slightly smaller than the total number of USOs, due to removal of linear; dependencies via Canonical Orthogonalization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs. * ``MO`` (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. * ``LO`` (Localized Orbitals): Localized occupied orbitals, a differ",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:12686,Modifiability,enhance,enhances,12686,"ed; combinations of SOs, blocked according to irrep. The total number of USOs; is the same as the number of SOs, but the number of USOs within each irrep; is usually much smaller, which can lead to significant performance; improvements. Note that this basis is sometimes unfortunately referred to; as the SO basis, so it's a bit context specific. * ``OSO`` (Orthogonal Symmetry-Adapted Orbitals): USOs orthogonalized by; Symmetric or Canonical Orthogonalization. The number of OSOs may be; slightly smaller than the total number of USOs, due to removal of linear; dependencies via Canonical Orthogonalization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs. * ``MO`` (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. * ``LO`` (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. .. _`faq:orbdims`:. How to name orbital dimensions; ------------------------------. There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below. A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. * nao |w---w| The number of atomic orbitals in Cartesian rep",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:13327,Modifiability,adapt,adapted,13327,"straight from USOs to MOs. * ``MO`` (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. * ``LO`` (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. .. _`faq:orbdims`:. How to name orbital dimensions; ------------------------------. There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below. A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. * nao |w---w| The number of atomic orbitals in Cartesian representation.; * nso |w---w| The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; * nbf |w---w| The number of basis functions, which is the same as nso.; * nmo |w---w| The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the stack, and is named by augmenting the name above; with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is; always the singular nirrep, and that the index variable h is always used; in a for-loop traverse of irreps. ..",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:14234,Modifiability,variab,variable,14234,"sis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. * nao |w---w| The number of atomic orbitals in Cartesian representation.; * nso |w---w| The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; * nbf |w---w| The number of basis functions, which is the same as nso.; * nmo |w---w| The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the stack, and is named by augmenting the name above; with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is; always the singular nirrep, and that the index variable h is always used; in a for-loop traverse of irreps. .. _`faq:orbspaces`:. How to name orbital spaces (e.g., docc); ---------------------------------------. As with basis sets, a number of names are used to refer to refer to the; quantity of electrons, virtuals, and active sub-quantities of a |PSIfour|; calculation. All of these can be defined per irrep as above. Some common; conventions are:. * nelec |w---w| The number of electrons, rarely used due to specialization of alphas and betas or soccs and doccs.; * nalpha |w---w| The number of alpha electrons.; * nbeta |w---w| The number of beta electrons; * docc |w---w| The number of doubly-occupied orbitals; * socc |w---w| The number of singly-occupied orbitals (Almost always alpha, we don't like open-shell singlets much).; * nvir |w---w| The number of virtual orbitals. Multireference Dimensions; ^^^^^^^^^^^^^^^^^^^^^^^^^. A orbital diagram of the nomenclature used for CI and MCSCF calculations. Diagrammatically::. -----",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:1380,Performance,scalab,scalable,1380,"; .. # it under the terms of the GNU Lesser General Public License as published by; .. # the Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:blaslapack`:. ===========================; Linear Algebra in |PSIfour|; ===========================. .. _`faq:blaswrappers`:. How to call BLAS & LAPACK in |PSIfour|; --------------------------------------. Computational chemistry is essentially linear algebra on molecular; systems, so using stable, portable, scalable, and efficient numerical; linear algebra methods in |PSIfour| is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so |PSIfour| provides a common set of wrappers in :source:`psi4/src/psi4/libqt/qt.h` . .. warning:: Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; `psi4.core.Matrix` itself. The advice in these docs will catch up; shortly. BLAS Wrappers; ^^^^^^^^^^^^^. BLAS wrappers are currently fully supported at double precision. BLAS commands involving matrices are wrapped so as ",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:1779,Performance,perform,performance,1779," received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:blaslapack`:. ===========================; Linear Algebra in |PSIfour|; ===========================. .. _`faq:blaswrappers`:. How to call BLAS & LAPACK in |PSIfour|; --------------------------------------. Computational chemistry is essentially linear algebra on molecular; systems, so using stable, portable, scalable, and efficient numerical; linear algebra methods in |PSIfour| is critical. To that end, we use BLAS1; (vector-vector operations, like dot products), BLAS2 (matrix-vector; operations, like rank-1 update), BLAS3 (matrix-matrix operations, like; matrix multiplication), and LAPACK (advanced matrix decompositions and; solutions). The methods provided by BLAS and LAPACK are standard, but the; performance of actual implementations differ greatly from one version to; another. Moreover, the standard interfaces to the libraries are Fortran,; so |PSIfour| provides a common set of wrappers in :source:`psi4/src/psi4/libqt/qt.h` . .. warning:: Although block_matrix, init_array, and print_mat are still; around, their use is discouraged in favor of operations on; `psi4.core.Matrix` itself. The advice in these docs will catch up; shortly. BLAS Wrappers; ^^^^^^^^^^^^^. BLAS wrappers are currently fully supported at double precision. BLAS commands involving matrices are wrapped so as to be conventional; C-style ""row-major"" indexing, meaning that the column is the fast index; like normal. * The calls to BLAS1 routines are wrapped so as to allow for operations on; vectors with more than 2^{31} elements (~16 GB, getting to be a problem).; So passing a signed or unsigned long works, though the stride arguments; must be integers. * All routines are declared in ``qt.h``. Each routine is prefixed with ",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:11846,Performance,perform,performance,11846,"emains ``(L + 1)(L + 2)/2``, and the ordering remains the same; as above. Note that the individual functions are not normalized for; angular momentum as in most codes: the self-overlap of a |PSIfour| Cartesian D; or higher function with more than one nonzero Cartesian exponent (e.g., lx; = 1, ly = 1, lz = 0) will be less than one. If Spherical Harmonics are; used, 2L + 1 real combinations of the spherical harmonics are built from; the ``(L+1)(L+2)/2`` Cartesian Gaussians, according to H. Schlegel and M.; Frish, IJQC, 54, 83-87, 1995. Unlike Cartesian functions these functions; are all strictly normalized. Note that in |PSIfour|, the real combinations of; spherical harmonic functions (see the paragraph below Eq. 15 in the; Schlegel paper) are ordered as: 0, 1+, 1-, 2+, 2-, .... * ``USO`` (Unique Symmetry-Adapted Orbitals): Spatial symmetry-adapted; combinations of SOs, blocked according to irrep. The total number of USOs; is the same as the number of SOs, but the number of USOs within each irrep; is usually much smaller, which can lead to significant performance; improvements. Note that this basis is sometimes unfortunately referred to; as the SO basis, so it's a bit context specific. * ``OSO`` (Orthogonal Symmetry-Adapted Orbitals): USOs orthogonalized by; Symmetric or Canonical Orthogonalization. The number of OSOs may be; slightly smaller than the total number of USOs, due to removal of linear; dependencies via Canonical Orthogonalization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs. * ``MO`` (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. * ``LO`` (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; ",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:5902,Safety,recover,recovery,5902,"* DGER: Rank-1 update (not wrapped yet). * BLAS3. * DGEMM: General Matrix-Matrix product; * DTRMM: General Triangular Matrix-General Matrix product; * DTRSM: Triangular Matrix-General Matrix solution via back substitution (just as fast as DTRMM); * DSYMM/DSYMV calls are not appreciably faster than DGEMM calls, and should only be used in expert situations (like using the other half of the matrix for some form of other transformation).; * DTRMM/DTRMV calls are 2x faster than DGEMM, and should be used where possible. LAPACK Wrappers; ^^^^^^^^^^^^^^^. All standard LAPACK 3.2 double precision routines are provided. LAPACK commands remain in Fortran's ""column-major"" indexing, so all the; results will be transposed, and leading dimensions may have to be fiddled; with (using ``lda = n`` in both directions for square matrices is highly; recommended). An example of the former problem is a Cholesky; Decomposition: you expect to get back a lower triangular matrix L such; that ``L L^T = A``, but this is returned in column-major order, so the actual; recovery of the matrix A with the row-major BLAS wrappers effectively; involves ``L^T L = A``. On of the biggest consequences is in linear equations:; The input/output forcing/solution vector must be explicitly formed in; column-major indexing (each vector is placed in a C++ row, with its; entries along the C++ column). This is visualized in C++ as the transpose; of the forcing/solution vector. All routines are declared in qt.h. Each; routine is prefixed with a ``C_``, followed by the standard Fortran name of; the routine, in capital letters. Input parameters of single primitives; (int, double, unsigned long int, char, ...) are passed by value. Arrays,; including multidimensional arrays, are required to be in contiguous memory; (as provided by block_matrix, for example), and are passed by providing a; pointer to the first double or int element of the data (this is array[0]; if array is ``double**``). All routines return an int INFO w",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:13011,Safety,redund,redundant,13011,"orthogonalized by; Symmetric or Canonical Orthogonalization. The number of OSOs may be; slightly smaller than the total number of USOs, due to removal of linear; dependencies via Canonical Orthogonalization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs. * ``MO`` (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. * ``LO`` (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. .. _`faq:orbdims`:. How to name orbital dimensions; ------------------------------. There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below. A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. * nao |w---w| The number of atomic orbitals in Cartesian representation.; * nso |w---w| The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; * nbf |w---w| The number of basis functions, which is the same as nso.; * nmo |w---w| The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep ",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:13483,Safety,redund,redundancies,13483," basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. * ``LO`` (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal to each other and the virtual space. .. _`faq:orbdims`:. How to name orbital dimensions; ------------------------------. There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below. A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. * nao |w---w| The number of atomic orbitals in Cartesian representation.; * nso |w---w| The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; * nbf |w---w| The number of basis functions, which is the same as nso.; * nmo |w---w| The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the stack, and is named by augmenting the name above; with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is; always the singular nirrep, and that the index variable h is always used; in a for-loop traverse of irreps. .. _`faq:orbspaces`:. How to name orbital spaces (e.g., docc); ---------------------------------------. As with basis sets, a nu",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:13941,Safety,redund,redundancies,13941,"There are a number of different names used to refer to the basis set size.; These may seem redundant, but they have subtly different meanings, as; detailed below. A calculation can use either pure (5D, 7F, 9G, etc.) basis functions or; Cartesian (6D, 10F, 15G, etc.), as dictated by the input file / basis set; specification. Also, the basis can be represented in terms of atomic; orbitals (AO) or symmetry-adapted orbitals (SO). Further complications; come from the fact that a nearly linearly-dependent basis set will have; functions removed from it to prevent redundancies. With all of these; factors in mind, here are the conventions used internally:. * nao |w---w| The number of atomic orbitals in Cartesian representation.; * nso |w---w| The number of atomic orbitals but in the pure representation if the current basis uses pure functions, number of Cartesian AOs otherwise.; * nbf |w---w| The number of basis functions, which is the same as nso.; * nmo |w---w| The number of basis functions, after projecting out redundancies in the basis. When molecular symmetry is utilized, a small array of sizes per irrep is; usually allocated on the stack, and is named by augmenting the name above; with a pi (per-irrep), e.g. nmopi. Note that the number of irreps is; always the singular nirrep, and that the index variable h is always used; in a for-loop traverse of irreps. .. _`faq:orbspaces`:. How to name orbital spaces (e.g., docc); ---------------------------------------. As with basis sets, a number of names are used to refer to refer to the; quantity of electrons, virtuals, and active sub-quantities of a |PSIfour|; calculation. All of these can be defined per irrep as above. Some common; conventions are:. * nelec |w---w| The number of electrons, rarely used due to specialization of alphas and betas or soccs and doccs.; * nalpha |w---w| The number of alpha electrons.; * nbeta |w---w| The number of beta electrons; * docc |w---w| The number of doubly-occupied orbitals; * socc |w---w| ",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst:8736,Usability,simpl,simple,8736,"lues and, optionally eigenvectors of a symmetric matrix. Eigenvectors take up to 10x longer than eigenvalues.; * DGEEV: Eigenvalues and, optionally eigenvectors of a general matrix. Up to 10x slower than DSYEV.; * DGESV: General solver (uses LU decomposition).; * DGESVD: General singular value decomposition.; * DGETRF: LU decomposition.; * DPOTRF: Cholesky decomposition (much more stable/faster); * DGETRS: Solver, given LU decomposition by DGETRF; * DPOTRS: Solver, given Cholesky decomposition by DPOTRF; * DGETRI: Inverse, given LU decomposition by DGETRF (Warning: it's faster and more stable just to solve with DGETRS); * DPOTRI: Inverse, given Cholesky decomposition by DPOTRF (Warning: it's faster and more stable just to solve with DPOTRS). .. _`faq:blasmatrix`:. How to use low-level BLAS/LAPACK with ``psi4.core.Matrix``; ----------------------------------------------------------. Jet's awesome new Matrix object has a lot of simple BLAS/LAPACK built in,; but you can just as easily use the ``double***`` array underneath if you are; careful (the outer index is the submatrix for each irrep). Here's an; example:. .. code-block:: cpp. // BLAS/LAPACK; #include ""psi4/libqt/qt.h""; // Matrix; #include ""psi4/libmints/matrix.h""; ; using namespace psi;; ...; int n = 100;; ; // Allocate A Matrix (new C1 convenience constructor);; shared_ptr<Matrix> A(new Matrix(""Still A, but way cooler"", n,n));; // Get the pointer to the 0 irrep (C1 for now, it errors if you ask for too high of an index); double** A_pointer = A->get_pointer(0);; ; // Call the LAPACK DPOTRF to get the Cholesky factor; // Note this works in column-major order; // The result fills like:; // * * * *; // * * *; // * *; // *; // instead of the expected:; // *; // * *; // * * *; // * * * *; //; int info = C_DPOTRF('L', n, A_pointer[0], n);; ; // Wow that's a lot easier; A->print();; ; // Don't free, it's shared_ptr!. .. _`faq:labas`:. How to name orbital bases (e.g., AO & SO); -----------------------------------------",MatchSource.DOCS,doc/sphinxman/source/prog_blas.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_blas.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_code_intro.rst:1293,Integrability,interface,interface,1293,".. #; .. # @BEGIN LICENSE; .. #; .. # Psi4: an open-source quantum chemistry software package; .. #; .. # Copyright (c) 2007-2023 The Psi4 Developers.; .. #; .. # The copyrights for code used from other parties are included in; .. # the corresponding files.; .. #; .. # This file is part of Psi4.; .. #; .. # Psi4 is free software; you can redistribute it and/or modify; .. # it under the terms of the GNU Lesser General Public License as published by; .. # the Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:prog_code_intro`:. ================================; General Introduction to the Code; ================================. Languages: C++ and Python; -------------------------. Intro to the hybrid code and how the C++/Python interface works. What Should Go in C++ vs Python; -------------------------------. Code Structure; --------------. Driver, libraries, modules, plugins, ... general tour of what goes where. ",MatchSource.DOCS,doc/sphinxman/source/prog_code_intro.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_code_intro.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_code_intro.rst:1436,Modifiability,plugin,plugins,1436,".. #; .. # @BEGIN LICENSE; .. #; .. # Psi4: an open-source quantum chemistry software package; .. #; .. # Copyright (c) 2007-2023 The Psi4 Developers.; .. #; .. # The copyrights for code used from other parties are included in; .. # the corresponding files.; .. #; .. # This file is part of Psi4.; .. #; .. # Psi4 is free software; you can redistribute it and/or modify; .. # it under the terms of the GNU Lesser General Public License as published by; .. # the Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:prog_code_intro`:. ================================; General Introduction to the Code; ================================. Languages: C++ and Python; -------------------------. Intro to the hybrid code and how the C++/Python interface works. What Should Go in C++ vs Python; -------------------------------. Code Structure; --------------. Driver, libraries, modules, plugins, ... general tour of what goes where. ",MatchSource.DOCS,doc/sphinxman/source/prog_code_intro.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_code_intro.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_faq.rst:1886,Deployability,release,releaseprocedure,1886,"ense as published by; .. # the Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. _`sec:progfaq`:. ===============; Programmers FAQ; ===============. C++ Style in |PSIfour|; ----------------------. #. :ref:`faq:nullptr`; #. :ref:`faq:automakeshared`; #. :ref:`faq:autodecl`; #. :ref:`faq:editorcodestyle`; #. :ref:`faq:githookscodestyle`; #. :ref:`faq:manualcodestyle`. Modules in |PSIfour|; --------------------. #. :ref:`faq:readoptions`; #. :ref:`faq:blaswrappers`; #. :ref:`faq:blasmatrix`; #. :ref:`faq:labas`; #. :ref:`faq:orbdims`; #. :ref:`faq:orbspaces`. Interfacing with |PSIfour|; --------------------------. #. :ref:`faq:addonname`; #. :ref:`faq:addoncmake`. Versioning |PSIfour|; --------------------. #. :ref:`faq:versionbump`; #. :ref:`faq:remotetag`; #. :ref:`faq:githubworkflow`; #. :ref:`faq:psi4version`. Releasing |PSIfour|; -------------------. #. :ref:`faq:annualprocedure`; #. :ref:`faq:prereleaseprocedure`; #. :ref:`faq:releaseprocedure`; #. :ref:`faq:postreleaseprocedure`. Workflow; --------. #. :ref:`faq:localaddon`; #. :ref:`faq:dirlayoutinstall`; #. :ref:`faq:githubworkflow`; #. :ref:`faq:vigitmerge`; #. :ref:`faq:gdblldb`; #. :ref:`faq:grepascii`; #. :ref:`faq:ignoringadvice`. Miscellaneous; -------------. #. :ref:`faq:add_tests`; #. :ref:`faq:add_psithon_tests`; #. :ref:`faq:add_psiapi_tests`; #. :ref:`How to set up PSIthon tests to run through pytest <faq:psithon_through_pytest>`; #. :ref:`faq:findmissingoutputref`; #. :ref:`faq:githubcodereview`. ",MatchSource.DOCS,doc/sphinxman/source/prog_faq.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_faq.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_faq.rst:2304,Testability,test,tests,2304,"ense as published by; .. # the Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. _`sec:progfaq`:. ===============; Programmers FAQ; ===============. C++ Style in |PSIfour|; ----------------------. #. :ref:`faq:nullptr`; #. :ref:`faq:automakeshared`; #. :ref:`faq:autodecl`; #. :ref:`faq:editorcodestyle`; #. :ref:`faq:githookscodestyle`; #. :ref:`faq:manualcodestyle`. Modules in |PSIfour|; --------------------. #. :ref:`faq:readoptions`; #. :ref:`faq:blaswrappers`; #. :ref:`faq:blasmatrix`; #. :ref:`faq:labas`; #. :ref:`faq:orbdims`; #. :ref:`faq:orbspaces`. Interfacing with |PSIfour|; --------------------------. #. :ref:`faq:addonname`; #. :ref:`faq:addoncmake`. Versioning |PSIfour|; --------------------. #. :ref:`faq:versionbump`; #. :ref:`faq:remotetag`; #. :ref:`faq:githubworkflow`; #. :ref:`faq:psi4version`. Releasing |PSIfour|; -------------------. #. :ref:`faq:annualprocedure`; #. :ref:`faq:prereleaseprocedure`; #. :ref:`faq:releaseprocedure`; #. :ref:`faq:postreleaseprocedure`. Workflow; --------. #. :ref:`faq:localaddon`; #. :ref:`faq:dirlayoutinstall`; #. :ref:`faq:githubworkflow`; #. :ref:`faq:vigitmerge`; #. :ref:`faq:gdblldb`; #. :ref:`faq:grepascii`; #. :ref:`faq:ignoringadvice`. Miscellaneous; -------------. #. :ref:`faq:add_tests`; #. :ref:`faq:add_psithon_tests`; #. :ref:`faq:add_psiapi_tests`; #. :ref:`How to set up PSIthon tests to run through pytest <faq:psithon_through_pytest>`; #. :ref:`faq:findmissingoutputref`; #. :ref:`faq:githubcodereview`. ",MatchSource.DOCS,doc/sphinxman/source/prog_faq.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_faq.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_full_integration.rst:1457,Testability,test,test,1457,".. #; .. # @BEGIN LICENSE; .. #; .. # Psi4: an open-source quantum chemistry software package; .. #; .. # Copyright (c) 2007-2023 The Psi4 Developers.; .. #; .. # The copyrights for code used from other parties are included in; .. # the corresponding files.; .. #; .. # This file is part of Psi4.; .. #; .. # Psi4 is free software; you can redistribute it and/or modify; .. # it under the terms of the GNU Lesser General Public License as published by; .. # the Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:prog_full_integration`:. =======================================; Integrating New Features into |PSIfour|; =======================================. Overview of Required Steps; --------------------------. Explain the different steps that are needed to add a few feature to ; |PSIfour| (where to put the code, how to add user options (w/docs), where; to add targets to CMake files, adding test cases, adding a section; to the Users' manual. Several of those steps are already documented ; elsewhere, so just point to them in the appropriate places. ",MatchSource.DOCS,doc/sphinxman/source/prog_full_integration.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_full_integration.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:1223,Availability,avail,available,1223,"ded in; .. # the corresponding files.; .. #; .. # This file is part of Psi4.; .. #; .. # Psi4 is free software; you can redistribute it and/or modify; .. # it under the terms of the GNU Lesser General Public License as published by; .. # the Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:prog_integrals`:. ======================; Integrals in |PSIfour|; ======================. Introduction; ------------. |PSIfour| has a number of backends available to compute integrals. In order to; accomodate these options, while providing a clean interface to the programmer,; an abstraction layer is implemented within Libmints. A recent upgrade to the; primary integral engine has seen some important changes to the way this; interface layer is used; this document is designed to aid new developers as; well as those familiar with the older calling conventions to ensure that the; most efficient calling conventions are applied. The older style; ---------------. A very simple loop that does not use permutational symmetry might look; something like this in the old scheme:. .. code-block:: cpp. auto sieve = std::make_shared<ERISieve>(basisset, cutoff);; auto factory= std::make_shared<IntegralFactory>(basisset);; int deriv_level = 0;; bool use_shell_pairs = true;; auto eri = factory->eri(deriv_level, use_shell_pairs);; const double* buffer = eri_->buffer();; for (int P = 0; P < basisset->nshell(); ++P) {; const auto& Pshell = basisset->shell",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:5138,Availability,redundant,redundant,5138," eri->first_RS_shell_block(blockPQ_idx);; for (int blockRS_idx = loop_start; blockRS_idx < blocksRS.size(); ++blockRS_idx) {; const auto& blockRS = blocksRS[blockRS_idx];. if (!eri->shell_block_significant(blockPQ_idx, blockRS_idx)) continue;. eri->compute_shell_blocks(blockPQ_idx, blockRS_idx);; const auto* block_start = buffers[0];. // Loop over all of the P,Q,R,S shells within the blocks. We have P>=Q, R>=S and PQ<=RS.; for (const auto& pairPQ : blockPQ) {; const auto &P = pairPQ.first;; const auto &Q = pairPQ.second;; const auto& Pshell = basisset->shell(P);; const auto& Qshell = basisset->shell(Q);; const auto Pam = Pshell.am();; const auto Qam = Qshell.am();; for (const auto& pairRS : blockRS) {; const auto &R = pairRS.first;; const auto &S = pairRS.second;; const auto& Rshell = basisset->shell(R);; const auto& Sshell = basisset->shell(S);; const auto Ram = Rshell.am();; const auto Sam = Sshell.am();. size_t block_size = Psize * Qsize * Rsize * Ssize;; // When there are chunks of shellpairs in RS, we need to make sure; // we filter out redundant combinations.; if (use_batching && Pam == Ram && Qam == Sam && ((P > R) || (P == R && Q > S))) {; block_start += block_size;; continue;; }; const double* int_ptr = block_start;; // Query P,Q,R,S shells for metadata and loop over that quartet; // as usual, getting the integrals from the int_ptr buffer.; block_start += block_size;; }; }; }; }. Although this looks more complex, it's essentially doing the same thing. There; are a number of differences that we'll highlight now. Sieving; ....... This is one of two breaking changes to the old style syntax. Instead of; constructing a sieve object, the integral object should be queried directly; using the exact same syntax. Requests for whether a shell is significant or a; shell block is significant are both supported. A sieve object is created if; matching basis sets are found in either the bra or the ket. For a density; fitting integral (PQ|0A) where 0 is the null basis set an",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:10226,Availability,redundant,redundant,10226," Therefore care must be taken to ensure that the missing permutations; are correctly accounted for when processing the integrals within the loop. See; the DirectJK code in libfock for an example of using this scheme for a Fock; matrix build. Using bra-ket symmetry; ...................... In cases where there is no batching performed, bra-ket symmetry can be; trivially enforced by ensuring that one of the block indices is greater than or; equal to the other. When batching is used, the situation is trickier; some ket; batches may contain a mixture of integrals that are bra-ket unique and those; that are not. To handle this we must do a coarse check at the top of the loop; to see if *any* integrals in the batch are needed, which is implemented by; asking the integral engine where to start looping in the ket via the call to; ``eri->first_RS_shell_block(PQpair_idx)``. This is followed by a more fine; grained check within the loops to filter individual integrals in the case where; bra and ket have the same angular momentum and there's a possibility of a; handful of integrals coming from the ket that are redundant. Note that the bra; is not batched in any of our engines currently: only the ket is. For this; reason, density fitting integrals should be written as (A0|PQ) rather than; (PQ|A0) where possible, because we want the ket to contain more functions than; the bra for efficient blocking. Instantiating integral objects; .............................. With sieving being introduced in the new integral objects, the cost of their; construction has increased. Although significantly cheaper than computing; integrals themselves, construction of integral objects can be non-negligible,; especially if many threads are used. For example, this pattern can be found in; old versions of the code:. .. code-block:: cpp. std::vector<std::shared_ptr<TwoBodyAOInt>> ints;; ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));; for (int thread = 1; thread < num_threads; thread++) {;",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:17791,Availability,avail,available,17791,"; this Cartesian basis, eliminating the need to transform to spherical harmonics; as the integrals are computed. This bottleneck no longer exists, so these; extra transformation steps have been removed as part of the switch to Libint2,; and the affected codes (PCM and CPPE interfaces) now compute the potential and; field integrals in the representation required by the basis set. Also, note that the way external point charges are specified has changed.; Previously, a set of N external point charges would be specified by passing a; matrix with dimensions N rows and 4 columns -- corresponding to charge, x, y, z; -- to the ``set_charge_field()`` member of the potential integral class. The; same information is now passed using the more verbose; ``std::vector<std::pair<double, std::array<double, 3>>>`` type instead, to be; consistent with Libint2's convention. New Operators Available; ....................... Libint2 provides a range of integrals that were previously not available in; |PSIfour|, such as the Erfc attenuated nuclear potential integrals needed for; Ewald methods. If new integrals are added to Libint2 but are not yet; interfaced to |PSIfour|, please open an issue on the |PSIfour| GitHub page to; alert the developers, who will be able to add the appropriate code.; Available integrals classes and parameters currently documented at ; `Libint2 C++11 Interface Wiki <https://github.com/evaleev/libint/wiki/using-modern-CPlusPlus-API#create-an-integral-engine>`_. Shell Pairs; ........... To ensure consistency between one- and two-electron terms when screening, and; for efficiency reasons, shell pair lists should be used to iterate over pairs; of Gaussian shells. These lists contain integer pair numbers, corresponding to; the pairs of shells that have sufficient overlap to survive the screening; process. Iterating over these lists is simple:. .. code-block:: cpp. const auto& shell_pairs = Vint->shellpairs();; size_t n_pairs = shell_pairs.size();; for (size_t p = 0; p < ",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:1410,Deployability,upgrade,upgrade,1410," will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:prog_integrals`:. ======================; Integrals in |PSIfour|; ======================. Introduction; ------------. |PSIfour| has a number of backends available to compute integrals. In order to; accomodate these options, while providing a clean interface to the programmer,; an abstraction layer is implemented within Libmints. A recent upgrade to the; primary integral engine has seen some important changes to the way this; interface layer is used; this document is designed to aid new developers as; well as those familiar with the older calling conventions to ensure that the; most efficient calling conventions are applied. The older style; ---------------. A very simple loop that does not use permutational symmetry might look; something like this in the old scheme:. .. code-block:: cpp. auto sieve = std::make_shared<ERISieve>(basisset, cutoff);; auto factory= std::make_shared<IntegralFactory>(basisset);; int deriv_level = 0;; bool use_shell_pairs = true;; auto eri = factory->eri(deriv_level, use_shell_pairs);; const double* buffer = eri_->buffer();; for (int P = 0; P < basisset->nshell(); ++P) {; const auto& Pshell = basisset->shell(P);; for (int Q = 0; Q < basisset->nshell(); ++Q) {; const auto& Qshell = basisset->shell(Q);; for (int R = 0; R < basisset->nshell(); ++R) {; const auto& Rshell = basisset->shell(R);; for (int S = 0; S < basisset->nshell(); ++S) {; const auto& Sshell = basisset->shell(S);; if(sieve->shell_significant(P, Q, R, S) {; eri->comput",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:7151,Deployability,update,updated,7151," code copied integrals into a buffer owned by the integral object, whose; address remained constant and could be retrieved by the ``buffer()`` member; function. To avoid unnecessary copies, the new code instead uses the integrals; directly from the underlying integral engine's memory, which may change with; each call to compute integrals. The integral engine provides a; ``std::vector<const double*>`` containing the pointers to the start of each; ""chunk"" of integrals. For first derivatives there are 12 such ""chunks"", which; are ordered Px,Py,Pz,Qx,Qy,Qz,Rx,Ry,Rz,Sx,Sy,Sz, where the Px refers to the x; derivative with respect to the basis functions in shell P. Note that all; integral derivatives are provided by the new integral code, unlike the previous; version where only 9 of 12 were provided and the user was responsible for using; translation invariance relationships to fill in the rest. The addresses for; each chunk are updated in the vector after each call to compute integrals, so; the user should keep a const reference to that object, and query that for the; address of interest. Density Screening; ................. The old code looked only at the integral to determine whether terms can be; avoided *a priori*. However, if the integral is to be contracted with a; density or a density-like quantity, the screening can be performed on the; product, which yields more sparsity. To enable this, simply call the integral; object's ``update_density`` member, passing it a SharedMatrix holding the; current density (remember that it changes during each iteration of the SCF) and; the product will be considered during screening. If only coulomb-like terms; are to be computed, the ``needs_exchange`` argument to the integral object; constructor should be set to false, otherwise it should be true to correcly; account for products of the density and integrals that contribute to; exchange-like terms. Shell blocking; .............. Each underlying integral engine knows whether it wil",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:1659,Energy Efficiency,efficient,efficient,1659," will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:prog_integrals`:. ======================; Integrals in |PSIfour|; ======================. Introduction; ------------. |PSIfour| has a number of backends available to compute integrals. In order to; accomodate these options, while providing a clean interface to the programmer,; an abstraction layer is implemented within Libmints. A recent upgrade to the; primary integral engine has seen some important changes to the way this; interface layer is used; this document is designed to aid new developers as; well as those familiar with the older calling conventions to ensure that the; most efficient calling conventions are applied. The older style; ---------------. A very simple loop that does not use permutational symmetry might look; something like this in the old scheme:. .. code-block:: cpp. auto sieve = std::make_shared<ERISieve>(basisset, cutoff);; auto factory= std::make_shared<IntegralFactory>(basisset);; int deriv_level = 0;; bool use_shell_pairs = true;; auto eri = factory->eri(deriv_level, use_shell_pairs);; const double* buffer = eri_->buffer();; for (int P = 0; P < basisset->nshell(); ++P) {; const auto& Pshell = basisset->shell(P);; for (int Q = 0; Q < basisset->nshell(); ++Q) {; const auto& Qshell = basisset->shell(Q);; for (int R = 0; R < basisset->nshell(); ++R) {; const auto& Rshell = basisset->shell(R);; for (int S = 0; S < basisset->nshell(); ++S) {; const auto& Sshell = basisset->shell(S);; if(sieve->shell_significant(P, Q, R, S) {; eri->comput",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:8705,Energy Efficiency,efficient,efficient,8705,"ity`` member, passing it a SharedMatrix holding the; current density (remember that it changes during each iteration of the SCF) and; the product will be considered during screening. If only coulomb-like terms; are to be computed, the ``needs_exchange`` argument to the integral object; constructor should be set to false, otherwise it should be true to correcly; account for products of the density and integrals that contribute to; exchange-like terms. Shell blocking; .............. Each underlying integral engine knows whether it will use blocks, and will set up; the metadata automatically. Instead of looping over individual shells, the; user should loop over blocks supplied by the integral object; these blocks will; be just a single shell quartet combination for the case where blocking is not; used. It is simple to loop over pairs within each block using C++11 syntax, as; demonstrated in the code snippet above. Only shell pairs with significant; overlap are included in the shell block information, making this an efficient; way to loop over non-negligible terms. Permutational symmetry; ...................... The pairs within each block are optimized for efficiency. First, they are; screened during the integral object's creation to ensure that only terms with; appreciable overlap are stored. Second, only P,Q combinations that are; permutationally unique are stored, ordered with the higher angular momentum; first. Therefore care must be taken to ensure that the missing permutations; are correctly accounted for when processing the integrals within the loop. See; the DirectJK code in libfock for an example of using this scheme for a Fock; matrix build. Using bra-ket symmetry; ...................... In cases where there is no batching performed, bra-ket symmetry can be; trivially enforced by ensuring that one of the block indices is greater than or; equal to the other. When batching is used, the situation is trickier; some ket; batches may contain a mixture of integrals th",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:10499,Energy Efficiency,efficient,efficient,10499,"e is no batching performed, bra-ket symmetry can be; trivially enforced by ensuring that one of the block indices is greater than or; equal to the other. When batching is used, the situation is trickier; some ket; batches may contain a mixture of integrals that are bra-ket unique and those; that are not. To handle this we must do a coarse check at the top of the loop; to see if *any* integrals in the batch are needed, which is implemented by; asking the integral engine where to start looping in the ket via the call to; ``eri->first_RS_shell_block(PQpair_idx)``. This is followed by a more fine; grained check within the loops to filter individual integrals in the case where; bra and ket have the same angular momentum and there's a possibility of a; handful of integrals coming from the ket that are redundant. Note that the bra; is not batched in any of our engines currently: only the ket is. For this; reason, density fitting integrals should be written as (A0|PQ) rather than; (PQ|A0) where possible, because we want the ket to contain more functions than; the bra for efficient blocking. Instantiating integral objects; .............................. With sieving being introduced in the new integral objects, the cost of their; construction has increased. Although significantly cheaper than computing; integrals themselves, construction of integral objects can be non-negligible,; especially if many threads are used. For example, this pattern can be found in; old versions of the code:. .. code-block:: cpp. std::vector<std::shared_ptr<TwoBodyAOInt>> ints;; ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));; for (int thread = 1; thread < num_threads; thread++) {; ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));; }. This builds many objects and the cost can add up. With the new scheme,; integral objects are forced to implement a `clone()` member that can be used as; follows:. .. code-block:: cpp. std::vector<std::shared_ptr<TwoBodyAOInt>> ints;; ints.p",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:11938,Energy Efficiency,reduce,reduced,11938,"example, this pattern can be found in; old versions of the code:. .. code-block:: cpp. std::vector<std::shared_ptr<TwoBodyAOInt>> ints;; ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));; for (int thread = 1; thread < num_threads; thread++) {; ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));; }. This builds many objects and the cost can add up. With the new scheme,; integral objects are forced to implement a `clone()` member that can be used as; follows:. .. code-block:: cpp. std::vector<std::shared_ptr<TwoBodyAOInt>> ints;; ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));; for (int thread = 1; thread < num_threads; thread++) {; ints.push_back(std::shared_ptr<TwoBodyAOInt>(ints[0]->clone()));; }. This method only incurs the cost of creating a single integral object, and; performs much cheaper cloning operations to create the other objects for each; thread. Moreover, if integral objects are created only in the initialization; of each code that uses them, and stored persistently, the cost of integral; object creation is further reduced. One Electron Integrals in |PSIfour|; -----------------------------------. After version 1.5, we started transitioning the one electron integral code over to; use Libint2 instead of the old handwritten Obara-Saika code. There are a; number of reasons motivating this switch. For methods requiring; potentials and fields evaluated at many external sites, such as PCM and; polarizable embedding, the efficiency of the one electron integrals can be rate; limiting. We also started to introduce integral screening, and it is important; to balance the screening used for one- and two-electron terms carefully, so this; is a good opportunity to re-evaluate the code. Finally, given the complexity; of the OS recursion code, the switch to an external library leaves a more; compact codebase to maintain. The one electron integrals which are not provided by Libint2; are now handled by a new implementation of the McM",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:17233,Energy Efficiency,charge,charges,17233,"instead provides all integrals, so the caller; simply needs to loop over all of the buffers provided in the appropriate order. Changes to External Potential Engines; ..................................... Benchmarking showed that early versions of the old code spent a non-negligible; amount of time performing the Cartesian to spherical harmonic transformation of; the integrals, which is needed for most modern basis sets. To improve; performance, we instead backtransformed the density to the Cartesian; representation (denoted ""CartAO"") and computed / contracted all integrals in; this Cartesian basis, eliminating the need to transform to spherical harmonics; as the integrals are computed. This bottleneck no longer exists, so these; extra transformation steps have been removed as part of the switch to Libint2,; and the affected codes (PCM and CPPE interfaces) now compute the potential and; field integrals in the representation required by the basis set. Also, note that the way external point charges are specified has changed.; Previously, a set of N external point charges would be specified by passing a; matrix with dimensions N rows and 4 columns -- corresponding to charge, x, y, z; -- to the ``set_charge_field()`` member of the potential integral class. The; same information is now passed using the more verbose; ``std::vector<std::pair<double, std::array<double, 3>>>`` type instead, to be; consistent with Libint2's convention. New Operators Available; ....................... Libint2 provides a range of integrals that were previously not available in; |PSIfour|, such as the Erfc attenuated nuclear potential integrals needed for; Ewald methods. If new integrals are added to Libint2 but are not yet; interfaced to |PSIfour|, please open an issue on the |PSIfour| GitHub page to; alert the developers, who will be able to add the appropriate code.; Available integrals classes and parameters currently documented at ; `Libint2 C++11 Interface Wiki <https://github.com/evaleev/l",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:17307,Energy Efficiency,charge,charges,17307,"al Engines; ..................................... Benchmarking showed that early versions of the old code spent a non-negligible; amount of time performing the Cartesian to spherical harmonic transformation of; the integrals, which is needed for most modern basis sets. To improve; performance, we instead backtransformed the density to the Cartesian; representation (denoted ""CartAO"") and computed / contracted all integrals in; this Cartesian basis, eliminating the need to transform to spherical harmonics; as the integrals are computed. This bottleneck no longer exists, so these; extra transformation steps have been removed as part of the switch to Libint2,; and the affected codes (PCM and CPPE interfaces) now compute the potential and; field integrals in the representation required by the basis set. Also, note that the way external point charges are specified has changed.; Previously, a set of N external point charges would be specified by passing a; matrix with dimensions N rows and 4 columns -- corresponding to charge, x, y, z; -- to the ``set_charge_field()`` member of the potential integral class. The; same information is now passed using the more verbose; ``std::vector<std::pair<double, std::array<double, 3>>>`` type instead, to be; consistent with Libint2's convention. New Operators Available; ....................... Libint2 provides a range of integrals that were previously not available in; |PSIfour|, such as the Erfc attenuated nuclear potential integrals needed for; Ewald methods. If new integrals are added to Libint2 but are not yet; interfaced to |PSIfour|, please open an issue on the |PSIfour| GitHub page to; alert the developers, who will be able to add the appropriate code.; Available integrals classes and parameters currently documented at ; `Libint2 C++11 Interface Wiki <https://github.com/evaleev/libint/wiki/using-modern-CPlusPlus-API#create-an-integral-engine>`_. Shell Pairs; ........... To ensure consistency between one- and two-electron terms whe",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:17412,Energy Efficiency,charge,charge,17412,"al Engines; ..................................... Benchmarking showed that early versions of the old code spent a non-negligible; amount of time performing the Cartesian to spherical harmonic transformation of; the integrals, which is needed for most modern basis sets. To improve; performance, we instead backtransformed the density to the Cartesian; representation (denoted ""CartAO"") and computed / contracted all integrals in; this Cartesian basis, eliminating the need to transform to spherical harmonics; as the integrals are computed. This bottleneck no longer exists, so these; extra transformation steps have been removed as part of the switch to Libint2,; and the affected codes (PCM and CPPE interfaces) now compute the potential and; field integrals in the representation required by the basis set. Also, note that the way external point charges are specified has changed.; Previously, a set of N external point charges would be specified by passing a; matrix with dimensions N rows and 4 columns -- corresponding to charge, x, y, z; -- to the ``set_charge_field()`` member of the potential integral class. The; same information is now passed using the more verbose; ``std::vector<std::pair<double, std::array<double, 3>>>`` type instead, to be; consistent with Libint2's convention. New Operators Available; ....................... Libint2 provides a range of integrals that were previously not available in; |PSIfour|, such as the Erfc attenuated nuclear potential integrals needed for; Ewald methods. If new integrals are added to Libint2 but are not yet; interfaced to |PSIfour|, please open an issue on the |PSIfour| GitHub page to; alert the developers, who will be able to add the appropriate code.; Available integrals classes and parameters currently documented at ; `Libint2 C++11 Interface Wiki <https://github.com/evaleev/libint/wiki/using-modern-CPlusPlus-API#create-an-integral-engine>`_. Shell Pairs; ........... To ensure consistency between one- and two-electron terms whe",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:20799,Energy Efficiency,charge,charge,20799,"nt`` | Libint2 | using ``libint2::Operator::delta`` for 4-center integrals |; +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+; | Angular Momentum | ``AngularMomentumInt`` | M-D | |; +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+; | Dipole | ``DipoleInt`` | Libint2 | no derivatives supported |; +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+; | Electric Field | ``ElectricFieldInt`` | Libint2 | using first derivative of ``libint2::Operator::nuclear`` |; +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+; | Coulomb Potential | ``ElectrostaticInt`` | Libint2 | evaluated for a single origin and unity charge |; +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+; | Kinetic | ``KineticInt`` | Libint2 | |; +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+; | Multipole Potential | ``MultipolePotentialInt`` | M-D | arbitrary order derivative of 1/R supported |; +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+; | Multipole Moments | ``MultipoleInt`` | M-D | arbitrary order multipoles supported, including nuclear gradients |; +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+; | Nabla Operator | ``NablaInt`` | Libint2 | using first derivative of ``libint2::Operator::overlap`` |; +----------------------------+-----",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:22189,Energy Efficiency,charge,charges,22189,"t`` | M-D | arbitrary order derivative of 1/R supported |; +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+; | Multipole Moments | ``MultipoleInt`` | M-D | arbitrary order multipoles supported, including nuclear gradients |; +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+; | Nabla Operator | ``NablaInt`` | Libint2 | using first derivative of ``libint2::Operator::overlap`` |; +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+; | Overlap | ``OverlapInt`` | Libint2 | |; +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+; | Nuclear Coulomb Potential | ``PotentialInt`` | Libint2 | assumes nuclear centers/charges as the potential |; +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+; | PCM Potential | ``PCMPotentialInt`` | Libint2 | parallelized over charge points |; +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+; | Quadrupole | ``QuadrupoleInt`` | Libint2 | |; +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+; | Traceless Quadrupole | ``TracelessQuadrupoleInt`` | Libint2 | |; +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+; | Relativistic Potential | ``RelPotentialInt`` | Libint2 | |; +----------------------------+----------------------------+-----------------+---------------------------------------------",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:22433,Energy Efficiency,charge,charge,22433,"der derivative of 1/R supported |; +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+; | Multipole Moments | ``MultipoleInt`` | M-D | arbitrary order multipoles supported, including nuclear gradients |; +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+; | Nabla Operator | ``NablaInt`` | Libint2 | using first derivative of ``libint2::Operator::overlap`` |; +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+; | Overlap | ``OverlapInt`` | Libint2 | |; +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+; | Nuclear Coulomb Potential | ``PotentialInt`` | Libint2 | assumes nuclear centers/charges as the potential |; +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+; | PCM Potential | ``PCMPotentialInt`` | Libint2 | parallelized over charge points |; +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+; | Quadrupole | ``QuadrupoleInt`` | Libint2 | |; +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+; | Traceless Quadrupole | ``TracelessQuadrupoleInt`` | Libint2 | |; +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+; | Relativistic Potential | ``RelPotentialInt`` | Libint2 | |; +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+.",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:1318,Integrability,interface,interface,1318,"are; you can redistribute it and/or modify; .. # it under the terms of the GNU Lesser General Public License as published by; .. # the Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:prog_integrals`:. ======================; Integrals in |PSIfour|; ======================. Introduction; ------------. |PSIfour| has a number of backends available to compute integrals. In order to; accomodate these options, while providing a clean interface to the programmer,; an abstraction layer is implemented within Libmints. A recent upgrade to the; primary integral engine has seen some important changes to the way this; interface layer is used; this document is designed to aid new developers as; well as those familiar with the older calling conventions to ensure that the; most efficient calling conventions are applied. The older style; ---------------. A very simple loop that does not use permutational symmetry might look; something like this in the old scheme:. .. code-block:: cpp. auto sieve = std::make_shared<ERISieve>(basisset, cutoff);; auto factory= std::make_shared<IntegralFactory>(basisset);; int deriv_level = 0;; bool use_shell_pairs = true;; auto eri = factory->eri(deriv_level, use_shell_pairs);; const double* buffer = eri_->buffer();; for (int P = 0; P < basisset->nshell(); ++P) {; const auto& Pshell = basisset->shell(P);; for (int Q = 0; Q < basisset->nshell(); ++Q) {; const auto& Qshell = basisset->shell(Q);; for (int R",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:1499,Integrability,interface,interface,1499," will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:prog_integrals`:. ======================; Integrals in |PSIfour|; ======================. Introduction; ------------. |PSIfour| has a number of backends available to compute integrals. In order to; accomodate these options, while providing a clean interface to the programmer,; an abstraction layer is implemented within Libmints. A recent upgrade to the; primary integral engine has seen some important changes to the way this; interface layer is used; this document is designed to aid new developers as; well as those familiar with the older calling conventions to ensure that the; most efficient calling conventions are applied. The older style; ---------------. A very simple loop that does not use permutational symmetry might look; something like this in the old scheme:. .. code-block:: cpp. auto sieve = std::make_shared<ERISieve>(basisset, cutoff);; auto factory= std::make_shared<IntegralFactory>(basisset);; int deriv_level = 0;; bool use_shell_pairs = true;; auto eri = factory->eri(deriv_level, use_shell_pairs);; const double* buffer = eri_->buffer();; for (int P = 0; P < basisset->nshell(); ++P) {; const auto& Pshell = basisset->shell(P);; for (int Q = 0; Q < basisset->nshell(); ++Q) {; const auto& Qshell = basisset->shell(Q);; for (int R = 0; R < basisset->nshell(); ++R) {; const auto& Rshell = basisset->shell(R);; for (int S = 0; S < basisset->nshell(); ++S) {; const auto& Sshell = basisset->shell(S);; if(sieve->shell_significant(P, Q, R, S) {; eri->comput",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:3206,Integrability,interface,interfaced,3206,"ell(); ++Q) {; const auto& Qshell = basisset->shell(Q);; for (int R = 0; R < basisset->nshell(); ++R) {; const auto& Rshell = basisset->shell(R);; for (int S = 0; S < basisset->nshell(); ++S) {; const auto& Sshell = basisset->shell(S);; if(sieve->shell_significant(P, Q, R, S) {; eri->compute_shell(P, Q, R, S);; // results are in buffer, do something with them..; }; }; }; }; }. An integral factory is used, which can then produce integral object for various; operator types and derivative levels. A sieve is also constructed; this allows; a quick determination of whether an integral shell quartet will be significant; in magnitude or not, potentially saving a lot of work. This simple scheme is; clean and easy to understand, and is still supported in the latest version of; |PSIfour| with only a small change to the sieve syntax and handling of buffer; addresses, noted below. The new syntax; --------------. The newer integral engines being interfaced to |PSIfour| may or may not require; a group of similar integrals to be computed together in a block using; vectorized instructions. To accomodate this possibility, a new syntax has been; introduced in Libmints:. .. code-block:: cpp. auto blocksPQ = ints[0]->get_blocks12();; auto blocksRS = ints[0]->get_blocks34();. auto factory= std::make_shared<IntegralFactory>(basisset);; int deriv_level = 0;; bool use_shell_pairs = true;; bool needs_exchange = true;; auto eri = factory->eri(deriv_level, use_shell_pairs, needs_exchange);; const auto &buffers = eri->buffers();. eri->update_density(D);; bool use_batching = eri->maximum_block_size() > 1;. // loop over all the blocks of (P>=Q|; for (size_t blockPQ_idx = 0; blockPQ_idx < blocksPQ.size(); blockPQ_idx++) {; const auto& blockPQ = blocksPQ[blockPQ_idx];; // loop over all the blocks of |R>=S); size_t start = eri->first_RS_shell_block(blockPQ_idx);; for (int blockRS_idx = loop_start; blockRS_idx < blocksRS.size(); ++blockRS_idx) {; const auto& blockRS = blocksRS[blockRS_idx];. if (!eri-",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:7482,Integrability,contract,contracted,7482,"call to compute integrals. The integral engine provides a; ``std::vector<const double*>`` containing the pointers to the start of each; ""chunk"" of integrals. For first derivatives there are 12 such ""chunks"", which; are ordered Px,Py,Pz,Qx,Qy,Qz,Rx,Ry,Rz,Sx,Sy,Sz, where the Px refers to the x; derivative with respect to the basis functions in shell P. Note that all; integral derivatives are provided by the new integral code, unlike the previous; version where only 9 of 12 were provided and the user was responsible for using; translation invariance relationships to fill in the rest. The addresses for; each chunk are updated in the vector after each call to compute integrals, so; the user should keep a const reference to that object, and query that for the; address of interest. Density Screening; ................. The old code looked only at the integral to determine whether terms can be; avoided *a priori*. However, if the integral is to be contracted with a; density or a density-like quantity, the screening can be performed on the; product, which yields more sparsity. To enable this, simply call the integral; object's ``update_density`` member, passing it a SharedMatrix holding the; current density (remember that it changes during each iteration of the SCF) and; the product will be considered during screening. If only coulomb-like terms; are to be computed, the ``needs_exchange`` argument to the integral object; constructor should be set to false, otherwise it should be true to correcly; account for products of the density and integrals that contribute to; exchange-like terms. Shell blocking; .............. Each underlying integral engine knows whether it will use blocks, and will set up; the metadata automatically. Instead of looping over individual shells, the; user should loop over blocks supplied by the integral object; these blocks will; be just a single shell quartet combination for the case where blocking is not; used. It is simple to loop over pairs within eac",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:13152,Integrability,interface,interface,13152,"ten Obara-Saika code. There are a; number of reasons motivating this switch. For methods requiring; potentials and fields evaluated at many external sites, such as PCM and; polarizable embedding, the efficiency of the one electron integrals can be rate; limiting. We also started to introduce integral screening, and it is important; to balance the screening used for one- and two-electron terms carefully, so this; is a good opportunity to re-evaluate the code. Finally, given the complexity; of the OS recursion code, the switch to an external library leaves a more; compact codebase to maintain. The one electron integrals which are not provided by Libint2; are now handled by a new implementation of the McMurchie-Davidson (M-D) algorithm,; leading to removal of the OS code in version 1.6. An overview of the one electron integrals; is shown in table :ref:`table:oei_impl_summary`, together with the implementation they use.; The tips below serve as a guide to what changed,; why it changed, and how to interface with |PSIfour|'s one-electron integral; machinery now. Calling ``compute_shell(int P, int Q)``; ....................................... The hand-implemented OS recursion code also took care of the Cartesian->pure; transformation (if required by the basis set). The mechanism for handling this; was to provide a public facing ``compute_shell(int P, int Q)`` method for the; caller; this then looked up the appropriate ``GaussianShell`` objects that were; passed into the corresponding (private) ``compute_pair(GaussianShell &s1,; GaussianShell &s2)`` function that computed the integrals and transformed them; to the spherical harmonic basis, if needed. The switch to Libint2 integrals; preserves this mechanism, but the ``compute_shell(int P, int Q)`` simply looks; up the appropriate Libint2-compatible shells and hands them off to the; re-written, private ``compute_pair()`` routines, which call Libint2 directly.; Therefore, any calls to shell-pair level integral computations sho",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:14039,Integrability,rout,routines,14039,"rview of the one electron integrals; is shown in table :ref:`table:oei_impl_summary`, together with the implementation they use.; The tips below serve as a guide to what changed,; why it changed, and how to interface with |PSIfour|'s one-electron integral; machinery now. Calling ``compute_shell(int P, int Q)``; ....................................... The hand-implemented OS recursion code also took care of the Cartesian->pure; transformation (if required by the basis set). The mechanism for handling this; was to provide a public facing ``compute_shell(int P, int Q)`` method for the; caller; this then looked up the appropriate ``GaussianShell`` objects that were; passed into the corresponding (private) ``compute_pair(GaussianShell &s1,; GaussianShell &s2)`` function that computed the integrals and transformed them; to the spherical harmonic basis, if needed. The switch to Libint2 integrals; preserves this mechanism, but the ``compute_shell(int P, int Q)`` simply looks; up the appropriate Libint2-compatible shells and hands them off to the; re-written, private ``compute_pair()`` routines, which call Libint2 directly.; Therefore, any calls to shell-pair level integral computations should look the; same as before the introduction of Libint2, however access to the integrals has; changed, as described below. Accessing integrals; ................... Before the Libint2 transition, one electron integrals were computed in a flat; array, internally called `buffer_`, which was accessed through the integral; object's ``buffer()`` method. For integrals with multiple operators, e.g.,; dipole operators that have three distinct components, the buffer was simply; elongated by the appropriate amount and the caller was responsible for striding; through each resulting batch correctly. The Libint2 engines instead return a; list of pointers into each operator's batch of integrals, the ordering of which; are detailed on the Libint2 wiki. For this reason, the call to ``buffer()``; that retur",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:15527,Integrability,depend,depends,15527,"perators that have three distinct components, the buffer was simply; elongated by the appropriate amount and the caller was responsible for striding; through each resulting batch correctly. The Libint2 engines instead return a; list of pointers into each operator's batch of integrals, the ordering of which; are detailed on the Libint2 wiki. For this reason, the call to ``buffer()``; that returns a single buffer must be replaced with a call to ``buffer()`` to; get a list of pointers; we recommend that be assigned the type ``const auto; &``. For simple integrals, such as overlap or kinetic, only the buffer; corresponding to the zeroth element of this array contains integrals. Derivative Integrals; .................... The old one electron integral code used translational invariance relations to; minimze the number of integrals to be computed, leaving the caller with some; bookkeeping to do to compute all terms. For example, consider an overlap; integral: its value depends only on the relative separation of the two centers; and not their absolute positions in space. Therefore, the derivative with; respect to center A is the negative of the same derivative with respect to; center B, so one is trivially gleaned from the other. Extending this to second; derivatives, the same principle leads to the fact that double derivatives with; respect to center A are equal to double derivatives with respect to center B,; which are also equal to the negative of the mixed double derivatives with; respect to both center A and B. The old code only provided the double; derivative with respect to center A, leaving the caller to determine the other; values. The Libint2 engine instead provides all integrals, so the caller; simply needs to loop over all of the buffers provided in the appropriate order. Changes to External Potential Engines; ..................................... Benchmarking showed that early versions of the old code spent a non-negligible; amount of time performing the Cartesi",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:16785,Integrability,contract,contracted,16785,"er. Extending this to second; derivatives, the same principle leads to the fact that double derivatives with; respect to center A are equal to double derivatives with respect to center B,; which are also equal to the negative of the mixed double derivatives with; respect to both center A and B. The old code only provided the double; derivative with respect to center A, leaving the caller to determine the other; values. The Libint2 engine instead provides all integrals, so the caller; simply needs to loop over all of the buffers provided in the appropriate order. Changes to External Potential Engines; ..................................... Benchmarking showed that early versions of the old code spent a non-negligible; amount of time performing the Cartesian to spherical harmonic transformation of; the integrals, which is needed for most modern basis sets. To improve; performance, we instead backtransformed the density to the Cartesian; representation (denoted ""CartAO"") and computed / contracted all integrals in; this Cartesian basis, eliminating the need to transform to spherical harmonics; as the integrals are computed. This bottleneck no longer exists, so these; extra transformation steps have been removed as part of the switch to Libint2,; and the affected codes (PCM and CPPE interfaces) now compute the potential and; field integrals in the representation required by the basis set. Also, note that the way external point charges are specified has changed.; Previously, a set of N external point charges would be specified by passing a; matrix with dimensions N rows and 4 columns -- corresponding to charge, x, y, z; -- to the ``set_charge_field()`` member of the potential integral class. The; same information is now passed using the more verbose; ``std::vector<std::pair<double, std::array<double, 3>>>`` type instead, to be; consistent with Libint2's convention. New Operators Available; ....................... Libint2 provides a range of integrals that were previously no",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:17086,Integrability,interface,interfaces,17086,"t to both center A and B. The old code only provided the double; derivative with respect to center A, leaving the caller to determine the other; values. The Libint2 engine instead provides all integrals, so the caller; simply needs to loop over all of the buffers provided in the appropriate order. Changes to External Potential Engines; ..................................... Benchmarking showed that early versions of the old code spent a non-negligible; amount of time performing the Cartesian to spherical harmonic transformation of; the integrals, which is needed for most modern basis sets. To improve; performance, we instead backtransformed the density to the Cartesian; representation (denoted ""CartAO"") and computed / contracted all integrals in; this Cartesian basis, eliminating the need to transform to spherical harmonics; as the integrals are computed. This bottleneck no longer exists, so these; extra transformation steps have been removed as part of the switch to Libint2,; and the affected codes (PCM and CPPE interfaces) now compute the potential and; field integrals in the representation required by the basis set. Also, note that the way external point charges are specified has changed.; Previously, a set of N external point charges would be specified by passing a; matrix with dimensions N rows and 4 columns -- corresponding to charge, x, y, z; -- to the ``set_charge_field()`` member of the potential integral class. The; same information is now passed using the more verbose; ``std::vector<std::pair<double, std::array<double, 3>>>`` type instead, to be; consistent with Libint2's convention. New Operators Available; ....................... Libint2 provides a range of integrals that were previously not available in; |PSIfour|, such as the Erfc attenuated nuclear potential integrals needed for; Ewald methods. If new integrals are added to Libint2 but are not yet; interfaced to |PSIfour|, please open an issue on the |PSIfour| GitHub page to; alert the developers, who ",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:17954,Integrability,interface,interfaced,17954,"e been removed as part of the switch to Libint2,; and the affected codes (PCM and CPPE interfaces) now compute the potential and; field integrals in the representation required by the basis set. Also, note that the way external point charges are specified has changed.; Previously, a set of N external point charges would be specified by passing a; matrix with dimensions N rows and 4 columns -- corresponding to charge, x, y, z; -- to the ``set_charge_field()`` member of the potential integral class. The; same information is now passed using the more verbose; ``std::vector<std::pair<double, std::array<double, 3>>>`` type instead, to be; consistent with Libint2's convention. New Operators Available; ....................... Libint2 provides a range of integrals that were previously not available in; |PSIfour|, such as the Erfc attenuated nuclear potential integrals needed for; Ewald methods. If new integrals are added to Libint2 but are not yet; interfaced to |PSIfour|, please open an issue on the |PSIfour| GitHub page to; alert the developers, who will be able to add the appropriate code.; Available integrals classes and parameters currently documented at ; `Libint2 C++11 Interface Wiki <https://github.com/evaleev/libint/wiki/using-modern-CPlusPlus-API#create-an-integral-engine>`_. Shell Pairs; ........... To ensure consistency between one- and two-electron terms when screening, and; for efficiency reasons, shell pair lists should be used to iterate over pairs; of Gaussian shells. These lists contain integer pair numbers, corresponding to; the pairs of shells that have sufficient overlap to survive the screening; process. Iterating over these lists is simple:. .. code-block:: cpp. const auto& shell_pairs = Vint->shellpairs();; size_t n_pairs = shell_pairs.size();; for (size_t p = 0; p < n_pairs; ++p) {; auto P = shell_pairs[p].first;; auto Q = shell_pairs[p].second;; // do something with shells P and Q; }. Note that list considers all P,Q pairs if the two basis sets dif",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:7558,Performance,perform,performed,7558,"call to compute integrals. The integral engine provides a; ``std::vector<const double*>`` containing the pointers to the start of each; ""chunk"" of integrals. For first derivatives there are 12 such ""chunks"", which; are ordered Px,Py,Pz,Qx,Qy,Qz,Rx,Ry,Rz,Sx,Sy,Sz, where the Px refers to the x; derivative with respect to the basis functions in shell P. Note that all; integral derivatives are provided by the new integral code, unlike the previous; version where only 9 of 12 were provided and the user was responsible for using; translation invariance relationships to fill in the rest. The addresses for; each chunk are updated in the vector after each call to compute integrals, so; the user should keep a const reference to that object, and query that for the; address of interest. Density Screening; ................. The old code looked only at the integral to determine whether terms can be; avoided *a priori*. However, if the integral is to be contracted with a; density or a density-like quantity, the screening can be performed on the; product, which yields more sparsity. To enable this, simply call the integral; object's ``update_density`` member, passing it a SharedMatrix holding the; current density (remember that it changes during each iteration of the SCF) and; the product will be considered during screening. If only coulomb-like terms; are to be computed, the ``needs_exchange`` argument to the integral object; constructor should be set to false, otherwise it should be true to correcly; account for products of the density and integrals that contribute to; exchange-like terms. Shell blocking; .............. Each underlying integral engine knows whether it will use blocks, and will set up; the metadata automatically. Instead of looping over individual shells, the; user should loop over blocks supplied by the integral object; these blocks will; be just a single shell quartet combination for the case where blocking is not; used. It is simple to loop over pairs within eac",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:8834,Performance,optimiz,optimized,8834," considered during screening. If only coulomb-like terms; are to be computed, the ``needs_exchange`` argument to the integral object; constructor should be set to false, otherwise it should be true to correcly; account for products of the density and integrals that contribute to; exchange-like terms. Shell blocking; .............. Each underlying integral engine knows whether it will use blocks, and will set up; the metadata automatically. Instead of looping over individual shells, the; user should loop over blocks supplied by the integral object; these blocks will; be just a single shell quartet combination for the case where blocking is not; used. It is simple to loop over pairs within each block using C++11 syntax, as; demonstrated in the code snippet above. Only shell pairs with significant; overlap are included in the shell block information, making this an efficient; way to loop over non-negligible terms. Permutational symmetry; ...................... The pairs within each block are optimized for efficiency. First, they are; screened during the integral object's creation to ensure that only terms with; appreciable overlap are stored. Second, only P,Q combinations that are; permutationally unique are stored, ordered with the higher angular momentum; first. Therefore care must be taken to ensure that the missing permutations; are correctly accounted for when processing the integrals within the loop. See; the DirectJK code in libfock for an example of using this scheme for a Fock; matrix build. Using bra-ket symmetry; ...................... In cases where there is no batching performed, bra-ket symmetry can be; trivially enforced by ensuring that one of the block indices is greater than or; equal to the other. When batching is used, the situation is trickier; some ket; batches may contain a mixture of integrals that are bra-ket unique and those; that are not. To handle this we must do a coarse check at the top of the loop; to see if *any* integrals in the batch a",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:9436,Performance,perform,performed,9436,"d. It is simple to loop over pairs within each block using C++11 syntax, as; demonstrated in the code snippet above. Only shell pairs with significant; overlap are included in the shell block information, making this an efficient; way to loop over non-negligible terms. Permutational symmetry; ...................... The pairs within each block are optimized for efficiency. First, they are; screened during the integral object's creation to ensure that only terms with; appreciable overlap are stored. Second, only P,Q combinations that are; permutationally unique are stored, ordered with the higher angular momentum; first. Therefore care must be taken to ensure that the missing permutations; are correctly accounted for when processing the integrals within the loop. See; the DirectJK code in libfock for an example of using this scheme for a Fock; matrix build. Using bra-ket symmetry; ...................... In cases where there is no batching performed, bra-ket symmetry can be; trivially enforced by ensuring that one of the block indices is greater than or; equal to the other. When batching is used, the situation is trickier; some ket; batches may contain a mixture of integrals that are bra-ket unique and those; that are not. To handle this we must do a coarse check at the top of the loop; to see if *any* integrals in the batch are needed, which is implemented by; asking the integral engine where to start looping in the ket via the call to; ``eri->first_RS_shell_block(PQpair_idx)``. This is followed by a more fine; grained check within the loops to filter individual integrals in the case where; bra and ket have the same angular momentum and there's a possibility of a; handful of integrals coming from the ket that are redundant. Note that the bra; is not batched in any of our engines currently: only the ket is. For this; reason, density fitting integrals should be written as (A0|PQ) rather than; (PQ|A0) where possible, because we want the ket to contain more functions than;",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:11678,Performance,perform,performs,11678,"ased. Although significantly cheaper than computing; integrals themselves, construction of integral objects can be non-negligible,; especially if many threads are used. For example, this pattern can be found in; old versions of the code:. .. code-block:: cpp. std::vector<std::shared_ptr<TwoBodyAOInt>> ints;; ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));; for (int thread = 1; thread < num_threads; thread++) {; ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));; }. This builds many objects and the cost can add up. With the new scheme,; integral objects are forced to implement a `clone()` member that can be used as; follows:. .. code-block:: cpp. std::vector<std::shared_ptr<TwoBodyAOInt>> ints;; ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));; for (int thread = 1; thread < num_threads; thread++) {; ints.push_back(std::shared_ptr<TwoBodyAOInt>(ints[0]->clone()));; }. This method only incurs the cost of creating a single integral object, and; performs much cheaper cloning operations to create the other objects for each; thread. Moreover, if integral objects are created only in the initialization; of each code that uses them, and stored persistently, the cost of integral; object creation is further reduced. One Electron Integrals in |PSIfour|; -----------------------------------. After version 1.5, we started transitioning the one electron integral code over to; use Libint2 instead of the old handwritten Obara-Saika code. There are a; number of reasons motivating this switch. For methods requiring; potentials and fields evaluated at many external sites, such as PCM and; polarizable embedding, the efficiency of the one electron integrals can be rate; limiting. We also started to introduce integral screening, and it is important; to balance the screening used for one- and two-electron terms carefully, so this; is a good opportunity to re-evaluate the code. Finally, given the complexity; of the OS recursion code, the switch to an ex",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:16529,Performance,perform,performing,16529,"the relative separation of the two centers; and not their absolute positions in space. Therefore, the derivative with; respect to center A is the negative of the same derivative with respect to; center B, so one is trivially gleaned from the other. Extending this to second; derivatives, the same principle leads to the fact that double derivatives with; respect to center A are equal to double derivatives with respect to center B,; which are also equal to the negative of the mixed double derivatives with; respect to both center A and B. The old code only provided the double; derivative with respect to center A, leaving the caller to determine the other; values. The Libint2 engine instead provides all integrals, so the caller; simply needs to loop over all of the buffers provided in the appropriate order. Changes to External Potential Engines; ..................................... Benchmarking showed that early versions of the old code spent a non-negligible; amount of time performing the Cartesian to spherical harmonic transformation of; the integrals, which is needed for most modern basis sets. To improve; performance, we instead backtransformed the density to the Cartesian; representation (denoted ""CartAO"") and computed / contracted all integrals in; this Cartesian basis, eliminating the need to transform to spherical harmonics; as the integrals are computed. This bottleneck no longer exists, so these; extra transformation steps have been removed as part of the switch to Libint2,; and the affected codes (PCM and CPPE interfaces) now compute the potential and; field integrals in the representation required by the basis set. Also, note that the way external point charges are specified has changed.; Previously, a set of N external point charges would be specified by passing a; matrix with dimensions N rows and 4 columns -- corresponding to charge, x, y, z; -- to the ``set_charge_field()`` member of the potential integral class. The; same information is now passed using",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:16666,Performance,perform,performance,16666,"er. Extending this to second; derivatives, the same principle leads to the fact that double derivatives with; respect to center A are equal to double derivatives with respect to center B,; which are also equal to the negative of the mixed double derivatives with; respect to both center A and B. The old code only provided the double; derivative with respect to center A, leaving the caller to determine the other; values. The Libint2 engine instead provides all integrals, so the caller; simply needs to loop over all of the buffers provided in the appropriate order. Changes to External Potential Engines; ..................................... Benchmarking showed that early versions of the old code spent a non-negligible; amount of time performing the Cartesian to spherical harmonic transformation of; the integrals, which is needed for most modern basis sets. To improve; performance, we instead backtransformed the density to the Cartesian; representation (denoted ""CartAO"") and computed / contracted all integrals in; this Cartesian basis, eliminating the need to transform to spherical harmonics; as the integrals are computed. This bottleneck no longer exists, so these; extra transformation steps have been removed as part of the switch to Libint2,; and the affected codes (PCM and CPPE interfaces) now compute the potential and; field integrals in the representation required by the basis set. Also, note that the way external point charges are specified has changed.; Previously, a set of N external point charges would be specified by passing a; matrix with dimensions N rows and 4 columns -- corresponding to charge, x, y, z; -- to the ``set_charge_field()`` member of the potential integral class. The; same information is now passed using the more verbose; ``std::vector<std::pair<double, std::array<double, 3>>>`` type instead, to be; consistent with Libint2's convention. New Operators Available; ....................... Libint2 provides a range of integrals that were previously no",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:16930,Performance,bottleneck,bottleneck,16930,"t to both center A and B. The old code only provided the double; derivative with respect to center A, leaving the caller to determine the other; values. The Libint2 engine instead provides all integrals, so the caller; simply needs to loop over all of the buffers provided in the appropriate order. Changes to External Potential Engines; ..................................... Benchmarking showed that early versions of the old code spent a non-negligible; amount of time performing the Cartesian to spherical harmonic transformation of; the integrals, which is needed for most modern basis sets. To improve; performance, we instead backtransformed the density to the Cartesian; representation (denoted ""CartAO"") and computed / contracted all integrals in; this Cartesian basis, eliminating the need to transform to spherical harmonics; as the integrals are computed. This bottleneck no longer exists, so these; extra transformation steps have been removed as part of the switch to Libint2,; and the affected codes (PCM and CPPE interfaces) now compute the potential and; field integrals in the representation required by the basis set. Also, note that the way external point charges are specified has changed.; Previously, a set of N external point charges would be specified by passing a; matrix with dimensions N rows and 4 columns -- corresponding to charge, x, y, z; -- to the ``set_charge_field()`` member of the potential integral class. The; same information is now passed using the more verbose; ``std::vector<std::pair<double, std::array<double, 3>>>`` type instead, to be; consistent with Libint2's convention. New Operators Available; ....................... Libint2 provides a range of integrals that were previously not available in; |PSIfour|, such as the Erfc attenuated nuclear potential integrals needed for; Ewald methods. If new integrals are added to Libint2 but are not yet; interfaced to |PSIfour|, please open an issue on the |PSIfour| GitHub page to; alert the developers, who ",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:5138,Safety,redund,redundant,5138," eri->first_RS_shell_block(blockPQ_idx);; for (int blockRS_idx = loop_start; blockRS_idx < blocksRS.size(); ++blockRS_idx) {; const auto& blockRS = blocksRS[blockRS_idx];. if (!eri->shell_block_significant(blockPQ_idx, blockRS_idx)) continue;. eri->compute_shell_blocks(blockPQ_idx, blockRS_idx);; const auto* block_start = buffers[0];. // Loop over all of the P,Q,R,S shells within the blocks. We have P>=Q, R>=S and PQ<=RS.; for (const auto& pairPQ : blockPQ) {; const auto &P = pairPQ.first;; const auto &Q = pairPQ.second;; const auto& Pshell = basisset->shell(P);; const auto& Qshell = basisset->shell(Q);; const auto Pam = Pshell.am();; const auto Qam = Qshell.am();; for (const auto& pairRS : blockRS) {; const auto &R = pairRS.first;; const auto &S = pairRS.second;; const auto& Rshell = basisset->shell(R);; const auto& Sshell = basisset->shell(S);; const auto Ram = Rshell.am();; const auto Sam = Sshell.am();. size_t block_size = Psize * Qsize * Rsize * Ssize;; // When there are chunks of shellpairs in RS, we need to make sure; // we filter out redundant combinations.; if (use_batching && Pam == Ram && Qam == Sam && ((P > R) || (P == R && Q > S))) {; block_start += block_size;; continue;; }; const double* int_ptr = block_start;; // Query P,Q,R,S shells for metadata and loop over that quartet; // as usual, getting the integrals from the int_ptr buffer.; block_start += block_size;; }; }; }; }. Although this looks more complex, it's essentially doing the same thing. There; are a number of differences that we'll highlight now. Sieving; ....... This is one of two breaking changes to the old style syntax. Instead of; constructing a sieve object, the integral object should be queried directly; using the exact same syntax. Requests for whether a shell is significant or a; shell block is significant are both supported. A sieve object is created if; matching basis sets are found in either the bra or the ket. For a density; fitting integral (PQ|0A) where 0 is the null basis set an",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:6379,Safety,avoid,avoid,6379,"= block_size;; }; }; }; }. Although this looks more complex, it's essentially doing the same thing. There; are a number of differences that we'll highlight now. Sieving; ....... This is one of two breaking changes to the old style syntax. Instead of; constructing a sieve object, the integral object should be queried directly; using the exact same syntax. Requests for whether a shell is significant or a; shell block is significant are both supported. A sieve object is created if; matching basis sets are found in either the bra or the ket. For a density; fitting integral (PQ|0A) where 0 is the null basis set and A is an auxiliary; basis set the (PQ| pair will be used to construct all of the sieving data. Buffer address; .............. The old code copied integrals into a buffer owned by the integral object, whose; address remained constant and could be retrieved by the ``buffer()`` member; function. To avoid unnecessary copies, the new code instead uses the integrals; directly from the underlying integral engine's memory, which may change with; each call to compute integrals. The integral engine provides a; ``std::vector<const double*>`` containing the pointers to the start of each; ""chunk"" of integrals. For first derivatives there are 12 such ""chunks"", which; are ordered Px,Py,Pz,Qx,Qy,Qz,Rx,Ry,Rz,Sx,Sy,Sz, where the Px refers to the x; derivative with respect to the basis functions in shell P. Note that all; integral derivatives are provided by the new integral code, unlike the previous; version where only 9 of 12 were provided and the user was responsible for using; translation invariance relationships to fill in the rest. The addresses for; each chunk are updated in the vector after each call to compute integrals, so; the user should keep a const reference to that object, and query that for the; address of interest. Density Screening; ................. The old code looked only at the integral to determine whether terms can be; avoided *a priori*. However, if the i",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:7428,Safety,avoid,avoided,7428,"pies, the new code instead uses the integrals; directly from the underlying integral engine's memory, which may change with; each call to compute integrals. The integral engine provides a; ``std::vector<const double*>`` containing the pointers to the start of each; ""chunk"" of integrals. For first derivatives there are 12 such ""chunks"", which; are ordered Px,Py,Pz,Qx,Qy,Qz,Rx,Ry,Rz,Sx,Sy,Sz, where the Px refers to the x; derivative with respect to the basis functions in shell P. Note that all; integral derivatives are provided by the new integral code, unlike the previous; version where only 9 of 12 were provided and the user was responsible for using; translation invariance relationships to fill in the rest. The addresses for; each chunk are updated in the vector after each call to compute integrals, so; the user should keep a const reference to that object, and query that for the; address of interest. Density Screening; ................. The old code looked only at the integral to determine whether terms can be; avoided *a priori*. However, if the integral is to be contracted with a; density or a density-like quantity, the screening can be performed on the; product, which yields more sparsity. To enable this, simply call the integral; object's ``update_density`` member, passing it a SharedMatrix holding the; current density (remember that it changes during each iteration of the SCF) and; the product will be considered during screening. If only coulomb-like terms; are to be computed, the ``needs_exchange`` argument to the integral object; constructor should be set to false, otherwise it should be true to correcly; account for products of the density and integrals that contribute to; exchange-like terms. Shell blocking; .............. Each underlying integral engine knows whether it will use blocks, and will set up; the metadata automatically. Instead of looping over individual shells, the; user should loop over blocks supplied by the integral object; these blocks wi",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:10226,Safety,redund,redundant,10226," Therefore care must be taken to ensure that the missing permutations; are correctly accounted for when processing the integrals within the loop. See; the DirectJK code in libfock for an example of using this scheme for a Fock; matrix build. Using bra-ket symmetry; ...................... In cases where there is no batching performed, bra-ket symmetry can be; trivially enforced by ensuring that one of the block indices is greater than or; equal to the other. When batching is used, the situation is trickier; some ket; batches may contain a mixture of integrals that are bra-ket unique and those; that are not. To handle this we must do a coarse check at the top of the loop; to see if *any* integrals in the batch are needed, which is implemented by; asking the integral engine where to start looping in the ket via the call to; ``eri->first_RS_shell_block(PQpair_idx)``. This is followed by a more fine; grained check within the loops to filter individual integrals in the case where; bra and ket have the same angular momentum and there's a possibility of a; handful of integrals coming from the ket that are redundant. Note that the bra; is not batched in any of our engines currently: only the ket is. For this; reason, density fitting integrals should be written as (A0|PQ) rather than; (PQ|A0) where possible, because we want the ket to contain more functions than; the bra for efficient blocking. Instantiating integral objects; .............................. With sieving being introduced in the new integral objects, the cost of their; construction has increased. Although significantly cheaper than computing; integrals themselves, construction of integral objects can be non-negligible,; especially if many threads are used. For example, this pattern can be found in; old versions of the code:. .. code-block:: cpp. std::vector<std::shared_ptr<TwoBodyAOInt>> ints;; ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));; for (int thread = 1; thread < num_threads; thread++) {;",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:14211,Security,access,access,14211,"our|'s one-electron integral; machinery now. Calling ``compute_shell(int P, int Q)``; ....................................... The hand-implemented OS recursion code also took care of the Cartesian->pure; transformation (if required by the basis set). The mechanism for handling this; was to provide a public facing ``compute_shell(int P, int Q)`` method for the; caller; this then looked up the appropriate ``GaussianShell`` objects that were; passed into the corresponding (private) ``compute_pair(GaussianShell &s1,; GaussianShell &s2)`` function that computed the integrals and transformed them; to the spherical harmonic basis, if needed. The switch to Libint2 integrals; preserves this mechanism, but the ``compute_shell(int P, int Q)`` simply looks; up the appropriate Libint2-compatible shells and hands them off to the; re-written, private ``compute_pair()`` routines, which call Libint2 directly.; Therefore, any calls to shell-pair level integral computations should look the; same as before the introduction of Libint2, however access to the integrals has; changed, as described below. Accessing integrals; ................... Before the Libint2 transition, one electron integrals were computed in a flat; array, internally called `buffer_`, which was accessed through the integral; object's ``buffer()`` method. For integrals with multiple operators, e.g.,; dipole operators that have three distinct components, the buffer was simply; elongated by the appropriate amount and the caller was responsible for striding; through each resulting batch correctly. The Libint2 engines instead return a; list of pointers into each operator's batch of integrals, the ordering of which; are detailed on the Libint2 wiki. For this reason, the call to ``buffer()``; that returns a single buffer must be replaced with a call to ``buffer()`` to; get a list of pointers; we recommend that be assigned the type ``const auto; &``. For simple integrals, such as overlap or kinetic, only the buffer; correspond",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:14435,Security,access,accessed,14435,"d by the basis set). The mechanism for handling this; was to provide a public facing ``compute_shell(int P, int Q)`` method for the; caller; this then looked up the appropriate ``GaussianShell`` objects that were; passed into the corresponding (private) ``compute_pair(GaussianShell &s1,; GaussianShell &s2)`` function that computed the integrals and transformed them; to the spherical harmonic basis, if needed. The switch to Libint2 integrals; preserves this mechanism, but the ``compute_shell(int P, int Q)`` simply looks; up the appropriate Libint2-compatible shells and hands them off to the; re-written, private ``compute_pair()`` routines, which call Libint2 directly.; Therefore, any calls to shell-pair level integral computations should look the; same as before the introduction of Libint2, however access to the integrals has; changed, as described below. Accessing integrals; ................... Before the Libint2 transition, one electron integrals were computed in a flat; array, internally called `buffer_`, which was accessed through the integral; object's ``buffer()`` method. For integrals with multiple operators, e.g.,; dipole operators that have three distinct components, the buffer was simply; elongated by the appropriate amount and the caller was responsible for striding; through each resulting batch correctly. The Libint2 engines instead return a; list of pointers into each operator's batch of integrals, the ordering of which; are detailed on the Libint2 wiki. For this reason, the call to ``buffer()``; that returns a single buffer must be replaced with a call to ``buffer()`` to; get a list of pointers; we recommend that be assigned the type ``const auto; &``. For simple integrals, such as overlap or kinetic, only the buffer; corresponding to the zeroth element of this array contains integrals. Derivative Integrals; .................... The old one electron integral code used translational invariance relations to; minimze the number of integrals to be computed,",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:1743,Usability,simpl,simple,1743,"ceived a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:prog_integrals`:. ======================; Integrals in |PSIfour|; ======================. Introduction; ------------. |PSIfour| has a number of backends available to compute integrals. In order to; accomodate these options, while providing a clean interface to the programmer,; an abstraction layer is implemented within Libmints. A recent upgrade to the; primary integral engine has seen some important changes to the way this; interface layer is used; this document is designed to aid new developers as; well as those familiar with the older calling conventions to ensure that the; most efficient calling conventions are applied. The older style; ---------------. A very simple loop that does not use permutational symmetry might look; something like this in the old scheme:. .. code-block:: cpp. auto sieve = std::make_shared<ERISieve>(basisset, cutoff);; auto factory= std::make_shared<IntegralFactory>(basisset);; int deriv_level = 0;; bool use_shell_pairs = true;; auto eri = factory->eri(deriv_level, use_shell_pairs);; const double* buffer = eri_->buffer();; for (int P = 0; P < basisset->nshell(); ++P) {; const auto& Pshell = basisset->shell(P);; for (int Q = 0; Q < basisset->nshell(); ++Q) {; const auto& Qshell = basisset->shell(Q);; for (int R = 0; R < basisset->nshell(); ++R) {; const auto& Rshell = basisset->shell(R);; for (int S = 0; S < basisset->nshell(); ++S) {; const auto& Sshell = basisset->shell(S);; if(sieve->shell_significant(P, Q, R, S) {; eri->compute_shell(P, Q, R, S);; // results are in buffer, do something with them..; }; }; }; }; }. An integral factory is used, which can then produce integral object for various; operator types and derivative levels. A sieve is also constructed; thi",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:2941,Usability,simpl,simple,2941,"e;; auto eri = factory->eri(deriv_level, use_shell_pairs);; const double* buffer = eri_->buffer();; for (int P = 0; P < basisset->nshell(); ++P) {; const auto& Pshell = basisset->shell(P);; for (int Q = 0; Q < basisset->nshell(); ++Q) {; const auto& Qshell = basisset->shell(Q);; for (int R = 0; R < basisset->nshell(); ++R) {; const auto& Rshell = basisset->shell(R);; for (int S = 0; S < basisset->nshell(); ++S) {; const auto& Sshell = basisset->shell(S);; if(sieve->shell_significant(P, Q, R, S) {; eri->compute_shell(P, Q, R, S);; // results are in buffer, do something with them..; }; }; }; }; }. An integral factory is used, which can then produce integral object for various; operator types and derivative levels. A sieve is also constructed; this allows; a quick determination of whether an integral shell quartet will be significant; in magnitude or not, potentially saving a lot of work. This simple scheme is; clean and easy to understand, and is still supported in the latest version of; |PSIfour| with only a small change to the sieve syntax and handling of buffer; addresses, noted below. The new syntax; --------------. The newer integral engines being interfaced to |PSIfour| may or may not require; a group of similar integrals to be computed together in a block using; vectorized instructions. To accomodate this possibility, a new syntax has been; introduced in Libmints:. .. code-block:: cpp. auto blocksPQ = ints[0]->get_blocks12();; auto blocksRS = ints[0]->get_blocks34();. auto factory= std::make_shared<IntegralFactory>(basisset);; int deriv_level = 0;; bool use_shell_pairs = true;; bool needs_exchange = true;; auto eri = factory->eri(deriv_level, use_shell_pairs, needs_exchange);; const auto &buffers = eri->buffers();. eri->update_density(D);; bool use_batching = eri->maximum_block_size() > 1;. // loop over all the blocks of (P>=Q|; for (size_t blockPQ_idx = 0; blockPQ_idx < blocksPQ.size(); blockPQ_idx++) {; const auto& blockPQ = blocksPQ[blockPQ_idx];; // loop ove",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:7629,Usability,simpl,simply,7629,", which; are ordered Px,Py,Pz,Qx,Qy,Qz,Rx,Ry,Rz,Sx,Sy,Sz, where the Px refers to the x; derivative with respect to the basis functions in shell P. Note that all; integral derivatives are provided by the new integral code, unlike the previous; version where only 9 of 12 were provided and the user was responsible for using; translation invariance relationships to fill in the rest. The addresses for; each chunk are updated in the vector after each call to compute integrals, so; the user should keep a const reference to that object, and query that for the; address of interest. Density Screening; ................. The old code looked only at the integral to determine whether terms can be; avoided *a priori*. However, if the integral is to be contracted with a; density or a density-like quantity, the screening can be performed on the; product, which yields more sparsity. To enable this, simply call the integral; object's ``update_density`` member, passing it a SharedMatrix holding the; current density (remember that it changes during each iteration of the SCF) and; the product will be considered during screening. If only coulomb-like terms; are to be computed, the ``needs_exchange`` argument to the integral object; constructor should be set to false, otherwise it should be true to correcly; account for products of the density and integrals that contribute to; exchange-like terms. Shell blocking; .............. Each underlying integral engine knows whether it will use blocks, and will set up; the metadata automatically. Instead of looping over individual shells, the; user should loop over blocks supplied by the integral object; these blocks will; be just a single shell quartet combination for the case where blocking is not; used. It is simple to loop over pairs within each block using C++11 syntax, as; demonstrated in the code snippet above. Only shell pairs with significant; overlap are included in the shell block information, making this an efficient; way to loop over non",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:8494,Usability,simpl,simple,8494,"eening can be performed on the; product, which yields more sparsity. To enable this, simply call the integral; object's ``update_density`` member, passing it a SharedMatrix holding the; current density (remember that it changes during each iteration of the SCF) and; the product will be considered during screening. If only coulomb-like terms; are to be computed, the ``needs_exchange`` argument to the integral object; constructor should be set to false, otherwise it should be true to correcly; account for products of the density and integrals that contribute to; exchange-like terms. Shell blocking; .............. Each underlying integral engine knows whether it will use blocks, and will set up; the metadata automatically. Instead of looping over individual shells, the; user should loop over blocks supplied by the integral object; these blocks will; be just a single shell quartet combination for the case where blocking is not; used. It is simple to loop over pairs within each block using C++11 syntax, as; demonstrated in the code snippet above. Only shell pairs with significant; overlap are included in the shell block information, making this an efficient; way to loop over non-negligible terms. Permutational symmetry; ...................... The pairs within each block are optimized for efficiency. First, they are; screened during the integral object's creation to ensure that only terms with; appreciable overlap are stored. Second, only P,Q combinations that are; permutationally unique are stored, ordered with the higher angular momentum; first. Therefore care must be taken to ensure that the missing permutations; are correctly accounted for when processing the integrals within the loop. See; the DirectJK code in libfock for an example of using this scheme for a Fock; matrix build. Using bra-ket symmetry; ...................... In cases where there is no batching performed, bra-ket symmetry can be; trivially enforced by ensuring that one of the block indices is greater ",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:13101,Usability,guid,guide,13101,"ten Obara-Saika code. There are a; number of reasons motivating this switch. For methods requiring; potentials and fields evaluated at many external sites, such as PCM and; polarizable embedding, the efficiency of the one electron integrals can be rate; limiting. We also started to introduce integral screening, and it is important; to balance the screening used for one- and two-electron terms carefully, so this; is a good opportunity to re-evaluate the code. Finally, given the complexity; of the OS recursion code, the switch to an external library leaves a more; compact codebase to maintain. The one electron integrals which are not provided by Libint2; are now handled by a new implementation of the McMurchie-Davidson (M-D) algorithm,; leading to removal of the OS code in version 1.6. An overview of the one electron integrals; is shown in table :ref:`table:oei_impl_summary`, together with the implementation they use.; The tips below serve as a guide to what changed,; why it changed, and how to interface with |PSIfour|'s one-electron integral; machinery now. Calling ``compute_shell(int P, int Q)``; ....................................... The hand-implemented OS recursion code also took care of the Cartesian->pure; transformation (if required by the basis set). The mechanism for handling this; was to provide a public facing ``compute_shell(int P, int Q)`` method for the; caller; this then looked up the appropriate ``GaussianShell`` objects that were; passed into the corresponding (private) ``compute_pair(GaussianShell &s1,; GaussianShell &s2)`` function that computed the integrals and transformed them; to the spherical harmonic basis, if needed. The switch to Libint2 integrals; preserves this mechanism, but the ``compute_shell(int P, int Q)`` simply looks; up the appropriate Libint2-compatible shells and hands them off to the; re-written, private ``compute_pair()`` routines, which call Libint2 directly.; Therefore, any calls to shell-pair level integral computations sho",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:13914,Usability,simpl,simply,13914,"rview of the one electron integrals; is shown in table :ref:`table:oei_impl_summary`, together with the implementation they use.; The tips below serve as a guide to what changed,; why it changed, and how to interface with |PSIfour|'s one-electron integral; machinery now. Calling ``compute_shell(int P, int Q)``; ....................................... The hand-implemented OS recursion code also took care of the Cartesian->pure; transformation (if required by the basis set). The mechanism for handling this; was to provide a public facing ``compute_shell(int P, int Q)`` method for the; caller; this then looked up the appropriate ``GaussianShell`` objects that were; passed into the corresponding (private) ``compute_pair(GaussianShell &s1,; GaussianShell &s2)`` function that computed the integrals and transformed them; to the spherical harmonic basis, if needed. The switch to Libint2 integrals; preserves this mechanism, but the ``compute_shell(int P, int Q)`` simply looks; up the appropriate Libint2-compatible shells and hands them off to the; re-written, private ``compute_pair()`` routines, which call Libint2 directly.; Therefore, any calls to shell-pair level integral computations should look the; same as before the introduction of Libint2, however access to the integrals has; changed, as described below. Accessing integrals; ................... Before the Libint2 transition, one electron integrals were computed in a flat; array, internally called `buffer_`, which was accessed through the integral; object's ``buffer()`` method. For integrals with multiple operators, e.g.,; dipole operators that have three distinct components, the buffer was simply; elongated by the appropriate amount and the caller was responsible for striding; through each resulting batch correctly. The Libint2 engines instead return a; list of pointers into each operator's batch of integrals, the ordering of which; are detailed on the Libint2 wiki. For this reason, the call to ``buffer()``; that retur",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:14611,Usability,simpl,simply,14611,"onding (private) ``compute_pair(GaussianShell &s1,; GaussianShell &s2)`` function that computed the integrals and transformed them; to the spherical harmonic basis, if needed. The switch to Libint2 integrals; preserves this mechanism, but the ``compute_shell(int P, int Q)`` simply looks; up the appropriate Libint2-compatible shells and hands them off to the; re-written, private ``compute_pair()`` routines, which call Libint2 directly.; Therefore, any calls to shell-pair level integral computations should look the; same as before the introduction of Libint2, however access to the integrals has; changed, as described below. Accessing integrals; ................... Before the Libint2 transition, one electron integrals were computed in a flat; array, internally called `buffer_`, which was accessed through the integral; object's ``buffer()`` method. For integrals with multiple operators, e.g.,; dipole operators that have three distinct components, the buffer was simply; elongated by the appropriate amount and the caller was responsible for striding; through each resulting batch correctly. The Libint2 engines instead return a; list of pointers into each operator's batch of integrals, the ordering of which; are detailed on the Libint2 wiki. For this reason, the call to ``buffer()``; that returns a single buffer must be replaced with a call to ``buffer()`` to; get a list of pointers; we recommend that be assigned the type ``const auto; &``. For simple integrals, such as overlap or kinetic, only the buffer; corresponding to the zeroth element of this array contains integrals. Derivative Integrals; .................... The old one electron integral code used translational invariance relations to; minimze the number of integrals to be computed, leaving the caller with some; bookkeeping to do to compute all terms. For example, consider an overlap; integral: its value depends only on the relative separation of the two centers; and not their absolute positions in space. Therefore",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:15100,Usability,simpl,simple,15100," as before the introduction of Libint2, however access to the integrals has; changed, as described below. Accessing integrals; ................... Before the Libint2 transition, one electron integrals were computed in a flat; array, internally called `buffer_`, which was accessed through the integral; object's ``buffer()`` method. For integrals with multiple operators, e.g.,; dipole operators that have three distinct components, the buffer was simply; elongated by the appropriate amount and the caller was responsible for striding; through each resulting batch correctly. The Libint2 engines instead return a; list of pointers into each operator's batch of integrals, the ordering of which; are detailed on the Libint2 wiki. For this reason, the call to ``buffer()``; that returns a single buffer must be replaced with a call to ``buffer()`` to; get a list of pointers; we recommend that be assigned the type ``const auto; &``. For simple integrals, such as overlap or kinetic, only the buffer; corresponding to the zeroth element of this array contains integrals. Derivative Integrals; .................... The old one electron integral code used translational invariance relations to; minimze the number of integrals to be computed, leaving the caller with some; bookkeeping to do to compute all terms. For example, consider an overlap; integral: its value depends only on the relative separation of the two centers; and not their absolute positions in space. Therefore, the derivative with; respect to center A is the negative of the same derivative with respect to; center B, so one is trivially gleaned from the other. Extending this to second; derivatives, the same principle leads to the fact that double derivatives with; respect to center A are equal to double derivatives with respect to center B,; which are also equal to the negative of the mixed double derivatives with; respect to both center A and B. The old code only provided the double; derivative with respect to center A, leav",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:16277,Usability,simpl,simply,16277," one electron integral code used translational invariance relations to; minimze the number of integrals to be computed, leaving the caller with some; bookkeeping to do to compute all terms. For example, consider an overlap; integral: its value depends only on the relative separation of the two centers; and not their absolute positions in space. Therefore, the derivative with; respect to center A is the negative of the same derivative with respect to; center B, so one is trivially gleaned from the other. Extending this to second; derivatives, the same principle leads to the fact that double derivatives with; respect to center A are equal to double derivatives with respect to center B,; which are also equal to the negative of the mixed double derivatives with; respect to both center A and B. The old code only provided the double; derivative with respect to center A, leaving the caller to determine the other; values. The Libint2 engine instead provides all integrals, so the caller; simply needs to loop over all of the buffers provided in the appropriate order. Changes to External Potential Engines; ..................................... Benchmarking showed that early versions of the old code spent a non-negligible; amount of time performing the Cartesian to spherical harmonic transformation of; the integrals, which is needed for most modern basis sets. To improve; performance, we instead backtransformed the density to the Cartesian; representation (denoted ""CartAO"") and computed / contracted all integrals in; this Cartesian basis, eliminating the need to transform to spherical harmonics; as the integrals are computed. This bottleneck no longer exists, so these; extra transformation steps have been removed as part of the switch to Libint2,; and the affected codes (PCM and CPPE interfaces) now compute the potential and; field integrals in the representation required by the basis set. Also, note that the way external point charges are specified has changed.; Previously, a ",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst:18675,Usability,simpl,simple,18675,"2's convention. New Operators Available; ....................... Libint2 provides a range of integrals that were previously not available in; |PSIfour|, such as the Erfc attenuated nuclear potential integrals needed for; Ewald methods. If new integrals are added to Libint2 but are not yet; interfaced to |PSIfour|, please open an issue on the |PSIfour| GitHub page to; alert the developers, who will be able to add the appropriate code.; Available integrals classes and parameters currently documented at ; `Libint2 C++11 Interface Wiki <https://github.com/evaleev/libint/wiki/using-modern-CPlusPlus-API#create-an-integral-engine>`_. Shell Pairs; ........... To ensure consistency between one- and two-electron terms when screening, and; for efficiency reasons, shell pair lists should be used to iterate over pairs; of Gaussian shells. These lists contain integer pair numbers, corresponding to; the pairs of shells that have sufficient overlap to survive the screening; process. Iterating over these lists is simple:. .. code-block:: cpp. const auto& shell_pairs = Vint->shellpairs();; size_t n_pairs = shell_pairs.size();; for (size_t p = 0; p < n_pairs; ++p) {; auto P = shell_pairs[p].first;; auto Q = shell_pairs[p].second;; // do something with shells P and Q; }. Note that list considers all P,Q pairs if the two basis sets differ, but only; P>=Q if the basis sets are the same; the caller should account for this; restricted summation in the latter case. One Electron Integral Algorithm Overview; ........................................ The following table summarizes which implementation is used; for each type of one electron integral in |PSIfour|. .. _`table:oei_impl_summary`:. .. table:: Algorithms used for One Electron Integrals. +----------------------------+----------------------------+-----------------+--------------------------------------------------------------------+; | Integral | Class | Implementation | Comment |; +============================+==========================",MatchSource.DOCS,doc/sphinxman/source/prog_integrals.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_integrals.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_newcode.rst:1207,Modifiability,plugin,plugins,1207,".. #; .. # @BEGIN LICENSE; .. #; .. # Psi4: an open-source quantum chemistry software package; .. #; .. # Copyright (c) 2007-2023 The Psi4 Developers.; .. #; .. # The copyrights for code used from other parties are included in; .. # the corresponding files.; .. #; .. # This file is part of Psi4.; .. #; .. # Psi4 is free software; you can redistribute it and/or modify; .. # it under the terms of the GNU Lesser General Public License as published by; .. # the Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. _`sec:prog_newcode`:. ================================================; Adding New Code to |PSIfour|; ================================================. .. toctree::; prog_ways_to_add; plugins; prog_full_integration ; proc_py; prog_style_py; prog_style_c; FAQ <prog_faq>. ",MatchSource.DOCS,doc/sphinxman/source/prog_newcode.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_newcode.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_style_c.rst:2838,Energy Efficiency,reduce,reduces,2838,"-----------------------------. Using ``std::make_shared``:. 1. Reduces code verbosity, especially when coupled with ``auto``:. .. code-block:: cpp. // Type information given 3 TIMES!!!; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));. // So much typing...; std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. // Much better!!!!; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. 2. Ensures exception safety and prevents resource leaks. 3. Improves efficiency:. .. code-block:: cpp. // Performs TWO allocations; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));. // Performs ONE allocation; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. *Reference:* Item 21 in `[Effective Modern C++] <https://isbnsearch.org/isbn/9781491903995>`_. .. _`faq:autodecl`:. Prefer ``auto`` to explicit type declarations; ---------------------------------------------. Using ``auto`` reduces and/or avoids:. 1. Verbosity in variable declarations:. .. code-block:: cpp. std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // So much typing...; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // Much better!. 2. Problems with uninitialized variables. auto works like template type; deduction, hence the right-hand side of the declaration needs to have an; initializer:. .. code-block:: cpp. int x1; // fine, but uninitialized :(; auto x2; // WON'T COMPILE!!!; auto x3 = 1; // fine and initialized. 3. Problems with unintended type casts and type mismatches that are hard; to impossible to catch:. .. code-block:: cpp. std::vector<int> v;; // !!! The size of a vector is of type std::vector<int>::size_type and is compiler- AND architecture-DEPENDENT; unsigned sz = v.size(); // might not be correct on some compiler/machines; auto size = v.size(); // size is ALWAYS of the correct type. *Reference:* Items 2 and 5 in `[Effective Modern C++] <https://",MatchSource.DOCS,doc/sphinxman/source/prog_style_c.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_style_c.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_style_c.rst:2878,Modifiability,variab,variable,2878,"d::make_shared``:. 1. Reduces code verbosity, especially when coupled with ``auto``:. .. code-block:: cpp. // Type information given 3 TIMES!!!; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));. // So much typing...; std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. // Much better!!!!; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. 2. Ensures exception safety and prevents resource leaks. 3. Improves efficiency:. .. code-block:: cpp. // Performs TWO allocations; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));. // Performs ONE allocation; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. *Reference:* Item 21 in `[Effective Modern C++] <https://isbnsearch.org/isbn/9781491903995>`_. .. _`faq:autodecl`:. Prefer ``auto`` to explicit type declarations; ---------------------------------------------. Using ``auto`` reduces and/or avoids:. 1. Verbosity in variable declarations:. .. code-block:: cpp. std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // So much typing...; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // Much better!. 2. Problems with uninitialized variables. auto works like template type; deduction, hence the right-hand side of the declaration needs to have an; initializer:. .. code-block:: cpp. int x1; // fine, but uninitialized :(; auto x2; // WON'T COMPILE!!!; auto x3 = 1; // fine and initialized. 3. Problems with unintended type casts and type mismatches that are hard; to impossible to catch:. .. code-block:: cpp. std::vector<int> v;; // !!! The size of a vector is of type std::vector<int>::size_type and is compiler- AND architecture-DEPENDENT; unsigned sz = v.size(); // might not be correct on some compiler/machines; auto size = v.size(); // size is ALWAYS of the correct type. *Reference:* Items 2 and 5 in `[Effective Modern C++] <https://isbnsearch.org/isbn/9781491903995>`_. Mar",MatchSource.DOCS,doc/sphinxman/source/prog_style_c.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_style_c.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_style_c.rst:3132,Modifiability,variab,variables,3132,"o much typing...; std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. // Much better!!!!; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. 2. Ensures exception safety and prevents resource leaks. 3. Improves efficiency:. .. code-block:: cpp. // Performs TWO allocations; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));. // Performs ONE allocation; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. *Reference:* Item 21 in `[Effective Modern C++] <https://isbnsearch.org/isbn/9781491903995>`_. .. _`faq:autodecl`:. Prefer ``auto`` to explicit type declarations; ---------------------------------------------. Using ``auto`` reduces and/or avoids:. 1. Verbosity in variable declarations:. .. code-block:: cpp. std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // So much typing...; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // Much better!. 2. Problems with uninitialized variables. auto works like template type; deduction, hence the right-hand side of the declaration needs to have an; initializer:. .. code-block:: cpp. int x1; // fine, but uninitialized :(; auto x2; // WON'T COMPILE!!!; auto x3 = 1; // fine and initialized. 3. Problems with unintended type casts and type mismatches that are hard; to impossible to catch:. .. code-block:: cpp. std::vector<int> v;; // !!! The size of a vector is of type std::vector<int>::size_type and is compiler- AND architecture-DEPENDENT; unsigned sz = v.size(); // might not be correct on some compiler/machines; auto size = v.size(); // size is ALWAYS of the correct type. *Reference:* Items 2 and 5 in `[Effective Modern C++] <https://isbnsearch.org/isbn/9781491903995>`_. Mark virtual functions in derived classes with override; -------------------------------------------------------. The ``override`` keyword introduced in C++11 is used to mark a function in a; derived class and guarantee that it is overloading ",MatchSource.DOCS,doc/sphinxman/source/prog_style_c.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_style_c.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_style_c.rst:2322,Safety,safe,safety,2322,"he details. If you; want to overload on pointer types and/or use pointer types with templates,; use ``nullptr`` to signal the null pointer. The correct overload/template; parameter will then be deduced. Using ``nullptr`` also makes the code more; readable, especially if ``auto`` is used consistently throughout. *Reference:* Item 8 in `[Effective Modern C++] <https://isbnsearch.org/isbn/9781491903995>`_. .. _`faq:automakeshared`:. Prefer ``std::make_shared`` to direct use of ``new``; ----------------------------------------------------. Using ``std::make_shared``:. 1. Reduces code verbosity, especially when coupled with ``auto``:. .. code-block:: cpp. // Type information given 3 TIMES!!!; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));. // So much typing...; std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. // Much better!!!!; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. 2. Ensures exception safety and prevents resource leaks. 3. Improves efficiency:. .. code-block:: cpp. // Performs TWO allocations; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));. // Performs ONE allocation; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. *Reference:* Item 21 in `[Effective Modern C++] <https://isbnsearch.org/isbn/9781491903995>`_. .. _`faq:autodecl`:. Prefer ``auto`` to explicit type declarations; ---------------------------------------------. Using ``auto`` reduces and/or avoids:. 1. Verbosity in variable declarations:. .. code-block:: cpp. std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // So much typing...; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // Much better!. 2. Problems with uninitialized variables. auto works like template type; deduction, hence the right-hand side of the declaration needs to have an; initializer:. .. code-block:: cpp. int x1; // fine, but uninitialized :(; auto x2;",MatchSource.DOCS,doc/sphinxman/source/prog_style_c.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_style_c.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_style_c.rst:2853,Safety,avoid,avoids,2853,"-----------------------------. Using ``std::make_shared``:. 1. Reduces code verbosity, especially when coupled with ``auto``:. .. code-block:: cpp. // Type information given 3 TIMES!!!; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));. // So much typing...; std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. // Much better!!!!; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. 2. Ensures exception safety and prevents resource leaks. 3. Improves efficiency:. .. code-block:: cpp. // Performs TWO allocations; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));. // Performs ONE allocation; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. *Reference:* Item 21 in `[Effective Modern C++] <https://isbnsearch.org/isbn/9781491903995>`_. .. _`faq:autodecl`:. Prefer ``auto`` to explicit type declarations; ---------------------------------------------. Using ``auto`` reduces and/or avoids:. 1. Verbosity in variable declarations:. .. code-block:: cpp. std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // So much typing...; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // Much better!. 2. Problems with uninitialized variables. auto works like template type; deduction, hence the right-hand side of the declaration needs to have an; initializer:. .. code-block:: cpp. int x1; // fine, but uninitialized :(; auto x2; // WON'T COMPILE!!!; auto x3 = 1; // fine and initialized. 3. Problems with unintended type casts and type mismatches that are hard; to impossible to catch:. .. code-block:: cpp. std::vector<int> v;; // !!! The size of a vector is of type std::vector<int>::size_type and is compiler- AND architecture-DEPENDENT; unsigned sz = v.size(); // might not be correct on some compiler/machines; auto size = v.size(); // size is ALWAYS of the correct type. *Reference:* Items 2 and 5 in `[Effective Modern C++] <https://",MatchSource.DOCS,doc/sphinxman/source/prog_style_c.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_style_c.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_style_c.rst:4748,Usability,guid,guideline,4748,"k:: cpp. std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // So much typing...; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // Much better!. 2. Problems with uninitialized variables. auto works like template type; deduction, hence the right-hand side of the declaration needs to have an; initializer:. .. code-block:: cpp. int x1; // fine, but uninitialized :(; auto x2; // WON'T COMPILE!!!; auto x3 = 1; // fine and initialized. 3. Problems with unintended type casts and type mismatches that are hard; to impossible to catch:. .. code-block:: cpp. std::vector<int> v;; // !!! The size of a vector is of type std::vector<int>::size_type and is compiler- AND architecture-DEPENDENT; unsigned sz = v.size(); // might not be correct on some compiler/machines; auto size = v.size(); // size is ALWAYS of the correct type. *Reference:* Items 2 and 5 in `[Effective Modern C++] <https://isbnsearch.org/isbn/9781491903995>`_. Mark virtual functions in derived classes with override; -------------------------------------------------------. The ``override`` keyword introduced in C++11 is used to mark a function in a; derived class and guarantee that it is overloading a function *with the same; signature* in the base class. This behavior is `checked at compile time; <https://en.cppreference.com/w/cpp/language/override>`_. .. _`faq:printmem`:. Prefer `GiB` for memory printing; --------------------------------. As memory sizes get larger, we should work in giga (requires decimal printing to not round to zero) rather than mega units.; As it's what we're computing anyways, we should work in 1024-based (mebi, gibi, etc. https://en.wikipedia.org/wiki/Gibibyte) rather than 1000-based units.; As it's a unit, put it in brackets.; Note that users can supply MiB, GB, bytes, or whatever; this guideline is for output printing. ::. outfile->Printf("" DFHelper Memory: AOs need %.3f [GiB]; user supplied %.3f [GiB]. "",; (required * 8 / (1024 * 1024 * 1024.0)),. ",MatchSource.DOCS,doc/sphinxman/source/prog_style_c.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_style_c.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_style_py.rst:1398,Usability,clear,clear,1398,".. #; .. # @BEGIN LICENSE; .. #; .. # Psi4: an open-source quantum chemistry software package; .. #; .. # Copyright (c) 2007-2023 The Psi4 Developers.; .. #; .. # The copyrights for code used from other parties are included in; .. # the corresponding files.; .. #; .. # This file is part of Psi4.; .. #; .. # Psi4 is free software; you can redistribute it and/or modify; .. # it under the terms of the GNU Lesser General Public License as published by; .. # the Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:style_python`:. Python Style; ============. .. _`faq:ignoringadvice`:. How to Ignore the Bots; ----------------------. Formatting and analysis bots are great because it takes more effort; to defy them than to accept their criticism. Nevertheless, for code; clarity, they can be honestly wrong, so we need a way to specifically; clear their findings. * Py Formatting (yapf) ``# yapf: disable`` (single line or block) ``# yapf: enable`` (resume). * C++ Formatting (clang-format) ``// clang-format off`` (single line or block) ``// clang-format on`` (resume). * Py Dynamic Analysis (coverage.py) ``# pragma: no cover``. * C++ Dynamic Analysis (gcov) https://stackoverflow.com/a/30078276 untested. * Py Static Analysis (lgtm) ``# lgtm[py/not-named-self]`` (click on the ""?"" to get the ""Query ID""). * C++ Static Analysis (lgtm) ``// lgtm[cpp/wrong-type-format-argument]`` (click on the ""?"" to get the ""Query ID""). ",MatchSource.DOCS,doc/sphinxman/source/prog_style_py.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_style_py.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_style_py.rst:1506,Usability,resume,resume,1506,".. #; .. # @BEGIN LICENSE; .. #; .. # Psi4: an open-source quantum chemistry software package; .. #; .. # Copyright (c) 2007-2023 The Psi4 Developers.; .. #; .. # The copyrights for code used from other parties are included in; .. # the corresponding files.; .. #; .. # This file is part of Psi4.; .. #; .. # Psi4 is free software; you can redistribute it and/or modify; .. # it under the terms of the GNU Lesser General Public License as published by; .. # the Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:style_python`:. Python Style; ============. .. _`faq:ignoringadvice`:. How to Ignore the Bots; ----------------------. Formatting and analysis bots are great because it takes more effort; to defy them than to accept their criticism. Nevertheless, for code; clarity, they can be honestly wrong, so we need a way to specifically; clear their findings. * Py Formatting (yapf) ``# yapf: disable`` (single line or block) ``# yapf: enable`` (resume). * C++ Formatting (clang-format) ``// clang-format off`` (single line or block) ``// clang-format on`` (resume). * Py Dynamic Analysis (coverage.py) ``# pragma: no cover``. * C++ Dynamic Analysis (gcov) https://stackoverflow.com/a/30078276 untested. * Py Static Analysis (lgtm) ``# lgtm[py/not-named-self]`` (click on the ""?"" to get the ""Query ID""). * C++ Static Analysis (lgtm) ``// lgtm[cpp/wrong-type-format-argument]`` (click on the ""?"" to get the ""Query ID""). ",MatchSource.DOCS,doc/sphinxman/source/prog_style_py.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_style_py.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_style_py.rst:1618,Usability,resume,resume,1618,".. #; .. # @BEGIN LICENSE; .. #; .. # Psi4: an open-source quantum chemistry software package; .. #; .. # Copyright (c) 2007-2023 The Psi4 Developers.; .. #; .. # The copyrights for code used from other parties are included in; .. # the corresponding files.; .. #; .. # This file is part of Psi4.; .. #; .. # Psi4 is free software; you can redistribute it and/or modify; .. # it under the terms of the GNU Lesser General Public License as published by; .. # the Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:style_python`:. Python Style; ============. .. _`faq:ignoringadvice`:. How to Ignore the Bots; ----------------------. Formatting and analysis bots are great because it takes more effort; to defy them than to accept their criticism. Nevertheless, for code; clarity, they can be honestly wrong, so we need a way to specifically; clear their findings. * Py Formatting (yapf) ``# yapf: disable`` (single line or block) ``# yapf: enable`` (resume). * C++ Formatting (clang-format) ``// clang-format off`` (single line or block) ``// clang-format on`` (resume). * Py Dynamic Analysis (coverage.py) ``# pragma: no cover``. * C++ Dynamic Analysis (gcov) https://stackoverflow.com/a/30078276 untested. * Py Static Analysis (lgtm) ``# lgtm[py/not-named-self]`` (click on the ""?"" to get the ""Query ID""). * C++ Static Analysis (lgtm) ``// lgtm[cpp/wrong-type-format-argument]`` (click on the ""?"" to get the ""Query ID""). ",MatchSource.DOCS,doc/sphinxman/source/prog_style_py.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_style_py.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_tour.rst:2324,Availability,avail,available,2324," heavy lifting in |PSIfour| is handled by libmints, which can be; found in the :source:`psi4/src/psi4/libmints` directory. New types of one- and; two-electron integral operators should be added here. The Wavefunction class; :source:`psi4/src/psi4/libmints/wavefunction.h` is also found here and is a key; part of the infrastructure. Every energy calculation is performed by a class; that derives from Wavefunction and is accessible as a return value in the; Python layer. The Wavefunction class contains all pertinent calculation; results, such as one-particle densities, molecular orbitals and gradients. Completely new methods; ----------------------. A new method that is not a modification of existing code belongs in its own; folder in :source:`psi4/src/psi4`; see other folders in that exist in that; location for examples of setting up CMake, and make sure that the new folder is; added to :source:`psi4/src/psi4/CMakeLists.txt`. There are also a number of; variables that can be exported to be available to the user, as detailed in; :ref:`sec:psiVariables`. To set these variables, the following member of; Wavefunction should be called::. set_variable(""Variable Name"", variable_value);. The new variable should also be documented in; :source:`doc/sphinxman/source/glossary_psivariables.rst`. There are a; number of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies; -------------------------------. The general philosophy in |PSIfour| is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (:source:`psi4/src/psi4/libfock`) accomplishes. A number of integral; te",MatchSource.DOCS,doc/sphinxman/source/prog_tour.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_tour.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_tour.rst:2805,Availability,avail,available,2805,"pertinent calculation; results, such as one-particle densities, molecular orbitals and gradients. Completely new methods; ----------------------. A new method that is not a modification of existing code belongs in its own; folder in :source:`psi4/src/psi4`; see other folders in that exist in that; location for examples of setting up CMake, and make sure that the new folder is; added to :source:`psi4/src/psi4/CMakeLists.txt`. There are also a number of; variables that can be exported to be available to the user, as detailed in; :ref:`sec:psiVariables`. To set these variables, the following member of; Wavefunction should be called::. set_variable(""Variable Name"", variable_value);. The new variable should also be documented in; :source:`doc/sphinxman/source/glossary_psivariables.rst`. There are a; number of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies; -------------------------------. The general philosophy in |PSIfour| is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (:source:`psi4/src/psi4/libfock`) accomplishes. A number of integral; technologies -- such as integral-direct, disk-based and density fitting -- are; supported in libFock, making them generally available to all elements of the; code that use the generalized Fock matrix strategy. .. _`sec:prog_tour-exposing`:. Exposing C++ code to Python; ---------------------------. The recent push to move sections of the code that are not a bottleneck into the; Python layer requires that the C++ code is callable from Python and that its; results are accessible. The result accessibility is",MatchSource.DOCS,doc/sphinxman/source/prog_tour.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_tour.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_tour.rst:3445,Availability,avail,available,3445,"e exported to be available to the user, as detailed in; :ref:`sec:psiVariables`. To set these variables, the following member of; Wavefunction should be called::. set_variable(""Variable Name"", variable_value);. The new variable should also be documented in; :source:`doc/sphinxman/source/glossary_psivariables.rst`. There are a; number of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies; -------------------------------. The general philosophy in |PSIfour| is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (:source:`psi4/src/psi4/libfock`) accomplishes. A number of integral; technologies -- such as integral-direct, disk-based and density fitting -- are; supported in libFock, making them generally available to all elements of the; code that use the generalized Fock matrix strategy. .. _`sec:prog_tour-exposing`:. Exposing C++ code to Python; ---------------------------. The recent push to move sections of the code that are not a bottleneck into the; Python layer requires that the C++ code is callable from Python and that its; results are accessible. The result accessibility is addressed by populating; the appropriate variables in the Wavefunction object. To make the code; callable from Python, we rely on the excellent `PyBind11 <https://pybind11.readthedocs.io/en/stable/>`_ library; to create the bindings. Existing code to export various |PSIfour| classes can; be found in :source:`psi4/src` in the files whose name begins with `export_`.; The code to export functions that run entire calculations is usually found in; :source:`psi4/src/core.cc`.; ",MatchSource.DOCS,doc/sphinxman/source/prog_tour.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_tour.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_tour.rst:1661,Energy Efficiency,energy,energy,1661,"eral Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:prog_tour`:. ==========================================================; General layout of the core: where new C++ code should live; ==========================================================. New integral operators; ----------------------. Most of the heavy lifting in |PSIfour| is handled by libmints, which can be; found in the :source:`psi4/src/psi4/libmints` directory. New types of one- and; two-electron integral operators should be added here. The Wavefunction class; :source:`psi4/src/psi4/libmints/wavefunction.h` is also found here and is a key; part of the infrastructure. Every energy calculation is performed by a class; that derives from Wavefunction and is accessible as a return value in the; Python layer. The Wavefunction class contains all pertinent calculation; results, such as one-particle densities, molecular orbitals and gradients. Completely new methods; ----------------------. A new method that is not a modification of existing code belongs in its own; folder in :source:`psi4/src/psi4`; see other folders in that exist in that; location for examples of setting up CMake, and make sure that the new folder is; added to :source:`psi4/src/psi4/CMakeLists.txt`. There are also a number of; variables that can be exported to be available to the user, as detailed in; :ref:`sec:psiVariables`. To set these variables, the following member of; Wavefunction should be called::. set_variable(""Variable Name"", variable_value);. The new variable should also be documented in; :source:`doc/sphinxman/source/glossary_psivariables.rst`. There are a; number of different helpers to export various quantities from the wavefunction; to exter",MatchSource.DOCS,doc/sphinxman/source/prog_tour.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_tour.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_tour.rst:2287,Modifiability,variab,variables,2287," heavy lifting in |PSIfour| is handled by libmints, which can be; found in the :source:`psi4/src/psi4/libmints` directory. New types of one- and; two-electron integral operators should be added here. The Wavefunction class; :source:`psi4/src/psi4/libmints/wavefunction.h` is also found here and is a key; part of the infrastructure. Every energy calculation is performed by a class; that derives from Wavefunction and is accessible as a return value in the; Python layer. The Wavefunction class contains all pertinent calculation; results, such as one-particle densities, molecular orbitals and gradients. Completely new methods; ----------------------. A new method that is not a modification of existing code belongs in its own; folder in :source:`psi4/src/psi4`; see other folders in that exist in that; location for examples of setting up CMake, and make sure that the new folder is; added to :source:`psi4/src/psi4/CMakeLists.txt`. There are also a number of; variables that can be exported to be available to the user, as detailed in; :ref:`sec:psiVariables`. To set these variables, the following member of; Wavefunction should be called::. set_variable(""Variable Name"", variable_value);. The new variable should also be documented in; :source:`doc/sphinxman/source/glossary_psivariables.rst`. There are a; number of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies; -------------------------------. The general philosophy in |PSIfour| is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (:source:`psi4/src/psi4/libfock`) accomplishes. A number of integral; te",MatchSource.DOCS,doc/sphinxman/source/prog_tour.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_tour.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_tour.rst:2401,Modifiability,variab,variables,2401,"ints` directory. New types of one- and; two-electron integral operators should be added here. The Wavefunction class; :source:`psi4/src/psi4/libmints/wavefunction.h` is also found here and is a key; part of the infrastructure. Every energy calculation is performed by a class; that derives from Wavefunction and is accessible as a return value in the; Python layer. The Wavefunction class contains all pertinent calculation; results, such as one-particle densities, molecular orbitals and gradients. Completely new methods; ----------------------. A new method that is not a modification of existing code belongs in its own; folder in :source:`psi4/src/psi4`; see other folders in that exist in that; location for examples of setting up CMake, and make sure that the new folder is; added to :source:`psi4/src/psi4/CMakeLists.txt`. There are also a number of; variables that can be exported to be available to the user, as detailed in; :ref:`sec:psiVariables`. To set these variables, the following member of; Wavefunction should be called::. set_variable(""Variable Name"", variable_value);. The new variable should also be documented in; :source:`doc/sphinxman/source/glossary_psivariables.rst`. There are a; number of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies; -------------------------------. The general philosophy in |PSIfour| is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (:source:`psi4/src/psi4/libfock`) accomplishes. A number of integral; technologies -- such as integral-direct, disk-based and density fitting -- are; supported in libFock, makin",MatchSource.DOCS,doc/sphinxman/source/prog_tour.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_tour.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_tour.rst:2526,Modifiability,variab,variable,2526,"4/libmints/wavefunction.h` is also found here and is a key; part of the infrastructure. Every energy calculation is performed by a class; that derives from Wavefunction and is accessible as a return value in the; Python layer. The Wavefunction class contains all pertinent calculation; results, such as one-particle densities, molecular orbitals and gradients. Completely new methods; ----------------------. A new method that is not a modification of existing code belongs in its own; folder in :source:`psi4/src/psi4`; see other folders in that exist in that; location for examples of setting up CMake, and make sure that the new folder is; added to :source:`psi4/src/psi4/CMakeLists.txt`. There are also a number of; variables that can be exported to be available to the user, as detailed in; :ref:`sec:psiVariables`. To set these variables, the following member of; Wavefunction should be called::. set_variable(""Variable Name"", variable_value);. The new variable should also be documented in; :source:`doc/sphinxman/source/glossary_psivariables.rst`. There are a; number of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies; -------------------------------. The general philosophy in |PSIfour| is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (:source:`psi4/src/psi4/libfock`) accomplishes. A number of integral; technologies -- such as integral-direct, disk-based and density fitting -- are; supported in libFock, making them generally available to all elements of the; code that use the generalized Fock matrix strategy. .. _`sec:prog_tour-exposing`:. Expos",MatchSource.DOCS,doc/sphinxman/source/prog_tour.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_tour.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_tour.rst:3872,Modifiability,variab,variables,3872,"e exported to be available to the user, as detailed in; :ref:`sec:psiVariables`. To set these variables, the following member of; Wavefunction should be called::. set_variable(""Variable Name"", variable_value);. The new variable should also be documented in; :source:`doc/sphinxman/source/glossary_psivariables.rst`. There are a; number of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies; -------------------------------. The general philosophy in |PSIfour| is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (:source:`psi4/src/psi4/libfock`) accomplishes. A number of integral; technologies -- such as integral-direct, disk-based and density fitting -- are; supported in libFock, making them generally available to all elements of the; code that use the generalized Fock matrix strategy. .. _`sec:prog_tour-exposing`:. Exposing C++ code to Python; ---------------------------. The recent push to move sections of the code that are not a bottleneck into the; Python layer requires that the C++ code is callable from Python and that its; results are accessible. The result accessibility is addressed by populating; the appropriate variables in the Wavefunction object. To make the code; callable from Python, we rely on the excellent `PyBind11 <https://pybind11.readthedocs.io/en/stable/>`_ library; to create the bindings. Existing code to export various |PSIfour| classes can; be found in :source:`psi4/src` in the files whose name begins with `export_`.; The code to export functions that run entire calculations is usually found in; :source:`psi4/src/core.cc`.; ",MatchSource.DOCS,doc/sphinxman/source/prog_tour.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_tour.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_tour.rst:1683,Performance,perform,performed,1683,"eral Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:prog_tour`:. ==========================================================; General layout of the core: where new C++ code should live; ==========================================================. New integral operators; ----------------------. Most of the heavy lifting in |PSIfour| is handled by libmints, which can be; found in the :source:`psi4/src/psi4/libmints` directory. New types of one- and; two-electron integral operators should be added here. The Wavefunction class; :source:`psi4/src/psi4/libmints/wavefunction.h` is also found here and is a key; part of the infrastructure. Every energy calculation is performed by a class; that derives from Wavefunction and is accessible as a return value in the; Python layer. The Wavefunction class contains all pertinent calculation; results, such as one-particle densities, molecular orbitals and gradients. Completely new methods; ----------------------. A new method that is not a modification of existing code belongs in its own; folder in :source:`psi4/src/psi4`; see other folders in that exist in that; location for examples of setting up CMake, and make sure that the new folder is; added to :source:`psi4/src/psi4/CMakeLists.txt`. There are also a number of; variables that can be exported to be available to the user, as detailed in; :ref:`sec:psiVariables`. To set these variables, the following member of; Wavefunction should be called::. set_variable(""Variable Name"", variable_value);. The new variable should also be documented in; :source:`doc/sphinxman/source/glossary_psivariables.rst`. There are a; number of different helpers to export various quantities from the wavefunction; to exter",MatchSource.DOCS,doc/sphinxman/source/prog_tour.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_tour.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_tour.rst:3680,Performance,bottleneck,bottleneck,3680,"e exported to be available to the user, as detailed in; :ref:`sec:psiVariables`. To set these variables, the following member of; Wavefunction should be called::. set_variable(""Variable Name"", variable_value);. The new variable should also be documented in; :source:`doc/sphinxman/source/glossary_psivariables.rst`. There are a; number of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies; -------------------------------. The general philosophy in |PSIfour| is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (:source:`psi4/src/psi4/libfock`) accomplishes. A number of integral; technologies -- such as integral-direct, disk-based and density fitting -- are; supported in libFock, making them generally available to all elements of the; code that use the generalized Fock matrix strategy. .. _`sec:prog_tour-exposing`:. Exposing C++ code to Python; ---------------------------. The recent push to move sections of the code that are not a bottleneck into the; Python layer requires that the C++ code is callable from Python and that its; results are accessible. The result accessibility is addressed by populating; the appropriate variables in the Wavefunction object. To make the code; callable from Python, we rely on the excellent `PyBind11 <https://pybind11.readthedocs.io/en/stable/>`_ library; to create the bindings. Existing code to export various |PSIfour| classes can; be found in :source:`psi4/src` in the files whose name begins with `export_`.; The code to export functions that run entire calculations is usually found in; :source:`psi4/src/core.cc`.; ",MatchSource.DOCS,doc/sphinxman/source/prog_tour.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_tour.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_tour.rst:1743,Security,access,accessible,1743,"eral Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:prog_tour`:. ==========================================================; General layout of the core: where new C++ code should live; ==========================================================. New integral operators; ----------------------. Most of the heavy lifting in |PSIfour| is handled by libmints, which can be; found in the :source:`psi4/src/psi4/libmints` directory. New types of one- and; two-electron integral operators should be added here. The Wavefunction class; :source:`psi4/src/psi4/libmints/wavefunction.h` is also found here and is a key; part of the infrastructure. Every energy calculation is performed by a class; that derives from Wavefunction and is accessible as a return value in the; Python layer. The Wavefunction class contains all pertinent calculation; results, such as one-particle densities, molecular orbitals and gradients. Completely new methods; ----------------------. A new method that is not a modification of existing code belongs in its own; folder in :source:`psi4/src/psi4`; see other folders in that exist in that; location for examples of setting up CMake, and make sure that the new folder is; added to :source:`psi4/src/psi4/CMakeLists.txt`. There are also a number of; variables that can be exported to be available to the user, as detailed in; :ref:`sec:psiVariables`. To set these variables, the following member of; Wavefunction should be called::. set_variable(""Variable Name"", variable_value);. The new variable should also be documented in; :source:`doc/sphinxman/source/glossary_psivariables.rst`. There are a; number of different helpers to export various quantities from the wavefunction; to exter",MatchSource.DOCS,doc/sphinxman/source/prog_tour.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_tour.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_tour.rst:3791,Security,access,accessible,3791,"e exported to be available to the user, as detailed in; :ref:`sec:psiVariables`. To set these variables, the following member of; Wavefunction should be called::. set_variable(""Variable Name"", variable_value);. The new variable should also be documented in; :source:`doc/sphinxman/source/glossary_psivariables.rst`. There are a; number of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies; -------------------------------. The general philosophy in |PSIfour| is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (:source:`psi4/src/psi4/libfock`) accomplishes. A number of integral; technologies -- such as integral-direct, disk-based and density fitting -- are; supported in libFock, making them generally available to all elements of the; code that use the generalized Fock matrix strategy. .. _`sec:prog_tour-exposing`:. Exposing C++ code to Python; ---------------------------. The recent push to move sections of the code that are not a bottleneck into the; Python layer requires that the C++ code is callable from Python and that its; results are accessible. The result accessibility is addressed by populating; the appropriate variables in the Wavefunction object. To make the code; callable from Python, we rely on the excellent `PyBind11 <https://pybind11.readthedocs.io/en/stable/>`_ library; to create the bindings. Existing code to export various |PSIfour| classes can; be found in :source:`psi4/src` in the files whose name begins with `export_`.; The code to export functions that run entire calculations is usually found in; :source:`psi4/src/core.cc`.; ",MatchSource.DOCS,doc/sphinxman/source/prog_tour.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_tour.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_tour.rst:3814,Security,access,accessibility,3814,"e exported to be available to the user, as detailed in; :ref:`sec:psiVariables`. To set these variables, the following member of; Wavefunction should be called::. set_variable(""Variable Name"", variable_value);. The new variable should also be documented in; :source:`doc/sphinxman/source/glossary_psivariables.rst`. There are a; number of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies; -------------------------------. The general philosophy in |PSIfour| is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (:source:`psi4/src/psi4/libfock`) accomplishes. A number of integral; technologies -- such as integral-direct, disk-based and density fitting -- are; supported in libFock, making them generally available to all elements of the; code that use the generalized Fock matrix strategy. .. _`sec:prog_tour-exposing`:. Exposing C++ code to Python; ---------------------------. The recent push to move sections of the code that are not a bottleneck into the; Python layer requires that the C++ code is callable from Python and that its; results are accessible. The result accessibility is addressed by populating; the appropriate variables in the Wavefunction object. To make the code; callable from Python, we rely on the excellent `PyBind11 <https://pybind11.readthedocs.io/en/stable/>`_ library; to create the bindings. Existing code to export various |PSIfour| classes can; be found in :source:`psi4/src` in the files whose name begins with `export_`.; The code to export functions that run entire calculations is usually found in; :source:`psi4/src/core.cc`.; ",MatchSource.DOCS,doc/sphinxman/source/prog_tour.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_tour.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_version.rst:678,Availability,mainten,maintenance,678,". * Making a release or prerelease. * update all three fields of metadata.py (see below ex); * commit; * on master, make annotated tag starting with v. note the hash.; * run enough of build to make sure tag formatted properly and ""Defining {} version"" sane. # MUST update metadata.py on same commit at which make tag. git tag -a v1.0 d2243ef; git push origin v1.0; git push [remote] [tagname]. do NOT use the GitHub tagging interface - it creates lightweight tags. :source:`psi4/metadata.py`. __version__ = '1.0'; __version_long = '1.0+d2243ef'; __version_upcoming_annotated_v_tag = '1.1a1'. # Example current and upcoming tag pairs; # * '1.0', '1.1a1'; # * '1.0.4', '1.0.5' on maintenance branch 1.0.x; # * '1.1a1', '1.1b1'; # * '1.1rc2', '1.1'; # * '1.1', '1.2'. ",MatchSource.DOCS,doc/sphinxman/source/prog_version.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_version.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_version.rst:13,Deployability,release,release,13,". * Making a release or prerelease. * update all three fields of metadata.py (see below ex); * commit; * on master, make annotated tag starting with v. note the hash.; * run enough of build to make sure tag formatted properly and ""Defining {} version"" sane. # MUST update metadata.py on same commit at which make tag. git tag -a v1.0 d2243ef; git push origin v1.0; git push [remote] [tagname]. do NOT use the GitHub tagging interface - it creates lightweight tags. :source:`psi4/metadata.py`. __version__ = '1.0'; __version_long = '1.0+d2243ef'; __version_upcoming_annotated_v_tag = '1.1a1'. # Example current and upcoming tag pairs; # * '1.0', '1.1a1'; # * '1.0.4', '1.0.5' on maintenance branch 1.0.x; # * '1.1a1', '1.1b1'; # * '1.1rc2', '1.1'; # * '1.1', '1.2'. ",MatchSource.DOCS,doc/sphinxman/source/prog_version.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_version.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_version.rst:38,Deployability,update,update,38,". * Making a release or prerelease. * update all three fields of metadata.py (see below ex); * commit; * on master, make annotated tag starting with v. note the hash.; * run enough of build to make sure tag formatted properly and ""Defining {} version"" sane. # MUST update metadata.py on same commit at which make tag. git tag -a v1.0 d2243ef; git push origin v1.0; git push [remote] [tagname]. do NOT use the GitHub tagging interface - it creates lightweight tags. :source:`psi4/metadata.py`. __version__ = '1.0'; __version_long = '1.0+d2243ef'; __version_upcoming_annotated_v_tag = '1.1a1'. # Example current and upcoming tag pairs; # * '1.0', '1.1a1'; # * '1.0.4', '1.0.5' on maintenance branch 1.0.x; # * '1.1a1', '1.1b1'; # * '1.1rc2', '1.1'; # * '1.1', '1.2'. ",MatchSource.DOCS,doc/sphinxman/source/prog_version.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_version.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_version.rst:265,Deployability,update,update,265,". * Making a release or prerelease. * update all three fields of metadata.py (see below ex); * commit; * on master, make annotated tag starting with v. note the hash.; * run enough of build to make sure tag formatted properly and ""Defining {} version"" sane. # MUST update metadata.py on same commit at which make tag. git tag -a v1.0 d2243ef; git push origin v1.0; git push [remote] [tagname]. do NOT use the GitHub tagging interface - it creates lightweight tags. :source:`psi4/metadata.py`. __version__ = '1.0'; __version_long = '1.0+d2243ef'; __version_upcoming_annotated_v_tag = '1.1a1'. # Example current and upcoming tag pairs; # * '1.0', '1.1a1'; # * '1.0.4', '1.0.5' on maintenance branch 1.0.x; # * '1.1a1', '1.1b1'; # * '1.1rc2', '1.1'; # * '1.1', '1.2'. ",MatchSource.DOCS,doc/sphinxman/source/prog_version.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_version.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_version.rst:424,Integrability,interface,interface,424,". * Making a release or prerelease. * update all three fields of metadata.py (see below ex); * commit; * on master, make annotated tag starting with v. note the hash.; * run enough of build to make sure tag formatted properly and ""Defining {} version"" sane. # MUST update metadata.py on same commit at which make tag. git tag -a v1.0 d2243ef; git push origin v1.0; git push [remote] [tagname]. do NOT use the GitHub tagging interface - it creates lightweight tags. :source:`psi4/metadata.py`. __version__ = '1.0'; __version_long = '1.0+d2243ef'; __version_upcoming_annotated_v_tag = '1.1a1'. # Example current and upcoming tag pairs; # * '1.0', '1.1a1'; # * '1.0.4', '1.0.5' on maintenance branch 1.0.x; # * '1.1a1', '1.1b1'; # * '1.1rc2', '1.1'; # * '1.1', '1.2'. ",MatchSource.DOCS,doc/sphinxman/source/prog_version.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_version.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_version.rst:161,Security,hash,hash,161,". * Making a release or prerelease. * update all three fields of metadata.py (see below ex); * commit; * on master, make annotated tag starting with v. note the hash.; * run enough of build to make sure tag formatted properly and ""Defining {} version"" sane. # MUST update metadata.py on same commit at which make tag. git tag -a v1.0 d2243ef; git push origin v1.0; git push [remote] [tagname]. do NOT use the GitHub tagging interface - it creates lightweight tags. :source:`psi4/metadata.py`. __version__ = '1.0'; __version_long = '1.0+d2243ef'; __version_upcoming_annotated_v_tag = '1.1a1'. # Example current and upcoming tag pairs; # * '1.0', '1.1a1'; # * '1.0.4', '1.0.5' on maintenance branch 1.0.x; # * '1.1a1', '1.1b1'; # * '1.1rc2', '1.1'; # * '1.1', '1.2'. ",MatchSource.DOCS,doc/sphinxman/source/prog_version.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_version.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:2343,Availability,avail,available,2343,"eatured electronic structure programs are large and complex. However,; the |PSIfour| ecosystem provides a path for easier and more rapid development; of new features. The earliest versions of |PSIfour| were written by merging; individual executables that performed specific tasks into a unified C++; executable. By linking this C++ executable against the Python interpreter, the; individual modules could be called in any sequence, enabling a very diverse; range of tasks to be accomplished within a given input. Although Python-driven; model allowed for great flexibility from a user's perspective, programming was; still relatively difficult because it required modifications to be made in C++; code. Since those early days, the code has undergone some important structural; changes that have greatly simplified the development workflow. These changes; were motivated by the realization that only a few bottlenecks exist in a typical; calculation; by focusing on optimized C++ implementations of these bottlenecks; and making these C++ functions available in Python, most of the code to implement; the overall calculation can be written in simpler Python code. Python is far; better suited to management tasks such as directory navigation and retrieval,; making it a natural choice for overall calculation layout than C++. With the; emergence of `NumPy <https://numpy.org/>`_ as a standard tool for executing almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. .. _`sec:prog_psi4numpy`:. Rapid initial development using Psi4NumPy; -----------------------------------------. The `Psi4NumPy <https://github.com/psi4/psi4numpy>`_ project [Smith:2018:3504]_ is the recommended; mechanism for developing and prototyping new methods in Psi4. Because; `NumPy <https://numpy.org/>`_ provides such a rich set of features for efficient l",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:3975,Availability,avail,available,3975,"ent using Psi4NumPy; -----------------------------------------. The `Psi4NumPy <https://github.com/psi4/psi4numpy>`_ project [Smith:2018:3504]_ is the recommended; mechanism for developing and prototyping new methods in Psi4. Because; `NumPy <https://numpy.org/>`_ provides such a rich set of features for efficient linear; algebra, Fourier transforms, and general tensor manipulations, a massive number; of methods can be easily implemented very easily using that library. To; facilitate this workflow, |PSIfour| exports key quantities such as integrals,; densities and molecular orbitals in NumPy format. From this point, the; programmer can simply call the appropriate |PSIfour| functions to compute the; desired input quantities, retrieve them in NumPy format, and then write the; remaining code using standard Python and/or NumPy syntax. This approach does; not require any recompilation of code, resulting in a particularly facile; development workflow. Detailed examples and tutorials are available in the; `Psi4NumPy <https://github.com/psi4/psi4numpy>`_ repository. .. _`sec:prog_plugins`:. Avoiding the need to modify Psi4, using plugins; -----------------------------------------------. In the early days when |PSIfour| was still primarily a C++ code, development; was very cumbersome due to a lengthy build process. To expedite development, a; plugin system was developed. This plugin machinery allows developers to access; the classes defined in the innards of |PSIfour|, with only the small plugin; code requiring recompilation during development. The resulting lightweight; code can be maintained and distributed independently of |PSIfour|, making this; a good strategy for development, especially in cases where tighter integration; of the new code with existing |PSIfour| machinery is required than that; afforded by the Numpy based strategy outlined in the :ref:`sec:prog_psi4numpy`; section. For details about how to write these plugins, see the; :ref:`sec:plugins` section. .. _`s",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:5336,Availability,down,downloads,5336,"machinery allows developers to access; the classes defined in the innards of |PSIfour|, with only the small plugin; code requiring recompilation during development. The resulting lightweight; code can be maintained and distributed independently of |PSIfour|, making this; a good strategy for development, especially in cases where tighter integration; of the new code with existing |PSIfour| machinery is required than that; afforded by the Numpy based strategy outlined in the :ref:`sec:prog_psi4numpy`; section. For details about how to write these plugins, see the; :ref:`sec:plugins` section. .. _`sec:prog_fullintegration`:. Incorporating code into |PSIfour|; ---------------------------------. For features to be incorporated fully into the |PSIfour| ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let's; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in |PSIfour| already to perform tasks like these that are; required, *e.g.*, for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in |PSIfo",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:6358,Availability,avail,available,6358," from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in |PSIfour| already to perform tasks like these that are; required, *e.g.*, for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in |PSIfour| and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in :ref:`sec:prog_tour-exposing`. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths. A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out *embarrassingly parallel* workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated. In SCF, we have a number of sources of external embe",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:6444,Availability,avail,available,6444," from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in |PSIfour| already to perform tasks like these that are; required, *e.g.*, for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in |PSIfour| and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in :ref:`sec:prog_tour-exposing`. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths. A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out *embarrassingly parallel* workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated. In SCF, we have a number of sources of external embe",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:4715,Deployability,integrat,integration,4715,"etrieve them in NumPy format, and then write the; remaining code using standard Python and/or NumPy syntax. This approach does; not require any recompilation of code, resulting in a particularly facile; development workflow. Detailed examples and tutorials are available in the; `Psi4NumPy <https://github.com/psi4/psi4numpy>`_ repository. .. _`sec:prog_plugins`:. Avoiding the need to modify Psi4, using plugins; -----------------------------------------------. In the early days when |PSIfour| was still primarily a C++ code, development; was very cumbersome due to a lengthy build process. To expedite development, a; plugin system was developed. This plugin machinery allows developers to access; the classes defined in the innards of |PSIfour|, with only the small plugin; code requiring recompilation during development. The resulting lightweight; code can be maintained and distributed independently of |PSIfour|, making this; a good strategy for development, especially in cases where tighter integration; of the new code with existing |PSIfour| machinery is required than that; afforded by the Numpy based strategy outlined in the :ref:`sec:prog_psi4numpy`; section. For details about how to write these plugins, see the; :ref:`sec:plugins` section. .. _`sec:prog_fullintegration`:. Incorporating code into |PSIfour|; ---------------------------------. For features to be incorporated fully into the |PSIfour| ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let's; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present i",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:2741,Energy Efficiency,efficient,efficiently,2741,"ven input. Although Python-driven; model allowed for great flexibility from a user's perspective, programming was; still relatively difficult because it required modifications to be made in C++; code. Since those early days, the code has undergone some important structural; changes that have greatly simplified the development workflow. These changes; were motivated by the realization that only a few bottlenecks exist in a typical; calculation; by focusing on optimized C++ implementations of these bottlenecks; and making these C++ functions available in Python, most of the code to implement; the overall calculation can be written in simpler Python code. Python is far; better suited to management tasks such as directory navigation and retrieval,; making it a natural choice for overall calculation layout than C++. With the; emergence of `NumPy <https://numpy.org/>`_ as a standard tool for executing almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. .. _`sec:prog_psi4numpy`:. Rapid initial development using Psi4NumPy; -----------------------------------------. The `Psi4NumPy <https://github.com/psi4/psi4numpy>`_ project [Smith:2018:3504]_ is the recommended; mechanism for developing and prototyping new methods in Psi4. Because; `NumPy <https://numpy.org/>`_ provides such a rich set of features for efficient linear; algebra, Fourier transforms, and general tensor manipulations, a massive number; of methods can be easily implemented very easily using that library. To; facilitate this workflow, |PSIfour| exports key quantities such as integrals,; densities and molecular orbitals in NumPy format. From this point, the; programmer can simply call the appropriate |PSIfour| functions to compute the; desired input quantities, retrieve them in NumPy format, and then write the; remaining code using standard Pyt",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:3285,Energy Efficiency,efficient,efficient,3285,"vailable in Python, most of the code to implement; the overall calculation can be written in simpler Python code. Python is far; better suited to management tasks such as directory navigation and retrieval,; making it a natural choice for overall calculation layout than C++. With the; emergence of `NumPy <https://numpy.org/>`_ as a standard tool for executing almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. .. _`sec:prog_psi4numpy`:. Rapid initial development using Psi4NumPy; -----------------------------------------. The `Psi4NumPy <https://github.com/psi4/psi4numpy>`_ project [Smith:2018:3504]_ is the recommended; mechanism for developing and prototyping new methods in Psi4. Because; `NumPy <https://numpy.org/>`_ provides such a rich set of features for efficient linear; algebra, Fourier transforms, and general tensor manipulations, a massive number; of methods can be easily implemented very easily using that library. To; facilitate this workflow, |PSIfour| exports key quantities such as integrals,; densities and molecular orbitals in NumPy format. From this point, the; programmer can simply call the appropriate |PSIfour| functions to compute the; desired input quantities, retrieve them in NumPy format, and then write the; remaining code using standard Python and/or NumPy syntax. This approach does; not require any recompilation of code, resulting in a particularly facile; development workflow. Detailed examples and tutorials are available in the; `Psi4NumPy <https://github.com/psi4/psi4numpy>`_ repository. .. _`sec:prog_plugins`:. Avoiding the need to modify Psi4, using plugins; -----------------------------------------------. In the early days when |PSIfour| was still primarily a C++ code, development; was very cumbersome due to a lengthy build process. To expedite development, a; plugin sy",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:6863,Energy Efficiency,energy,energy,6863,"ifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in |PSIfour| already to perform tasks like these that are; required, *e.g.*, for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in |PSIfour| and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in :ref:`sec:prog_tour-exposing`. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths. A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out *embarrassingly parallel* workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated. In SCF, we have a number of sources of external embedding potentials that could; enter the calculation. Allowing Python to handle only the details of driving; the SCF iterations, such as external potentials and convergence acceleration; methods, but deferring to C++ to do the heavy lifting for building and; diagonalizing the Fock matrix also takes advantage of the two languages'; strengths and improves maintainability of the code.; ",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:7034,Energy Efficiency,energy,energy,7034,"ifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in |PSIfour| already to perform tasks like these that are; required, *e.g.*, for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in |PSIfour| and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in :ref:`sec:prog_tour-exposing`. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths. A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out *embarrassingly parallel* workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated. In SCF, we have a number of sources of external embedding potentials that could; enter the calculation. Allowing Python to handle only the details of driving; the SCF iterations, such as external potentials and convergence acceleration; methods, but deferring to C++ to do the heavy lifting for building and; diagonalizing the Fock matrix also takes advantage of the two languages'; strengths and improves maintainability of the code.; ",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:7265,Energy Efficiency,energy,energy,7265,"ifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in |PSIfour| already to perform tasks like these that are; required, *e.g.*, for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in |PSIfour| and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in :ref:`sec:prog_tour-exposing`. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths. A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out *embarrassingly parallel* workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated. In SCF, we have a number of sources of external embedding potentials that could; enter the calculation. Allowing Python to handle only the details of driving; the SCF iterations, such as external potentials and convergence acceleration; methods, but deferring to C++ to do the heavy lifting for building and; diagonalizing the Fock matrix also takes advantage of the two languages'; strengths and improves maintainability of the code.; ",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:4715,Integrability,integrat,integration,4715,"etrieve them in NumPy format, and then write the; remaining code using standard Python and/or NumPy syntax. This approach does; not require any recompilation of code, resulting in a particularly facile; development workflow. Detailed examples and tutorials are available in the; `Psi4NumPy <https://github.com/psi4/psi4numpy>`_ repository. .. _`sec:prog_plugins`:. Avoiding the need to modify Psi4, using plugins; -----------------------------------------------. In the early days when |PSIfour| was still primarily a C++ code, development; was very cumbersome due to a lengthy build process. To expedite development, a; plugin system was developed. This plugin machinery allows developers to access; the classes defined in the innards of |PSIfour|, with only the small plugin; code requiring recompilation during development. The resulting lightweight; code can be maintained and distributed independently of |PSIfour|, making this; a good strategy for development, especially in cases where tighter integration; of the new code with existing |PSIfour| machinery is required than that; afforded by the Numpy based strategy outlined in the :ref:`sec:prog_psi4numpy`; section. For details about how to write these plugins, see the; :ref:`sec:plugins` section. .. _`sec:prog_fullintegration`:. Incorporating code into |PSIfour|; ---------------------------------. For features to be incorporated fully into the |PSIfour| ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let's; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present i",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:5165,Integrability,rout,routines,5165,"-------------------------------------------. In the early days when |PSIfour| was still primarily a C++ code, development; was very cumbersome due to a lengthy build process. To expedite development, a; plugin system was developed. This plugin machinery allows developers to access; the classes defined in the innards of |PSIfour|, with only the small plugin; code requiring recompilation during development. The resulting lightweight; code can be maintained and distributed independently of |PSIfour|, making this; a good strategy for development, especially in cases where tighter integration; of the new code with existing |PSIfour| machinery is required than that; afforded by the Numpy based strategy outlined in the :ref:`sec:prog_psi4numpy`; section. For details about how to write these plugins, see the; :ref:`sec:plugins` section. .. _`sec:prog_fullintegration`:. Incorporating code into |PSIfour|; ---------------------------------. For features to be incorporated fully into the |PSIfour| ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let's; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in |PSIfour| already to perf",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:5697,Integrability,rout,routines,5697,"ere tighter integration; of the new code with existing |PSIfour| machinery is required than that; afforded by the Numpy based strategy outlined in the :ref:`sec:prog_psi4numpy`; section. For details about how to write these plugins, see the; :ref:`sec:plugins` section. .. _`sec:prog_fullintegration`:. Incorporating code into |PSIfour|; ---------------------------------. For features to be incorporated fully into the |PSIfour| ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let's; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in |PSIfour| already to perform tasks like these that are; required, *e.g.*, for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in |PSIfour| and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in :ref:`sec:prog_tour-exposing`. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the wo",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:6038,Integrability,rout,routines,6038,"features to be incorporated fully into the |PSIfour| ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let's; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in |PSIfour| already to perform tasks like these that are; required, *e.g.*, for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in |PSIfour| and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in :ref:`sec:prog_tour-exposing`. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths. A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work i",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:6349,Integrability,rout,routines,6349," from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in |PSIfour| already to perform tasks like these that are; required, *e.g.*, for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in |PSIfour| and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in :ref:`sec:prog_tour-exposing`. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths. A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out *embarrassingly parallel* workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated. In SCF, we have a number of sources of external embe",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:4119,Modifiability,plugin,plugins,4119,"he recommended; mechanism for developing and prototyping new methods in Psi4. Because; `NumPy <https://numpy.org/>`_ provides such a rich set of features for efficient linear; algebra, Fourier transforms, and general tensor manipulations, a massive number; of methods can be easily implemented very easily using that library. To; facilitate this workflow, |PSIfour| exports key quantities such as integrals,; densities and molecular orbitals in NumPy format. From this point, the; programmer can simply call the appropriate |PSIfour| functions to compute the; desired input quantities, retrieve them in NumPy format, and then write the; remaining code using standard Python and/or NumPy syntax. This approach does; not require any recompilation of code, resulting in a particularly facile; development workflow. Detailed examples and tutorials are available in the; `Psi4NumPy <https://github.com/psi4/psi4numpy>`_ repository. .. _`sec:prog_plugins`:. Avoiding the need to modify Psi4, using plugins; -----------------------------------------------. In the early days when |PSIfour| was still primarily a C++ code, development; was very cumbersome due to a lengthy build process. To expedite development, a; plugin system was developed. This plugin machinery allows developers to access; the classes defined in the innards of |PSIfour|, with only the small plugin; code requiring recompilation during development. The resulting lightweight; code can be maintained and distributed independently of |PSIfour|, making this; a good strategy for development, especially in cases where tighter integration; of the new code with existing |PSIfour| machinery is required than that; afforded by the Numpy based strategy outlined in the :ref:`sec:prog_psi4numpy`; section. For details about how to write these plugins, see the; :ref:`sec:plugins` section. .. _`sec:prog_fullintegration`:. Incorporating code into |PSIfour|; ---------------------------------. For features to be incorporated fully into the |PSI",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:4335,Modifiability,plugin,plugin,4335,"d general tensor manipulations, a massive number; of methods can be easily implemented very easily using that library. To; facilitate this workflow, |PSIfour| exports key quantities such as integrals,; densities and molecular orbitals in NumPy format. From this point, the; programmer can simply call the appropriate |PSIfour| functions to compute the; desired input quantities, retrieve them in NumPy format, and then write the; remaining code using standard Python and/or NumPy syntax. This approach does; not require any recompilation of code, resulting in a particularly facile; development workflow. Detailed examples and tutorials are available in the; `Psi4NumPy <https://github.com/psi4/psi4numpy>`_ repository. .. _`sec:prog_plugins`:. Avoiding the need to modify Psi4, using plugins; -----------------------------------------------. In the early days when |PSIfour| was still primarily a C++ code, development; was very cumbersome due to a lengthy build process. To expedite development, a; plugin system was developed. This plugin machinery allows developers to access; the classes defined in the innards of |PSIfour|, with only the small plugin; code requiring recompilation during development. The resulting lightweight; code can be maintained and distributed independently of |PSIfour|, making this; a good strategy for development, especially in cases where tighter integration; of the new code with existing |PSIfour| machinery is required than that; afforded by the Numpy based strategy outlined in the :ref:`sec:prog_psi4numpy`; section. For details about how to write these plugins, see the; :ref:`sec:plugins` section. .. _`sec:prog_fullintegration`:. Incorporating code into |PSIfour|; ---------------------------------. For features to be incorporated fully into the |PSIfour| ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let's; consider a new feature that",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:4369,Modifiability,plugin,plugin,4369,". To; facilitate this workflow, |PSIfour| exports key quantities such as integrals,; densities and molecular orbitals in NumPy format. From this point, the; programmer can simply call the appropriate |PSIfour| functions to compute the; desired input quantities, retrieve them in NumPy format, and then write the; remaining code using standard Python and/or NumPy syntax. This approach does; not require any recompilation of code, resulting in a particularly facile; development workflow. Detailed examples and tutorials are available in the; `Psi4NumPy <https://github.com/psi4/psi4numpy>`_ repository. .. _`sec:prog_plugins`:. Avoiding the need to modify Psi4, using plugins; -----------------------------------------------. In the early days when |PSIfour| was still primarily a C++ code, development; was very cumbersome due to a lengthy build process. To expedite development, a; plugin system was developed. This plugin machinery allows developers to access; the classes defined in the innards of |PSIfour|, with only the small plugin; code requiring recompilation during development. The resulting lightweight; code can be maintained and distributed independently of |PSIfour|, making this; a good strategy for development, especially in cases where tighter integration; of the new code with existing |PSIfour| machinery is required than that; afforded by the Numpy based strategy outlined in the :ref:`sec:prog_psi4numpy`; section. For details about how to write these plugins, see the; :ref:`sec:plugins` section. .. _`sec:prog_fullintegration`:. Incorporating code into |PSIfour|; ---------------------------------. For features to be incorporated fully into the |PSIfour| ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let's; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:4484,Modifiability,plugin,plugin,4484,". To; facilitate this workflow, |PSIfour| exports key quantities such as integrals,; densities and molecular orbitals in NumPy format. From this point, the; programmer can simply call the appropriate |PSIfour| functions to compute the; desired input quantities, retrieve them in NumPy format, and then write the; remaining code using standard Python and/or NumPy syntax. This approach does; not require any recompilation of code, resulting in a particularly facile; development workflow. Detailed examples and tutorials are available in the; `Psi4NumPy <https://github.com/psi4/psi4numpy>`_ repository. .. _`sec:prog_plugins`:. Avoiding the need to modify Psi4, using plugins; -----------------------------------------------. In the early days when |PSIfour| was still primarily a C++ code, development; was very cumbersome due to a lengthy build process. To expedite development, a; plugin system was developed. This plugin machinery allows developers to access; the classes defined in the innards of |PSIfour|, with only the small plugin; code requiring recompilation during development. The resulting lightweight; code can be maintained and distributed independently of |PSIfour|, making this; a good strategy for development, especially in cases where tighter integration; of the new code with existing |PSIfour| machinery is required than that; afforded by the Numpy based strategy outlined in the :ref:`sec:prog_psi4numpy`; section. For details about how to write these plugins, see the; :ref:`sec:plugins` section. .. _`sec:prog_fullintegration`:. Incorporating code into |PSIfour|; ---------------------------------. For features to be incorporated fully into the |PSIfour| ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let's; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:4927,Modifiability,plugin,plugins,4927,"orkflow. Detailed examples and tutorials are available in the; `Psi4NumPy <https://github.com/psi4/psi4numpy>`_ repository. .. _`sec:prog_plugins`:. Avoiding the need to modify Psi4, using plugins; -----------------------------------------------. In the early days when |PSIfour| was still primarily a C++ code, development; was very cumbersome due to a lengthy build process. To expedite development, a; plugin system was developed. This plugin machinery allows developers to access; the classes defined in the innards of |PSIfour|, with only the small plugin; code requiring recompilation during development. The resulting lightweight; code can be maintained and distributed independently of |PSIfour|, making this; a good strategy for development, especially in cases where tighter integration; of the new code with existing |PSIfour| machinery is required than that; afforded by the Numpy based strategy outlined in the :ref:`sec:prog_psi4numpy`; section. For details about how to write these plugins, see the; :ref:`sec:plugins` section. .. _`sec:prog_fullintegration`:. Incorporating code into |PSIfour|; ---------------------------------. For features to be incorporated fully into the |PSIfour| ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let's; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storag",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:4955,Modifiability,plugin,plugins,4955,"orkflow. Detailed examples and tutorials are available in the; `Psi4NumPy <https://github.com/psi4/psi4numpy>`_ repository. .. _`sec:prog_plugins`:. Avoiding the need to modify Psi4, using plugins; -----------------------------------------------. In the early days when |PSIfour| was still primarily a C++ code, development; was very cumbersome due to a lengthy build process. To expedite development, a; plugin system was developed. This plugin machinery allows developers to access; the classes defined in the innards of |PSIfour|, with only the small plugin; code requiring recompilation during development. The resulting lightweight; code can be maintained and distributed independently of |PSIfour|, making this; a good strategy for development, especially in cases where tighter integration; of the new code with existing |PSIfour| machinery is required than that; afforded by the Numpy based strategy outlined in the :ref:`sec:prog_psi4numpy`; section. For details about how to write these plugins, see the; :ref:`sec:plugins` section. .. _`sec:prog_fullintegration`:. Incorporating code into |PSIfour|; ---------------------------------. For features to be incorporated fully into the |PSIfour| ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let's; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storag",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:7710,Modifiability,maintainab,maintainability,7710,"ifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in |PSIfour| already to perform tasks like these that are; required, *e.g.*, for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in |PSIfour| and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in :ref:`sec:prog_tour-exposing`. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths. A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out *embarrassingly parallel* workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated. In SCF, we have a number of sources of external embedding potentials that could; enter the calculation. Allowing Python to handle only the details of driving; the SCF iterations, such as external potentials and convergence acceleration; methods, but deferring to C++ to do the heavy lifting for building and; diagonalizing the Fock matrix also takes advantage of the two languages'; strengths and improves maintainability of the code.; ",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:1550,Performance,perform,performed,1550," the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. _`sec:prog_ways_to_add`:. ======================================================; Ways to Add Code: Psi4NumPy, Plugins, Full Integration ; ======================================================. Easier and more rapid development; ---------------------------------. Fully-featured electronic structure programs are large and complex. However,; the |PSIfour| ecosystem provides a path for easier and more rapid development; of new features. The earliest versions of |PSIfour| were written by merging; individual executables that performed specific tasks into a unified C++; executable. By linking this C++ executable against the Python interpreter, the; individual modules could be called in any sequence, enabling a very diverse; range of tasks to be accomplished within a given input. Although Python-driven; model allowed for great flexibility from a user's perspective, programming was; still relatively difficult because it required modifications to be made in C++; code. Since those early days, the code has undergone some important structural; changes that have greatly simplified the development workflow. These changes; were motivated by the realization that only a few bottlenecks exist in a typical; calculation; by focusing on optimized C++ implementations of these bottlenecks; and making these C++ functions available in Python, most of the code to implement; the overall calculation can be written in simpler Python code. Python is far; better suited to management tasks such as directory navigatio",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:2200,Performance,bottleneck,bottlenecks,2200,"eatured electronic structure programs are large and complex. However,; the |PSIfour| ecosystem provides a path for easier and more rapid development; of new features. The earliest versions of |PSIfour| were written by merging; individual executables that performed specific tasks into a unified C++; executable. By linking this C++ executable against the Python interpreter, the; individual modules could be called in any sequence, enabling a very diverse; range of tasks to be accomplished within a given input. Although Python-driven; model allowed for great flexibility from a user's perspective, programming was; still relatively difficult because it required modifications to be made in C++; code. Since those early days, the code has undergone some important structural; changes that have greatly simplified the development workflow. These changes; were motivated by the realization that only a few bottlenecks exist in a typical; calculation; by focusing on optimized C++ implementations of these bottlenecks; and making these C++ functions available in Python, most of the code to implement; the overall calculation can be written in simpler Python code. Python is far; better suited to management tasks such as directory navigation and retrieval,; making it a natural choice for overall calculation layout than C++. With the; emergence of `NumPy <https://numpy.org/>`_ as a standard tool for executing almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. .. _`sec:prog_psi4numpy`:. Rapid initial development using Psi4NumPy; -----------------------------------------. The `Psi4NumPy <https://github.com/psi4/psi4numpy>`_ project [Smith:2018:3504]_ is the recommended; mechanism for developing and prototyping new methods in Psi4. Because; `NumPy <https://numpy.org/>`_ provides such a rich set of features for efficient l",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:2260,Performance,optimiz,optimized,2260,"eatured electronic structure programs are large and complex. However,; the |PSIfour| ecosystem provides a path for easier and more rapid development; of new features. The earliest versions of |PSIfour| were written by merging; individual executables that performed specific tasks into a unified C++; executable. By linking this C++ executable against the Python interpreter, the; individual modules could be called in any sequence, enabling a very diverse; range of tasks to be accomplished within a given input. Although Python-driven; model allowed for great flexibility from a user's perspective, programming was; still relatively difficult because it required modifications to be made in C++; code. Since those early days, the code has undergone some important structural; changes that have greatly simplified the development workflow. These changes; were motivated by the realization that only a few bottlenecks exist in a typical; calculation; by focusing on optimized C++ implementations of these bottlenecks; and making these C++ functions available in Python, most of the code to implement; the overall calculation can be written in simpler Python code. Python is far; better suited to management tasks such as directory navigation and retrieval,; making it a natural choice for overall calculation layout than C++. With the; emergence of `NumPy <https://numpy.org/>`_ as a standard tool for executing almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. .. _`sec:prog_psi4numpy`:. Rapid initial development using Psi4NumPy; -----------------------------------------. The `Psi4NumPy <https://github.com/psi4/psi4numpy>`_ project [Smith:2018:3504]_ is the recommended; mechanism for developing and prototyping new methods in Psi4. Because; `NumPy <https://numpy.org/>`_ provides such a rich set of features for efficient l",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:2299,Performance,bottleneck,bottlenecks,2299,"eatured electronic structure programs are large and complex. However,; the |PSIfour| ecosystem provides a path for easier and more rapid development; of new features. The earliest versions of |PSIfour| were written by merging; individual executables that performed specific tasks into a unified C++; executable. By linking this C++ executable against the Python interpreter, the; individual modules could be called in any sequence, enabling a very diverse; range of tasks to be accomplished within a given input. Although Python-driven; model allowed for great flexibility from a user's perspective, programming was; still relatively difficult because it required modifications to be made in C++; code. Since those early days, the code has undergone some important structural; changes that have greatly simplified the development workflow. These changes; were motivated by the realization that only a few bottlenecks exist in a typical; calculation; by focusing on optimized C++ implementations of these bottlenecks; and making these C++ functions available in Python, most of the code to implement; the overall calculation can be written in simpler Python code. Python is far; better suited to management tasks such as directory navigation and retrieval,; making it a natural choice for overall calculation layout than C++. With the; emergence of `NumPy <https://numpy.org/>`_ as a standard tool for executing almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. .. _`sec:prog_psi4numpy`:. Rapid initial development using Psi4NumPy; -----------------------------------------. The `Psi4NumPy <https://github.com/psi4/psi4numpy>`_ project [Smith:2018:3504]_ is the recommended; mechanism for developing and prototyping new methods in Psi4. Because; `NumPy <https://numpy.org/>`_ provides such a rich set of features for efficient l",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:5390,Performance,perform,performs,5390,"machinery allows developers to access; the classes defined in the innards of |PSIfour|, with only the small plugin; code requiring recompilation during development. The resulting lightweight; code can be maintained and distributed independently of |PSIfour|, making this; a good strategy for development, especially in cases where tighter integration; of the new code with existing |PSIfour| machinery is required than that; afforded by the Numpy based strategy outlined in the :ref:`sec:prog_psi4numpy`; section. For details about how to write these plugins, see the; :ref:`sec:plugins` section. .. _`sec:prog_fullintegration`:. Incorporating code into |PSIfour|; ---------------------------------. For features to be incorporated fully into the |PSIfour| ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let's; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in |PSIfour| already to perform tasks like these that are; required, *e.g.*, for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in |PSIfo",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:6128,Performance,perform,perform,6128,"features to be incorporated fully into the |PSIfour| ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let's; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in |PSIfour| already to perform tasks like these that are; required, *e.g.*, for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in |PSIfour| and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in :ref:`sec:prog_tour-exposing`. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths. A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work i",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:6286,Performance,perform,performs,6286," from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in |PSIfour| already to perform tasks like these that are; required, *e.g.*, for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in |PSIfour| and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in :ref:`sec:prog_tour-exposing`. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths. A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out *embarrassingly parallel* workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated. In SCF, we have a number of sources of external embe",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:4407,Security,access,access,4407,". To; facilitate this workflow, |PSIfour| exports key quantities such as integrals,; densities and molecular orbitals in NumPy format. From this point, the; programmer can simply call the appropriate |PSIfour| functions to compute the; desired input quantities, retrieve them in NumPy format, and then write the; remaining code using standard Python and/or NumPy syntax. This approach does; not require any recompilation of code, resulting in a particularly facile; development workflow. Detailed examples and tutorials are available in the; `Psi4NumPy <https://github.com/psi4/psi4numpy>`_ repository. .. _`sec:prog_plugins`:. Avoiding the need to modify Psi4, using plugins; -----------------------------------------------. In the early days when |PSIfour| was still primarily a C++ code, development; was very cumbersome due to a lengthy build process. To expedite development, a; plugin system was developed. This plugin machinery allows developers to access; the classes defined in the innards of |PSIfour|, with only the small plugin; code requiring recompilation during development. The resulting lightweight; code can be maintained and distributed independently of |PSIfour|, making this; a good strategy for development, especially in cases where tighter integration; of the new code with existing |PSIfour| machinery is required than that; afforded by the Numpy based strategy outlined in the :ref:`sec:prog_psi4numpy`; section. For details about how to write these plugins, see the; :ref:`sec:plugins` section. .. _`sec:prog_fullintegration`:. Incorporating code into |PSIfour|; ---------------------------------. For features to be incorporated fully into the |PSIfour| ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let's; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:6887,Testability,log,logic,6887,"ifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in |PSIfour| already to perform tasks like these that are; required, *e.g.*, for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in |PSIfour| and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in :ref:`sec:prog_tour-exposing`. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths. A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out *embarrassingly parallel* workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated. In SCF, we have a number of sources of external embedding potentials that could; enter the calculation. Allowing Python to handle only the details of driving; the SCF iterations, such as external potentials and convergence acceleration; methods, but deferring to C++ to do the heavy lifting for building and; diagonalizing the Fock matrix also takes advantage of the two languages'; strengths and improves maintainability of the code.; ",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:2098,Usability,simpl,simplified,2098,"======================================; Ways to Add Code: Psi4NumPy, Plugins, Full Integration ; ======================================================. Easier and more rapid development; ---------------------------------. Fully-featured electronic structure programs are large and complex. However,; the |PSIfour| ecosystem provides a path for easier and more rapid development; of new features. The earliest versions of |PSIfour| were written by merging; individual executables that performed specific tasks into a unified C++; executable. By linking this C++ executable against the Python interpreter, the; individual modules could be called in any sequence, enabling a very diverse; range of tasks to be accomplished within a given input. Although Python-driven; model allowed for great flexibility from a user's perspective, programming was; still relatively difficult because it required modifications to be made in C++; code. Since those early days, the code has undergone some important structural; changes that have greatly simplified the development workflow. These changes; were motivated by the realization that only a few bottlenecks exist in a typical; calculation; by focusing on optimized C++ implementations of these bottlenecks; and making these C++ functions available in Python, most of the code to implement; the overall calculation can be written in simpler Python code. Python is far; better suited to management tasks such as directory navigation and retrieval,; making it a natural choice for overall calculation layout than C++. With the; emergence of `NumPy <https://numpy.org/>`_ as a standard tool for executing almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. .. _`sec:prog_psi4numpy`:. Rapid initial development using Psi4NumPy; -----------------------------------------. The `Psi4NumPy <https:/",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:2437,Usability,simpl,simpler,2437,"eatured electronic structure programs are large and complex. However,; the |PSIfour| ecosystem provides a path for easier and more rapid development; of new features. The earliest versions of |PSIfour| were written by merging; individual executables that performed specific tasks into a unified C++; executable. By linking this C++ executable against the Python interpreter, the; individual modules could be called in any sequence, enabling a very diverse; range of tasks to be accomplished within a given input. Although Python-driven; model allowed for great flexibility from a user's perspective, programming was; still relatively difficult because it required modifications to be made in C++; code. Since those early days, the code has undergone some important structural; changes that have greatly simplified the development workflow. These changes; were motivated by the realization that only a few bottlenecks exist in a typical; calculation; by focusing on optimized C++ implementations of these bottlenecks; and making these C++ functions available in Python, most of the code to implement; the overall calculation can be written in simpler Python code. Python is far; better suited to management tasks such as directory navigation and retrieval,; making it a natural choice for overall calculation layout than C++. With the; emergence of `NumPy <https://numpy.org/>`_ as a standard tool for executing almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. .. _`sec:prog_psi4numpy`:. Rapid initial development using Psi4NumPy; -----------------------------------------. The `Psi4NumPy <https://github.com/psi4/psi4numpy>`_ project [Smith:2018:3504]_ is the recommended; mechanism for developing and prototyping new methods in Psi4. Because; `NumPy <https://numpy.org/>`_ provides such a rich set of features for efficient l",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:2833,Usability,simpl,simpler,2833,"ven input. Although Python-driven; model allowed for great flexibility from a user's perspective, programming was; still relatively difficult because it required modifications to be made in C++; code. Since those early days, the code has undergone some important structural; changes that have greatly simplified the development workflow. These changes; were motivated by the realization that only a few bottlenecks exist in a typical; calculation; by focusing on optimized C++ implementations of these bottlenecks; and making these C++ functions available in Python, most of the code to implement; the overall calculation can be written in simpler Python code. Python is far; better suited to management tasks such as directory navigation and retrieval,; making it a natural choice for overall calculation layout than C++. With the; emergence of `NumPy <https://numpy.org/>`_ as a standard tool for executing almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. .. _`sec:prog_psi4numpy`:. Rapid initial development using Psi4NumPy; -----------------------------------------. The `Psi4NumPy <https://github.com/psi4/psi4numpy>`_ project [Smith:2018:3504]_ is the recommended; mechanism for developing and prototyping new methods in Psi4. Because; `NumPy <https://numpy.org/>`_ provides such a rich set of features for efficient linear; algebra, Fourier transforms, and general tensor manipulations, a massive number; of methods can be easily implemented very easily using that library. To; facilitate this workflow, |PSIfour| exports key quantities such as integrals,; densities and molecular orbitals in NumPy format. From this point, the; programmer can simply call the appropriate |PSIfour| functions to compute the; desired input quantities, retrieve them in NumPy format, and then write the; remaining code using standard Pyt",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:3623,Usability,simpl,simply,3623,"ng almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. .. _`sec:prog_psi4numpy`:. Rapid initial development using Psi4NumPy; -----------------------------------------. The `Psi4NumPy <https://github.com/psi4/psi4numpy>`_ project [Smith:2018:3504]_ is the recommended; mechanism for developing and prototyping new methods in Psi4. Because; `NumPy <https://numpy.org/>`_ provides such a rich set of features for efficient linear; algebra, Fourier transforms, and general tensor manipulations, a massive number; of methods can be easily implemented very easily using that library. To; facilitate this workflow, |PSIfour| exports key quantities such as integrals,; densities and molecular orbitals in NumPy format. From this point, the; programmer can simply call the appropriate |PSIfour| functions to compute the; desired input quantities, retrieve them in NumPy format, and then write the; remaining code using standard Python and/or NumPy syntax. This approach does; not require any recompilation of code, resulting in a particularly facile; development workflow. Detailed examples and tutorials are available in the; `Psi4NumPy <https://github.com/psi4/psi4numpy>`_ repository. .. _`sec:prog_plugins`:. Avoiding the need to modify Psi4, using plugins; -----------------------------------------------. In the early days when |PSIfour| was still primarily a C++ code, development; was very cumbersome due to a lengthy build process. To expedite development, a; plugin system was developed. This plugin machinery allows developers to access; the classes defined in the innards of |PSIfour|, with only the small plugin; code requiring recompilation during development. The resulting lightweight; code can be maintained and distributed independently of |PSIfour|, making this; a good strategy for development, especially in cases wh",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:5677,Usability,simpl,simply,5677,"ere tighter integration; of the new code with existing |PSIfour| machinery is required than that; afforded by the Numpy based strategy outlined in the :ref:`sec:prog_psi4numpy`; section. For details about how to write these plugins, see the; :ref:`sec:plugins` section. .. _`sec:prog_fullintegration`:. Incorporating code into |PSIfour|; ---------------------------------. For features to be incorporated fully into the |PSIfour| ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let's; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in |PSIfour| already to perform tasks like these that are; required, *e.g.*, for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in |PSIfour| and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in :ref:`sec:prog_tour-exposing`. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the wo",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:5974,Usability,clear,clear,5974,"ails about how to write these plugins, see the; :ref:`sec:plugins` section. .. _`sec:prog_fullintegration`:. Incorporating code into |PSIfour|; ---------------------------------. For features to be incorporated fully into the |PSIfour| ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let's; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in |PSIfour| already to perform tasks like these that are; required, *e.g.*, for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in |PSIfour| and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in :ref:`sec:prog_tour-exposing`. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths. A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to de",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst:6243,Usability,simpl,simple,6243," from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in |PSIfour| already to perform tasks like these that are; required, *e.g.*, for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in |PSIfour| and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in :ref:`sec:prog_tour-exposing`. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths. A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out *embarrassingly parallel* workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated. In SCF, we have a number of sources of external embe",MatchSource.DOCS,doc/sphinxman/source/prog_ways_to_add.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_ways_to_add.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_welcome.rst:1362,Usability,feedback,feedback,1362,".. #; .. # @BEGIN LICENSE; .. #; .. # Psi4: an open-source quantum chemistry software package; .. #; .. # Copyright (c) 2007-2023 The Psi4 Developers.; .. #; .. # The copyrights for code used from other parties are included in; .. # the corresponding files.; .. #; .. # This file is part of Psi4.; .. #; .. # Psi4 is free software; you can redistribute it and/or modify; .. # it under the terms of the GNU Lesser General Public License as published by; .. # the Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:prog_welcome`:. ===========================; Welcome to New Programmers; ===========================. The |PSIfour| community; -----------------------. |PSIfour| is an open-source project and welcomes contributions from; developers around the world. etc. We have annual meetings, we welcome; feedback, slack channel, etc. ",MatchSource.DOCS,doc/sphinxman/source/prog_welcome.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/prog_welcome.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst:6829,Availability,avail,available,6829,"te. The |psimrcc__follow_root| option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants. ::. molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD ; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; follow_root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the ``docc`` array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are available to place into; the active space (given by ``active``), which consists of 2 orbitals.; Thus there are two active electrons in two orbitals. In this particular; example, we are using standard ROHF orbitals for the Mk-MRCCSD procedure,; rather than TCSCF orbitals. Nevertheless, with the present code, ; these orbitals must be provided through the MCSCF module, as specified in the; ``set mcscf`` section above. Orbital ordering and selection of the model space; _________________________________________________. The reference determinants :math:`\Phi_\mu` are specified in PSIMRCC; via occupational numbers. PSIMRCC requires that four arrays be specified; for this purpose. - Frozen doubly occupied orbitals (|globals__frozen_docc|) are doubly; occupied in each reference determinant and are not correlated in the; MRCC procedure.; - Doubly occupied orbitals (|globals__restricted_docc|) are doubly; occupied in each reference determinant and are correlated in the MRCC; procedure.; - Active orbitals (|globals__active|) ar",MatchSource.DOCS,doc/sphinxman/source/psimrcc.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst:3938,Deployability,configurat,configuration,3938,"hosen eigenvalue of the effective Hamiltonian,; :math:`\textrm{H}^{eff}_{\mu \nu}`. .. math:: \sum_\nu \textrm{H}^{eff}_{\mu \nu} c_\nu =E c_\nu. where . .. math:: \textrm{H}^{eff}_{\mu \nu} = \left \langle \Phi_\mu \right | \hat{H}e^{\hat{T}^\nu} \left | \Phi_\nu \right \rangle \, \textrm{.}. |PSIfour| currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]_. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728]_. The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include ; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CASCI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure. The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CASCI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CASCI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying |mcscf__reference| to be ``twocon``).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSI",MatchSource.DOCS,doc/sphinxman/source/psimrcc.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst:4554,Deployability,configurat,configuration,4554,"ll determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include ; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CASCI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure. The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CASCI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CASCI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying |mcscf__reference| to be ``twocon``).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC's MCSCF module regardless of what; orbital type is chosen, ``twocon``, ``rhf``, or ``rohf``. An example of the; MCSCF input is given below. PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (*e.g.*, triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example; ________________ . The |psimrcc__corr_wfn| allows you to select one of three methods; Mk-MRPT2 [``PT2``], Mk-MRCCSD [``CCSD``], or Mk-MRCCSD(T) [``CCSD_T``].; The |psimrc",MatchSource.DOCS,doc/sphinxman/source/psimrcc.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst:4647,Deployability,configurat,configuration,4647,"ll determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include ; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CASCI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure. The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CASCI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CASCI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying |mcscf__reference| to be ``twocon``).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC's MCSCF module regardless of what; orbital type is chosen, ``twocon``, ``rhf``, or ``rohf``. An example of the; MCSCF input is given below. PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (*e.g.*, triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example; ________________ . The |psimrcc__corr_wfn| allows you to select one of three methods; Mk-MRPT2 [``PT2``], Mk-MRCCSD [``CCSD``], or Mk-MRCCSD(T) [``CCSD_T``].; The |psimrc",MatchSource.DOCS,doc/sphinxman/source/psimrcc.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst:1842,Energy Efficiency,power,powerful,1842," with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index::; single: multireference; single: Mk-MRCC. .. _`sec:psimrcc`:. PSIMRCC Implementation of Mk-MRCC Theory; ========================================. .. codeauthor:: Francesco A. Evangelista and Andrew C. Simmonett ; .. sectionauthor:: Alexander E. Vaughn. *Module:* :ref:`Keywords <apdx:psimrcc>`, :ref:`PSI Variables <apdx:psimrcc_psivar>`, :source:`PSIMRCC <psi4/src/psi4/psimrcc>`. State-specific Multireference coupled cluster theories provide highly; accurate energies and properties of electronic states that require; a multiconfigurational zeroth-order wavefunction. The PSIMRCC; module contained in |PSIfour| implements the state-specific; multireference coupled-cluster approach of Mukherjee and co-workers; (Mk-MRCC). This method is implemented and shown to be a powerful tool in; [Evangelista:2006:154113]_ and [Evangelista:2008:124104]_. Mk-MRCC is; based on the Jeziorski-Monkhorst ansatz [Jeziorski:1981:1668]_ for the; wavefunction, :math:`\Psi`. .. math:: \left| \Psi \right \rangle = \sum_\mu^d e^{\hat{T}^\mu} \left| \Phi_\mu \right\rangle c_\mu \, \text{,}. where :math:`\Phi_\mu` are the reference determinants,; :math:`\hat{T}^\mu` are reference-specific excitation operators, and; :math:`c_\mu` are expansion coefficients obtained through diagonalization; of the Mk-MRCC effective Hamiltonian matrix that allows the various; reference determinants to interact. As an example of how this works; the Mk-MRCCSD excitation operators for each reference is contracted; two-body terms. .. math:: \hat{T}^\mu = \hat{T}^\mu_1 + \hat{T}^\mu_2. where. .. math:: \hat{T}^\mu_1 = \sum_i^{\textrm{occ}(\mu)} \sum_a^{\textrm{vir}(\mu)} t_i^a (\mu) \hat{a}^\dagger_a \hat{a}_i. and. .. math:: \hat{T}^\mu_2 =\frac{1}{4} \sum_i^{\textrm{occ}(\mu)} \sum_a^{\textrm{vir}(\mu)} t_{ij}^{",MatchSource.DOCS,doc/sphinxman/source/psimrcc.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst:2937,Energy Efficiency,energy,energy,2937,"ski:1981:1668]_ for the; wavefunction, :math:`\Psi`. .. math:: \left| \Psi \right \rangle = \sum_\mu^d e^{\hat{T}^\mu} \left| \Phi_\mu \right\rangle c_\mu \, \text{,}. where :math:`\Phi_\mu` are the reference determinants,; :math:`\hat{T}^\mu` are reference-specific excitation operators, and; :math:`c_\mu` are expansion coefficients obtained through diagonalization; of the Mk-MRCC effective Hamiltonian matrix that allows the various; reference determinants to interact. As an example of how this works; the Mk-MRCCSD excitation operators for each reference is contracted; two-body terms. .. math:: \hat{T}^\mu = \hat{T}^\mu_1 + \hat{T}^\mu_2. where. .. math:: \hat{T}^\mu_1 = \sum_i^{\textrm{occ}(\mu)} \sum_a^{\textrm{vir}(\mu)} t_i^a (\mu) \hat{a}^\dagger_a \hat{a}_i. and. .. math:: \hat{T}^\mu_2 =\frac{1}{4} \sum_i^{\textrm{occ}(\mu)} \sum_a^{\textrm{vir}(\mu)} t_{ij}^{ab} (\mu) \hat{a}^\dagger_b \hat{a}_j \hat{a}^\dagger_a \hat{a}_i . The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian,; :math:`\textrm{H}^{eff}_{\mu \nu}`. .. math:: \sum_\nu \textrm{H}^{eff}_{\mu \nu} c_\nu =E c_\nu. where . .. math:: \textrm{H}^{eff}_{\mu \nu} = \left \langle \Phi_\mu \right | \hat{H}e^{\hat{T}^\nu} \left | \Phi_\nu \right \rangle \, \textrm{.}. |PSIfour| currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]_. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728]_. The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include ; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CASCI) referen",MatchSource.DOCS,doc/sphinxman/source/psimrcc.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst:4487,Energy Efficiency,energy,energy,4487,"074107]_. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728]_. The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include ; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CASCI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure. The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CASCI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CASCI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying |mcscf__reference| to be ``twocon``).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC's MCSCF module regardless of what; orbital type is chosen, ``twocon``, ``rhf``, or ``rohf``. An example of the; MCSCF input is given below. PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (*e.g.*, triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-",MatchSource.DOCS,doc/sphinxman/source/psimrcc.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst:5824,Energy Efficiency,energy,energy,5824,"als. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC's MCSCF module regardless of what; orbital type is chosen, ``twocon``, ``rhf``, or ``rohf``. An example of the; MCSCF input is given below. PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (*e.g.*, triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example; ________________ . The |psimrcc__corr_wfn| allows you to select one of three methods; Mk-MRPT2 [``PT2``], Mk-MRCCSD [``CCSD``], or Mk-MRCCSD(T) [``CCSD_T``].; The |psimrcc__corr_multp| option allows you to select the Slater; determinants with a particular :math:`M_s` value. The |psimrcc__wfn_sym|; keyword is neccesary if you do not want to compute the energy of the; totally-symmetric state. The |psimrcc__follow_root| option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants. ::. molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD ; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; follow_root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the ``docc`` array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence",MatchSource.DOCS,doc/sphinxman/source/psimrcc.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst:6038,Energy Efficiency,energy,energy,6038,", ``rhf``, or ``rohf``. An example of the; MCSCF input is given below. PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (*e.g.*, triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example; ________________ . The |psimrcc__corr_wfn| allows you to select one of three methods; Mk-MRPT2 [``PT2``], Mk-MRCCSD [``CCSD``], or Mk-MRCCSD(T) [``CCSD_T``].; The |psimrcc__corr_multp| option allows you to select the Slater; determinants with a particular :math:`M_s` value. The |psimrcc__wfn_sym|; keyword is neccesary if you do not want to compute the energy of the; totally-symmetric state. The |psimrcc__follow_root| option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants. ::. molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD ; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; follow_root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the ``docc`` array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are available to place into; the active space (given by ``active``), which consists of 2 orbitals.; Thus there are two active electrons in two orbitals. In this particular; example, we are using stan",MatchSource.DOCS,doc/sphinxman/source/psimrcc.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst:6628,Energy Efficiency,energy,energy,6628,"correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example; ________________ . The |psimrcc__corr_wfn| allows you to select one of three methods; Mk-MRPT2 [``PT2``], Mk-MRCCSD [``CCSD``], or Mk-MRCCSD(T) [``CCSD_T``].; The |psimrcc__corr_multp| option allows you to select the Slater; determinants with a particular :math:`M_s` value. The |psimrcc__wfn_sym|; keyword is neccesary if you do not want to compute the energy of the; totally-symmetric state. The |psimrcc__follow_root| option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants. ::. molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD ; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; follow_root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the ``docc`` array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are available to place into; the active space (given by ``active``), which consists of 2 orbitals.; Thus there are two active electrons in two orbitals. In this particular; example, we are using standard ROHF orbitals for the Mk-MRCCSD procedure,; rather than TCSCF orbitals. Nevertheless, with the present code, ; these orbitals must be provided through the MCSCF module, as specified in the; ``set mcscf`` section above. Orbital ordering and selection of the model space; _________________________________________________. The reference determinants :mat",MatchSource.DOCS,doc/sphinxman/source/psimrcc.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst:2542,Integrability,contract,contracted,2542,"rovide highly; accurate energies and properties of electronic states that require; a multiconfigurational zeroth-order wavefunction. The PSIMRCC; module contained in |PSIfour| implements the state-specific; multireference coupled-cluster approach of Mukherjee and co-workers; (Mk-MRCC). This method is implemented and shown to be a powerful tool in; [Evangelista:2006:154113]_ and [Evangelista:2008:124104]_. Mk-MRCC is; based on the Jeziorski-Monkhorst ansatz [Jeziorski:1981:1668]_ for the; wavefunction, :math:`\Psi`. .. math:: \left| \Psi \right \rangle = \sum_\mu^d e^{\hat{T}^\mu} \left| \Phi_\mu \right\rangle c_\mu \, \text{,}. where :math:`\Phi_\mu` are the reference determinants,; :math:`\hat{T}^\mu` are reference-specific excitation operators, and; :math:`c_\mu` are expansion coefficients obtained through diagonalization; of the Mk-MRCC effective Hamiltonian matrix that allows the various; reference determinants to interact. As an example of how this works; the Mk-MRCCSD excitation operators for each reference is contracted; two-body terms. .. math:: \hat{T}^\mu = \hat{T}^\mu_1 + \hat{T}^\mu_2. where. .. math:: \hat{T}^\mu_1 = \sum_i^{\textrm{occ}(\mu)} \sum_a^{\textrm{vir}(\mu)} t_i^a (\mu) \hat{a}^\dagger_a \hat{a}_i. and. .. math:: \hat{T}^\mu_2 =\frac{1}{4} \sum_i^{\textrm{occ}(\mu)} \sum_a^{\textrm{vir}(\mu)} t_{ij}^{ab} (\mu) \hat{a}^\dagger_b \hat{a}_j \hat{a}^\dagger_a \hat{a}_i . The Mk-MRCC energy is a chosen eigenvalue of the effective Hamiltonian,; :math:`\textrm{H}^{eff}_{\mu \nu}`. .. math:: \sum_\nu \textrm{H}^{eff}_{\mu \nu} c_\nu =E c_\nu. where . .. math:: \textrm{H}^{eff}_{\mu \nu} = \left \langle \Phi_\mu \right | \hat{H}e^{\hat{T}^\nu} \left | \Phi_\nu \right \rangle \, \textrm{.}. |PSIfour| currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]_. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee f",MatchSource.DOCS,doc/sphinxman/source/psimrcc.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst:3938,Modifiability,config,configuration,3938,"hosen eigenvalue of the effective Hamiltonian,; :math:`\textrm{H}^{eff}_{\mu \nu}`. .. math:: \sum_\nu \textrm{H}^{eff}_{\mu \nu} c_\nu =E c_\nu. where . .. math:: \textrm{H}^{eff}_{\mu \nu} = \left \langle \Phi_\mu \right | \hat{H}e^{\hat{T}^\nu} \left | \Phi_\nu \right \rangle \, \textrm{.}. |PSIfour| currently implements Mk-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]_. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728]_. The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include ; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CASCI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure. The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CASCI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CASCI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying |mcscf__reference| to be ``twocon``).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSI",MatchSource.DOCS,doc/sphinxman/source/psimrcc.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst:4554,Modifiability,config,configuration,4554,"ll determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include ; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CASCI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure. The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CASCI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CASCI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying |mcscf__reference| to be ``twocon``).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC's MCSCF module regardless of what; orbital type is chosen, ``twocon``, ``rhf``, or ``rohf``. An example of the; MCSCF input is given below. PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (*e.g.*, triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example; ________________ . The |psimrcc__corr_wfn| allows you to select one of three methods; Mk-MRPT2 [``PT2``], Mk-MRCCSD [``CCSD``], or Mk-MRCCSD(T) [``CCSD_T``].; The |psimrc",MatchSource.DOCS,doc/sphinxman/source/psimrcc.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst:4647,Modifiability,config,configuration,4647,"ll determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include ; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CASCI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure. The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CASCI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CASCI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying |mcscf__reference| to be ``twocon``).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC's MCSCF module regardless of what; orbital type is chosen, ``twocon``, ``rhf``, or ``rohf``. An example of the; MCSCF input is given below. PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (*e.g.*, triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example; ________________ . The |psimrcc__corr_wfn| allows you to select one of three methods; Mk-MRPT2 [``PT2``], Mk-MRCCSD [``CCSD``], or Mk-MRCCSD(T) [``CCSD_T``].; The |psimrc",MatchSource.DOCS,doc/sphinxman/source/psimrcc.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst:4280,Performance,perform,perform,4280,"k-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]_. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728]_. The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include ; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CASCI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure. The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CASCI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CASCI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying |mcscf__reference| to be ``twocon``).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC's MCSCF module regardless of what; orbital type is chosen, ``twocon``, ``rhf``, or ``rohf``. An example of the; MCSCF input is given below. PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (*e.g.*, triplets), but in general",MatchSource.DOCS,doc/sphinxman/source/psimrcc.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst:4296,Performance,optimiz,optimization,4296,"k-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]_. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728]_. The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include ; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CASCI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure. The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CASCI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CASCI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying |mcscf__reference| to be ``twocon``).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC's MCSCF module regardless of what; orbital type is chosen, ``twocon``, ``rhf``, or ``rohf``. An example of the; MCSCF input is given below. PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (*e.g.*, triplets), but in general",MatchSource.DOCS,doc/sphinxman/source/psimrcc.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst:4447,Performance,optimiz,optimized,4447,"074107]_. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728]_. The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include ; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CASCI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure. The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CASCI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CASCI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying |mcscf__reference| to be ``twocon``).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC's MCSCF module regardless of what; orbital type is chosen, ``twocon``, ``rhf``, or ``rohf``. An example of the; MCSCF input is given below. PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (*e.g.*, triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-",MatchSource.DOCS,doc/sphinxman/source/psimrcc.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst:5197,Performance,perform,performing,5197,"n; to the true Mk-MRCC procedure. The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CASCI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CASCI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying |mcscf__reference| to be ``twocon``).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC's MCSCF module regardless of what; orbital type is chosen, ``twocon``, ``rhf``, or ``rohf``. An example of the; MCSCF input is given below. PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (*e.g.*, triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example; ________________ . The |psimrcc__corr_wfn| allows you to select one of three methods; Mk-MRPT2 [``PT2``], Mk-MRCCSD [``CCSD``], or Mk-MRCCSD(T) [``CCSD_T``].; The |psimrcc__corr_multp| option allows you to select the Slater; determinants with a particular :math:`M_s` value. The |psimrcc__wfn_sym|; keyword is neccesary if you do not want to compute the energy of the; totally-symmetric state. The |psimrcc__follow_root| option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants. ::. molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2",MatchSource.DOCS,doc/sphinxman/source/psimrcc.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psimrcc.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonfunc.rst:1553,Energy Efficiency,efficient,efficient,1553,".. #; .. # @BEGIN LICENSE; .. #; .. # Psi4: an open-source quantum chemistry software package; .. #; .. # Copyright (c) 2007-2023 The Psi4 Developers.; .. #; .. # The copyrights for code used from other parties are included in; .. # the corresponding files.; .. #; .. # This file is part of Psi4.; .. #; .. # Psi4 is free software; you can redistribute it and/or modify; .. # it under the terms of the GNU Lesser General Public License as published by; .. # the Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. _`sec:psithonFunc`:. =========================================; Psithon Functions: Invoking a Calculation; =========================================. To allow arbitrarily complex computations to be performed, |PSIfour| is built; upon the Python interpreter, with modifications termed Psithon. Sec. ; :ref:`sec:psithonInput` describes the non-standard Python associated with; clean molecule, basis, and option specification in the |PSIfour| input file.; This documentation addresses the pure Python side- what functions allow; the efficient compiled code to be run, what functions post-process and; interact with that output, and how the ordinary (or ambitious) user can; extent |PSIfours| functionality. .. toctree::; :maxdepth: 2. notes_py; energy; prop; nbody; opt; freq; db; cbs; diatomic; intercalls; sowreap; cubeprop. ",MatchSource.DOCS,doc/sphinxman/source/psithonfunc.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonfunc.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonfunc.rst:1765,Energy Efficiency,energy,energy,1765,".. #; .. # @BEGIN LICENSE; .. #; .. # Psi4: an open-source quantum chemistry software package; .. #; .. # Copyright (c) 2007-2023 The Psi4 Developers.; .. #; .. # The copyrights for code used from other parties are included in; .. # the corresponding files.; .. #; .. # This file is part of Psi4.; .. #; .. # Psi4 is free software; you can redistribute it and/or modify; .. # it under the terms of the GNU Lesser General Public License as published by; .. # the Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. _`sec:psithonFunc`:. =========================================; Psithon Functions: Invoking a Calculation; =========================================. To allow arbitrarily complex computations to be performed, |PSIfour| is built; upon the Python interpreter, with modifications termed Psithon. Sec. ; :ref:`sec:psithonInput` describes the non-standard Python associated with; clean molecule, basis, and option specification in the |PSIfour| input file.; This documentation addresses the pure Python side- what functions allow; the efficient compiled code to be run, what functions post-process and; interact with that output, and how the ordinary (or ambitious) user can; extent |PSIfours| functionality. .. toctree::; :maxdepth: 2. notes_py; energy; prop; nbody; opt; freq; db; cbs; diatomic; intercalls; sowreap; cubeprop. ",MatchSource.DOCS,doc/sphinxman/source/psithonfunc.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonfunc.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonfunc.rst:1221,Performance,perform,performed,1221,".. #; .. # @BEGIN LICENSE; .. #; .. # Psi4: an open-source quantum chemistry software package; .. #; .. # Copyright (c) 2007-2023 The Psi4 Developers.; .. #; .. # The copyrights for code used from other parties are included in; .. # the corresponding files.; .. #; .. # This file is part of Psi4.; .. #; .. # Psi4 is free software; you can redistribute it and/or modify; .. # it under the terms of the GNU Lesser General Public License as published by; .. # the Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. _`sec:psithonFunc`:. =========================================; Psithon Functions: Invoking a Calculation; =========================================. To allow arbitrarily complex computations to be performed, |PSIfour| is built; upon the Python interpreter, with modifications termed Psithon. Sec. ; :ref:`sec:psithonInput` describes the non-standard Python associated with; clean molecule, basis, and option specification in the |PSIfour| input file.; This documentation addresses the pure Python side- what functions allow; the efficient compiled code to be run, what functions post-process and; interact with that output, and how the ordinary (or ambitious) user can; extent |PSIfours| functionality. .. toctree::; :maxdepth: 2. notes_py; energy; prop; nbody; opt; freq; db; cbs; diatomic; intercalls; sowreap; cubeprop. ",MatchSource.DOCS,doc/sphinxman/source/psithonfunc.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonfunc.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:2432,Availability,avail,available,2432,"ng in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; |PSIfour| is distributed with an extensive test suite, described in section; :ref:`apdx:testSuite`; the input files for these test cases can be found in the; samples subdirectory of the top-level |PSIfour| source directory and should; serve as useful examples. .. index:: physical constants; .. _`sec:physicalConstants`:. Physical Constants; ==================. For convenience, the Python interpreter will execute the contents of the; |psirc| file in the current user's home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the |psirc| file ::. UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable ``UGC`` available in all |PSIfour| input files.; For convenience, the physical constants used within the |PSIfour| code (which; are obtained from `NIST CODATA 2014; <https://physics.nist.gov/cuu/Constants/archive2014.html>`_; are also automatically loaded as Psithon; variables (before |psirc| is loaded, so that the user's |psirc| values can; override the builtins (in the input file, not in the C++ code). The physical constants used within |PSIfour|, which are automatically; made available within all |PSIfour| input files are in :ref:`table:physconst`. .. .. literalinclude:: @SFNX_INCLUDE@psi4/driver/constants/physconst.py; .. :lines: 28-. In Psithon input files, prepend physical constants with ``psi_`` to; prevent clashes with user-defined variables (*e.g.*, ``psi_h``). In; PsiAPI mode, access as, *e.g.*, ``psi4.constants.h``. .. index:: memory; .. _`sec:memory`:. Memory Specification; ====================. By default, |PSIfour| assumes that 500 MiB of memory are available. While this is; enou",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:2908,Availability,avail,available,2908,"cal Constants; ==================. For convenience, the Python interpreter will execute the contents of the; |psirc| file in the current user's home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the |psirc| file ::. UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable ``UGC`` available in all |PSIfour| input files.; For convenience, the physical constants used within the |PSIfour| code (which; are obtained from `NIST CODATA 2014; <https://physics.nist.gov/cuu/Constants/archive2014.html>`_; are also automatically loaded as Psithon; variables (before |psirc| is loaded, so that the user's |psirc| values can; override the builtins (in the input file, not in the C++ code). The physical constants used within |PSIfour|, which are automatically; made available within all |PSIfour| input files are in :ref:`table:physconst`. .. .. literalinclude:: @SFNX_INCLUDE@psi4/driver/constants/physconst.py; .. :lines: 28-. In Psithon input files, prepend physical constants with ``psi_`` to; prevent clashes with user-defined variables (*e.g.*, ``psi_h``). In; PsiAPI mode, access as, *e.g.*, ``psi4.constants.h``. .. index:: memory; .. _`sec:memory`:. Memory Specification; ====================. By default, |PSIfour| assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the ``memory`` keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to |PSIfour|::. # all equivalent. memory 2 GB; ; memory 2000 MB; ; memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). |PSIfour| recognizes an",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:3402,Availability,avail,available,3402,"3 / kg^-1 s^-2. which would make the variable ``UGC`` available in all |PSIfour| input files.; For convenience, the physical constants used within the |PSIfour| code (which; are obtained from `NIST CODATA 2014; <https://physics.nist.gov/cuu/Constants/archive2014.html>`_; are also automatically loaded as Psithon; variables (before |psirc| is loaded, so that the user's |psirc| values can; override the builtins (in the input file, not in the C++ code). The physical constants used within |PSIfour|, which are automatically; made available within all |PSIfour| input files are in :ref:`table:physconst`. .. .. literalinclude:: @SFNX_INCLUDE@psi4/driver/constants/physconst.py; .. :lines: 28-. In Psithon input files, prepend physical constants with ``psi_`` to; prevent clashes with user-defined variables (*e.g.*, ``psi_h``). In; PsiAPI mode, access as, *e.g.*, ``psi4.constants.h``. .. index:: memory; .. _`sec:memory`:. Memory Specification; ====================. By default, |PSIfour| assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the ``memory`` keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to |PSIfour|::. # all equivalent. memory 2 GB; ; memory 2000 MB; ; memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). |PSIfour| recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB). By default, |PSIfour| performs a ""sanity check"" when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to |PSIfour|::. # setting available memory to 2 MB; set_memory_bytes(2000000). Please note that this memory ",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:3513,Availability,avail,available,3513,"les.; For convenience, the physical constants used within the |PSIfour| code (which; are obtained from `NIST CODATA 2014; <https://physics.nist.gov/cuu/Constants/archive2014.html>`_; are also automatically loaded as Psithon; variables (before |psirc| is loaded, so that the user's |psirc| values can; override the builtins (in the input file, not in the C++ code). The physical constants used within |PSIfour|, which are automatically; made available within all |PSIfour| input files are in :ref:`table:physconst`. .. .. literalinclude:: @SFNX_INCLUDE@psi4/driver/constants/physconst.py; .. :lines: 28-. In Psithon input files, prepend physical constants with ``psi_`` to; prevent clashes with user-defined variables (*e.g.*, ``psi_h``). In; PsiAPI mode, access as, *e.g.*, ``psi4.constants.h``. .. index:: memory; .. _`sec:memory`:. Memory Specification; ====================. By default, |PSIfour| assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the ``memory`` keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to |PSIfour|::. # all equivalent. memory 2 GB; ; memory 2000 MB; ; memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). |PSIfour| recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB). By default, |PSIfour| performs a ""sanity check"" when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to |PSIfour|::. # setting available memory to 2 MB; set_memory_bytes(2000000). Please note that this memory setting only governs the maximal memory; usage of the major data structures, and actual to",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:3665,Availability,avail,available,3665,"2014.html>`_; are also automatically loaded as Psithon; variables (before |psirc| is loaded, so that the user's |psirc| values can; override the builtins (in the input file, not in the C++ code). The physical constants used within |PSIfour|, which are automatically; made available within all |PSIfour| input files are in :ref:`table:physconst`. .. .. literalinclude:: @SFNX_INCLUDE@psi4/driver/constants/physconst.py; .. :lines: 28-. In Psithon input files, prepend physical constants with ``psi_`` to; prevent clashes with user-defined variables (*e.g.*, ``psi_h``). In; PsiAPI mode, access as, *e.g.*, ``psi4.constants.h``. .. index:: memory; .. _`sec:memory`:. Memory Specification; ====================. By default, |PSIfour| assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the ``memory`` keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to |PSIfour|::. # all equivalent. memory 2 GB; ; memory 2000 MB; ; memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). |PSIfour| recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB). By default, |PSIfour| performs a ""sanity check"" when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to |PSIfour|::. # setting available memory to 2 MB; set_memory_bytes(2000000). Please note that this memory setting only governs the maximal memory; usage of the major data structures, and actual total memory usage; is slightly higher. This is usually a negligible amount, except when; setting tiny memory allowances. One convenient way to override the |PSIfour| def",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:4261,Availability,avail,availble,4261,"iAPI mode, access as, *e.g.*, ``psi4.constants.h``. .. index:: memory; .. _`sec:memory`:. Memory Specification; ====================. By default, |PSIfour| assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the ``memory`` keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to |PSIfour|::. # all equivalent. memory 2 GB; ; memory 2000 MB; ; memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). |PSIfour| recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB). By default, |PSIfour| performs a ""sanity check"" when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to |PSIfour|::. # setting available memory to 2 MB; set_memory_bytes(2000000). Please note that this memory setting only governs the maximal memory; usage of the major data structures, and actual total memory usage; is slightly higher. This is usually a negligible amount, except when; setting tiny memory allowances. One convenient way to override the |PSIfour| default memory is to place a; memory command in the |psirc| file (Sec. :ref:`sec:psirc`). For example,; the following makes the default memory 2 GB. ::. set_memory(2000000000). However, unless you're assured of having only one job running on a node at; a time (and all nodes on the filesystem with |psirc| have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. That same command can be used for PsiAPI mode::. psi4.set_memory(int(5e8)). .. tabs::. .. code-tab:: bash PSIthon. set_memory(2000000000). .. code-tab:: py PsiAPI.",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:4296,Availability,avail,available,4296,"ation; ====================. By default, |PSIfour| assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the ``memory`` keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to |PSIfour|::. # all equivalent. memory 2 GB; ; memory 2000 MB; ; memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). |PSIfour| recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB). By default, |PSIfour| performs a ""sanity check"" when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to |PSIfour|::. # setting available memory to 2 MB; set_memory_bytes(2000000). Please note that this memory setting only governs the maximal memory; usage of the major data structures, and actual total memory usage; is slightly higher. This is usually a negligible amount, except when; setting tiny memory allowances. One convenient way to override the |PSIfour| default memory is to place a; memory command in the |psirc| file (Sec. :ref:`sec:psirc`). For example,; the following makes the default memory 2 GB. ::. set_memory(2000000000). However, unless you're assured of having only one job running on a node at; a time (and all nodes on the filesystem with |psirc| have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. That same command can be used for PsiAPI mode::. psi4.set_memory(int(5e8)). .. tabs::. .. code-tab:: bash PSIthon. set_memory(2000000000). .. code-tab:: py PsiAPI. psi4.set_memory(int(5e8)). .. note:: For parallel jobs, the ``memory`` keyword represents the total memor",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:5320,Availability,avail,available,5320," memory to 2 MB; set_memory_bytes(2000000). Please note that this memory setting only governs the maximal memory; usage of the major data structures, and actual total memory usage; is slightly higher. This is usually a negligible amount, except when; setting tiny memory allowances. One convenient way to override the |PSIfour| default memory is to place a; memory command in the |psirc| file (Sec. :ref:`sec:psirc`). For example,; the following makes the default memory 2 GB. ::. set_memory(2000000000). However, unless you're assured of having only one job running on a node at; a time (and all nodes on the filesystem with |psirc| have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. That same command can be used for PsiAPI mode::. psi4.set_memory(int(5e8)). .. tabs::. .. code-tab:: bash PSIthon. set_memory(2000000000). .. code-tab:: py PsiAPI. psi4.set_memory(int(5e8)). .. note:: For parallel jobs, the ``memory`` keyword represents the total memory; available to the job, *not* the memory per thread. Molecule and Geometry Specification; ===================================. .. toctree::; :maxdepth: 2. psithonmol. .. comment To add EFP fragments to a molecule, see :ref:`sec:usingEFPFragments`. To add EFP fragments to a molecule, see :ref:`sec:usingEFPFragments`. .. index::; triple: setting; keywords; general; .. _`sec:jobControl`:. Job Control Keywords; ====================. |PSIfour| comprises a number of C++ modules that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file which control its function.; These keywords are detailed in Appendix :ref:`apdx:options_c_module`.; The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified::. # all equivalent. set globals basis cc-pVDZ. set basis cc-pVDZ. set globals basis = cc-p",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:8917,Availability,avail,available,8917,"in the order they appear in; the input file, so if the last four commands in the above example were to read ::. set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. In PsiAPI mode, one can use the command :py:func:`~psi4.driver.set_options`; like below for general and module-specific options. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function `~psi4.core.clean_options` that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session. ::. psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True,; 'optking__geom_maxiter': 50; }). Basis Sets; ==========. .. toctree::; :maxdepth: 2. basissets. .. _`sec:psiVariables`:. PSI Variables; =============. To harness the power of Python, |PSIfour| makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H\ :sub:`2` and H atom::. molecule h2 {; H; H 1 0.9; }; ; set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'); ; molecule h {; H; }; ; set basis cc-pvdz; set reference uhf; h_energy = energy('scf'); ; D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The :py:func:`~psi4.driver.energy` function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation. Generally, there are multiple quantities of interest. Appendix; :ref:`apdx:psivariables_module` lists PSI variables variables set by each; module, and :ref:`apdx:psivariables_alpha` defines them. These can be; accessed through the :py:func:`~psi4.core.get_variable` function. For ex",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:10032,Availability,avail,available,10032,"essing. To demonstrate, we can embellish the previous example of; H\ :sub:`2` and H atom::. molecule h2 {; H; H 1 0.9; }; ; set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'); ; molecule h {; H; }; ; set basis cc-pvdz; set reference uhf; h_energy = energy('scf'); ; D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The :py:func:`~psi4.driver.energy` function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation. Generally, there are multiple quantities of interest. Appendix; :ref:`apdx:psivariables_module` lists PSI variables variables set by each; module, and :ref:`apdx:psivariables_alpha` defines them. These can be; accessed through the :py:func:`~psi4.core.get_variable` function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available::. e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command :py:func:`~psi4.core.print_variables`. Note that PSI variables; are cleared at the start of each :py:func:`~psi4.driver.energy`, etc. in an input; file by :py:func:`~psi4.core.clean_variables()`.; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a :py:func:`~psi4.core.print_variables` command, the; last will include :psivar:`SCF TOTAL ENERGY` but not; :psivar:`FCI TOTAL ENERGY`.; The entire dictionary of PSI variables can be obtained through; :py:func:`~psi4.core.get_variables`. .. _`sec:returnvals`:. Return Values; =============. Most of the usual user computation functions (*i.e.*,; :py:func:`~psi4.driver.en",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:11232,Availability,avail,available,11232," PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command :py:func:`~psi4.core.print_variables`. Note that PSI variables; are cleared at the start of each :py:func:`~psi4.driver.energy`, etc. in an input; file by :py:func:`~psi4.core.clean_variables()`.; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a :py:func:`~psi4.core.print_variables` command, the; last will include :psivar:`SCF TOTAL ENERGY` but not; :psivar:`FCI TOTAL ENERGY`.; The entire dictionary of PSI variables can be obtained through; :py:func:`~psi4.core.get_variables`. .. _`sec:returnvals`:. Return Values; =============. Most of the usual user computation functions (*i.e.*,; :py:func:`~psi4.driver.energy`, :py:func:`~psi4.driver.optimize`, and; :py:func:`~psi4.driver.frequency`) return simply the current total energy.; Consult the descriptions of other functions in :ref:`sec:psithonFunc` for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions. ::. # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; ``return_wfn=True`` keyword argument additionally returns; :py:class:`~psi4.core.Wavefunction`. ::. # power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for o",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:13739,Deployability,update,update,13739,"n preprocessor; wraps strings in quotes by default, we have to tell it that ``basis_set`` is a; Python variable, not a string, by prefixing it with a dollar sign. . The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water::. molecule h2o{; O; H 1 R; H 1 R 2 A; }; ; Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2); ; set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of ``Rvals`` and ``Avals`` are both completely standard Python syntax.; Having named our molecule ``h2o`` we can then set the values of ``R`` and ``A`` within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the ``set`` keyword. Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See :srcsample:`scf4` for analogous Z-matrix; and Cartiesian scans. .. _`sec:resultsTables`:. Tables of Results; =================. The Psithon function ``psi4.driver.p4util.Table`` has been removed,; as the Python ecosystem provides many more flexible alternatives. An; example tabulating a potential energy surface scan for water with Pandas; is shown below::. molecule h2o {; O; H 1 R; H 1 R 2 A; }; ; Rvals=[0.9,1.0,1.1]; Avals=range(100,103,2); ; rows = []; table = []; ; set basis cc-pvdz; ; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = variable('SCF TOTAL ENERGY'); edfmp2 = variable('MP2 TOTAL ENERGY'); escsmp2 = variable('SCS-MP2 TOTAL ENERGY'); rows.append((R, A)); table.append([escf, escsmp2, edfmp2]); ; import pandas as pd; df = pd.DataFrame(table, columns = [""E(SCF)"", ""E(SCS)"", ""E(DFMP2)""], index=rows); print(df). # E(SCF) E(SCS) E(DFMP2); # (0.9, 100) -76.020",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:15218,Deployability,integrat,integrated,15218,"rface scan for water with Pandas; is shown below::. molecule h2o {; O; H 1 R; H 1 R 2 A; }; ; Rvals=[0.9,1.0,1.1]; Avals=range(100,103,2); ; rows = []; table = []; ; set basis cc-pvdz; ; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = variable('SCF TOTAL ENERGY'); edfmp2 = variable('MP2 TOTAL ENERGY'); escsmp2 = variable('SCS-MP2 TOTAL ENERGY'); rows.append((R, A)); table.append([escf, escsmp2, edfmp2]); ; import pandas as pd; df = pd.DataFrame(table, columns = [""E(SCF)"", ""E(SCS)"", ""E(DFMP2)""], index=rows); print(df). # E(SCF) E(SCS) E(DFMP2); # (0.9, 100) -76.020680 -76.217006 -76.221189; # (0.9, 102) -76.021305 -76.217439 -76.221605; # (1.0, 100) -76.021264 -76.224987 -76.228727; # (1.0, 102) -76.021460 -76.224946 -76.228668; # (1.1, 100) -75.990195 -76.201891 -76.205087; # (1.1, 102) -75.990085 -76.201498 -76.204676. .. _`sec:wrappers`:. Python Wrappers; ===============. The Python foundations of the |PSIfour| driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the |PSIfour| suite. . As seen in the neon dimer example from the :ref:`tutorial <sec:tutorial>` section,; the :py:func:`~psi4.driver.driver_nbody.nbody` wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example, ::. energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules. |PSIfour| also provides the :py:func:`~psi4.driver.cbs` wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,::. # all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extr",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:7424,Energy Efficiency,energy,energy,7424,"; basis = cc-pVDZ; }. Note the lack of quotes around ``cc-pVDZ``, even though it is a string. The; Psithon preprocessor automatically wraps any string values in ``set`` commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords::. set {; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, *viz.*::. set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening ``[`` is; on the same line as the name of the keyword. Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the ``set`` keyword. Omitting the module; name, or using the name ``global`` or ``globals`` will result in the keyword being; applied to all modules. For example, in the following input ::. molecule{; o; h 1 roh; h 1 roh 2 ahoh; ; roh = 0.957; ahoh = 104.5; }; ; set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the :py:func:`~psi4.driver.energy` Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read ::. set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. In PsiAPI mode, one can use the command :py:func:`~psi4.driver.set_options`; like below for general and module-specific options. Note that these values; should be of correct type, strings fo",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:7772,Energy Efficiency,energy,energy,7772,"ould; be used, *viz.*::. set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening ``[`` is; on the same line as the name of the keyword. Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the ``set`` keyword. Omitting the module; name, or using the name ``global`` or ``globals`` will result in the keyword being; applied to all modules. For example, in the following input ::. molecule{; o; h 1 roh; h 1 roh 2 ahoh; ; roh = 0.957; ahoh = 104.5; }; ; set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the :py:func:`~psi4.driver.energy` Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read ::. set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. In PsiAPI mode, one can use the command :py:func:`~psi4.driver.set_options`; like below for general and module-specific options. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function `~psi4.core.clean_options` that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session. ::. psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True,; 'optking__geom_maxiter': 50; }). Basis Sets; ==========. .. toctree::; :maxdepth: 2. basissets. .. _`sec:psiVariables`:. PSI Variables; ==",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:8028,Energy Efficiency,energy,energy,8028,"dividual modules,; by adding the name of the module after the ``set`` keyword. Omitting the module; name, or using the name ``global`` or ``globals`` will result in the keyword being; applied to all modules. For example, in the following input ::. molecule{; o; h 1 roh; h 1 roh 2 ahoh; ; roh = 0.957; ahoh = 104.5; }; ; set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the :py:func:`~psi4.driver.energy` Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read ::. set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. In PsiAPI mode, one can use the command :py:func:`~psi4.driver.set_options`; like below for general and module-specific options. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function `~psi4.core.clean_options` that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session. ::. psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True,; 'optking__geom_maxiter': 50; }). Basis Sets; ==========. .. toctree::; :maxdepth: 2. basissets. .. _`sec:psiVariables`:. PSI Variables; =============. To harness the power of Python, |PSIfour| makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H\ :sub:`2` ",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:8836,Energy Efficiency,power,power,8836,"in the order they appear in; the input file, so if the last four commands in the above example were to read ::. set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. In PsiAPI mode, one can use the command :py:func:`~psi4.driver.set_options`; like below for general and module-specific options. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function `~psi4.core.clean_options` that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session. ::. psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True,; 'optking__geom_maxiter': 50; }). Basis Sets; ==========. .. toctree::; :maxdepth: 2. basissets. .. _`sec:psiVariables`:. PSI Variables; =============. To harness the power of Python, |PSIfour| makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H\ :sub:`2` and H atom::. molecule h2 {; H; H 1 0.9; }; ; set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'); ; molecule h {; H; }; ; set basis cc-pvdz; set reference uhf; h_energy = energy('scf'); ; D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The :py:func:`~psi4.driver.energy` function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation. Generally, there are multiple quantities of interest. Appendix; :ref:`apdx:psivariables_module` lists PSI variables variables set by each; module, and :ref:`apdx:psivariables_alpha` defines them. These can be; accessed through the :py:func:`~psi4.core.get_variable` function. For ex",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:9141,Energy Efficiency,energy,energy,9141,"pletes. In PsiAPI mode, one can use the command :py:func:`~psi4.driver.set_options`; like below for general and module-specific options. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function `~psi4.core.clean_options` that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session. ::. psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True,; 'optking__geom_maxiter': 50; }). Basis Sets; ==========. .. toctree::; :maxdepth: 2. basissets. .. _`sec:psiVariables`:. PSI Variables; =============. To harness the power of Python, |PSIfour| makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H\ :sub:`2` and H atom::. molecule h2 {; H; H 1 0.9; }; ; set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'); ; molecule h {; H; }; ; set basis cc-pvdz; set reference uhf; h_energy = energy('scf'); ; D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The :py:func:`~psi4.driver.energy` function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation. Generally, there are multiple quantities of interest. Appendix; :ref:`apdx:psivariables_module` lists PSI variables variables set by each; module, and :ref:`apdx:psivariables_alpha` defines them. These can be; accessed through the :py:func:`~psi4.core.get_variable` function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available::. e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the cour",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:9229,Energy Efficiency,energy,energy,9229,"pletes. In PsiAPI mode, one can use the command :py:func:`~psi4.driver.set_options`; like below for general and module-specific options. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function `~psi4.core.clean_options` that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session. ::. psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True,; 'optking__geom_maxiter': 50; }). Basis Sets; ==========. .. toctree::; :maxdepth: 2. basissets. .. _`sec:psiVariables`:. PSI Variables; =============. To harness the power of Python, |PSIfour| makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H\ :sub:`2` and H atom::. molecule h2 {; H; H 1 0.9; }; ; set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'); ; molecule h {; H; }; ; set basis cc-pvdz; set reference uhf; h_energy = energy('scf'); ; D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The :py:func:`~psi4.driver.energy` function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation. Generally, there are multiple quantities of interest. Appendix; :ref:`apdx:psivariables_module` lists PSI variables variables set by each; module, and :ref:`apdx:psivariables_alpha` defines them. These can be; accessed through the :py:func:`~psi4.core.get_variable` function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available::. e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the cour",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:9348,Energy Efficiency,energy,energy,9348,"or floats like; convergences. The function `~psi4.core.clean_options` that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session. ::. psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True,; 'optking__geom_maxiter': 50; }). Basis Sets; ==========. .. toctree::; :maxdepth: 2. basissets. .. _`sec:psiVariables`:. PSI Variables; =============. To harness the power of Python, |PSIfour| makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H\ :sub:`2` and H atom::. molecule h2 {; H; H 1 0.9; }; ; set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'); ; molecule h {; H; }; ; set basis cc-pvdz; set reference uhf; h_energy = energy('scf'); ; D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The :py:func:`~psi4.driver.energy` function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation. Generally, there are multiple quantities of interest. Appendix; :ref:`apdx:psivariables_module` lists PSI variables variables set by each; module, and :ref:`apdx:psivariables_alpha` defines them. These can be; accessed through the :py:func:`~psi4.core.get_variable` function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available::. e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command :py:func:`~psi4.core.print_variables`. Note that PSI variables; are cleared at the start of each :py:func:`~psi4.",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:9431,Energy Efficiency,energy,energy,9431,"or floats like; convergences. The function `~psi4.core.clean_options` that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session. ::. psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True,; 'optking__geom_maxiter': 50; }). Basis Sets; ==========. .. toctree::; :maxdepth: 2. basissets. .. _`sec:psiVariables`:. PSI Variables; =============. To harness the power of Python, |PSIfour| makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H\ :sub:`2` and H atom::. molecule h2 {; H; H 1 0.9; }; ; set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'); ; molecule h {; H; }; ; set basis cc-pvdz; set reference uhf; h_energy = energy('scf'); ; D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The :py:func:`~psi4.driver.energy` function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation. Generally, there are multiple quantities of interest. Appendix; :ref:`apdx:psivariables_module` lists PSI variables variables set by each; module, and :ref:`apdx:psivariables_alpha` defines them. These can be; accessed through the :py:func:`~psi4.core.get_variable` function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available::. e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command :py:func:`~psi4.core.print_variables`. Note that PSI variables; are cleared at the start of each :py:func:`~psi4.",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:9545,Energy Efficiency,energy,energy,9545,"calculations in a PsiAPI; session. ::. psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True,; 'optking__geom_maxiter': 50; }). Basis Sets; ==========. .. toctree::; :maxdepth: 2. basissets. .. _`sec:psiVariables`:. PSI Variables; =============. To harness the power of Python, |PSIfour| makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H\ :sub:`2` and H atom::. molecule h2 {; H; H 1 0.9; }; ; set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'); ; molecule h {; H; }; ; set basis cc-pvdz; set reference uhf; h_energy = energy('scf'); ; D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The :py:func:`~psi4.driver.energy` function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation. Generally, there are multiple quantities of interest. Appendix; :ref:`apdx:psivariables_module` lists PSI variables variables set by each; module, and :ref:`apdx:psivariables_alpha` defines them. These can be; accessed through the :py:func:`~psi4.core.get_variable` function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available::. e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command :py:func:`~psi4.core.print_variables`. Note that PSI variables; are cleared at the start of each :py:func:`~psi4.driver.energy`, etc. in an input; file by :py:func:`~psi4.core.clean_variables()`.; So if you run in a single input file a STO-3G FCI",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:9988,Energy Efficiency,energy,energy,9988,"essing. To demonstrate, we can embellish the previous example of; H\ :sub:`2` and H atom::. molecule h2 {; H; H 1 0.9; }; ; set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'); ; molecule h {; H; }; ; set basis cc-pvdz; set reference uhf; h_energy = energy('scf'); ; D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The :py:func:`~psi4.driver.energy` function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation. Generally, there are multiple quantities of interest. Appendix; :ref:`apdx:psivariables_module` lists PSI variables variables set by each; module, and :ref:`apdx:psivariables_alpha` defines them. These can be; accessed through the :py:func:`~psi4.core.get_variable` function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available::. e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command :py:func:`~psi4.core.print_variables`. Note that PSI variables; are cleared at the start of each :py:func:`~psi4.driver.energy`, etc. in an input; file by :py:func:`~psi4.core.clean_variables()`.; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a :py:func:`~psi4.core.print_variables` command, the; last will include :psivar:`SCF TOTAL ENERGY` but not; :psivar:`FCI TOTAL ENERGY`.; The entire dictionary of PSI variables can be obtained through; :py:func:`~psi4.core.get_variables`. .. _`sec:returnvals`:. Return Values; =============. Most of the usual user computation functions (*i.e.*,; :py:func:`~psi4.driver.en",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:10016,Energy Efficiency,energy,energy,10016,"essing. To demonstrate, we can embellish the previous example of; H\ :sub:`2` and H atom::. molecule h2 {; H; H 1 0.9; }; ; set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'); ; molecule h {; H; }; ; set basis cc-pvdz; set reference uhf; h_energy = energy('scf'); ; D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The :py:func:`~psi4.driver.energy` function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation. Generally, there are multiple quantities of interest. Appendix; :ref:`apdx:psivariables_module` lists PSI variables variables set by each; module, and :ref:`apdx:psivariables_alpha` defines them. These can be; accessed through the :py:func:`~psi4.core.get_variable` function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available::. e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command :py:func:`~psi4.core.print_variables`. Note that PSI variables; are cleared at the start of each :py:func:`~psi4.driver.energy`, etc. in an input; file by :py:func:`~psi4.core.clean_variables()`.; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a :py:func:`~psi4.core.print_variables` command, the; last will include :psivar:`SCF TOTAL ENERGY` but not; :psivar:`FCI TOTAL ENERGY`.; The entire dictionary of PSI variables can be obtained through; :py:func:`~psi4.core.get_variables`. .. _`sec:returnvals`:. Return Values; =============. Most of the usual user computation functions (*i.e.*,; :py:func:`~psi4.driver.en",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:10426,Energy Efficiency,energy,energy,10426,"nergy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation. Generally, there are multiple quantities of interest. Appendix; :ref:`apdx:psivariables_module` lists PSI variables variables set by each; module, and :ref:`apdx:psivariables_alpha` defines them. These can be; accessed through the :py:func:`~psi4.core.get_variable` function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available::. e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command :py:func:`~psi4.core.print_variables`. Note that PSI variables; are cleared at the start of each :py:func:`~psi4.driver.energy`, etc. in an input; file by :py:func:`~psi4.core.clean_variables()`.; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a :py:func:`~psi4.core.print_variables` command, the; last will include :psivar:`SCF TOTAL ENERGY` but not; :psivar:`FCI TOTAL ENERGY`.; The entire dictionary of PSI variables can be obtained through; :py:func:`~psi4.core.get_variables`. .. _`sec:returnvals`:. Return Values; =============. Most of the usual user computation functions (*i.e.*,; :py:func:`~psi4.driver.energy`, :py:func:`~psi4.driver.optimize`, and; :py:func:`~psi4.driver.frequency`) return simply the current total energy.; Consult the descriptions of other functions in :ref:`sec:psithonFunc` for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions. ::. # E is total energy float; # G is gradient array; # H is hessian array; # wfn is",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:10965,Energy Efficiency,energy,energy,10965,"nt; scaled energy and the unscaled MP2 energy are made available::. e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command :py:func:`~psi4.core.print_variables`. Note that PSI variables; are cleared at the start of each :py:func:`~psi4.driver.energy`, etc. in an input; file by :py:func:`~psi4.core.clean_variables()`.; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a :py:func:`~psi4.core.print_variables` command, the; last will include :psivar:`SCF TOTAL ENERGY` but not; :psivar:`FCI TOTAL ENERGY`.; The entire dictionary of PSI variables can be obtained through; :py:func:`~psi4.core.get_variables`. .. _`sec:returnvals`:. Return Values; =============. Most of the usual user computation functions (*i.e.*,; :py:func:`~psi4.driver.energy`, :py:func:`~psi4.driver.optimize`, and; :py:func:`~psi4.driver.frequency`) return simply the current total energy.; Consult the descriptions of other functions in :ref:`sec:psithonFunc` for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions. ::. # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; ``return_wfn=True`` keyword argument additionally returns; :py:class:`~psi4.core.Wavefunction`. ::. # power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:11080,Energy Efficiency,energy,energy,11080,"able('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command :py:func:`~psi4.core.print_variables`. Note that PSI variables; are cleared at the start of each :py:func:`~psi4.driver.energy`, etc. in an input; file by :py:func:`~psi4.core.clean_variables()`.; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a :py:func:`~psi4.core.print_variables` command, the; last will include :psivar:`SCF TOTAL ENERGY` but not; :psivar:`FCI TOTAL ENERGY`.; The entire dictionary of PSI variables can be obtained through; :py:func:`~psi4.core.get_variables`. .. _`sec:returnvals`:. Return Values; =============. Most of the usual user computation functions (*i.e.*,; :py:func:`~psi4.driver.energy`, :py:func:`~psi4.driver.optimize`, and; :py:func:`~psi4.driver.frequency`) return simply the current total energy.; Consult the descriptions of other functions in :ref:`sec:psithonFunc` for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions. ::. # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; ``return_wfn=True`` keyword argument additionally returns; :py:class:`~psi4.core.Wavefunction`. ::. # power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency()",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:11366,Energy Efficiency,energy,energy,11366,"i4.driver.energy`, etc. in an input; file by :py:func:`~psi4.core.clean_variables()`.; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a :py:func:`~psi4.core.print_variables` command, the; last will include :psivar:`SCF TOTAL ENERGY` but not; :psivar:`FCI TOTAL ENERGY`.; The entire dictionary of PSI variables can be obtained through; :py:func:`~psi4.core.get_variables`. .. _`sec:returnvals`:. Return Values; =============. Most of the usual user computation functions (*i.e.*,; :py:func:`~psi4.driver.energy`, :py:func:`~psi4.driver.optimize`, and; :py:func:`~psi4.driver.frequency`) return simply the current total energy.; Consult the descriptions of other functions in :ref:`sec:psithonFunc` for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions. ::. # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; ``return_wfn=True`` keyword argument additionally returns; :py:class:`~psi4.core.Wavefunction`. ::. # power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). .. _`sec:loops`:. Loops; =====. Python provides many control structures, any of which can be used within |PSIfour|; input files. For examp",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:11504,Energy Efficiency,energy,energy,11504,"s()`.; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a :py:func:`~psi4.core.print_variables` command, the; last will include :psivar:`SCF TOTAL ENERGY` but not; :psivar:`FCI TOTAL ENERGY`.; The entire dictionary of PSI variables can be obtained through; :py:func:`~psi4.core.get_variables`. .. _`sec:returnvals`:. Return Values; =============. Most of the usual user computation functions (*i.e.*,; :py:func:`~psi4.driver.energy`, :py:func:`~psi4.driver.optimize`, and; :py:func:`~psi4.driver.frequency`) return simply the current total energy.; Consult the descriptions of other functions in :ref:`sec:psithonFunc` for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions. ::. # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; ``return_wfn=True`` keyword argument additionally returns; :py:class:`~psi4.core.Wavefunction`. ::. # power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). .. _`sec:loops`:. Loops; =====. Python provides many control structures, any of which can be used within |PSIfour|; input files. For example, to loop over three basis sets, the following code can; be used:. .. code-blo",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:11798,Energy Efficiency,power,power,11798,"re.get_variables`. .. _`sec:returnvals`:. Return Values; =============. Most of the usual user computation functions (*i.e.*,; :py:func:`~psi4.driver.energy`, :py:func:`~psi4.driver.optimize`, and; :py:func:`~psi4.driver.frequency`) return simply the current total energy.; Consult the descriptions of other functions in :ref:`sec:psithonFunc` for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions. ::. # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; ``return_wfn=True`` keyword argument additionally returns; :py:class:`~psi4.core.Wavefunction`. ::. # power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). .. _`sec:loops`:. Loops; =====. Python provides many control structures, any of which can be used within |PSIfour|; input files. For example, to loop over three basis sets, the following code can; be used:. .. code-block:: none. basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of ``basis_sets`` is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by def",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:11827,Energy Efficiency,energy,energy,11827,"re.get_variables`. .. _`sec:returnvals`:. Return Values; =============. Most of the usual user computation functions (*i.e.*,; :py:func:`~psi4.driver.energy`, :py:func:`~psi4.driver.optimize`, and; :py:func:`~psi4.driver.frequency`) return simply the current total energy.; Consult the descriptions of other functions in :ref:`sec:psithonFunc` for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions. ::. # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; ``return_wfn=True`` keyword argument additionally returns; :py:class:`~psi4.core.Wavefunction`. ::. # power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). .. _`sec:loops`:. Loops; =====. Python provides many control structures, any of which can be used within |PSIfour|; input files. For example, to loop over three basis sets, the following code can; be used:. .. code-block:: none. basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of ``basis_sets`` is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by def",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:12610,Energy Efficiency,energy,energy,12610,"ent(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; ``return_wfn=True`` keyword argument additionally returns; :py:class:`~psi4.core.Wavefunction`. ::. # power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). .. _`sec:loops`:. Loops; =====. Python provides many control structures, any of which can be used within |PSIfour|; input files. For example, to loop over three basis sets, the following code can; be used:. .. code-block:: none. basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of ``basis_sets`` is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that ``basis_set`` is a; Python variable, not a string, by prefixing it with a dollar sign. . The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water::. molecule h2o{; O; H 1 R; H 1 R 2 A; }; ; Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2); ; set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of ``Rvals`` and ``Avals`` are both completely standard Python syntax.; Having named our molecule ``h2o`` we can then set the values of ``R`` and ``A`` within; the loops. Note that we do not need the dollar sign to access",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:13031,Energy Efficiency,energy,energy,13031,"y optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). .. _`sec:loops`:. Loops; =====. Python provides many control structures, any of which can be used within |PSIfour|; input files. For example, to loop over three basis sets, the following code can; be used:. .. code-block:: none. basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of ``basis_sets`` is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that ``basis_set`` is a; Python variable, not a string, by prefixing it with a dollar sign. . The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water::. molecule h2o{; O; H 1 R; H 1 R 2 A; }; ; Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2); ; set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of ``Rvals`` and ``Avals`` are both completely standard Python syntax.; Having named our molecule ``h2o`` we can then set the values of ``R`` and ``A`` within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the ``set`` keyword. Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See :srcsample:`scf4` for analogous Z-matrix; and Cartiesian scans. .. _`sec:resultsTables`:. Tables of Results; =================",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:13313,Energy Efficiency,energy,energy,13313,"n provides many control structures, any of which can be used within |PSIfour|; input files. For example, to loop over three basis sets, the following code can; be used:. .. code-block:: none. basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of ``basis_sets`` is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that ``basis_set`` is a; Python variable, not a string, by prefixing it with a dollar sign. . The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water::. molecule h2o{; O; H 1 R; H 1 R 2 A; }; ; Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2); ; set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of ``Rvals`` and ``Avals`` are both completely standard Python syntax.; Having named our molecule ``h2o`` we can then set the values of ``R`` and ``A`` within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the ``set`` keyword. Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See :srcsample:`scf4` for analogous Z-matrix; and Cartiesian scans. .. _`sec:resultsTables`:. Tables of Results; =================. The Psithon function ``psi4.driver.p4util.Table`` has been removed,; as the Python ecosystem provides many more flexible alternatives. An; example tabulating a potential energy surface scan for water with Pandas; is shown below::. molecule h2o {; O; H 1 R; H 1 R 2 A; }; ; Rvals=[0.9,1.0,1.1]; Avals=range(100,103,2); ; rows =",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:14161,Energy Efficiency,energy,energy,14161,"0, 1.1]; Avals = range(102, 106, 2); ; set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of ``Rvals`` and ``Avals`` are both completely standard Python syntax.; Having named our molecule ``h2o`` we can then set the values of ``R`` and ``A`` within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the ``set`` keyword. Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See :srcsample:`scf4` for analogous Z-matrix; and Cartiesian scans. .. _`sec:resultsTables`:. Tables of Results; =================. The Psithon function ``psi4.driver.p4util.Table`` has been removed,; as the Python ecosystem provides many more flexible alternatives. An; example tabulating a potential energy surface scan for water with Pandas; is shown below::. molecule h2o {; O; H 1 R; H 1 R 2 A; }; ; Rvals=[0.9,1.0,1.1]; Avals=range(100,103,2); ; rows = []; table = []; ; set basis cc-pvdz; ; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = variable('SCF TOTAL ENERGY'); edfmp2 = variable('MP2 TOTAL ENERGY'); escsmp2 = variable('SCS-MP2 TOTAL ENERGY'); rows.append((R, A)); table.append([escf, escsmp2, edfmp2]); ; import pandas as pd; df = pd.DataFrame(table, columns = [""E(SCF)"", ""E(SCS)"", ""E(DFMP2)""], index=rows); print(df). # E(SCF) E(SCS) E(DFMP2); # (0.9, 100) -76.020680 -76.217006 -76.221189; # (0.9, 102) -76.021305 -76.217439 -76.221605; # (1.0, 100) -76.021264 -76.224987 -76.228727; # (1.0, 102) -76.021460 -76.224946 -76.228668; # (1.1, 100) -75.990195 -76.201891 -76.205087; # (1.1, 102) -75.990085 -76.201498 -76.204676. .. _`sec:wrappers`:. Python Wrappers; ===============. The Python foundations of the |PSIfour| driver and Psithon syntax permit; many commonl",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:14413,Energy Efficiency,energy,energy,14413,"f ``R`` and ``A`` within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the ``set`` keyword. Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See :srcsample:`scf4` for analogous Z-matrix; and Cartiesian scans. .. _`sec:resultsTables`:. Tables of Results; =================. The Psithon function ``psi4.driver.p4util.Table`` has been removed,; as the Python ecosystem provides many more flexible alternatives. An; example tabulating a potential energy surface scan for water with Pandas; is shown below::. molecule h2o {; O; H 1 R; H 1 R 2 A; }; ; Rvals=[0.9,1.0,1.1]; Avals=range(100,103,2); ; rows = []; table = []; ; set basis cc-pvdz; ; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = variable('SCF TOTAL ENERGY'); edfmp2 = variable('MP2 TOTAL ENERGY'); escsmp2 = variable('SCS-MP2 TOTAL ENERGY'); rows.append((R, A)); table.append([escf, escsmp2, edfmp2]); ; import pandas as pd; df = pd.DataFrame(table, columns = [""E(SCF)"", ""E(SCS)"", ""E(DFMP2)""], index=rows); print(df). # E(SCF) E(SCS) E(DFMP2); # (0.9, 100) -76.020680 -76.217006 -76.221189; # (0.9, 102) -76.021305 -76.217439 -76.221605; # (1.0, 100) -76.021264 -76.224987 -76.228727; # (1.0, 102) -76.021460 -76.224946 -76.228668; # (1.1, 100) -75.990195 -76.201891 -76.205087; # (1.1, 102) -75.990085 -76.201498 -76.204676. .. _`sec:wrappers`:. Python Wrappers; ===============. The Python foundations of the |PSIfour| driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the |PSIfour| suite. . As seen in the neon dimer example from the :ref:`tutorial <sec:tutorial>` section,; the :py:func:`~psi4.driver.driver_nbody.nbody` wrapper provides automatic computation of; counterpoise-corrected interaction energies betw",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:15517,Energy Efficiency,energy,energy,15517," TOTAL ENERGY'); rows.append((R, A)); table.append([escf, escsmp2, edfmp2]); ; import pandas as pd; df = pd.DataFrame(table, columns = [""E(SCF)"", ""E(SCS)"", ""E(DFMP2)""], index=rows); print(df). # E(SCF) E(SCS) E(DFMP2); # (0.9, 100) -76.020680 -76.217006 -76.221189; # (0.9, 102) -76.021305 -76.217439 -76.221605; # (1.0, 100) -76.021264 -76.224987 -76.228727; # (1.0, 102) -76.021460 -76.224946 -76.228668; # (1.1, 100) -75.990195 -76.201891 -76.205087; # (1.1, 102) -75.990085 -76.201498 -76.204676. .. _`sec:wrappers`:. Python Wrappers; ===============. The Python foundations of the |PSIfour| driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the |PSIfour| suite. . As seen in the neon dimer example from the :ref:`tutorial <sec:tutorial>` section,; the :py:func:`~psi4.driver.driver_nbody.nbody` wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example, ::. energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules. |PSIfour| also provides the :py:func:`~psi4.driver.cbs` wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,::. # all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree--Fock energy in the; largest basis (cc-pVTZ). :py:func:`~psi4.driver.cbs` can; be configured behind-the-scenes with explicit arguments, as in the; first example, or the convenience syntax of the equivalent second; example can be used. Another very useful and powerful feature of |PSIfour| is the ability; to compute re",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:15619,Energy Efficiency,energy,energy,15619,"edfmp2]); ; import pandas as pd; df = pd.DataFrame(table, columns = [""E(SCF)"", ""E(SCS)"", ""E(DFMP2)""], index=rows); print(df). # E(SCF) E(SCS) E(DFMP2); # (0.9, 100) -76.020680 -76.217006 -76.221189; # (0.9, 102) -76.021305 -76.217439 -76.221605; # (1.0, 100) -76.021264 -76.224987 -76.228727; # (1.0, 102) -76.021460 -76.224946 -76.228668; # (1.1, 100) -75.990195 -76.201891 -76.205087; # (1.1, 102) -75.990085 -76.201498 -76.204676. .. _`sec:wrappers`:. Python Wrappers; ===============. The Python foundations of the |PSIfour| driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the |PSIfour| suite. . As seen in the neon dimer example from the :ref:`tutorial <sec:tutorial>` section,; the :py:func:`~psi4.driver.driver_nbody.nbody` wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example, ::. energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules. |PSIfour| also provides the :py:func:`~psi4.driver.cbs` wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,::. # all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree--Fock energy in the; largest basis (cc-pVTZ). :py:func:`~psi4.driver.cbs` can; be configured behind-the-scenes with explicit arguments, as in the; first example, or the convenience syntax of the equivalent second; example can be used. Another very useful and powerful feature of |PSIfour| is the ability; to compute results on entire databases of molecules at a time,; as provided by ",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:15921,Energy Efficiency,energy,energy,15921,"0195 -76.201891 -76.205087; # (1.1, 102) -75.990085 -76.201498 -76.204676. .. _`sec:wrappers`:. Python Wrappers; ===============. The Python foundations of the |PSIfour| driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the |PSIfour| suite. . As seen in the neon dimer example from the :ref:`tutorial <sec:tutorial>` section,; the :py:func:`~psi4.driver.driver_nbody.nbody` wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example, ::. energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules. |PSIfour| also provides the :py:func:`~psi4.driver.cbs` wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,::. # all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree--Fock energy in the; largest basis (cc-pVTZ). :py:func:`~psi4.driver.cbs` can; be configured behind-the-scenes with explicit arguments, as in the; first example, or the convenience syntax of the equivalent second; example can be used. Another very useful and powerful feature of |PSIfour| is the ability; to compute results on entire databases of molecules at a time,; as provided by the :py:func:`~psi4.driver.wrapper_database.database` wrapper. For example,::. database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (``cp=1``) on all members of Hobza's S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases i",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:15995,Energy Efficiency,energy,energy,15995,"5 -76.201498 -76.204676. .. _`sec:wrappers`:. Python Wrappers; ===============. The Python foundations of the |PSIfour| driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the |PSIfour| suite. . As seen in the neon dimer example from the :ref:`tutorial <sec:tutorial>` section,; the :py:func:`~psi4.driver.driver_nbody.nbody` wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example, ::. energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules. |PSIfour| also provides the :py:func:`~psi4.driver.cbs` wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,::. # all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree--Fock energy in the; largest basis (cc-pVTZ). :py:func:`~psi4.driver.cbs` can; be configured behind-the-scenes with explicit arguments, as in the; first example, or the convenience syntax of the equivalent second; example can be used. Another very useful and powerful feature of |PSIfour| is the ability; to compute results on entire databases of molecules at a time,; as provided by the :py:func:`~psi4.driver.wrapper_database.database` wrapper. For example,::. database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (``cp=1``) on all members of Hobza's S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSC",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:16086,Energy Efficiency,energy,energy,16086,"sithon syntax permit; many commonly performed post-processing procedures to be integrated into; the |PSIfour| suite. . As seen in the neon dimer example from the :ref:`tutorial <sec:tutorial>` section,; the :py:func:`~psi4.driver.driver_nbody.nbody` wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example, ::. energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules. |PSIfour| also provides the :py:func:`~psi4.driver.cbs` wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,::. # all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree--Fock energy in the; largest basis (cc-pVTZ). :py:func:`~psi4.driver.cbs` can; be configured behind-the-scenes with explicit arguments, as in the; first example, or the convenience syntax of the equivalent second; example can be used. Another very useful and powerful feature of |PSIfour| is the ability; to compute results on entire databases of molecules at a time,; as provided by the :py:func:`~psi4.driver.wrapper_database.database` wrapper. For example,::. database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (``cp=1``) on all members of Hobza's S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others. These wrapper functions are discussed separately in; :ref:`sec:psithonFunc`. Note that th",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:16192,Energy Efficiency,energy,energy,16192,"sithon syntax permit; many commonly performed post-processing procedures to be integrated into; the |PSIfour| suite. . As seen in the neon dimer example from the :ref:`tutorial <sec:tutorial>` section,; the :py:func:`~psi4.driver.driver_nbody.nbody` wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example, ::. energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules. |PSIfour| also provides the :py:func:`~psi4.driver.cbs` wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,::. # all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree--Fock energy in the; largest basis (cc-pVTZ). :py:func:`~psi4.driver.cbs` can; be configured behind-the-scenes with explicit arguments, as in the; first example, or the convenience syntax of the equivalent second; example can be used. Another very useful and powerful feature of |PSIfour| is the ability; to compute results on entire databases of molecules at a time,; as provided by the :py:func:`~psi4.driver.wrapper_database.database` wrapper. For example,::. database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (``cp=1``) on all members of Hobza's S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others. These wrapper functions are discussed separately in; :ref:`sec:psithonFunc`. Note that th",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:16220,Energy Efficiency,energy,energy,16220,"sithon syntax permit; many commonly performed post-processing procedures to be integrated into; the |PSIfour| suite. . As seen in the neon dimer example from the :ref:`tutorial <sec:tutorial>` section,; the :py:func:`~psi4.driver.driver_nbody.nbody` wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example, ::. energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules. |PSIfour| also provides the :py:func:`~psi4.driver.cbs` wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,::. # all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree--Fock energy in the; largest basis (cc-pVTZ). :py:func:`~psi4.driver.cbs` can; be configured behind-the-scenes with explicit arguments, as in the; first example, or the convenience syntax of the equivalent second; example can be used. Another very useful and powerful feature of |PSIfour| is the ability; to compute results on entire databases of molecules at a time,; as provided by the :py:func:`~psi4.driver.wrapper_database.database` wrapper. For example,::. database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (``cp=1``) on all members of Hobza's S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others. These wrapper functions are discussed separately in; :ref:`sec:psithonFunc`. Note that th",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:16473,Energy Efficiency,power,powerful,16473,"l <sec:tutorial>` section,; the :py:func:`~psi4.driver.driver_nbody.nbody` wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example, ::. energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules. |PSIfour| also provides the :py:func:`~psi4.driver.cbs` wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,::. # all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree--Fock energy in the; largest basis (cc-pVTZ). :py:func:`~psi4.driver.cbs` can; be configured behind-the-scenes with explicit arguments, as in the; first example, or the convenience syntax of the equivalent second; example can be used. Another very useful and powerful feature of |PSIfour| is the ability; to compute results on entire databases of molecules at a time,; as provided by the :py:func:`~psi4.driver.wrapper_database.database` wrapper. For example,::. database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (``cp=1``) on all members of Hobza's S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others. These wrapper functions are discussed separately in; :ref:`sec:psithonFunc`. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the ``set {...}`` block or with any other ``set`` command. ",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:6532,Integrability,wrap,wraps,6532,"f:`sec:usingEFPFragments`. To add EFP fragments to a molecule, see :ref:`sec:usingEFPFragments`. .. index::; triple: setting; keywords; general; .. _`sec:jobControl`:. Job Control Keywords; ====================. |PSIfour| comprises a number of C++ modules that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file which control its function.; These keywords are detailed in Appendix :ref:`apdx:options_c_module`.; The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified::. # all equivalent. set globals basis cc-pVDZ. set basis cc-pVDZ. set globals basis = cc-pVDZ. set basis = cc-pVDZ. set globals{; basis cc-pVDZ; }; ; set {; basis cc-pVDZ; }; ; set {; basis = cc-pVDZ; }. Note the lack of quotes around ``cc-pVDZ``, even though it is a string. The; Psithon preprocessor automatically wraps any string values in ``set`` commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords::. set {; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, *viz.*::. set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening ``[`` is; on the same line as the name of the keyword. Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the ``set`` keyword. Omitting the module; name, or using the name ``global`` or ``globals`` will result in the keyword being; applied to all modules. For example, in the following input ::. molecule{; o; h 1 roh; h 1 roh 2 ahoh; ; roh = 0.957; ahoh = 104.5; }; ; set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccene",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:12785,Integrability,wrap,wraps,12785,"., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). .. _`sec:loops`:. Loops; =====. Python provides many control structures, any of which can be used within |PSIfour|; input files. For example, to loop over three basis sets, the following code can; be used:. .. code-block:: none. basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of ``basis_sets`` is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that ``basis_set`` is a; Python variable, not a string, by prefixing it with a dollar sign. . The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water::. molecule h2o{; O; H 1 R; H 1 R 2 A; }; ; Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2); ; set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of ``Rvals`` and ``Avals`` are both completely standard Python syntax.; Having named our molecule ``h2o`` we can then set the values of ``R`` and ``A`` within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the ``set`` keyword. Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometr",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:15041,Integrability,wrap,wrappers,15041,"s been removed,; as the Python ecosystem provides many more flexible alternatives. An; example tabulating a potential energy surface scan for water with Pandas; is shown below::. molecule h2o {; O; H 1 R; H 1 R 2 A; }; ; Rvals=[0.9,1.0,1.1]; Avals=range(100,103,2); ; rows = []; table = []; ; set basis cc-pvdz; ; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = variable('SCF TOTAL ENERGY'); edfmp2 = variable('MP2 TOTAL ENERGY'); escsmp2 = variable('SCS-MP2 TOTAL ENERGY'); rows.append((R, A)); table.append([escf, escsmp2, edfmp2]); ; import pandas as pd; df = pd.DataFrame(table, columns = [""E(SCF)"", ""E(SCS)"", ""E(DFMP2)""], index=rows); print(df). # E(SCF) E(SCS) E(DFMP2); # (0.9, 100) -76.020680 -76.217006 -76.221189; # (0.9, 102) -76.021305 -76.217439 -76.221605; # (1.0, 100) -76.021264 -76.224987 -76.228727; # (1.0, 102) -76.021460 -76.224946 -76.228668; # (1.1, 100) -75.990195 -76.201891 -76.205087; # (1.1, 102) -75.990085 -76.201498 -76.204676. .. _`sec:wrappers`:. Python Wrappers; ===============. The Python foundations of the |PSIfour| driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the |PSIfour| suite. . As seen in the neon dimer example from the :ref:`tutorial <sec:tutorial>` section,; the :py:func:`~psi4.driver.driver_nbody.nbody` wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example, ::. energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules. |PSIfour| also provides the :py:func:`~psi4.driver.cbs` wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,::. # all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:15218,Integrability,integrat,integrated,15218,"rface scan for water with Pandas; is shown below::. molecule h2o {; O; H 1 R; H 1 R 2 A; }; ; Rvals=[0.9,1.0,1.1]; Avals=range(100,103,2); ; rows = []; table = []; ; set basis cc-pvdz; ; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = variable('SCF TOTAL ENERGY'); edfmp2 = variable('MP2 TOTAL ENERGY'); escsmp2 = variable('SCS-MP2 TOTAL ENERGY'); rows.append((R, A)); table.append([escf, escsmp2, edfmp2]); ; import pandas as pd; df = pd.DataFrame(table, columns = [""E(SCF)"", ""E(SCS)"", ""E(DFMP2)""], index=rows); print(df). # E(SCF) E(SCS) E(DFMP2); # (0.9, 100) -76.020680 -76.217006 -76.221189; # (0.9, 102) -76.021305 -76.217439 -76.221605; # (1.0, 100) -76.021264 -76.224987 -76.228727; # (1.0, 102) -76.021460 -76.224946 -76.228668; # (1.1, 100) -75.990195 -76.201891 -76.205087; # (1.1, 102) -75.990085 -76.201498 -76.204676. .. _`sec:wrappers`:. Python Wrappers; ===============. The Python foundations of the |PSIfour| driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the |PSIfour| suite. . As seen in the neon dimer example from the :ref:`tutorial <sec:tutorial>` section,; the :py:func:`~psi4.driver.driver_nbody.nbody` wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example, ::. energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules. |PSIfour| also provides the :py:func:`~psi4.driver.cbs` wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,::. # all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extr",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:15389,Integrability,wrap,wrapper,15389,"ble('SCF TOTAL ENERGY'); edfmp2 = variable('MP2 TOTAL ENERGY'); escsmp2 = variable('SCS-MP2 TOTAL ENERGY'); rows.append((R, A)); table.append([escf, escsmp2, edfmp2]); ; import pandas as pd; df = pd.DataFrame(table, columns = [""E(SCF)"", ""E(SCS)"", ""E(DFMP2)""], index=rows); print(df). # E(SCF) E(SCS) E(DFMP2); # (0.9, 100) -76.020680 -76.217006 -76.221189; # (0.9, 102) -76.021305 -76.217439 -76.221605; # (1.0, 100) -76.021264 -76.224987 -76.228727; # (1.0, 102) -76.021460 -76.224946 -76.228668; # (1.1, 100) -75.990195 -76.201891 -76.205087; # (1.1, 102) -75.990085 -76.201498 -76.204676. .. _`sec:wrappers`:. Python Wrappers; ===============. The Python foundations of the |PSIfour| driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the |PSIfour| suite. . As seen in the neon dimer example from the :ref:`tutorial <sec:tutorial>` section,; the :py:func:`~psi4.driver.driver_nbody.nbody` wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example, ::. energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules. |PSIfour| also provides the :py:func:`~psi4.driver.cbs` wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,::. # all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree--Fock energy in the; largest basis (cc-pVTZ). :py:func:`~psi4.driver.cbs` can; be configured behind-the-scenes with explicit arguments, as in the; first example, or the convenience syntax of the equivalent second; example can ",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:15706,Integrability,wrap,wrapper,15706,"89; # (0.9, 102) -76.021305 -76.217439 -76.221605; # (1.0, 100) -76.021264 -76.224987 -76.228727; # (1.0, 102) -76.021460 -76.224946 -76.228668; # (1.1, 100) -75.990195 -76.201891 -76.205087; # (1.1, 102) -75.990085 -76.201498 -76.204676. .. _`sec:wrappers`:. Python Wrappers; ===============. The Python foundations of the |PSIfour| driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the |PSIfour| suite. . As seen in the neon dimer example from the :ref:`tutorial <sec:tutorial>` section,; the :py:func:`~psi4.driver.driver_nbody.nbody` wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example, ::. energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules. |PSIfour| also provides the :py:func:`~psi4.driver.cbs` wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,::. # all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree--Fock energy in the; largest basis (cc-pVTZ). :py:func:`~psi4.driver.cbs` can; be configured behind-the-scenes with explicit arguments, as in the; first example, or the convenience syntax of the equivalent second; example can be used. Another very useful and powerful feature of |PSIfour| is the ability; to compute results on entire databases of molecules at a time,; as provided by the :py:func:`~psi4.driver.wrapper_database.database` wrapper. For example,::. database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (``c",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:16652,Integrability,wrap,wrapper,16652,"l <sec:tutorial>` section,; the :py:func:`~psi4.driver.driver_nbody.nbody` wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example, ::. energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules. |PSIfour| also provides the :py:func:`~psi4.driver.cbs` wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,::. # all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree--Fock energy in the; largest basis (cc-pVTZ). :py:func:`~psi4.driver.cbs` can; be configured behind-the-scenes with explicit arguments, as in the; first example, or the convenience syntax of the equivalent second; example can be used. Another very useful and powerful feature of |PSIfour| is the ability; to compute results on entire databases of molecules at a time,; as provided by the :py:func:`~psi4.driver.wrapper_database.database` wrapper. For example,::. database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (``cp=1``) on all members of Hobza's S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others. These wrapper functions are discussed separately in; :ref:`sec:psithonFunc`. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the ``set {...}`` block or with any other ``set`` command. ",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:17057,Integrability,wrap,wrapper,17057,"l <sec:tutorial>` section,; the :py:func:`~psi4.driver.driver_nbody.nbody` wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example, ::. energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules. |PSIfour| also provides the :py:func:`~psi4.driver.cbs` wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,::. # all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree--Fock energy in the; largest basis (cc-pVTZ). :py:func:`~psi4.driver.cbs` can; be configured behind-the-scenes with explicit arguments, as in the; first example, or the convenience syntax of the equivalent second; example can be used. Another very useful and powerful feature of |PSIfour| is the ability; to compute results on entire databases of molecules at a time,; as provided by the :py:func:`~psi4.driver.wrapper_database.database` wrapper. For example,::. database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (``cp=1``) on all members of Hobza's S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others. These wrapper functions are discussed separately in; :ref:`sec:psithonFunc`. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the ``set {...}`` block or with any other ``set`` command. ",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:2156,Modifiability,variab,variables,2156,"=========================. To allow arbitrarily complex computations to be performed, |PSIfour| was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; |PSIfour| is distributed with an extensive test suite, described in section; :ref:`apdx:testSuite`; the input files for these test cases can be found in the; samples subdirectory of the top-level |PSIfour| source directory and should; serve as useful examples. .. index:: physical constants; .. _`sec:physicalConstants`:. Physical Constants; ==================. For convenience, the Python interpreter will execute the contents of the; |psirc| file in the current user's home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the |psirc| file ::. UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable ``UGC`` available in all |PSIfour| input files.; For convenience, the physical constants used within the |PSIfour| code (which; are obtained from `NIST CODATA 2014; <https://physics.nist.gov/cuu/Constants/archive2014.html>`_; are also automatically loaded as Psithon; variables (before |psirc| is loaded, so that the user's |psirc| values can; override the builtins (in the input file, not in the C++ code). The physical constants used within |PSIfour|, which are automatically; made available within all |PSIfour| input files are in :ref:`table:physconst`. .. .. literalinclude:: @SFNX_INCLUDE@psi4/driver/constants/physconst.py; .. :lines: 28-. In Psithon input files, prepend physical constants with ``psi_`` to; prevent clashes with user-d",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:2415,Modifiability,variab,variable,2415,"ng in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; |PSIfour| is distributed with an extensive test suite, described in section; :ref:`apdx:testSuite`; the input files for these test cases can be found in the; samples subdirectory of the top-level |PSIfour| source directory and should; serve as useful examples. .. index:: physical constants; .. _`sec:physicalConstants`:. Physical Constants; ==================. For convenience, the Python interpreter will execute the contents of the; |psirc| file in the current user's home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the |psirc| file ::. UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable ``UGC`` available in all |PSIfour| input files.; For convenience, the physical constants used within the |PSIfour| code (which; are obtained from `NIST CODATA 2014; <https://physics.nist.gov/cuu/Constants/archive2014.html>`_; are also automatically loaded as Psithon; variables (before |psirc| is loaded, so that the user's |psirc| values can; override the builtins (in the input file, not in the C++ code). The physical constants used within |PSIfour|, which are automatically; made available within all |PSIfour| input files are in :ref:`table:physconst`. .. .. literalinclude:: @SFNX_INCLUDE@psi4/driver/constants/physconst.py; .. :lines: 28-. In Psithon input files, prepend physical constants with ``psi_`` to; prevent clashes with user-defined variables (*e.g.*, ``psi_h``). In; PsiAPI mode, access as, *e.g.*, ``psi4.constants.h``. .. index:: memory; .. _`sec:memory`:. Memory Specification; ====================. By default, |PSIfour| assumes that 500 MiB of memory are available. While this is; enou",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:2692,Modifiability,variab,variables,2692," samples subdirectory of the top-level |PSIfour| source directory and should; serve as useful examples. .. index:: physical constants; .. _`sec:physicalConstants`:. Physical Constants; ==================. For convenience, the Python interpreter will execute the contents of the; |psirc| file in the current user's home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the |psirc| file ::. UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable ``UGC`` available in all |PSIfour| input files.; For convenience, the physical constants used within the |PSIfour| code (which; are obtained from `NIST CODATA 2014; <https://physics.nist.gov/cuu/Constants/archive2014.html>`_; are also automatically loaded as Psithon; variables (before |psirc| is loaded, so that the user's |psirc| values can; override the builtins (in the input file, not in the C++ code). The physical constants used within |PSIfour|, which are automatically; made available within all |PSIfour| input files are in :ref:`table:physconst`. .. .. literalinclude:: @SFNX_INCLUDE@psi4/driver/constants/physconst.py; .. :lines: 28-. In Psithon input files, prepend physical constants with ``psi_`` to; prevent clashes with user-defined variables (*e.g.*, ``psi_h``). In; PsiAPI mode, access as, *e.g.*, ``psi4.constants.h``. .. index:: memory; .. _`sec:memory`:. Memory Specification; ====================. By default, |PSIfour| assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the ``memory`` keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to |PSIfour|::. # all equivalent. memory 2 GB; ; memory 2000",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:3174,Modifiability,variab,variables,3174,"ows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the |psirc| file ::. UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable ``UGC`` available in all |PSIfour| input files.; For convenience, the physical constants used within the |PSIfour| code (which; are obtained from `NIST CODATA 2014; <https://physics.nist.gov/cuu/Constants/archive2014.html>`_; are also automatically loaded as Psithon; variables (before |psirc| is loaded, so that the user's |psirc| values can; override the builtins (in the input file, not in the C++ code). The physical constants used within |PSIfour|, which are automatically; made available within all |PSIfour| input files are in :ref:`table:physconst`. .. .. literalinclude:: @SFNX_INCLUDE@psi4/driver/constants/physconst.py; .. :lines: 28-. In Psithon input files, prepend physical constants with ``psi_`` to; prevent clashes with user-defined variables (*e.g.*, ``psi_h``). In; PsiAPI mode, access as, *e.g.*, ``psi4.constants.h``. .. index:: memory; .. _`sec:memory`:. Memory Specification; ====================. By default, |PSIfour| assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the ``memory`` keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to |PSIfour|::. # all equivalent. memory 2 GB; ; memory 2000 MB; ; memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). |PSIfour| recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB). By default, |PSIfour| performs a ""sanity check"" when parsing Psithon input files, enforcing a minimum memory requirement of ",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:9480,Modifiability,variab,variable,9480,"or floats like; convergences. The function `~psi4.core.clean_options` that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session. ::. psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True,; 'optking__geom_maxiter': 50; }). Basis Sets; ==========. .. toctree::; :maxdepth: 2. basissets. .. _`sec:psiVariables`:. PSI Variables; =============. To harness the power of Python, |PSIfour| makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H\ :sub:`2` and H atom::. molecule h2 {; H; H 1 0.9; }; ; set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'); ; molecule h {; H; }; ; set basis cc-pvdz; set reference uhf; h_energy = energy('scf'); ; D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The :py:func:`~psi4.driver.energy` function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation. Generally, there are multiple quantities of interest. Appendix; :ref:`apdx:psivariables_module` lists PSI variables variables set by each; module, and :ref:`apdx:psivariables_alpha` defines them. These can be; accessed through the :py:func:`~psi4.core.get_variable` function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available::. e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command :py:func:`~psi4.core.print_variables`. Note that PSI variables; are cleared at the start of each :py:func:`~psi4.",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:9721,Modifiability,variab,variables,9721,"; :maxdepth: 2. basissets. .. _`sec:psiVariables`:. PSI Variables; =============. To harness the power of Python, |PSIfour| makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H\ :sub:`2` and H atom::. molecule h2 {; H; H 1 0.9; }; ; set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'); ; molecule h {; H; }; ; set basis cc-pvdz; set reference uhf; h_energy = energy('scf'); ; D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The :py:func:`~psi4.driver.energy` function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation. Generally, there are multiple quantities of interest. Appendix; :ref:`apdx:psivariables_module` lists PSI variables variables set by each; module, and :ref:`apdx:psivariables_alpha` defines them. These can be; accessed through the :py:func:`~psi4.core.get_variable` function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available::. e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command :py:func:`~psi4.core.print_variables`. Note that PSI variables; are cleared at the start of each :py:func:`~psi4.driver.energy`, etc. in an input; file by :py:func:`~psi4.core.clean_variables()`.; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a :py:func:`~psi4.core.print_variables` command, the; last will include :psivar:`SCF TOTAL ENERGY` but not; :psivar:`FCI TOTAL ENERGY`.; The en",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:9731,Modifiability,variab,variables,9731,"; :maxdepth: 2. basissets. .. _`sec:psiVariables`:. PSI Variables; =============. To harness the power of Python, |PSIfour| makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H\ :sub:`2` and H atom::. molecule h2 {; H; H 1 0.9; }; ; set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'); ; molecule h {; H; }; ; set basis cc-pvdz; set reference uhf; h_energy = energy('scf'); ; D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The :py:func:`~psi4.driver.energy` function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation. Generally, there are multiple quantities of interest. Appendix; :ref:`apdx:psivariables_module` lists PSI variables variables set by each; module, and :ref:`apdx:psivariables_alpha` defines them. These can be; accessed through the :py:func:`~psi4.core.get_variable` function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available::. e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command :py:func:`~psi4.core.print_variables`. Note that PSI variables; are cleared at the start of each :py:func:`~psi4.driver.energy`, etc. in an input; file by :py:func:`~psi4.core.clean_variables()`.; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a :py:func:`~psi4.core.print_variables` command, the; last will include :psivar:`SCF TOTAL ENERGY` but not; :psivar:`FCI TOTAL ENERGY`.; The en",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:10179,Modifiability,variab,variables,10179," set basis cc-pvdz; set reference uhf; h_energy = energy('scf'); ; D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The :py:func:`~psi4.driver.energy` function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation. Generally, there are multiple quantities of interest. Appendix; :ref:`apdx:psivariables_module` lists PSI variables variables set by each; module, and :ref:`apdx:psivariables_alpha` defines them. These can be; accessed through the :py:func:`~psi4.core.get_variable` function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available::. e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command :py:func:`~psi4.core.print_variables`. Note that PSI variables; are cleared at the start of each :py:func:`~psi4.driver.energy`, etc. in an input; file by :py:func:`~psi4.core.clean_variables()`.; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a :py:func:`~psi4.core.print_variables` command, the; last will include :psivar:`SCF TOTAL ENERGY` but not; :psivar:`FCI TOTAL ENERGY`.; The entire dictionary of PSI variables can be obtained through; :py:func:`~psi4.core.get_variables`. .. _`sec:returnvals`:. Return Values; =============. Most of the usual user computation functions (*i.e.*,; :py:func:`~psi4.driver.energy`, :py:func:`~psi4.driver.optimize`, and; :py:func:`~psi4.driver.frequency`) return simply the current total energy.; Consult the descriptions of other functions in :ref:`sec:psithonFunc` for; what quantities ",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:10359,Modifiability,variab,variables,10359,"l result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation. Generally, there are multiple quantities of interest. Appendix; :ref:`apdx:psivariables_module` lists PSI variables variables set by each; module, and :ref:`apdx:psivariables_alpha` defines them. These can be; accessed through the :py:func:`~psi4.core.get_variable` function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available::. e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command :py:func:`~psi4.core.print_variables`. Note that PSI variables; are cleared at the start of each :py:func:`~psi4.driver.energy`, etc. in an input; file by :py:func:`~psi4.core.clean_variables()`.; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a :py:func:`~psi4.core.print_variables` command, the; last will include :psivar:`SCF TOTAL ENERGY` but not; :psivar:`FCI TOTAL ENERGY`.; The entire dictionary of PSI variables can be obtained through; :py:func:`~psi4.core.get_variables`. .. _`sec:returnvals`:. Return Values; =============. Most of the usual user computation functions (*i.e.*,; :py:func:`~psi4.driver.energy`, :py:func:`~psi4.driver.optimize`, and; :py:func:`~psi4.driver.frequency`) return simply the current total energy.; Consult the descriptions of other functions in :ref:`sec:psithonFunc` for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions. ::. # E is total energy float; # ",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:10762,Modifiability,variab,variables,10762,"apdx:psivariables_alpha` defines them. These can be; accessed through the :py:func:`~psi4.core.get_variable` function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available::. e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command :py:func:`~psi4.core.print_variables`. Note that PSI variables; are cleared at the start of each :py:func:`~psi4.driver.energy`, etc. in an input; file by :py:func:`~psi4.core.clean_variables()`.; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a :py:func:`~psi4.core.print_variables` command, the; last will include :psivar:`SCF TOTAL ENERGY` but not; :psivar:`FCI TOTAL ENERGY`.; The entire dictionary of PSI variables can be obtained through; :py:func:`~psi4.core.get_variables`. .. _`sec:returnvals`:. Return Values; =============. Most of the usual user computation functions (*i.e.*,; :py:func:`~psi4.driver.energy`, :py:func:`~psi4.driver.optimize`, and; :py:func:`~psi4.driver.frequency`) return simply the current total energy.; Consult the descriptions of other functions in :ref:`sec:psithonFunc` for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions. ::. # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; ``return_wfn=True`` keyword argument additionally returns; :py:class:`~psi4.",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:12872,Modifiability,variab,variable,12872,"., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). .. _`sec:loops`:. Loops; =====. Python provides many control structures, any of which can be used within |PSIfour|; input files. For example, to loop over three basis sets, the following code can; be used:. .. code-block:: none. basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of ``basis_sets`` is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that ``basis_set`` is a; Python variable, not a string, by prefixing it with a dollar sign. . The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water::. molecule h2o{; O; H 1 R; H 1 R 2 A; }; ; Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2); ; set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of ``Rvals`` and ``Avals`` are both completely standard Python syntax.; Having named our molecule ``h2o`` we can then set the values of ``R`` and ``A`` within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the ``set`` keyword. Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometr",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:12996,Modifiability,variab,variable,12996,"y optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). .. _`sec:loops`:. Loops; =====. Python provides many control structures, any of which can be used within |PSIfour|; input files. For example, to loop over three basis sets, the following code can; be used:. .. code-block:: none. basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of ``basis_sets`` is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that ``basis_set`` is a; Python variable, not a string, by prefixing it with a dollar sign. . The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water::. molecule h2o{; O; H 1 R; H 1 R 2 A; }; ; Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2); ; set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of ``Rvals`` and ``Avals`` are both completely standard Python syntax.; Having named our molecule ``h2o`` we can then set the values of ``R`` and ``A`` within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the ``set`` keyword. Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See :srcsample:`scf4` for analogous Z-matrix; and Cartiesian scans. .. _`sec:resultsTables`:. Tables of Results; =================",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:13579,Modifiability,variab,variable,13579,"$basis_set; energy('scf'). The declaration of ``basis_sets`` is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that ``basis_set`` is a; Python variable, not a string, by prefixing it with a dollar sign. . The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water::. molecule h2o{; O; H 1 R; H 1 R 2 A; }; ; Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2); ; set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of ``Rvals`` and ``Avals`` are both completely standard Python syntax.; Having named our molecule ``h2o`` we can then set the values of ``R`` and ``A`` within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the ``set`` keyword. Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See :srcsample:`scf4` for analogous Z-matrix; and Cartiesian scans. .. _`sec:resultsTables`:. Tables of Results; =================. The Psithon function ``psi4.driver.p4util.Table`` has been removed,; as the Python ecosystem provides many more flexible alternatives. An; example tabulating a potential energy surface scan for water with Pandas; is shown below::. molecule h2o {; O; H 1 R; H 1 R 2 A; }; ; Rvals=[0.9,1.0,1.1]; Avals=range(100,103,2); ; rows = []; table = []; ; set basis cc-pvdz; ; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = variable('SCF TOTAL ENERGY'); edfmp2 = variable('MP2 TOTAL ENERGY'); escsmp2 = variable('SCS-MP2 TOTAL ENERGY'); rows.append((R, A)); table.append([escf, escsmp2, ",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:13645,Modifiability,variab,variables,13645,"$basis_set; energy('scf'). The declaration of ``basis_sets`` is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that ``basis_set`` is a; Python variable, not a string, by prefixing it with a dollar sign. . The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water::. molecule h2o{; O; H 1 R; H 1 R 2 A; }; ; Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2); ; set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of ``Rvals`` and ``Avals`` are both completely standard Python syntax.; Having named our molecule ``h2o`` we can then set the values of ``R`` and ``A`` within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the ``set`` keyword. Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See :srcsample:`scf4` for analogous Z-matrix; and Cartiesian scans. .. _`sec:resultsTables`:. Tables of Results; =================. The Psithon function ``psi4.driver.p4util.Table`` has been removed,; as the Python ecosystem provides many more flexible alternatives. An; example tabulating a potential energy surface scan for water with Pandas; is shown below::. molecule h2o {; O; H 1 R; H 1 R 2 A; }; ; Rvals=[0.9,1.0,1.1]; Avals=range(100,103,2); ; rows = []; table = []; ; set basis cc-pvdz; ; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = variable('SCF TOTAL ENERGY'); edfmp2 = variable('MP2 TOTAL ENERGY'); escsmp2 = variable('SCS-MP2 TOTAL ENERGY'); rows.append((R, A)); table.append([escf, escsmp2, ",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:14103,Modifiability,flexible,flexible,14103,"e; angle and bond length in water::. molecule h2o{; O; H 1 R; H 1 R 2 A; }; ; Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2); ; set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of ``Rvals`` and ``Avals`` are both completely standard Python syntax.; Having named our molecule ``h2o`` we can then set the values of ``R`` and ``A`` within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the ``set`` keyword. Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See :srcsample:`scf4` for analogous Z-matrix; and Cartiesian scans. .. _`sec:resultsTables`:. Tables of Results; =================. The Psithon function ``psi4.driver.p4util.Table`` has been removed,; as the Python ecosystem provides many more flexible alternatives. An; example tabulating a potential energy surface scan for water with Pandas; is shown below::. molecule h2o {; O; H 1 R; H 1 R 2 A; }; ; Rvals=[0.9,1.0,1.1]; Avals=range(100,103,2); ; rows = []; table = []; ; set basis cc-pvdz; ; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = variable('SCF TOTAL ENERGY'); edfmp2 = variable('MP2 TOTAL ENERGY'); escsmp2 = variable('SCS-MP2 TOTAL ENERGY'); rows.append((R, A)); table.append([escf, escsmp2, edfmp2]); ; import pandas as pd; df = pd.DataFrame(table, columns = [""E(SCF)"", ""E(SCS)"", ""E(DFMP2)""], index=rows); print(df). # E(SCF) E(SCS) E(DFMP2); # (0.9, 100) -76.020680 -76.217006 -76.221189; # (0.9, 102) -76.021305 -76.217439 -76.221605; # (1.0, 100) -76.021264 -76.224987 -76.228727; # (1.0, 102) -76.021460 -76.224946 -76.228668; # (1.1, 100) -75.990195 -76.201891 -76.205087; # (1.1, 102) -75.990085 -76.201498 -76.204676. .. _`sec:wrappers`:. Python Wrappers; =========",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:14435,Modifiability,variab,variable,14435,"f ``R`` and ``A`` within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the ``set`` keyword. Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See :srcsample:`scf4` for analogous Z-matrix; and Cartiesian scans. .. _`sec:resultsTables`:. Tables of Results; =================. The Psithon function ``psi4.driver.p4util.Table`` has been removed,; as the Python ecosystem provides many more flexible alternatives. An; example tabulating a potential energy surface scan for water with Pandas; is shown below::. molecule h2o {; O; H 1 R; H 1 R 2 A; }; ; Rvals=[0.9,1.0,1.1]; Avals=range(100,103,2); ; rows = []; table = []; ; set basis cc-pvdz; ; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = variable('SCF TOTAL ENERGY'); edfmp2 = variable('MP2 TOTAL ENERGY'); escsmp2 = variable('SCS-MP2 TOTAL ENERGY'); rows.append((R, A)); table.append([escf, escsmp2, edfmp2]); ; import pandas as pd; df = pd.DataFrame(table, columns = [""E(SCF)"", ""E(SCS)"", ""E(DFMP2)""], index=rows); print(df). # E(SCF) E(SCS) E(DFMP2); # (0.9, 100) -76.020680 -76.217006 -76.221189; # (0.9, 102) -76.021305 -76.217439 -76.221605; # (1.0, 100) -76.021264 -76.224987 -76.228727; # (1.0, 102) -76.021460 -76.224946 -76.228668; # (1.1, 100) -75.990195 -76.201891 -76.205087; # (1.1, 102) -75.990085 -76.201498 -76.204676. .. _`sec:wrappers`:. Python Wrappers; ===============. The Python foundations of the |PSIfour| driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the |PSIfour| suite. . As seen in the neon dimer example from the :ref:`tutorial <sec:tutorial>` section,; the :py:func:`~psi4.driver.driver_nbody.nbody` wrapper provides automatic computation of; counterpoise-corrected interaction energies betw",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:14474,Modifiability,variab,variable,14474,"f ``R`` and ``A`` within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the ``set`` keyword. Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See :srcsample:`scf4` for analogous Z-matrix; and Cartiesian scans. .. _`sec:resultsTables`:. Tables of Results; =================. The Psithon function ``psi4.driver.p4util.Table`` has been removed,; as the Python ecosystem provides many more flexible alternatives. An; example tabulating a potential energy surface scan for water with Pandas; is shown below::. molecule h2o {; O; H 1 R; H 1 R 2 A; }; ; Rvals=[0.9,1.0,1.1]; Avals=range(100,103,2); ; rows = []; table = []; ; set basis cc-pvdz; ; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = variable('SCF TOTAL ENERGY'); edfmp2 = variable('MP2 TOTAL ENERGY'); escsmp2 = variable('SCS-MP2 TOTAL ENERGY'); rows.append((R, A)); table.append([escf, escsmp2, edfmp2]); ; import pandas as pd; df = pd.DataFrame(table, columns = [""E(SCF)"", ""E(SCS)"", ""E(DFMP2)""], index=rows); print(df). # E(SCF) E(SCS) E(DFMP2); # (0.9, 100) -76.020680 -76.217006 -76.221189; # (0.9, 102) -76.021305 -76.217439 -76.221605; # (1.0, 100) -76.021264 -76.224987 -76.228727; # (1.0, 102) -76.021460 -76.224946 -76.228668; # (1.1, 100) -75.990195 -76.201891 -76.205087; # (1.1, 102) -75.990085 -76.201498 -76.204676. .. _`sec:wrappers`:. Python Wrappers; ===============. The Python foundations of the |PSIfour| driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the |PSIfour| suite. . As seen in the neon dimer example from the :ref:`tutorial <sec:tutorial>` section,; the :py:func:`~psi4.driver.driver_nbody.nbody` wrapper provides automatic computation of; counterpoise-corrected interaction energies betw",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:14514,Modifiability,variab,variable,14514,"f ``R`` and ``A`` within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the ``set`` keyword. Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See :srcsample:`scf4` for analogous Z-matrix; and Cartiesian scans. .. _`sec:resultsTables`:. Tables of Results; =================. The Psithon function ``psi4.driver.p4util.Table`` has been removed,; as the Python ecosystem provides many more flexible alternatives. An; example tabulating a potential energy surface scan for water with Pandas; is shown below::. molecule h2o {; O; H 1 R; H 1 R 2 A; }; ; Rvals=[0.9,1.0,1.1]; Avals=range(100,103,2); ; rows = []; table = []; ; set basis cc-pvdz; ; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = variable('SCF TOTAL ENERGY'); edfmp2 = variable('MP2 TOTAL ENERGY'); escsmp2 = variable('SCS-MP2 TOTAL ENERGY'); rows.append((R, A)); table.append([escf, escsmp2, edfmp2]); ; import pandas as pd; df = pd.DataFrame(table, columns = [""E(SCF)"", ""E(SCS)"", ""E(DFMP2)""], index=rows); print(df). # E(SCF) E(SCS) E(DFMP2); # (0.9, 100) -76.020680 -76.217006 -76.221189; # (0.9, 102) -76.021305 -76.217439 -76.221605; # (1.0, 100) -76.021264 -76.224987 -76.228727; # (1.0, 102) -76.021460 -76.224946 -76.228668; # (1.1, 100) -75.990195 -76.201891 -76.205087; # (1.1, 102) -75.990085 -76.201498 -76.204676. .. _`sec:wrappers`:. Python Wrappers; ===============. The Python foundations of the |PSIfour| driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the |PSIfour| suite. . As seen in the neon dimer example from the :ref:`tutorial <sec:tutorial>` section,; the :py:func:`~psi4.driver.driver_nbody.nbody` wrapper provides automatic computation of; counterpoise-corrected interaction energies betw",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:16296,Modifiability,config,configured,16296,"l <sec:tutorial>` section,; the :py:func:`~psi4.driver.driver_nbody.nbody` wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example, ::. energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules. |PSIfour| also provides the :py:func:`~psi4.driver.cbs` wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,::. # all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree--Fock energy in the; largest basis (cc-pVTZ). :py:func:`~psi4.driver.cbs` can; be configured behind-the-scenes with explicit arguments, as in the; first example, or the convenience syntax of the equivalent second; example can be used. Another very useful and powerful feature of |PSIfour| is the ability; to compute results on entire databases of molecules at a time,; as provided by the :py:func:`~psi4.driver.wrapper_database.database` wrapper. For example,::. database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (``cp=1``) on all members of Hobza's S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others. These wrapper functions are discussed separately in; :ref:`sec:psithonFunc`. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the ``set {...}`` block or with any other ``set`` command. ",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:1242,Performance,perform,performed,1242,"ing files.; .. #; .. # This file is part of Psi4.; .. #; .. # Psi4 is free software; you can redistribute it and/or modify; .. # it under the terms of the GNU Lesser General Public License as published by; .. # the Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:psithonInput`:. ==================================; Psithon: Structuring an Input File; ==================================. To allow arbitrarily complex computations to be performed, |PSIfour| was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; |PSIfour| is distributed with an extensive test suite, described in section; :ref:`apdx:testSuite`; the input files for these test cases can be found in the; samples subdirectory of the top-level |PSIfour| source directory and should; serve as useful examples. .. index:: physical constants; .. _`sec:physicalConstants`:. Physical Constants; ==================. For convenience, the Python interpreter will execute the contents of the; |psirc| file in the current user's home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly mak",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:1388,Performance,perform,performed,1388,"the GNU Lesser General Public License as published by; .. # the Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:psithonInput`:. ==================================; Psithon: Structuring an Input File; ==================================. To allow arbitrarily complex computations to be performed, |PSIfour| was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; |PSIfour| is distributed with an extensive test suite, described in section; :ref:`apdx:testSuite`; the input files for these test cases can be found in the; samples subdirectory of the top-level |PSIfour| source directory and should; serve as useful examples. .. index:: physical constants; .. _`sec:physicalConstants`:. Physical Constants; ==================. For convenience, the Python interpreter will execute the contents of the; |psirc| file in the current user's home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the |psirc| file ::. UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:2080,Performance,perform,performing,2080,":: autodoc_abbr_options_c.rst. .. _`sec:psithonInput`:. ==================================; Psithon: Structuring an Input File; ==================================. To allow arbitrarily complex computations to be performed, |PSIfour| was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; |PSIfour| is distributed with an extensive test suite, described in section; :ref:`apdx:testSuite`; the input files for these test cases can be found in the; samples subdirectory of the top-level |PSIfour| source directory and should; serve as useful examples. .. index:: physical constants; .. _`sec:physicalConstants`:. Physical Constants; ==================. For convenience, the Python interpreter will execute the contents of the; |psirc| file in the current user's home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the |psirc| file ::. UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable ``UGC`` available in all |PSIfour| input files.; For convenience, the physical constants used within the |PSIfour| code (which; are obtained from `NIST CODATA 2014; <https://physics.nist.gov/cuu/Constants/archive2014.html>`_; are also automatically loaded as Psithon; variables (before |psirc| is loaded, so that the user's |psirc| values can; override the builtins (in the input file, not in the C++ code). The physical constants used within |PSIfour|, which are automatically; made available within all |PSIfour| input files are in :ref:`table:physconst`. .. .. literalinclude:: @SFNX_INCLUDE@psi4/driver",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:2673,Performance,load,loaded,2673," samples subdirectory of the top-level |PSIfour| source directory and should; serve as useful examples. .. index:: physical constants; .. _`sec:physicalConstants`:. Physical Constants; ==================. For convenience, the Python interpreter will execute the contents of the; |psirc| file in the current user's home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the |psirc| file ::. UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable ``UGC`` available in all |PSIfour| input files.; For convenience, the physical constants used within the |PSIfour| code (which; are obtained from `NIST CODATA 2014; <https://physics.nist.gov/cuu/Constants/archive2014.html>`_; are also automatically loaded as Psithon; variables (before |psirc| is loaded, so that the user's |psirc| values can; override the builtins (in the input file, not in the C++ code). The physical constants used within |PSIfour|, which are automatically; made available within all |PSIfour| input files are in :ref:`table:physconst`. .. .. literalinclude:: @SFNX_INCLUDE@psi4/driver/constants/physconst.py; .. :lines: 28-. In Psithon input files, prepend physical constants with ``psi_`` to; prevent clashes with user-defined variables (*e.g.*, ``psi_h``). In; PsiAPI mode, access as, *e.g.*, ``psi4.constants.h``. .. index:: memory; .. _`sec:memory`:. Memory Specification; ====================. By default, |PSIfour| assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the ``memory`` keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to |PSIfour|::. # all equivalent. memory 2 GB; ; memory 2000",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:2721,Performance,load,loaded,2721," samples subdirectory of the top-level |PSIfour| source directory and should; serve as useful examples. .. index:: physical constants; .. _`sec:physicalConstants`:. Physical Constants; ==================. For convenience, the Python interpreter will execute the contents of the; |psirc| file in the current user's home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the |psirc| file ::. UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable ``UGC`` available in all |PSIfour| input files.; For convenience, the physical constants used within the |PSIfour| code (which; are obtained from `NIST CODATA 2014; <https://physics.nist.gov/cuu/Constants/archive2014.html>`_; are also automatically loaded as Psithon; variables (before |psirc| is loaded, so that the user's |psirc| values can; override the builtins (in the input file, not in the C++ code). The physical constants used within |PSIfour|, which are automatically; made available within all |PSIfour| input files are in :ref:`table:physconst`. .. .. literalinclude:: @SFNX_INCLUDE@psi4/driver/constants/physconst.py; .. :lines: 28-. In Psithon input files, prepend physical constants with ``psi_`` to; prevent clashes with user-defined variables (*e.g.*, ``psi_h``). In; PsiAPI mode, access as, *e.g.*, ``psi4.constants.h``. .. index:: memory; .. _`sec:memory`:. Memory Specification; ====================. By default, |PSIfour| assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the ``memory`` keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to |PSIfour|::. # all equivalent. memory 2 GB; ; memory 2000",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:3486,Performance,perform,perform,3486,"les.; For convenience, the physical constants used within the |PSIfour| code (which; are obtained from `NIST CODATA 2014; <https://physics.nist.gov/cuu/Constants/archive2014.html>`_; are also automatically loaded as Psithon; variables (before |psirc| is loaded, so that the user's |psirc| values can; override the builtins (in the input file, not in the C++ code). The physical constants used within |PSIfour|, which are automatically; made available within all |PSIfour| input files are in :ref:`table:physconst`. .. .. literalinclude:: @SFNX_INCLUDE@psi4/driver/constants/physconst.py; .. :lines: 28-. In Psithon input files, prepend physical constants with ``psi_`` to; prevent clashes with user-defined variables (*e.g.*, ``psi_h``). In; PsiAPI mode, access as, *e.g.*, ``psi4.constants.h``. .. index:: memory; .. _`sec:memory`:. Memory Specification; ====================. By default, |PSIfour| assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the ``memory`` keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to |PSIfour|::. # all equivalent. memory 2 GB; ; memory 2000 MB; ; memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). |PSIfour| recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB). By default, |PSIfour| performs a ""sanity check"" when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to |PSIfour|::. # setting available memory to 2 MB; set_memory_bytes(2000000). Please note that this memory setting only governs the maximal memory; usage of the major data structures, and actual to",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:4027,Performance,perform,performs,4027," In Psithon input files, prepend physical constants with ``psi_`` to; prevent clashes with user-defined variables (*e.g.*, ``psi_h``). In; PsiAPI mode, access as, *e.g.*, ``psi4.constants.h``. .. index:: memory; .. _`sec:memory`:. Memory Specification; ====================. By default, |PSIfour| assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the ``memory`` keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to |PSIfour|::. # all equivalent. memory 2 GB; ; memory 2000 MB; ; memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). |PSIfour| recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB). By default, |PSIfour| performs a ""sanity check"" when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to |PSIfour|::. # setting available memory to 2 MB; set_memory_bytes(2000000). Please note that this memory setting only governs the maximal memory; usage of the major data structures, and actual total memory usage; is slightly higher. This is usually a negligible amount, except when; setting tiny memory allowances. One convenient way to override the |PSIfour| default memory is to place a; memory command in the |psirc| file (Sec. :ref:`sec:psirc`). For example,; the following makes the default memory 2 GB. ::. set_memory(2000000000). However, unless you're assured of having only one job running on a node at; a time (and all nodes on the filesystem with |psirc| have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. That same command can b",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:5805,Performance,perform,perform,5805,"er, unless you're assured of having only one job running on a node at; a time (and all nodes on the filesystem with |psirc| have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. That same command can be used for PsiAPI mode::. psi4.set_memory(int(5e8)). .. tabs::. .. code-tab:: bash PSIthon. set_memory(2000000000). .. code-tab:: py PsiAPI. psi4.set_memory(int(5e8)). .. note:: For parallel jobs, the ``memory`` keyword represents the total memory; available to the job, *not* the memory per thread. Molecule and Geometry Specification; ===================================. .. toctree::; :maxdepth: 2. psithonmol. .. comment To add EFP fragments to a molecule, see :ref:`sec:usingEFPFragments`. To add EFP fragments to a molecule, see :ref:`sec:usingEFPFragments`. .. index::; triple: setting; keywords; general; .. _`sec:jobControl`:. Job Control Keywords; ====================. |PSIfour| comprises a number of C++ modules that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file which control its function.; These keywords are detailed in Appendix :ref:`apdx:options_c_module`.; The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified::. # all equivalent. set globals basis cc-pVDZ. set basis cc-pVDZ. set globals basis = cc-pVDZ. set basis = cc-pVDZ. set globals{; basis cc-pVDZ; }; ; set {; basis cc-pVDZ; }; ; set {; basis = cc-pVDZ; }. Note the lack of quotes around ``cc-pVDZ``, even though it is a string. The; Psithon preprocessor automatically wraps any string values in ``set`` commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords::. set {; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:7556,Performance,perform,performs,7556," wraps any string values in ``set`` commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords::. set {; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, *viz.*::. set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening ``[`` is; on the same line as the name of the keyword. Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the ``set`` keyword. Omitting the module; name, or using the name ``global`` or ``globals`` will result in the keyword being; applied to all modules. For example, in the following input ::. molecule{; o; h 1 roh; h 1 roh 2 ahoh; ; roh = 0.957; ahoh = 104.5; }; ; set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the :py:func:`~psi4.driver.energy` Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read ::. set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. In PsiAPI mode, one can use the command :py:func:`~psi4.driver.set_options`; like below for general and module-specific options. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function `~psi4.core.clean_options` that reinitializes; all options may also be ",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:7669,Performance,perform,performed,7669," cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, *viz.*::. set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening ``[`` is; on the same line as the name of the keyword. Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the ``set`` keyword. Omitting the module; name, or using the name ``global`` or ``globals`` will result in the keyword being; applied to all modules. For example, in the following input ::. molecule{; o; h 1 roh; h 1 roh 2 ahoh; ; roh = 0.957; ahoh = 104.5; }; ; set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the :py:func:`~psi4.driver.energy` Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read ::. set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. In PsiAPI mode, one can use the command :py:func:`~psi4.driver.set_options`; like below for general and module-specific options. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function `~psi4.core.clean_options` that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session. ::. psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True,; 'optking__geom_maxiter': ",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:7824,Performance,perform,performed,7824,"ould; be used, *viz.*::. set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening ``[`` is; on the same line as the name of the keyword. Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the ``set`` keyword. Omitting the module; name, or using the name ``global`` or ``globals`` will result in the keyword being; applied to all modules. For example, in the following input ::. molecule{; o; h 1 roh; h 1 roh 2 ahoh; ; roh = 0.957; ahoh = 104.5; }; ; set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the :py:func:`~psi4.driver.energy` Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read ::. set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. In PsiAPI mode, one can use the command :py:func:`~psi4.driver.set_options`; like below for general and module-specific options. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function `~psi4.core.clean_options` that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session. ::. psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True,; 'optking__geom_maxiter': 50; }). Basis Sets; ==========. .. toctree::; :maxdepth: 2. basissets. .. _`sec:psiVariables`:. PSI Variables; ==",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:9911,Performance,perform,performing,9911,"essing. To demonstrate, we can embellish the previous example of; H\ :sub:`2` and H atom::. molecule h2 {; H; H 1 0.9; }; ; set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'); ; molecule h {; H; }; ; set basis cc-pvdz; set reference uhf; h_energy = energy('scf'); ; D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The :py:func:`~psi4.driver.energy` function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation. Generally, there are multiple quantities of interest. Appendix; :ref:`apdx:psivariables_module` lists PSI variables variables set by each; module, and :ref:`apdx:psivariables_alpha` defines them. These can be; accessed through the :py:func:`~psi4.core.get_variable` function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available::. e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command :py:func:`~psi4.core.print_variables`. Note that PSI variables; are cleared at the start of each :py:func:`~psi4.driver.energy`, etc. in an input; file by :py:func:`~psi4.core.clean_variables()`.; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a :py:func:`~psi4.core.print_variables` command, the; last will include :psivar:`SCF TOTAL ENERGY` but not; :psivar:`FCI TOTAL ENERGY`.; The entire dictionary of PSI variables can be obtained through; :py:func:`~psi4.core.get_variables`. .. _`sec:returnvals`:. Return Values; =============. Most of the usual user computation functions (*i.e.*,; :py:func:`~psi4.driver.en",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:10997,Performance,optimiz,optimize,10997,"P2 energy are made available::. e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command :py:func:`~psi4.core.print_variables`. Note that PSI variables; are cleared at the start of each :py:func:`~psi4.driver.energy`, etc. in an input; file by :py:func:`~psi4.core.clean_variables()`.; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a :py:func:`~psi4.core.print_variables` command, the; last will include :psivar:`SCF TOTAL ENERGY` but not; :psivar:`FCI TOTAL ENERGY`.; The entire dictionary of PSI variables can be obtained through; :py:func:`~psi4.core.get_variables`. .. _`sec:returnvals`:. Return Values; =============. Most of the usual user computation functions (*i.e.*,; :py:func:`~psi4.driver.energy`, :py:func:`~psi4.driver.optimize`, and; :py:func:`~psi4.driver.frequency`) return simply the current total energy.; Consult the descriptions of other functions in :ref:`sec:psithonFunc` for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions. ::. # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; ``return_wfn=True`` keyword argument additionally returns; :py:class:`~psi4.core.Wavefunction`. ::. # power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = he",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:11521,Performance,optimiz,optimize,11521,"single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a :py:func:`~psi4.core.print_variables` command, the; last will include :psivar:`SCF TOTAL ENERGY` but not; :psivar:`FCI TOTAL ENERGY`.; The entire dictionary of PSI variables can be obtained through; :py:func:`~psi4.core.get_variables`. .. _`sec:returnvals`:. Return Values; =============. Most of the usual user computation functions (*i.e.*,; :py:func:`~psi4.driver.energy`, :py:func:`~psi4.driver.optimize`, and; :py:func:`~psi4.driver.frequency`) return simply the current total energy.; Consult the descriptions of other functions in :ref:`sec:psithonFunc` for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions. ::. # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; ``return_wfn=True`` keyword argument additionally returns; :py:class:`~psi4.core.Wavefunction`. ::. # power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). .. _`sec:loops`:. Loops; =====. Python provides many control structures, any of which can be used within |PSIfour|; input files. For example, to loop over three basis sets, the following code can; be used:. .. code-block:: none. basis_sets = [""",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:11584,Performance,optimiz,optimize,11584,"ed by a :py:func:`~psi4.core.print_variables` command, the; last will include :psivar:`SCF TOTAL ENERGY` but not; :psivar:`FCI TOTAL ENERGY`.; The entire dictionary of PSI variables can be obtained through; :py:func:`~psi4.core.get_variables`. .. _`sec:returnvals`:. Return Values; =============. Most of the usual user computation functions (*i.e.*,; :py:func:`~psi4.driver.energy`, :py:func:`~psi4.driver.optimize`, and; :py:func:`~psi4.driver.frequency`) return simply the current total energy.; Consult the descriptions of other functions in :ref:`sec:psithonFunc` for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions. ::. # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; ``return_wfn=True`` keyword argument additionally returns; :py:class:`~psi4.core.Wavefunction`. ::. # power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). .. _`sec:loops`:. Loops; =====. Python provides many control structures, any of which can be used within |PSIfour|; input files. For example, to loop over three basis sets, the following code can; be used:. .. code-block:: none. basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set b",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:11866,Performance,optimiz,optimize,11866," Return Values; =============. Most of the usual user computation functions (*i.e.*,; :py:func:`~psi4.driver.energy`, :py:func:`~psi4.driver.optimize`, and; :py:func:`~psi4.driver.frequency`) return simply the current total energy.; Consult the descriptions of other functions in :ref:`sec:psithonFunc` for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions. ::. # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; ``return_wfn=True`` keyword argument additionally returns; :py:class:`~psi4.core.Wavefunction`. ::. # power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). .. _`sec:loops`:. Loops; =====. Python provides many control structures, any of which can be used within |PSIfour|; input files. For example, to loop over three basis sets, the following code can; be used:. .. code-block:: none. basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of ``basis_sets`` is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that ``basis_set`",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:11990,Performance,optimiz,optimize,11990,"driver.optimize`, and; :py:func:`~psi4.driver.frequency`) return simply the current total energy.; Consult the descriptions of other functions in :ref:`sec:psithonFunc` for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions. ::. # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; ``return_wfn=True`` keyword argument additionally returns; :py:class:`~psi4.core.Wavefunction`. ::. # power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). .. _`sec:loops`:. Loops; =====. Python provides many control structures, any of which can be used within |PSIfour|; input files. For example, to loop over three basis sets, the following code can; be used:. .. code-block:: none. basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of ``basis_sets`` is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that ``basis_set`` is a; Python variable, not a string, by prefixing it with a dollar sign. . The geometry specification supports delayed initializatio",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:13848,Performance,perform,performed,13848,"n preprocessor; wraps strings in quotes by default, we have to tell it that ``basis_set`` is a; Python variable, not a string, by prefixing it with a dollar sign. . The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water::. molecule h2o{; O; H 1 R; H 1 R 2 A; }; ; Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2); ; set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of ``Rvals`` and ``Avals`` are both completely standard Python syntax.; Having named our molecule ``h2o`` we can then set the values of ``R`` and ``A`` within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the ``set`` keyword. Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See :srcsample:`scf4` for analogous Z-matrix; and Cartiesian scans. .. _`sec:resultsTables`:. Tables of Results; =================. The Psithon function ``psi4.driver.p4util.Table`` has been removed,; as the Python ecosystem provides many more flexible alternatives. An; example tabulating a potential energy surface scan for water with Pandas; is shown below::. molecule h2o {; O; H 1 R; H 1 R 2 A; }; ; Rvals=[0.9,1.0,1.1]; Avals=range(100,103,2); ; rows = []; table = []; ; set basis cc-pvdz; ; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = variable('SCF TOTAL ENERGY'); edfmp2 = variable('MP2 TOTAL ENERGY'); escsmp2 = variable('SCS-MP2 TOTAL ENERGY'); rows.append((R, A)); table.append([escf, escsmp2, edfmp2]); ; import pandas as pd; df = pd.DataFrame(table, columns = [""E(SCF)"", ""E(SCS)"", ""E(DFMP2)""], index=rows); print(df). # E(SCF) E(SCS) E(DFMP2); # (0.9, 100) -76.020",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:15175,Performance,perform,performed,15175,"rface scan for water with Pandas; is shown below::. molecule h2o {; O; H 1 R; H 1 R 2 A; }; ; Rvals=[0.9,1.0,1.1]; Avals=range(100,103,2); ; rows = []; table = []; ; set basis cc-pvdz; ; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = variable('SCF TOTAL ENERGY'); edfmp2 = variable('MP2 TOTAL ENERGY'); escsmp2 = variable('SCS-MP2 TOTAL ENERGY'); rows.append((R, A)); table.append([escf, escsmp2, edfmp2]); ; import pandas as pd; df = pd.DataFrame(table, columns = [""E(SCF)"", ""E(SCS)"", ""E(DFMP2)""], index=rows); print(df). # E(SCF) E(SCS) E(DFMP2); # (0.9, 100) -76.020680 -76.217006 -76.221189; # (0.9, 102) -76.021305 -76.217439 -76.221605; # (1.0, 100) -76.021264 -76.224987 -76.228727; # (1.0, 102) -76.021460 -76.224946 -76.228668; # (1.1, 100) -75.990195 -76.201891 -76.205087; # (1.1, 102) -75.990085 -76.201498 -76.204676. .. _`sec:wrappers`:. Python Wrappers; ===============. The Python foundations of the |PSIfour| driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the |PSIfour| suite. . As seen in the neon dimer example from the :ref:`tutorial <sec:tutorial>` section,; the :py:func:`~psi4.driver.driver_nbody.nbody` wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example, ::. energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules. |PSIfour| also provides the :py:func:`~psi4.driver.cbs` wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,::. # all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extr",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:16730,Performance,perform,perform,16730,"l <sec:tutorial>` section,; the :py:func:`~psi4.driver.driver_nbody.nbody` wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example, ::. energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules. |PSIfour| also provides the :py:func:`~psi4.driver.cbs` wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,::. # all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree--Fock energy in the; largest basis (cc-pVTZ). :py:func:`~psi4.driver.cbs` can; be configured behind-the-scenes with explicit arguments, as in the; first example, or the convenience syntax of the equivalent second; example can be used. Another very useful and powerful feature of |PSIfour| is the ability; to compute results on entire databases of molecules at a time,; as provided by the :py:func:`~psi4.driver.wrapper_database.database` wrapper. For example,::. database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (``cp=1``) on all members of Hobza's S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others. These wrapper functions are discussed separately in; :ref:`sec:psithonFunc`. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the ``set {...}`` block or with any other ``set`` command. ",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:4039,Safety,sanity check,sanity check,4039," In Psithon input files, prepend physical constants with ``psi_`` to; prevent clashes with user-defined variables (*e.g.*, ``psi_h``). In; PsiAPI mode, access as, *e.g.*, ``psi4.constants.h``. .. index:: memory; .. _`sec:memory`:. Memory Specification; ====================. By default, |PSIfour| assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the ``memory`` keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to |PSIfour|::. # all equivalent. memory 2 GB; ; memory 2000 MB; ; memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). |PSIfour| recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB). By default, |PSIfour| performs a ""sanity check"" when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to |PSIfour|::. # setting available memory to 2 MB; set_memory_bytes(2000000). Please note that this memory setting only governs the maximal memory; usage of the major data structures, and actual total memory usage; is slightly higher. This is usually a negligible amount, except when; setting tiny memory allowances. One convenient way to override the |PSIfour| default memory is to place a; memory command in the |psirc| file (Sec. :ref:`sec:psirc`). For example,; the following makes the default memory 2 GB. ::. set_memory(2000000000). However, unless you're assured of having only one job running on a node at; a time (and all nodes on the filesystem with |psirc| have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. That same command can b",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:3222,Security,access,access,3222,"xample, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the |psirc| file ::. UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable ``UGC`` available in all |PSIfour| input files.; For convenience, the physical constants used within the |PSIfour| code (which; are obtained from `NIST CODATA 2014; <https://physics.nist.gov/cuu/Constants/archive2014.html>`_; are also automatically loaded as Psithon; variables (before |psirc| is loaded, so that the user's |psirc| values can; override the builtins (in the input file, not in the C++ code). The physical constants used within |PSIfour|, which are automatically; made available within all |PSIfour| input files are in :ref:`table:physconst`. .. .. literalinclude:: @SFNX_INCLUDE@psi4/driver/constants/physconst.py; .. :lines: 28-. In Psithon input files, prepend physical constants with ``psi_`` to; prevent clashes with user-defined variables (*e.g.*, ``psi_h``). In; PsiAPI mode, access as, *e.g.*, ``psi4.constants.h``. .. index:: memory; .. _`sec:memory`:. Memory Specification; ====================. By default, |PSIfour| assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the ``memory`` keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to |PSIfour|::. # all equivalent. memory 2 GB; ; memory 2000 MB; ; memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). |PSIfour| recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB). By default, |PSIfour| performs a ""sanity check"" when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:9825,Security,access,accessed,9825,"power of Python, |PSIfour| makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H\ :sub:`2` and H atom::. molecule h2 {; H; H 1 0.9; }; ; set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'); ; molecule h {; H; }; ; set basis cc-pvdz; set reference uhf; h_energy = energy('scf'); ; D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The :py:func:`~psi4.driver.energy` function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation. Generally, there are multiple quantities of interest. Appendix; :ref:`apdx:psivariables_module` lists PSI variables variables set by each; module, and :ref:`apdx:psivariables_alpha` defines them. These can be; accessed through the :py:func:`~psi4.core.get_variable` function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available::. e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command :py:func:`~psi4.core.print_variables`. Note that PSI variables; are cleared at the start of each :py:func:`~psi4.driver.energy`, etc. in an input; file by :py:func:`~psi4.core.clean_variables()`.; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a :py:func:`~psi4.core.print_variables` command, the; last will include :psivar:`SCF TOTAL ENERGY` but not; :psivar:`FCI TOTAL ENERGY`.; The entire dictionary of PSI variables can be obtained through; :py:func:`~psi4.core.get_variables`. ..",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:12222,Security,access,access,12222,"ble for post-processing. Many users need only deal with the simple return; form for the computation functions. ::. # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; ``return_wfn=True`` keyword argument additionally returns; :py:class:`~psi4.core.Wavefunction`. ::. # power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). .. _`sec:loops`:. Loops; =====. Python provides many control structures, any of which can be used within |PSIfour|; input files. For example, to loop over three basis sets, the following code can; be used:. .. code-block:: none. basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of ``basis_sets`` is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that ``basis_set`` is a; Python variable, not a string, by prefixing it with a dollar sign. . The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water::. molecule h2o{; O; H 1 R; H 1 R 2 A; }; ; Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2); ; set basis cc-pvdz; set scf",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:13560,Security,access,access,13560,"$basis_set; energy('scf'). The declaration of ``basis_sets`` is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that ``basis_set`` is a; Python variable, not a string, by prefixing it with a dollar sign. . The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water::. molecule h2o{; O; H 1 R; H 1 R 2 A; }; ; Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2); ; set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of ``Rvals`` and ``Avals`` are both completely standard Python syntax.; Having named our molecule ``h2o`` we can then set the values of ``R`` and ``A`` within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the ``set`` keyword. Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See :srcsample:`scf4` for analogous Z-matrix; and Cartiesian scans. .. _`sec:resultsTables`:. Tables of Results; =================. The Psithon function ``psi4.driver.p4util.Table`` has been removed,; as the Python ecosystem provides many more flexible alternatives. An; example tabulating a potential energy surface scan for water with Pandas; is shown below::. molecule h2o {; O; H 1 R; H 1 R 2 A; }; ; Rvals=[0.9,1.0,1.1]; Avals=range(100,103,2); ; rows = []; table = []; ; set basis cc-pvdz; ; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = variable('SCF TOTAL ENERGY'); edfmp2 = variable('MP2 TOTAL ENERGY'); escsmp2 = variable('SCS-MP2 TOTAL ENERGY'); rows.append((R, A)); table.append([escf, escsmp2, ",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:1622,Testability,test,test,1622," GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:psithonInput`:. ==================================; Psithon: Structuring an Input File; ==================================. To allow arbitrarily complex computations to be performed, |PSIfour| was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; |PSIfour| is distributed with an extensive test suite, described in section; :ref:`apdx:testSuite`; the input files for these test cases can be found in the; samples subdirectory of the top-level |PSIfour| source directory and should; serve as useful examples. .. index:: physical constants; .. _`sec:physicalConstants`:. Physical Constants; ==================. For convenience, the Python interpreter will execute the contents of the; |psirc| file in the current user's home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the |psirc| file ::. UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable ``UGC`` available in all |PSIfour| input files.; For convenience, the physical constants used within the |PSIfour| code (which; are obtained from `NIST CODATA 2014; <https://physics.nist.gov/cuu/Constants/archive2014.html>`_; are also automatically loaded as Psithon; variables (befor",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:1667,Testability,test,testSuite,1667," GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:psithonInput`:. ==================================; Psithon: Structuring an Input File; ==================================. To allow arbitrarily complex computations to be performed, |PSIfour| was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; |PSIfour| is distributed with an extensive test suite, described in section; :ref:`apdx:testSuite`; the input files for these test cases can be found in the; samples subdirectory of the top-level |PSIfour| source directory and should; serve as useful examples. .. index:: physical constants; .. _`sec:physicalConstants`:. Physical Constants; ==================. For convenience, the Python interpreter will execute the contents of the; |psirc| file in the current user's home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the |psirc| file ::. UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable ``UGC`` available in all |PSIfour| input files.; For convenience, the physical constants used within the |PSIfour| code (which; are obtained from `NIST CODATA 2014; <https://physics.nist.gov/cuu/Constants/archive2014.html>`_; are also automatically loaded as Psithon; variables (befor",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:1705,Testability,test,test,1705," GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:psithonInput`:. ==================================; Psithon: Structuring an Input File; ==================================. To allow arbitrarily complex computations to be performed, |PSIfour| was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; |PSIfour| is distributed with an extensive test suite, described in section; :ref:`apdx:testSuite`; the input files for these test cases can be found in the; samples subdirectory of the top-level |PSIfour| source directory and should; serve as useful examples. .. index:: physical constants; .. _`sec:physicalConstants`:. Physical Constants; ==================. For convenience, the Python interpreter will execute the contents of the; |psirc| file in the current user's home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the |psirc| file ::. UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable ``UGC`` available in all |PSIfour| input files.; For convenience, the physical constants used within the |PSIfour| code (which; are obtained from `NIST CODATA 2014; <https://physics.nist.gov/cuu/Constants/archive2014.html>`_; are also automatically loaded as Psithon; variables (befor",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:16706,Testability,benchmark,benchmark,16706,"l <sec:tutorial>` section,; the :py:func:`~psi4.driver.driver_nbody.nbody` wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example, ::. energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules. |PSIfour| also provides the :py:func:`~psi4.driver.cbs` wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,::. # all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree--Fock energy in the; largest basis (cc-pVTZ). :py:func:`~psi4.driver.cbs` can; be configured behind-the-scenes with explicit arguments, as in the; first example, or the convenience syntax of the equivalent second; example can be used. Another very useful and powerful feature of |PSIfour| is the ability; to compute results on entire databases of molecules at a time,; as provided by the :py:func:`~psi4.driver.wrapper_database.database` wrapper. For example,::. database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (``cp=1``) on all members of Hobza's S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others. These wrapper functions are discussed separately in; :ref:`sec:psithonFunc`. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the ``set {...}`` block or with any other ``set`` command. ",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:16916,Testability,benchmark,benchmark,16916,"l <sec:tutorial>` section,; the :py:func:`~psi4.driver.driver_nbody.nbody` wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example, ::. energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules. |PSIfour| also provides the :py:func:`~psi4.driver.cbs` wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,::. # all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree--Fock energy in the; largest basis (cc-pVTZ). :py:func:`~psi4.driver.cbs` can; be configured behind-the-scenes with explicit arguments, as in the; first example, or the convenience syntax of the equivalent second; example can be used. Another very useful and powerful feature of |PSIfour| is the ability; to compute results on entire databases of molecules at a time,; as provided by the :py:func:`~psi4.driver.wrapper_database.database` wrapper. For example,::. database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (``cp=1``) on all members of Hobza's S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others. These wrapper functions are discussed separately in; :ref:`sec:psithonFunc`. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the ``set {...}`` block or with any other ``set`` command. ",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:1337,Usability,simpl,simpler,1337,"the GNU Lesser General Public License as published by; .. # the Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:psithonInput`:. ==================================; Psithon: Structuring an Input File; ==================================. To allow arbitrarily complex computations to be performed, |PSIfour| was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; |PSIfour| is distributed with an extensive test suite, described in section; :ref:`apdx:testSuite`; the input files for these test cases can be found in the; samples subdirectory of the top-level |PSIfour| source directory and should; serve as useful examples. .. index:: physical constants; .. _`sec:physicalConstants`:. Physical Constants; ==================. For convenience, the Python interpreter will execute the contents of the; |psirc| file in the current user's home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the |psirc| file ::. UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:10374,Usability,clear,cleared,10374,"l result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation. Generally, there are multiple quantities of interest. Appendix; :ref:`apdx:psivariables_module` lists PSI variables variables set by each; module, and :ref:`apdx:psivariables_alpha` defines them. These can be; accessed through the :py:func:`~psi4.core.get_variable` function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available::. e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command :py:func:`~psi4.core.print_variables`. Note that PSI variables; are cleared at the start of each :py:func:`~psi4.driver.energy`, etc. in an input; file by :py:func:`~psi4.core.clean_variables()`.; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a :py:func:`~psi4.core.print_variables` command, the; last will include :psivar:`SCF TOTAL ENERGY` but not; :psivar:`FCI TOTAL ENERGY`.; The entire dictionary of PSI variables can be obtained through; :py:func:`~psi4.core.get_variables`. .. _`sec:returnvals`:. Return Values; =============. Most of the usual user computation functions (*i.e.*,; :py:func:`~psi4.driver.energy`, :py:func:`~psi4.driver.optimize`, and; :py:func:`~psi4.driver.frequency`) return simply the current total energy.; Consult the descriptions of other functions in :ref:`sec:psithonFunc` for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions. ::. # E is total energy float; # ",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:11055,Usability,simpl,simply,11055,"able('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command :py:func:`~psi4.core.print_variables`. Note that PSI variables; are cleared at the start of each :py:func:`~psi4.driver.energy`, etc. in an input; file by :py:func:`~psi4.core.clean_variables()`.; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a :py:func:`~psi4.core.print_variables` command, the; last will include :psivar:`SCF TOTAL ENERGY` but not; :psivar:`FCI TOTAL ENERGY`.; The entire dictionary of PSI variables can be obtained through; :py:func:`~psi4.core.get_variables`. .. _`sec:returnvals`:. Return Values; =============. Most of the usual user computation functions (*i.e.*,; :py:func:`~psi4.driver.energy`, :py:func:`~psi4.driver.optimize`, and; :py:func:`~psi4.driver.frequency`) return simply the current total energy.; Consult the descriptions of other functions in :ref:`sec:psithonFunc` for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions. ::. # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; ``return_wfn=True`` keyword argument additionally returns; :py:class:`~psi4.core.Wavefunction`. ::. # power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency()",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:11298,Usability,simpl,simple,11298," :py:func:`~psi4.core.print_variables`. Note that PSI variables; are cleared at the start of each :py:func:`~psi4.driver.energy`, etc. in an input; file by :py:func:`~psi4.core.clean_variables()`.; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a :py:func:`~psi4.core.print_variables` command, the; last will include :psivar:`SCF TOTAL ENERGY` but not; :psivar:`FCI TOTAL ENERGY`.; The entire dictionary of PSI variables can be obtained through; :py:func:`~psi4.core.get_variables`. .. _`sec:returnvals`:. Return Values; =============. Most of the usual user computation functions (*i.e.*,; :py:func:`~psi4.driver.energy`, :py:func:`~psi4.driver.optimize`, and; :py:func:`~psi4.driver.frequency`) return simply the current total energy.; Consult the descriptions of other functions in :ref:`sec:psithonFunc` for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions. ::. # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; ``return_wfn=True`` keyword argument additionally returns; :py:class:`~psi4.core.Wavefunction`. ::. # power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). .. _`sec:loops`:. Loops; =",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst:11484,Usability,simpl,simple,11484,"s()`.; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a :py:func:`~psi4.core.print_variables` command, the; last will include :psivar:`SCF TOTAL ENERGY` but not; :psivar:`FCI TOTAL ENERGY`.; The entire dictionary of PSI variables can be obtained through; :py:func:`~psi4.core.get_variables`. .. _`sec:returnvals`:. Return Values; =============. Most of the usual user computation functions (*i.e.*,; :py:func:`~psi4.driver.energy`, :py:func:`~psi4.driver.optimize`, and; :py:func:`~psi4.driver.frequency`) return simply the current total energy.; Consult the descriptions of other functions in :ref:`sec:psithonFunc` for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions. ::. # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; ``return_wfn=True`` keyword argument additionally returns; :py:class:`~psi4.core.Wavefunction`. ::. # power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). .. _`sec:loops`:. Loops; =====. Python provides many control structures, any of which can be used within |PSIfour|; input files. For example, to loop over three basis sets, the following code can; be used:. .. code-blo",MatchSource.DOCS,doc/sphinxman/source/psithoninput.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithoninput.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:18215,Availability,reliab,reliable,18215,"0, 1, 0]. in the input file. If any ensuing computations lower the symmetry, the above; array will be appropriately remapped. For example, reducing the symmetry to; :math:`C_s` (with the molecular plane defining the mirror plane), the above; array will be automatically interpreted as::. SOCC = [0, 1]. Some caution is required, however. The :math:`^2A_1` state can be obtained with; the ::. SOCC = [1, 0, 0, 0]. specification, which would become ::. SOCC = [1, 0]. under the above-mentioned reduction in symmetry. The :math:`^2B_2` state,; whose singly-occupied orbitals are ::. SOCC = [0, 0, 0, 1]. would be mapped to ::. SOCC = [1, 0]. which is the same occupation as the :math:`^2A_1` state. In this case, the; :math:`^2A_1` state is lower in energy, and is not problematic. The distorted; geometries for the :math:`^2B_2` state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it's easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. .. index:: molecule; multiple fragments; .. _`sec:fragments`:. Non-Covalently Bonded Molecule Fragments; ========================================. |PSIfour| has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. |PSIfour| provides a very simple mechanism; for doing so: simply define the complex's geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragments. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block::. molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:3031,Deployability,patch,patch,3031,"ot matter, although the ``molecule`` keyword itself must; be aligned within the input according to standard Python syntax. For more; examples of geometry specification, see the :srcsample:`mints1` input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the :srcsample:`mints4` and; :srcsample:`mints6` sample input files. For example, consider the following; geometry specification, taken from the :srcsample:`mints6` input::. molecule alanine {; N -1.527107413251 0.745960643462 0.766603000356; C -0.075844098953 0.811790225041 0.711418672248; C 0.503195220163 -0.247849447550 -0.215671574613; O -0.351261319421 -0.748978309671 -1.089590304723; O 1.639498336738 -0.571249748886 -0.174705953194; H -1.207655674855 -0.365913941094 -0.918035522052; # First, remove the H from the alpha carbon. This line could be deleted; # and is only included for completeness; #H 0.429560656538 0.717651915252 1.673774709694; # Now patch it, using a Z Matrix specification. This patch can be applied; # anywhere in the coord specification, as long as it appears lower than; # the atoms referenced, as is usual for Z-Matrices; C 2 rCC 3 aCCC 1 dCCCN; H 7 rCH1 2 aHCC1 3 dHCCC1; H 7 rCH2 2 aHCC2 3 dHCCC2; H 7 rCH3 2 aHCC3 3 dHCCC3; H 0.221781602033 1.772570540211 0.286988509018; H -1.833601608592 0.108401996052 1.481873213172; H -1.925572581453 1.640882152784 0.986471814808; ; aCCC = 108.0; rCC = 1.4; dCCCN = 120; rCH1 = 1.08; rCH2 = 1.08; rCH3 = 1.08; aHCC1 = 109.0; aHCC2 = 109.0; aHCC3 = 109.0; dHCCC1 = 0.0; dHCCC2 = 120.0; dHCCC3 = 240.0; }. Here, we remove the hydrogen from the alpha carbon of glycine and replace it; with a methyl group. Applying this patch using Cartesian coordinates is; difficult, because it depends on the orientation of the existing glycine unit.; In this example, we use Z-Matrix coordinates to define the methyl group, and; define the orientation in terms of the existing glycine Cartesian coordinates; which",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:3078,Deployability,patch,patch,3078,"ation, see the :srcsample:`mints1` input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the :srcsample:`mints4` and; :srcsample:`mints6` sample input files. For example, consider the following; geometry specification, taken from the :srcsample:`mints6` input::. molecule alanine {; N -1.527107413251 0.745960643462 0.766603000356; C -0.075844098953 0.811790225041 0.711418672248; C 0.503195220163 -0.247849447550 -0.215671574613; O -0.351261319421 -0.748978309671 -1.089590304723; O 1.639498336738 -0.571249748886 -0.174705953194; H -1.207655674855 -0.365913941094 -0.918035522052; # First, remove the H from the alpha carbon. This line could be deleted; # and is only included for completeness; #H 0.429560656538 0.717651915252 1.673774709694; # Now patch it, using a Z Matrix specification. This patch can be applied; # anywhere in the coord specification, as long as it appears lower than; # the atoms referenced, as is usual for Z-Matrices; C 2 rCC 3 aCCC 1 dCCCN; H 7 rCH1 2 aHCC1 3 dHCCC1; H 7 rCH2 2 aHCC2 3 dHCCC2; H 7 rCH3 2 aHCC3 3 dHCCC3; H 0.221781602033 1.772570540211 0.286988509018; H -1.833601608592 0.108401996052 1.481873213172; H -1.925572581453 1.640882152784 0.986471814808; ; aCCC = 108.0; rCC = 1.4; dCCCN = 120; rCH1 = 1.08; rCH2 = 1.08; rCH3 = 1.08; aHCC1 = 109.0; aHCC2 = 109.0; aHCC3 = 109.0; dHCCC1 = 0.0; dHCCC2 = 120.0; dHCCC3 = 240.0; }. Here, we remove the hydrogen from the alpha carbon of glycine and replace it; with a methyl group. Applying this patch using Cartesian coordinates is; difficult, because it depends on the orientation of the existing glycine unit.; In this example, we use Z-Matrix coordinates to define the methyl group, and; define the orientation in terms of the existing glycine Cartesian coordinates; which is much easier to visualize than the corresponding Cartesian-only; approach. .. index:: molecule; multiple in input file; .. _`sec:multipleMolecules`:. .. index",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:3762,Deployability,patch,patch,3762," -1.207655674855 -0.365913941094 -0.918035522052; # First, remove the H from the alpha carbon. This line could be deleted; # and is only included for completeness; #H 0.429560656538 0.717651915252 1.673774709694; # Now patch it, using a Z Matrix specification. This patch can be applied; # anywhere in the coord specification, as long as it appears lower than; # the atoms referenced, as is usual for Z-Matrices; C 2 rCC 3 aCCC 1 dCCCN; H 7 rCH1 2 aHCC1 3 dHCCC1; H 7 rCH2 2 aHCC2 3 dHCCC2; H 7 rCH3 2 aHCC3 3 dHCCC3; H 0.221781602033 1.772570540211 0.286988509018; H -1.833601608592 0.108401996052 1.481873213172; H -1.925572581453 1.640882152784 0.986471814808; ; aCCC = 108.0; rCC = 1.4; dCCCN = 120; rCH1 = 1.08; rCH2 = 1.08; rCH3 = 1.08; aHCC1 = 109.0; aHCC2 = 109.0; aHCC3 = 109.0; dHCCC1 = 0.0; dHCCC2 = 120.0; dHCCC3 = 240.0; }. Here, we remove the hydrogen from the alpha carbon of glycine and replace it; with a methyl group. Applying this patch using Cartesian coordinates is; difficult, because it depends on the orientation of the existing glycine unit.; In this example, we use Z-Matrix coordinates to define the methyl group, and; define the orientation in terms of the existing glycine Cartesian coordinates; which is much easier to visualize than the corresponding Cartesian-only; approach. .. index:: molecule; multiple in input file; .. _`sec:multipleMolecules`:. .. index::; triple: setting; keywords; molecule; pair: molecule; charge; pair: molecule; multiplicity; pair: molecule; symmetry; pair: molecule; no_reorient; pair: molecule; units; .. _`sec:moleculeKeywords`:. Molecule Keywords; =================. In addition to specifying the geometry, additional information can be; provided in the molecule block :samp:`molecule {optional_molecule_name} \\{...\\}`. **Charge & Multiplicity**; If two integers :samp:`{charge} {multiplicity}` are encountered on any; line of the molecule block, they are interpreted as the molecular charge; and multiplicity (:math:`2 M_s + 1`), resp",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:22148,Deployability,update,update,22148,"ecule contains fragments but is not conveniently ordered for the; ``--`` marker, the :py:func:`~psi4.driver.wrapper_autofrag.auto_fragments` function can be applied, as shown in; :srcsample:`pywrap-basis`, to return as active molecule the previous; active molecule, only fragmented. Advanced Python; ===============. A named molecule in an input file is a full-fledged instance of the; powerful C++ :py:class:`~psi4.core.Molecule` class. Thus, all member; functions (that have been exported via pybind11) documented thereat; are accessible through the handle :samp:`{option_molecule_name}` in; :samp:`molecule {optional_molecule_name} \\{...\\}`. * The molecular geometry can be got and set and manipulated as a; :py:class:`~psi4.core.Matrix` object. Below shows how to access; coordinates in an input file in Python. ::. molecule formaldehyde {; C 0.0 0.0 0.0; O 0.0 1.2 0.0; H -0.8 -0.3 0.0; H 0.8 -0.3 0.0 # set geometry in angstroms; }. formaldehyde.update_geometry() # update the molecule internals since pre-energy()-like call; formaldehyde.print_out() # print molecule to output file; geom1psi = formaldehyde.geometry() # get coordinates in bohr as a psi4.Matrix. geom1psi.print_out() # print coordinates array to output file; geom1py = mat2arr(geom1psi) # get coordinates as a Python array; print geom1py # print coordinates to screen. geom2py = [[ 0.0, 0.0, 0.0],; [ 0.0, 1.5, 0.0],; [-0.8, -0.3, 0.0],; [ 0.8, -0.3, 0.0]] # define alternate coordinates in angstroms as Python array. geom2psi = psi4.Matrix(4, 3) # initialize psi4.Matrix; geom2psi.set(geom2py) # load Python array into psi4.Matrix; geom2psi.scale(1.0/psi_bohr2angstroms) # scale into bohr; geom2psi.print_out() # print alternate coord array to output file. formaldehyde.set_geometry(geom2psi) # load alternate coordinates into molecule; formaldehyde.update_geometry() # update the molecule internals; formaldehyde.print_out() # print new molecule to output file; compare_values(28.9950517332, formaldehyde.nuclear_repulsion_e",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:23020,Deployability,update,update,23020,".0; O 0.0 1.2 0.0; H -0.8 -0.3 0.0; H 0.8 -0.3 0.0 # set geometry in angstroms; }. formaldehyde.update_geometry() # update the molecule internals since pre-energy()-like call; formaldehyde.print_out() # print molecule to output file; geom1psi = formaldehyde.geometry() # get coordinates in bohr as a psi4.Matrix. geom1psi.print_out() # print coordinates array to output file; geom1py = mat2arr(geom1psi) # get coordinates as a Python array; print geom1py # print coordinates to screen. geom2py = [[ 0.0, 0.0, 0.0],; [ 0.0, 1.5, 0.0],; [-0.8, -0.3, 0.0],; [ 0.8, -0.3, 0.0]] # define alternate coordinates in angstroms as Python array. geom2psi = psi4.Matrix(4, 3) # initialize psi4.Matrix; geom2psi.set(geom2py) # load Python array into psi4.Matrix; geom2psi.scale(1.0/psi_bohr2angstroms) # scale into bohr; geom2psi.print_out() # print alternate coord array to output file. formaldehyde.set_geometry(geom2psi) # load alternate coordinates into molecule; formaldehyde.update_geometry() # update the molecule internals; formaldehyde.print_out() # print new molecule to output file; compare_values(28.9950517332, formaldehyde.nuclear_repulsion_energy(), 4, ""geom2 took""). * Molecules can be initiated from XYZ files and fragmented for SAPT computations. ::. # >>> cat mol1.xyz; #7; #; #O 0.00000000 -0.05786571 -1.47979303; #N 0.00000000 0.01436394 1.46454628; #H 0.00000000 0.82293384 -1.85541474; #H 0.81348351 0.39876776 1.92934049; #H 0.00000000 0.07949567 -0.51934253; #H 0.00000000 -0.98104857 1.65344779; #H -0.81348351 0.39876776 1.92934049. # >>> cat mol2.xyz; # 6 au; # stuff; # C 0.00000000000000 0.00000000000000 5.26601138679877; # C 0.00000000000000 0.00000000000000 -3.15195886530135; # H 0.00000000000000 0.00000000000000 7.28558683837122; # H 0.00000000000000 0.00000000000000 -1.12178201232889; # N 0.00000000000000 0.00000000000000 3.08339310458383; # N 0.00000000000000 0.00000000000000 -5.33865984413460. sapt = {'mol1': -0.0105313323529,; 'mol2': -0.00839486625709}. nre = {'mol1'",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:4260,Energy Efficiency,charge,charge,4260,"aHCC2 3 dHCCC2; H 7 rCH3 2 aHCC3 3 dHCCC3; H 0.221781602033 1.772570540211 0.286988509018; H -1.833601608592 0.108401996052 1.481873213172; H -1.925572581453 1.640882152784 0.986471814808; ; aCCC = 108.0; rCC = 1.4; dCCCN = 120; rCH1 = 1.08; rCH2 = 1.08; rCH3 = 1.08; aHCC1 = 109.0; aHCC2 = 109.0; aHCC3 = 109.0; dHCCC1 = 0.0; dHCCC2 = 120.0; dHCCC3 = 240.0; }. Here, we remove the hydrogen from the alpha carbon of glycine and replace it; with a methyl group. Applying this patch using Cartesian coordinates is; difficult, because it depends on the orientation of the existing glycine unit.; In this example, we use Z-Matrix coordinates to define the methyl group, and; define the orientation in terms of the existing glycine Cartesian coordinates; which is much easier to visualize than the corresponding Cartesian-only; approach. .. index:: molecule; multiple in input file; .. _`sec:multipleMolecules`:. .. index::; triple: setting; keywords; molecule; pair: molecule; charge; pair: molecule; multiplicity; pair: molecule; symmetry; pair: molecule; no_reorient; pair: molecule; units; .. _`sec:moleculeKeywords`:. Molecule Keywords; =================. In addition to specifying the geometry, additional information can be; provided in the molecule block :samp:`molecule {optional_molecule_name} \\{...\\}`. **Charge & Multiplicity**; If two integers :samp:`{charge} {multiplicity}` are encountered on any; line of the molecule block, they are interpreted as the molecular charge; and multiplicity (:math:`2 M_s + 1`), respectively. If not specified, the; charge is taken to be zero, and the multiplicity will be taken to be the; lowest multiplicity consistent with that charge. For multi-fragment ; complexes, each fragment can have a :samp:`{charge} {multiplicity}` line.; See :ref:`sec:fragments` for details. **Units**; By default, |Angstrom| units are used; this is changed by adding; a line that reads :samp:`units {spec}`, where :samp:`{spec}` is one; of ``ang``, ``angstrom``, ``a.u.``, ``",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:4649,Energy Efficiency,charge,charge,4649,"e and replace it; with a methyl group. Applying this patch using Cartesian coordinates is; difficult, because it depends on the orientation of the existing glycine unit.; In this example, we use Z-Matrix coordinates to define the methyl group, and; define the orientation in terms of the existing glycine Cartesian coordinates; which is much easier to visualize than the corresponding Cartesian-only; approach. .. index:: molecule; multiple in input file; .. _`sec:multipleMolecules`:. .. index::; triple: setting; keywords; molecule; pair: molecule; charge; pair: molecule; multiplicity; pair: molecule; symmetry; pair: molecule; no_reorient; pair: molecule; units; .. _`sec:moleculeKeywords`:. Molecule Keywords; =================. In addition to specifying the geometry, additional information can be; provided in the molecule block :samp:`molecule {optional_molecule_name} \\{...\\}`. **Charge & Multiplicity**; If two integers :samp:`{charge} {multiplicity}` are encountered on any; line of the molecule block, they are interpreted as the molecular charge; and multiplicity (:math:`2 M_s + 1`), respectively. If not specified, the; charge is taken to be zero, and the multiplicity will be taken to be the; lowest multiplicity consistent with that charge. For multi-fragment ; complexes, each fragment can have a :samp:`{charge} {multiplicity}` line.; See :ref:`sec:fragments` for details. **Units**; By default, |Angstrom| units are used; this is changed by adding; a line that reads :samp:`units {spec}`, where :samp:`{spec}` is one; of ``ang``, ``angstrom``, ``a.u.``, ``au``, or ``bohr``. **Orientation**; Certain computations require that the molecule is not reoriented. This ; can be achieved by adding either ``no_reorient`` or ``noreorient``. ; To prevent even recentering of the molecule, add ``no_com`` or ``nocom``. **PubChem**; A line reading :samp:`pubchem:{mol}` fetches the geometry for molecule; :samp:`{mol}` from the PubChem database, where :samp:`{mol}` is either; the IUPAC mol",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:4763,Energy Efficiency,charge,charge,4763,"e and replace it; with a methyl group. Applying this patch using Cartesian coordinates is; difficult, because it depends on the orientation of the existing glycine unit.; In this example, we use Z-Matrix coordinates to define the methyl group, and; define the orientation in terms of the existing glycine Cartesian coordinates; which is much easier to visualize than the corresponding Cartesian-only; approach. .. index:: molecule; multiple in input file; .. _`sec:multipleMolecules`:. .. index::; triple: setting; keywords; molecule; pair: molecule; charge; pair: molecule; multiplicity; pair: molecule; symmetry; pair: molecule; no_reorient; pair: molecule; units; .. _`sec:moleculeKeywords`:. Molecule Keywords; =================. In addition to specifying the geometry, additional information can be; provided in the molecule block :samp:`molecule {optional_molecule_name} \\{...\\}`. **Charge & Multiplicity**; If two integers :samp:`{charge} {multiplicity}` are encountered on any; line of the molecule block, they are interpreted as the molecular charge; and multiplicity (:math:`2 M_s + 1`), respectively. If not specified, the; charge is taken to be zero, and the multiplicity will be taken to be the; lowest multiplicity consistent with that charge. For multi-fragment ; complexes, each fragment can have a :samp:`{charge} {multiplicity}` line.; See :ref:`sec:fragments` for details. **Units**; By default, |Angstrom| units are used; this is changed by adding; a line that reads :samp:`units {spec}`, where :samp:`{spec}` is one; of ``ang``, ``angstrom``, ``a.u.``, ``au``, or ``bohr``. **Orientation**; Certain computations require that the molecule is not reoriented. This ; can be achieved by adding either ``no_reorient`` or ``noreorient``. ; To prevent even recentering of the molecule, add ``no_com`` or ``nocom``. **PubChem**; A line reading :samp:`pubchem:{mol}` fetches the geometry for molecule; :samp:`{mol}` from the PubChem database, where :samp:`{mol}` is either; the IUPAC mol",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:4846,Energy Efficiency,charge,charge,4846,", we use Z-Matrix coordinates to define the methyl group, and; define the orientation in terms of the existing glycine Cartesian coordinates; which is much easier to visualize than the corresponding Cartesian-only; approach. .. index:: molecule; multiple in input file; .. _`sec:multipleMolecules`:. .. index::; triple: setting; keywords; molecule; pair: molecule; charge; pair: molecule; multiplicity; pair: molecule; symmetry; pair: molecule; no_reorient; pair: molecule; units; .. _`sec:moleculeKeywords`:. Molecule Keywords; =================. In addition to specifying the geometry, additional information can be; provided in the molecule block :samp:`molecule {optional_molecule_name} \\{...\\}`. **Charge & Multiplicity**; If two integers :samp:`{charge} {multiplicity}` are encountered on any; line of the molecule block, they are interpreted as the molecular charge; and multiplicity (:math:`2 M_s + 1`), respectively. If not specified, the; charge is taken to be zero, and the multiplicity will be taken to be the; lowest multiplicity consistent with that charge. For multi-fragment ; complexes, each fragment can have a :samp:`{charge} {multiplicity}` line.; See :ref:`sec:fragments` for details. **Units**; By default, |Angstrom| units are used; this is changed by adding; a line that reads :samp:`units {spec}`, where :samp:`{spec}` is one; of ``ang``, ``angstrom``, ``a.u.``, ``au``, or ``bohr``. **Orientation**; Certain computations require that the molecule is not reoriented. This ; can be achieved by adding either ``no_reorient`` or ``noreorient``. ; To prevent even recentering of the molecule, add ``no_com`` or ``nocom``. **PubChem**; A line reading :samp:`pubchem:{mol}` fetches the geometry for molecule; :samp:`{mol}` from the PubChem database, where :samp:`{mol}` is either; the IUPAC molecule name or the CID number. See :ref:`sec:pubchem` for; details. **Symmetry**; The symmetry can be specified by a line reading :samp:`symmetry; {symbol}`, where :samp:`{symbol}` is th",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:4961,Energy Efficiency,charge,charge,4961,", we use Z-Matrix coordinates to define the methyl group, and; define the orientation in terms of the existing glycine Cartesian coordinates; which is much easier to visualize than the corresponding Cartesian-only; approach. .. index:: molecule; multiple in input file; .. _`sec:multipleMolecules`:. .. index::; triple: setting; keywords; molecule; pair: molecule; charge; pair: molecule; multiplicity; pair: molecule; symmetry; pair: molecule; no_reorient; pair: molecule; units; .. _`sec:moleculeKeywords`:. Molecule Keywords; =================. In addition to specifying the geometry, additional information can be; provided in the molecule block :samp:`molecule {optional_molecule_name} \\{...\\}`. **Charge & Multiplicity**; If two integers :samp:`{charge} {multiplicity}` are encountered on any; line of the molecule block, they are interpreted as the molecular charge; and multiplicity (:math:`2 M_s + 1`), respectively. If not specified, the; charge is taken to be zero, and the multiplicity will be taken to be the; lowest multiplicity consistent with that charge. For multi-fragment ; complexes, each fragment can have a :samp:`{charge} {multiplicity}` line.; See :ref:`sec:fragments` for details. **Units**; By default, |Angstrom| units are used; this is changed by adding; a line that reads :samp:`units {spec}`, where :samp:`{spec}` is one; of ``ang``, ``angstrom``, ``a.u.``, ``au``, or ``bohr``. **Orientation**; Certain computations require that the molecule is not reoriented. This ; can be achieved by adding either ``no_reorient`` or ``noreorient``. ; To prevent even recentering of the molecule, add ``no_com`` or ``nocom``. **PubChem**; A line reading :samp:`pubchem:{mol}` fetches the geometry for molecule; :samp:`{mol}` from the PubChem database, where :samp:`{mol}` is either; the IUPAC molecule name or the CID number. See :ref:`sec:pubchem` for; details. **Symmetry**; The symmetry can be specified by a line reading :samp:`symmetry; {symbol}`, where :samp:`{symbol}` is th",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:5034,Energy Efficiency,charge,charge,5034,"artesian coordinates; which is much easier to visualize than the corresponding Cartesian-only; approach. .. index:: molecule; multiple in input file; .. _`sec:multipleMolecules`:. .. index::; triple: setting; keywords; molecule; pair: molecule; charge; pair: molecule; multiplicity; pair: molecule; symmetry; pair: molecule; no_reorient; pair: molecule; units; .. _`sec:moleculeKeywords`:. Molecule Keywords; =================. In addition to specifying the geometry, additional information can be; provided in the molecule block :samp:`molecule {optional_molecule_name} \\{...\\}`. **Charge & Multiplicity**; If two integers :samp:`{charge} {multiplicity}` are encountered on any; line of the molecule block, they are interpreted as the molecular charge; and multiplicity (:math:`2 M_s + 1`), respectively. If not specified, the; charge is taken to be zero, and the multiplicity will be taken to be the; lowest multiplicity consistent with that charge. For multi-fragment ; complexes, each fragment can have a :samp:`{charge} {multiplicity}` line.; See :ref:`sec:fragments` for details. **Units**; By default, |Angstrom| units are used; this is changed by adding; a line that reads :samp:`units {spec}`, where :samp:`{spec}` is one; of ``ang``, ``angstrom``, ``a.u.``, ``au``, or ``bohr``. **Orientation**; Certain computations require that the molecule is not reoriented. This ; can be achieved by adding either ``no_reorient`` or ``noreorient``. ; To prevent even recentering of the molecule, add ``no_com`` or ``nocom``. **PubChem**; A line reading :samp:`pubchem:{mol}` fetches the geometry for molecule; :samp:`{mol}` from the PubChem database, where :samp:`{mol}` is either; the IUPAC molecule name or the CID number. See :ref:`sec:pubchem` for; details. **Symmetry**; The symmetry can be specified by a line reading :samp:`symmetry; {symbol}`, where :samp:`{symbol}` is the Sch\ |o_dots|\ nflies symbol; of the (Abelian) point group to use for the computation, one of one of; ``c1``, ``c2``, `",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:6689,Energy Efficiency,energy,energy,6689,"l}` is either; the IUPAC molecule name or the CID number. See :ref:`sec:pubchem` for; details. **Symmetry**; The symmetry can be specified by a line reading :samp:`symmetry; {symbol}`, where :samp:`{symbol}` is the Sch\ |o_dots|\ nflies symbol; of the (Abelian) point group to use for the computation, one of one of; ``c1``, ``c2``, ``ci``, ``cs``, ``d2``, ``c2h``, ``c2v``, or ``d2h``.; This need not be specified, as the molecular symmetry is automatically; detected by |PSIfour|. See :ref:`sec:symmetry` for details. **Fragments**; A line reading ``--`` is interpreted as the separator between two non-covalently ; bound molecular fragments. See :ref:`sec:fragments` for details. Multiple Molecules; ==================. To facilitate more elaborate computations, it is possible to provide a name for; each molecule and tell |PSIfour| which one should be used in a given; calculation. For example, consider the following input file::. molecule h2 {; H; H 1 0.9; }; ; set basis cc-pvdz; set reference rhf; energy('scf') # on H2; ; clean(). molecule h {; H; }; ; set basis cc-pvdz; set reference uhf; energy('scf') # on H. Here, two separate jobs are performed on two different molecules; the first is; performed on H\ :sub:`2`, while the second is for H atom. The last molecule to be; specified is the ""active"" molecule by default. To explicitly activate a named; molecule, the activate command is provided. With it, the above input file can be; equivalently written as follows. Alternatively, the molecule can be specified; directly to the computing function. Below, the third calculation is the same as; the first. ::. molecule h2 {; H; H 1 0.9; }; ; molecule h {; H; }; ; activate(h2); set basis cc-pvdz; set reference rhf; energy('scf') # on H2; ; clean(). activate(h); set basis cc-pvdz; set reference uhf; energy('scf') # on H. # --------------------------------------; # equivalent to previous input ends here. clean(). set reference rhf; energy('scf', molecule=h2) # on H2. :ref:`sec:jobContr",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:6783,Energy Efficiency,energy,energy,6783,"for; details. **Symmetry**; The symmetry can be specified by a line reading :samp:`symmetry; {symbol}`, where :samp:`{symbol}` is the Sch\ |o_dots|\ nflies symbol; of the (Abelian) point group to use for the computation, one of one of; ``c1``, ``c2``, ``ci``, ``cs``, ``d2``, ``c2h``, ``c2v``, or ``d2h``.; This need not be specified, as the molecular symmetry is automatically; detected by |PSIfour|. See :ref:`sec:symmetry` for details. **Fragments**; A line reading ``--`` is interpreted as the separator between two non-covalently ; bound molecular fragments. See :ref:`sec:fragments` for details. Multiple Molecules; ==================. To facilitate more elaborate computations, it is possible to provide a name for; each molecule and tell |PSIfour| which one should be used in a given; calculation. For example, consider the following input file::. molecule h2 {; H; H 1 0.9; }; ; set basis cc-pvdz; set reference rhf; energy('scf') # on H2; ; clean(). molecule h {; H; }; ; set basis cc-pvdz; set reference uhf; energy('scf') # on H. Here, two separate jobs are performed on two different molecules; the first is; performed on H\ :sub:`2`, while the second is for H atom. The last molecule to be; specified is the ""active"" molecule by default. To explicitly activate a named; molecule, the activate command is provided. With it, the above input file can be; equivalently written as follows. Alternatively, the molecule can be specified; directly to the computing function. Below, the third calculation is the same as; the first. ::. molecule h2 {; H; H 1 0.9; }; ; molecule h {; H; }; ; activate(h2); set basis cc-pvdz; set reference rhf; energy('scf') # on H2; ; clean(). activate(h); set basis cc-pvdz; set reference uhf; energy('scf') # on H. # --------------------------------------; # equivalent to previous input ends here. clean(). set reference rhf; energy('scf', molecule=h2) # on H2. :ref:`sec:jobControl` provides more details about the job control; and calculation keywords used i",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:7410,Energy Efficiency,energy,energy,7410,"==================. To facilitate more elaborate computations, it is possible to provide a name for; each molecule and tell |PSIfour| which one should be used in a given; calculation. For example, consider the following input file::. molecule h2 {; H; H 1 0.9; }; ; set basis cc-pvdz; set reference rhf; energy('scf') # on H2; ; clean(). molecule h {; H; }; ; set basis cc-pvdz; set reference uhf; energy('scf') # on H. Here, two separate jobs are performed on two different molecules; the first is; performed on H\ :sub:`2`, while the second is for H atom. The last molecule to be; specified is the ""active"" molecule by default. To explicitly activate a named; molecule, the activate command is provided. With it, the above input file can be; equivalently written as follows. Alternatively, the molecule can be specified; directly to the computing function. Below, the third calculation is the same as; the first. ::. molecule h2 {; H; H 1 0.9; }; ; molecule h {; H; }; ; activate(h2); set basis cc-pvdz; set reference rhf; energy('scf') # on H2; ; clean(). activate(h); set basis cc-pvdz; set reference uhf; energy('scf') # on H. # --------------------------------------; # equivalent to previous input ends here. clean(). set reference rhf; energy('scf', molecule=h2) # on H2. :ref:`sec:jobControl` provides more details about the job control; and calculation keywords used in the above examples. .. index:: ; single: Ghost Atoms; single: molecule; ghost; .. _`sec:ghosts`:. Ghost Atoms; ===========. While many common computations, particularly SAPT and counterpoise corrections, can; be greatly simplified using the notation described in :ref:`sec:fragments`,; manual specification of ghost atoms is sometimes required. Either ::. molecule he2 {; He; Gh(He) 1 2.0; }. or ::. molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer with the second atom ghosted, *i.e.*, possessing; basis functions but no electrons or nuclear charge. See :srcsample:`dfmp2-1`; and :srcsample:`ghosts` for a ",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:7495,Energy Efficiency,energy,energy,7495,"e for; each molecule and tell |PSIfour| which one should be used in a given; calculation. For example, consider the following input file::. molecule h2 {; H; H 1 0.9; }; ; set basis cc-pvdz; set reference rhf; energy('scf') # on H2; ; clean(). molecule h {; H; }; ; set basis cc-pvdz; set reference uhf; energy('scf') # on H. Here, two separate jobs are performed on two different molecules; the first is; performed on H\ :sub:`2`, while the second is for H atom. The last molecule to be; specified is the ""active"" molecule by default. To explicitly activate a named; molecule, the activate command is provided. With it, the above input file can be; equivalently written as follows. Alternatively, the molecule can be specified; directly to the computing function. Below, the third calculation is the same as; the first. ::. molecule h2 {; H; H 1 0.9; }; ; molecule h {; H; }; ; activate(h2); set basis cc-pvdz; set reference rhf; energy('scf') # on H2; ; clean(). activate(h); set basis cc-pvdz; set reference uhf; energy('scf') # on H. # --------------------------------------; # equivalent to previous input ends here. clean(). set reference rhf; energy('scf', molecule=h2) # on H2. :ref:`sec:jobControl` provides more details about the job control; and calculation keywords used in the above examples. .. index:: ; single: Ghost Atoms; single: molecule; ghost; .. _`sec:ghosts`:. Ghost Atoms; ===========. While many common computations, particularly SAPT and counterpoise corrections, can; be greatly simplified using the notation described in :ref:`sec:fragments`,; manual specification of ghost atoms is sometimes required. Either ::. molecule he2 {; He; Gh(He) 1 2.0; }. or ::. molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer with the second atom ghosted, *i.e.*, possessing; basis functions but no electrons or nuclear charge. See :srcsample:`dfmp2-1`; and :srcsample:`ghosts` for a demonstration of both mechanisms for specifying; ghost atoms. .. index:: ; single: Isotopes; s",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:7629,Energy Efficiency,energy,energy,7629," H 1 0.9; }; ; set basis cc-pvdz; set reference rhf; energy('scf') # on H2; ; clean(). molecule h {; H; }; ; set basis cc-pvdz; set reference uhf; energy('scf') # on H. Here, two separate jobs are performed on two different molecules; the first is; performed on H\ :sub:`2`, while the second is for H atom. The last molecule to be; specified is the ""active"" molecule by default. To explicitly activate a named; molecule, the activate command is provided. With it, the above input file can be; equivalently written as follows. Alternatively, the molecule can be specified; directly to the computing function. Below, the third calculation is the same as; the first. ::. molecule h2 {; H; H 1 0.9; }; ; molecule h {; H; }; ; activate(h2); set basis cc-pvdz; set reference rhf; energy('scf') # on H2; ; clean(). activate(h); set basis cc-pvdz; set reference uhf; energy('scf') # on H. # --------------------------------------; # equivalent to previous input ends here. clean(). set reference rhf; energy('scf', molecule=h2) # on H2. :ref:`sec:jobControl` provides more details about the job control; and calculation keywords used in the above examples. .. index:: ; single: Ghost Atoms; single: molecule; ghost; .. _`sec:ghosts`:. Ghost Atoms; ===========. While many common computations, particularly SAPT and counterpoise corrections, can; be greatly simplified using the notation described in :ref:`sec:fragments`,; manual specification of ghost atoms is sometimes required. Either ::. molecule he2 {; He; Gh(He) 1 2.0; }. or ::. molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer with the second atom ghosted, *i.e.*, possessing; basis functions but no electrons or nuclear charge. See :srcsample:`dfmp2-1`; and :srcsample:`ghosts` for a demonstration of both mechanisms for specifying; ghost atoms. .. index:: ; single: Isotopes; single: molecule; isotope; .. _`sec:isotope`:. Isotopic Substitution; =====================. .. caution:: Use of isotopic substitution in |PSIfour| is not wel",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:8322,Energy Efficiency,charge,charge,8322,"st. ::. molecule h2 {; H; H 1 0.9; }; ; molecule h {; H; }; ; activate(h2); set basis cc-pvdz; set reference rhf; energy('scf') # on H2; ; clean(). activate(h); set basis cc-pvdz; set reference uhf; energy('scf') # on H. # --------------------------------------; # equivalent to previous input ends here. clean(). set reference rhf; energy('scf', molecule=h2) # on H2. :ref:`sec:jobControl` provides more details about the job control; and calculation keywords used in the above examples. .. index:: ; single: Ghost Atoms; single: molecule; ghost; .. _`sec:ghosts`:. Ghost Atoms; ===========. While many common computations, particularly SAPT and counterpoise corrections, can; be greatly simplified using the notation described in :ref:`sec:fragments`,; manual specification of ghost atoms is sometimes required. Either ::. molecule he2 {; He; Gh(He) 1 2.0; }. or ::. molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer with the second atom ghosted, *i.e.*, possessing; basis functions but no electrons or nuclear charge. See :srcsample:`dfmp2-1`; and :srcsample:`ghosts` for a demonstration of both mechanisms for specifying; ghost atoms. .. index:: ; single: Isotopes; single: molecule; isotope; .. _`sec:isotope`:. Isotopic Substitution; =====================. .. caution:: Use of isotopic substitution in |PSIfour| is not well; developed, and the syntax is subject to change. At present, isotopes can only be specified at creation-time of the molecule. The syntax for a deuterium- and tritium-substituted water is below. Note; that asymmetric isotopic substitution such as this *will* change the; molecule's point group symmetry. ::. molecule dto {; units au; O 0.00000000 0.00000000 0.00000000; H@2.014101779 0.00000000 1.93042809 -1.10715266; H_label@3.01604927 0.00000000 -1.93042809 -1.10715266; }. The masses used by |PSIfour| can be found at; :source:`psi4/include/psi4/masses.h`. See :srcsample:`freq-isotope2` for about; the only use to which isotopologues can presently be pu",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:12575,Energy Efficiency,charge,charge,12575,"ide; 7505 benzonitrile; 78438 N-[anilino(phenyl)phosphoryl]aniline; 12581 3-phenylpropanenitrile; 517327 sodium benzenesulfonate; 637563 1-methoxy-4-[(E)-prop-1-enyl]benzene; 252325 [(E)-prop-1-enyl]benzene. Note that some of these results do not contain the string ""benzene""; these; compounds have synonyms containing that text. We can now replace the; ""benzene*"" in the input file with one of the above compounds using either the; IUPAC name or the CID provided in the list, *viz*::. molecule benzene {; pubchem:637563; }; ; or ::; ; molecule benzene {; pubchem:1-methoxy-4-[(E)-prop-1-enyl]benzene; }. Some of the structures in the database are quite loosely optimized and do not; have the correct symmetry. Before starting the computation, |PSIfour| will; check to see if the molecule is close to having each of the possible; symmetries, and will adjust the structure accordingly so that the maximum; symmetry is utilized. The standard keywords, described in :ref:`sec:moleculeKeywords`, can be; used in conjunction to specify charge, multiplicity, symmetry to use, *etc.* . .. index:: symmetry, Cotton-ordering; .. _`sec:symmetry`:. Symmetry; ========. For efficiency, |PSIfour| can utilize the largest Abelian subgroup of the full; point group of the molecule. Concomitantly, a number of quantities, such as; |globals__socc| and |globals__docc|, are arrays whose entries pertain to irreducible; representations (irreps) of the molecular point group. Ordering of irreps; follows the convention used in Cotton's :title:`Chemical Applications of Group; Theory`, as detailed in Table :ref:`Irreps <table:irrepOrdering>`. We refer to this; convention as ""Cotton Ordering"" hereafter. .. _`table:irrepOrdering`:. .. table:: Ordering of irreducible representations (irreps) used in |PSIfour|. +----------------+-------------+----------------+----------------+----------------+-------------+----------------+----------------+----------------+; | Point Group | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | ; +=========",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:18049,Energy Efficiency,energy,energy,18049," the symmetry of the molecule. When this happens; symmetry-dependent arrays, such as |globals__socc|, are automatically remapped; to the lower symmetry. For example, if we were to investigate the :math:`^2B_1`; state of water cation, we can specify ::. SOCC = [0, 0, 1, 0]. in the input file. If any ensuing computations lower the symmetry, the above; array will be appropriately remapped. For example, reducing the symmetry to; :math:`C_s` (with the molecular plane defining the mirror plane), the above; array will be automatically interpreted as::. SOCC = [0, 1]. Some caution is required, however. The :math:`^2A_1` state can be obtained with; the ::. SOCC = [1, 0, 0, 0]. specification, which would become ::. SOCC = [1, 0]. under the above-mentioned reduction in symmetry. The :math:`^2B_2` state,; whose singly-occupied orbitals are ::. SOCC = [0, 0, 0, 1]. would be mapped to ::. SOCC = [1, 0]. which is the same occupation as the :math:`^2A_1` state. In this case, the; :math:`^2A_1` state is lower in energy, and is not problematic. The distorted; geometries for the :math:`^2B_2` state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it's easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. .. index:: molecule; multiple fragments; .. _`sec:fragments`:. Non-Covalently Bonded Molecule Fragments; ========================================. |PSIfour| has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. |PSIfour| provides a very simple mechanism; for doing so: simply define the complex's geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fra",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:18697,Energy Efficiency,adapt,adapted,18697,"math:`^2A_1` state can be obtained with; the ::. SOCC = [1, 0, 0, 0]. specification, which would become ::. SOCC = [1, 0]. under the above-mentioned reduction in symmetry. The :math:`^2B_2` state,; whose singly-occupied orbitals are ::. SOCC = [0, 0, 0, 1]. would be mapped to ::. SOCC = [1, 0]. which is the same occupation as the :math:`^2A_1` state. In this case, the; :math:`^2A_1` state is lower in energy, and is not problematic. The distorted; geometries for the :math:`^2B_2` state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it's easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. .. index:: molecule; multiple fragments; .. _`sec:fragments`:. Non-Covalently Bonded Molecule Fragments; ========================================. |PSIfour| has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. |PSIfour| provides a very simple mechanism; for doing so: simply define the complex's geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragments. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block::. molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. This specifies that there are two neutral, spin-singlet fragments. It is; possible to further specify that the overall complex is",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:19086,Energy Efficiency,energy,energy,19086,"for the :math:`^2B_2` state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it's easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. .. index:: molecule; multiple fragments; .. _`sec:fragments`:. Non-Covalently Bonded Molecule Fragments; ========================================. |PSIfour| has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. |PSIfour| provides a very simple mechanism; for doing so: simply define the complex's geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragments. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block::. molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. This specifies that there are two neutral, spin-singlet fragments. It is; possible to further specify that the overall complex is neutral and spin-singlet; by inserting another :samp:`{charge} {multiplicity}` line, separated from the first; molecule block by a `--` line. If any information is missing, |PSIfour| will set the; unprovided charges and multiplicities to be consistent with those that are given.; For example, the overall charge must be simply the sum of all fragment charges.; |PSIfour| further assumes that any unpaired electrons are coupled to yield the highest; possible :ma",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:19701,Energy Efficiency,charge,charge,19701,"and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. |PSIfour| provides a very simple mechanism; for doing so: simply define the complex's geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragments. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block::. molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. This specifies that there are two neutral, spin-singlet fragments. It is; possible to further specify that the overall complex is neutral and spin-singlet; by inserting another :samp:`{charge} {multiplicity}` line, separated from the first; molecule block by a `--` line. If any information is missing, |PSIfour| will set the; unprovided charges and multiplicities to be consistent with those that are given.; For example, the overall charge must be simply the sum of all fragment charges.; |PSIfour| further assumes that any unpaired electrons are coupled to yield the highest; possible :math:`M_s` value. Psi will also favor neutral, spin-singlet fragments.; For anything complicated, we strongly suggest explicitly providing the charge; and multiplicity of each fragment as well as the total molecular charge and multiplicity. For details and examples, see https://github.com/MolSSI/QCElemental/blob/master/qcelemental/molparse/chgmult.py#L105-L136 . Having defined a molecule containing fragments like ``eneyne`` above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:19854,Energy Efficiency,charge,charges,19854,"chanism; for doing so: simply define the complex's geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragments. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block::. molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. This specifies that there are two neutral, spin-singlet fragments. It is; possible to further specify that the overall complex is neutral and spin-singlet; by inserting another :samp:`{charge} {multiplicity}` line, separated from the first; molecule block by a `--` line. If any information is missing, |PSIfour| will set the; unprovided charges and multiplicities to be consistent with those that are given.; For example, the overall charge must be simply the sum of all fragment charges.; |PSIfour| further assumes that any unpaired electrons are coupled to yield the highest; possible :math:`M_s` value. Psi will also favor neutral, spin-singlet fragments.; For anything complicated, we strongly suggest explicitly providing the charge; and multiplicity of each fragment as well as the total molecular charge and multiplicity. For details and examples, see https://github.com/MolSSI/QCElemental/blob/master/qcelemental/molparse/chgmult.py#L105-L136 . Having defined a molecule containing fragments like ``eneyne`` above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (``extract_subsets(1)`` pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment gh",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:19951,Energy Efficiency,charge,charge,19951,"re thereof, specifications and then place two; dashes between nonbonded fragments. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block::. molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. This specifies that there are two neutral, spin-singlet fragments. It is; possible to further specify that the overall complex is neutral and spin-singlet; by inserting another :samp:`{charge} {multiplicity}` line, separated from the first; molecule block by a `--` line. If any information is missing, |PSIfour| will set the; unprovided charges and multiplicities to be consistent with those that are given.; For example, the overall charge must be simply the sum of all fragment charges.; |PSIfour| further assumes that any unpaired electrons are coupled to yield the highest; possible :math:`M_s` value. Psi will also favor neutral, spin-singlet fragments.; For anything complicated, we strongly suggest explicitly providing the charge; and multiplicity of each fragment as well as the total molecular charge and multiplicity. For details and examples, see https://github.com/MolSSI/QCElemental/blob/master/qcelemental/molparse/chgmult.py#L105-L136 . Having defined a molecule containing fragments like ``eneyne`` above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (``extract_subsets(1)`` pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (``extract_subsets(1,2)`` pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For ",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:19997,Energy Efficiency,charge,charges,19997,"re thereof, specifications and then place two; dashes between nonbonded fragments. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block::. molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. This specifies that there are two neutral, spin-singlet fragments. It is; possible to further specify that the overall complex is neutral and spin-singlet; by inserting another :samp:`{charge} {multiplicity}` line, separated from the first; molecule block by a `--` line. If any information is missing, |PSIfour| will set the; unprovided charges and multiplicities to be consistent with those that are given.; For example, the overall charge must be simply the sum of all fragment charges.; |PSIfour| further assumes that any unpaired electrons are coupled to yield the highest; possible :math:`M_s` value. Psi will also favor neutral, spin-singlet fragments.; For anything complicated, we strongly suggest explicitly providing the charge; and multiplicity of each fragment as well as the total molecular charge and multiplicity. For details and examples, see https://github.com/MolSSI/QCElemental/blob/master/qcelemental/molparse/chgmult.py#L105-L136 . Having defined a molecule containing fragments like ``eneyne`` above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (``extract_subsets(1)`` pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (``extract_subsets(1,2)`` pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For ",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:20248,Energy Efficiency,charge,charge,20248,"923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. This specifies that there are two neutral, spin-singlet fragments. It is; possible to further specify that the overall complex is neutral and spin-singlet; by inserting another :samp:`{charge} {multiplicity}` line, separated from the first; molecule block by a `--` line. If any information is missing, |PSIfour| will set the; unprovided charges and multiplicities to be consistent with those that are given.; For example, the overall charge must be simply the sum of all fragment charges.; |PSIfour| further assumes that any unpaired electrons are coupled to yield the highest; possible :math:`M_s` value. Psi will also favor neutral, spin-singlet fragments.; For anything complicated, we strongly suggest explicitly providing the charge; and multiplicity of each fragment as well as the total molecular charge and multiplicity. For details and examples, see https://github.com/MolSSI/QCElemental/blob/master/qcelemental/molparse/chgmult.py#L105-L136 . Having defined a molecule containing fragments like ``eneyne`` above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (``extract_subsets(1)`` pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (``extract_subsets(1,2)`` pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. ``extract_subsets(2,[1,3])``::. mA = eneyne.extract_subsets(1); energy('scf'); ; clean(); ; mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; ``--`` marker, the :",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:20321,Energy Efficiency,charge,charge,20321,"923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. This specifies that there are two neutral, spin-singlet fragments. It is; possible to further specify that the overall complex is neutral and spin-singlet; by inserting another :samp:`{charge} {multiplicity}` line, separated from the first; molecule block by a `--` line. If any information is missing, |PSIfour| will set the; unprovided charges and multiplicities to be consistent with those that are given.; For example, the overall charge must be simply the sum of all fragment charges.; |PSIfour| further assumes that any unpaired electrons are coupled to yield the highest; possible :math:`M_s` value. Psi will also favor neutral, spin-singlet fragments.; For anything complicated, we strongly suggest explicitly providing the charge; and multiplicity of each fragment as well as the total molecular charge and multiplicity. For details and examples, see https://github.com/MolSSI/QCElemental/blob/master/qcelemental/molparse/chgmult.py#L105-L136 . Having defined a molecule containing fragments like ``eneyne`` above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (``extract_subsets(1)`` pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (``extract_subsets(1,2)`` pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. ``extract_subsets(2,[1,3])``::. mA = eneyne.extract_subsets(1); energy('scf'); ; clean(); ; mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; ``--`` marker, the :",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:21085,Energy Efficiency,energy,energy,21085,"ossible :math:`M_s` value. Psi will also favor neutral, spin-singlet fragments.; For anything complicated, we strongly suggest explicitly providing the charge; and multiplicity of each fragment as well as the total molecular charge and multiplicity. For details and examples, see https://github.com/MolSSI/QCElemental/blob/master/qcelemental/molparse/chgmult.py#L105-L136 . Having defined a molecule containing fragments like ``eneyne`` above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (``extract_subsets(1)`` pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (``extract_subsets(1,2)`` pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. ``extract_subsets(2,[1,3])``::. mA = eneyne.extract_subsets(1); energy('scf'); ; clean(); ; mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; ``--`` marker, the :py:func:`~psi4.driver.wrapper_autofrag.auto_fragments` function can be applied, as shown in; :srcsample:`pywrap-basis`, to return as active molecule the previous; active molecule, only fragmented. Advanced Python; ===============. A named molecule in an input file is a full-fledged instance of the; powerful C++ :py:class:`~psi4.core.Molecule` class. Thus, all member; functions (that have been exported via pybind11) documented thereat; are accessible through the handle :samp:`{option_molecule_name}` in; :samp:`molecule {optional_molecule_name} \\{...\\}`. * The molecular geometry can be got and set and manipulated as a; :py:class:`~psi4.core.Matrix` object. Below shows how to access; coordinates in an input file in Python. ::. molecule formaldehyde {; C 0.0 0.0 0.0; O 0.0 1.2 0.0; H -0.8 -0.3 0.0; H 0.8 -0.3 0.0 # set geometr",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:21149,Energy Efficiency,energy,energy,21149,"utral, spin-singlet fragments.; For anything complicated, we strongly suggest explicitly providing the charge; and multiplicity of each fragment as well as the total molecular charge and multiplicity. For details and examples, see https://github.com/MolSSI/QCElemental/blob/master/qcelemental/molparse/chgmult.py#L105-L136 . Having defined a molecule containing fragments like ``eneyne`` above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (``extract_subsets(1)`` pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (``extract_subsets(1,2)`` pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. ``extract_subsets(2,[1,3])``::. mA = eneyne.extract_subsets(1); energy('scf'); ; clean(); ; mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; ``--`` marker, the :py:func:`~psi4.driver.wrapper_autofrag.auto_fragments` function can be applied, as shown in; :srcsample:`pywrap-basis`, to return as active molecule the previous; active molecule, only fragmented. Advanced Python; ===============. A named molecule in an input file is a full-fledged instance of the; powerful C++ :py:class:`~psi4.core.Molecule` class. Thus, all member; functions (that have been exported via pybind11) documented thereat; are accessible through the handle :samp:`{option_molecule_name}` in; :samp:`molecule {optional_molecule_name} \\{...\\}`. * The molecular geometry can be got and set and manipulated as a; :py:class:`~psi4.core.Matrix` object. Below shows how to access; coordinates in an input file in Python. ::. molecule formaldehyde {; C 0.0 0.0 0.0; O 0.0 1.2 0.0; H -0.8 -0.3 0.0; H 0.8 -0.3 0.0 # set geometry in angstroms; }. formaldehyde.update_geometry()",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:21560,Energy Efficiency,power,powerful,21560,"it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (``extract_subsets(1)`` pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (``extract_subsets(1,2)`` pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. ``extract_subsets(2,[1,3])``::. mA = eneyne.extract_subsets(1); energy('scf'); ; clean(); ; mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; ``--`` marker, the :py:func:`~psi4.driver.wrapper_autofrag.auto_fragments` function can be applied, as shown in; :srcsample:`pywrap-basis`, to return as active molecule the previous; active molecule, only fragmented. Advanced Python; ===============. A named molecule in an input file is a full-fledged instance of the; powerful C++ :py:class:`~psi4.core.Molecule` class. Thus, all member; functions (that have been exported via pybind11) documented thereat; are accessible through the handle :samp:`{option_molecule_name}` in; :samp:`molecule {optional_molecule_name} \\{...\\}`. * The molecular geometry can be got and set and manipulated as a; :py:class:`~psi4.core.Matrix` object. Below shows how to access; coordinates in an input file in Python. ::. molecule formaldehyde {; C 0.0 0.0 0.0; O 0.0 1.2 0.0; H -0.8 -0.3 0.0; H 0.8 -0.3 0.0 # set geometry in angstroms; }. formaldehyde.update_geometry() # update the molecule internals since pre-energy()-like call; formaldehyde.print_out() # print molecule to output file; geom1psi = formaldehyde.geometry() # get coordinates in bohr as a psi4.Matrix. geom1psi.print_out() # print coordinates array to output file; geom1py = mat2arr(geom1psi) # get coordinates as a Python array; print geom1py # print coordinates to screen. geom2py = [[ 0.0, 0.0,",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:22188,Energy Efficiency,energy,energy,22188,"ecule contains fragments but is not conveniently ordered for the; ``--`` marker, the :py:func:`~psi4.driver.wrapper_autofrag.auto_fragments` function can be applied, as shown in; :srcsample:`pywrap-basis`, to return as active molecule the previous; active molecule, only fragmented. Advanced Python; ===============. A named molecule in an input file is a full-fledged instance of the; powerful C++ :py:class:`~psi4.core.Molecule` class. Thus, all member; functions (that have been exported via pybind11) documented thereat; are accessible through the handle :samp:`{option_molecule_name}` in; :samp:`molecule {optional_molecule_name} \\{...\\}`. * The molecular geometry can be got and set and manipulated as a; :py:class:`~psi4.core.Matrix` object. Below shows how to access; coordinates in an input file in Python. ::. molecule formaldehyde {; C 0.0 0.0 0.0; O 0.0 1.2 0.0; H -0.8 -0.3 0.0; H 0.8 -0.3 0.0 # set geometry in angstroms; }. formaldehyde.update_geometry() # update the molecule internals since pre-energy()-like call; formaldehyde.print_out() # print molecule to output file; geom1psi = formaldehyde.geometry() # get coordinates in bohr as a psi4.Matrix. geom1psi.print_out() # print coordinates array to output file; geom1py = mat2arr(geom1psi) # get coordinates as a Python array; print geom1py # print coordinates to screen. geom2py = [[ 0.0, 0.0, 0.0],; [ 0.0, 1.5, 0.0],; [-0.8, -0.3, 0.0],; [ 0.8, -0.3, 0.0]] # define alternate coordinates in angstroms as Python array. geom2psi = psi4.Matrix(4, 3) # initialize psi4.Matrix; geom2psi.set(geom2py) # load Python array into psi4.Matrix; geom2psi.scale(1.0/psi_bohr2angstroms) # scale into bohr; geom2psi.print_out() # print alternate coord array to output file. formaldehyde.set_geometry(geom2psi) # load alternate coordinates into molecule; formaldehyde.update_geometry() # update the molecule internals; formaldehyde.print_out() # print new molecule to output file; compare_values(28.9950517332, formaldehyde.nuclear_repulsion_e",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:24369,Energy Efficiency,energy,energy,24369,"1348351 0.39876776 1.92934049; #H 0.00000000 0.07949567 -0.51934253; #H 0.00000000 -0.98104857 1.65344779; #H -0.81348351 0.39876776 1.92934049. # >>> cat mol2.xyz; # 6 au; # stuff; # C 0.00000000000000 0.00000000000000 5.26601138679877; # C 0.00000000000000 0.00000000000000 -3.15195886530135; # H 0.00000000000000 0.00000000000000 7.28558683837122; # H 0.00000000000000 0.00000000000000 -1.12178201232889; # N 0.00000000000000 0.00000000000000 3.08339310458383; # N 0.00000000000000 0.00000000000000 -5.33865984413460. sapt = {'mol1': -0.0105313323529,; 'mol2': -0.00839486625709}. nre = {'mol1': 38.8138764635,; 'mol2': 72.3451968428}. set basis jun-cc-pvdz. for mol in ['mol1', 'mol2']:; filen = mol + '.xyz'; p4mol = Molecule.init_with_xyz(filen) # create molecule from file above; fragmentedmol = auto_fragments(molecule=p4mol) # fragment with BFS algorithm; activate(fragmentedmol) # activate returned molecule (for sapt). e = energy('sapt0') # run SAPT that requires 2 fragments; compare_values(sapt[mol], e, 5, '%s sapt ok' % mol); compare_values(nre[mol], p4mol.nuclear_repulsion_energy(), 4, '%s ok' % mol); clean() # clean scratch between loop calcs. * The essential element, mass and coordinate information of the molecule is accessible ::. molecule eneyne {; 0 1; C_ene 0.000000 -0.667578 -2.124659; C_ene 0.000000 0.667578 -2.124659; H_ene@2.014 0.923621 -1.232253 -2.126185; H_ene -0.923621 -1.232253 -2.126185; H_ene -0.923621 1.232253 -2.126185; Gh(H_ene) 0.923621 1.232253 -2.126185; --; 0 1; X 9.0 9.0 9.0; C_yne 0.000000 0.000000 2.900503; C_yne 0.000000 0.000000 1.693240; H_yne 0.000000 0.000000 0.627352; H_yne 0.000000 0.000000 3.963929; }. eneyne.update_geometry(). for iat in range(eneyne.natom()):; print """"""{:4} {:4} {:12} {:8.4f} {:12.6f} {:12.6f} {:12.6f} {:12.6f}"""""".format(; eneyne.Z(iat), # atomic number; eneyne.symbol(iat), # element symbol; eneyne.label(iat), # input element label; eneyne.charge(iat), # element charge; eneyne.x(iat), # x-coordinate; eneyne.y(iat",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:25362,Energy Efficiency,charge,charge,25362," 'mol2']:; filen = mol + '.xyz'; p4mol = Molecule.init_with_xyz(filen) # create molecule from file above; fragmentedmol = auto_fragments(molecule=p4mol) # fragment with BFS algorithm; activate(fragmentedmol) # activate returned molecule (for sapt). e = energy('sapt0') # run SAPT that requires 2 fragments; compare_values(sapt[mol], e, 5, '%s sapt ok' % mol); compare_values(nre[mol], p4mol.nuclear_repulsion_energy(), 4, '%s ok' % mol); clean() # clean scratch between loop calcs. * The essential element, mass and coordinate information of the molecule is accessible ::. molecule eneyne {; 0 1; C_ene 0.000000 -0.667578 -2.124659; C_ene 0.000000 0.667578 -2.124659; H_ene@2.014 0.923621 -1.232253 -2.126185; H_ene -0.923621 -1.232253 -2.126185; H_ene -0.923621 1.232253 -2.126185; Gh(H_ene) 0.923621 1.232253 -2.126185; --; 0 1; X 9.0 9.0 9.0; C_yne 0.000000 0.000000 2.900503; C_yne 0.000000 0.000000 1.693240; H_yne 0.000000 0.000000 0.627352; H_yne 0.000000 0.000000 3.963929; }. eneyne.update_geometry(). for iat in range(eneyne.natom()):; print """"""{:4} {:4} {:12} {:8.4f} {:12.6f} {:12.6f} {:12.6f} {:12.6f}"""""".format(; eneyne.Z(iat), # atomic number; eneyne.symbol(iat), # element symbol; eneyne.label(iat), # input element label; eneyne.charge(iat), # element charge; eneyne.x(iat), # x-coordinate; eneyne.y(iat), # y-coordinate; eneyne.z(iat), # z-coordinate; eneyne.mass(iat), # mass; ). # 6.0 C C_ENE 6.0000 -0.031900 -1.218981 -3.948079 12.000000; # 6.0 C C_ENE 6.0000 -0.031900 1.304098 -3.948079 12.000000; # 1.0 H H_ENE 1.0000 1.713491 -2.286062 -3.950962 2.014000; # 1.0 H H_ENE 1.0000 -1.777290 -2.286062 -3.950962 1.007825; # 1.0 H H_ENE 1.0000 -1.777290 2.371180 -3.950962 1.007825; # 0.0 H H_ENE 0.0000 1.713491 2.371180 -3.950962 1.007825; # 6.0 C C_YNE 6.0000 -0.031900 0.042559 5.548101 12.000000; # 6.0 C C_YNE 6.0000 -0.031900 0.042559 3.266705 12.000000; # 1.0 H H_YNE 1.0000 -0.031900 0.042559 1.252468 1.007825; # 1.0 H H_YNE 1.0000 -0.031900 0.042559 7.557685 1.007825. ",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:25385,Energy Efficiency,charge,charge,25385," 'mol2']:; filen = mol + '.xyz'; p4mol = Molecule.init_with_xyz(filen) # create molecule from file above; fragmentedmol = auto_fragments(molecule=p4mol) # fragment with BFS algorithm; activate(fragmentedmol) # activate returned molecule (for sapt). e = energy('sapt0') # run SAPT that requires 2 fragments; compare_values(sapt[mol], e, 5, '%s sapt ok' % mol); compare_values(nre[mol], p4mol.nuclear_repulsion_energy(), 4, '%s ok' % mol); clean() # clean scratch between loop calcs. * The essential element, mass and coordinate information of the molecule is accessible ::. molecule eneyne {; 0 1; C_ene 0.000000 -0.667578 -2.124659; C_ene 0.000000 0.667578 -2.124659; H_ene@2.014 0.923621 -1.232253 -2.126185; H_ene -0.923621 -1.232253 -2.126185; H_ene -0.923621 1.232253 -2.126185; Gh(H_ene) 0.923621 1.232253 -2.126185; --; 0 1; X 9.0 9.0 9.0; C_yne 0.000000 0.000000 2.900503; C_yne 0.000000 0.000000 1.693240; H_yne 0.000000 0.000000 0.627352; H_yne 0.000000 0.000000 3.963929; }. eneyne.update_geometry(). for iat in range(eneyne.natom()):; print """"""{:4} {:4} {:12} {:8.4f} {:12.6f} {:12.6f} {:12.6f} {:12.6f}"""""".format(; eneyne.Z(iat), # atomic number; eneyne.symbol(iat), # element symbol; eneyne.label(iat), # input element label; eneyne.charge(iat), # element charge; eneyne.x(iat), # x-coordinate; eneyne.y(iat), # y-coordinate; eneyne.z(iat), # z-coordinate; eneyne.mass(iat), # mass; ). # 6.0 C C_ENE 6.0000 -0.031900 -1.218981 -3.948079 12.000000; # 6.0 C C_ENE 6.0000 -0.031900 1.304098 -3.948079 12.000000; # 1.0 H H_ENE 1.0000 1.713491 -2.286062 -3.950962 2.014000; # 1.0 H H_ENE 1.0000 -1.777290 -2.286062 -3.950962 1.007825; # 1.0 H H_ENE 1.0000 -1.777290 2.371180 -3.950962 1.007825; # 0.0 H H_ENE 0.0000 1.713491 2.371180 -3.950962 1.007825; # 6.0 C C_YNE 6.0000 -0.031900 0.042559 5.548101 12.000000; # 6.0 C C_YNE 6.0000 -0.031900 0.042559 3.266705 12.000000; # 1.0 H H_YNE 1.0000 -0.031900 0.042559 1.252468 1.007825; # 1.0 H H_YNE 1.0000 -0.031900 0.042559 7.557685 1.007825. ",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:3822,Integrability,depend,depends,3822," -1.207655674855 -0.365913941094 -0.918035522052; # First, remove the H from the alpha carbon. This line could be deleted; # and is only included for completeness; #H 0.429560656538 0.717651915252 1.673774709694; # Now patch it, using a Z Matrix specification. This patch can be applied; # anywhere in the coord specification, as long as it appears lower than; # the atoms referenced, as is usual for Z-Matrices; C 2 rCC 3 aCCC 1 dCCCN; H 7 rCH1 2 aHCC1 3 dHCCC1; H 7 rCH2 2 aHCC2 3 dHCCC2; H 7 rCH3 2 aHCC3 3 dHCCC3; H 0.221781602033 1.772570540211 0.286988509018; H -1.833601608592 0.108401996052 1.481873213172; H -1.925572581453 1.640882152784 0.986471814808; ; aCCC = 108.0; rCC = 1.4; dCCCN = 120; rCH1 = 1.08; rCH2 = 1.08; rCH3 = 1.08; aHCC1 = 109.0; aHCC2 = 109.0; aHCC3 = 109.0; dHCCC1 = 0.0; dHCCC2 = 120.0; dHCCC3 = 240.0; }. Here, we remove the hydrogen from the alpha carbon of glycine and replace it; with a methyl group. Applying this patch using Cartesian coordinates is; difficult, because it depends on the orientation of the existing glycine unit.; In this example, we use Z-Matrix coordinates to define the methyl group, and; define the orientation in terms of the existing glycine Cartesian coordinates; which is much easier to visualize than the corresponding Cartesian-only; approach. .. index:: molecule; multiple in input file; .. _`sec:multipleMolecules`:. .. index::; triple: setting; keywords; molecule; pair: molecule; charge; pair: molecule; multiplicity; pair: molecule; symmetry; pair: molecule; no_reorient; pair: molecule; units; .. _`sec:moleculeKeywords`:. Molecule Keywords; =================. In addition to specifying the geometry, additional information can be; provided in the molecule block :samp:`molecule {optional_molecule_name} \\{...\\}`. **Charge & Multiplicity**; If two integers :samp:`{charge} {multiplicity}` are encountered on any; line of the molecule block, they are interpreted as the molecular charge; and multiplicity (:math:`2 M_s + 1`), resp",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:17097,Integrability,depend,dependent,17097,"uffice for :samp:`{symbol}`.; For certain computations, the user might want to specify which particular; subgroup is to be used by appending a unique axis specifier. For example when; running a computation on a molecule with :math:`D_{2h}` symmetry in :math:`C_{2v}`, the; :math:`C_2` axis can be chosen as either the :math:`x`, the :math:`y`, or the :math:`z`; these can; be specified by requesting the symmetry as ``c2vx``, ``c2vy``, or ``c2vz``, respectively.; Likewise the ``c2x``, ``c2y``, ``c2z``, ``c2hx``, ``c2hy``, and ``c2hz``; labels are valid. For :math:`C_s` symmetry the labels ``csx``, ``csy``, and; ``csz`` request the :math:`yz`, :math:`xz`, and :math:`xy` planes be used as the mirror plane,; respectively. If no unique axis is specified, |PSIfour| will choose an appropriate; subgroup. Certain types of finite difference computations, such as numerical vibrational; frequencies, might lower the symmetry of the molecule. When this happens; symmetry-dependent arrays, such as |globals__socc|, are automatically remapped; to the lower symmetry. For example, if we were to investigate the :math:`^2B_1`; state of water cation, we can specify ::. SOCC = [0, 0, 1, 0]. in the input file. If any ensuing computations lower the symmetry, the above; array will be appropriately remapped. For example, reducing the symmetry to; :math:`C_s` (with the molecular plane defining the mirror plane), the above; array will be automatically interpreted as::. SOCC = [0, 1]. Some caution is required, however. The :math:`^2A_1` state can be obtained with; the ::. SOCC = [1, 0, 0, 0]. specification, which would become ::. SOCC = [1, 0]. under the above-mentioned reduction in symmetry. The :math:`^2B_2` state,; whose singly-occupied orbitals are ::. SOCC = [0, 0, 0, 1]. would be mapped to ::. SOCC = [1, 0]. which is the same occupation as the :math:`^2A_1` state. In this case, the; :math:`^2A_1` state is lower in energy, and is not problematic. The distorted; geometries for the :math:`^2B_2` ",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:1289,Modifiability,flexible,flexible,1289,"ibute it and/or modify; .. # it under the terms of the GNU Lesser General Public License as published by; .. # the Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index:: molecule; specification; .. _`sec:moleculeSpecification`:. ===================================; Molecule and Geometry Specification; ===================================. Coordinates; ===========. |PSIfour| has a very flexible input parser that allows the user to provide; geometries as Cartesian coordinates, Z-matrix variables, or a combination of; both. The use of fixed values and variables are supported for both. For; example, the geometry for H\ :sub:`2` can be specified a number of ways, using the; :samp:`molecule {optional_molecule_name} \\{...\\}` block. ::. molecule {; H; H 1 0.9; }; ; or ::; ; molecule {; H; H 1 r; r = 0.9; }; ; or ::; ; molecule {; H1; H2 H1 0.9; }; ; or ::; ; molecule {; H 0.0 0.0 0.0; H 0.0 0.0 0.9; }; ; or ::; ; molecule {; H 0.0 0.0 0.0; H 0.0 0.0 r; r = 0.9; }; ; or ::; ; molecule {; H 0.0 0.0 -r; H 0.0 0.0 r; r = 0.45; }. Blank lines are ignored and, unlike regular Python syntax, indentation within; the molecule block does not matter, although the ``molecule`` keyword itself must; be aligned within the input according to standard Python syntax. For more; examples of geometry specification, see the :srcsample:`mints1` input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:1390,Modifiability,variab,variables,1390,"ibute it and/or modify; .. # it under the terms of the GNU Lesser General Public License as published by; .. # the Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index:: molecule; specification; .. _`sec:moleculeSpecification`:. ===================================; Molecule and Geometry Specification; ===================================. Coordinates; ===========. |PSIfour| has a very flexible input parser that allows the user to provide; geometries as Cartesian coordinates, Z-matrix variables, or a combination of; both. The use of fixed values and variables are supported for both. For; example, the geometry for H\ :sub:`2` can be specified a number of ways, using the; :samp:`molecule {optional_molecule_name} \\{...\\}` block. ::. molecule {; H; H 1 0.9; }; ; or ::; ; molecule {; H; H 1 r; r = 0.9; }; ; or ::; ; molecule {; H1; H2 H1 0.9; }; ; or ::; ; molecule {; H 0.0 0.0 0.0; H 0.0 0.0 0.9; }; ; or ::; ; molecule {; H 0.0 0.0 0.0; H 0.0 0.0 r; r = 0.9; }; ; or ::; ; molecule {; H 0.0 0.0 -r; H 0.0 0.0 r; r = 0.45; }. Blank lines are ignored and, unlike regular Python syntax, indentation within; the molecule block does not matter, although the ``molecule`` keyword itself must; be aligned within the input according to standard Python syntax. For more; examples of geometry specification, see the :srcsample:`mints1` input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:1456,Modifiability,variab,variables,1456,"the Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index:: molecule; specification; .. _`sec:moleculeSpecification`:. ===================================; Molecule and Geometry Specification; ===================================. Coordinates; ===========. |PSIfour| has a very flexible input parser that allows the user to provide; geometries as Cartesian coordinates, Z-matrix variables, or a combination of; both. The use of fixed values and variables are supported for both. For; example, the geometry for H\ :sub:`2` can be specified a number of ways, using the; :samp:`molecule {optional_molecule_name} \\{...\\}` block. ::. molecule {; H; H 1 0.9; }; ; or ::; ; molecule {; H; H 1 r; r = 0.9; }; ; or ::; ; molecule {; H1; H2 H1 0.9; }; ; or ::; ; molecule {; H 0.0 0.0 0.0; H 0.0 0.0 0.9; }; ; or ::; ; molecule {; H 0.0 0.0 0.0; H 0.0 0.0 r; r = 0.9; }; ; or ::; ; molecule {; H 0.0 0.0 -r; H 0.0 0.0 r; r = 0.45; }. Blank lines are ignored and, unlike regular Python syntax, indentation within; the molecule block does not matter, although the ``molecule`` keyword itself must; be aligned within the input according to standard Python syntax. For more; examples of geometry specification, see the :srcsample:`mints1` input file in the samples; folder. It is also possible to mix Cartesian and Z-matrix geometry; specifications, as demonstrated in the :srcsample:`mints4` and; :srcsample:`mints6` sample input files. For example, consider",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:18697,Modifiability,adapt,adapted,18697,"math:`^2A_1` state can be obtained with; the ::. SOCC = [1, 0, 0, 0]. specification, which would become ::. SOCC = [1, 0]. under the above-mentioned reduction in symmetry. The :math:`^2B_2` state,; whose singly-occupied orbitals are ::. SOCC = [0, 0, 0, 1]. would be mapped to ::. SOCC = [1, 0]. which is the same occupation as the :math:`^2A_1` state. In this case, the; :math:`^2A_1` state is lower in energy, and is not problematic. The distorted; geometries for the :math:`^2B_2` state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it's easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. .. index:: molecule; multiple fragments; .. _`sec:fragments`:. Non-Covalently Bonded Molecule Fragments; ========================================. |PSIfour| has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. |PSIfour| provides a very simple mechanism; for doing so: simply define the complex's geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragments. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block::. molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. This specifies that there are two neutral, spin-singlet fragments. It is; possible to further specify that the overall complex is",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:6833,Performance,perform,performed,6833,":samp:`{symbol}` is the Sch\ |o_dots|\ nflies symbol; of the (Abelian) point group to use for the computation, one of one of; ``c1``, ``c2``, ``ci``, ``cs``, ``d2``, ``c2h``, ``c2v``, or ``d2h``.; This need not be specified, as the molecular symmetry is automatically; detected by |PSIfour|. See :ref:`sec:symmetry` for details. **Fragments**; A line reading ``--`` is interpreted as the separator between two non-covalently ; bound molecular fragments. See :ref:`sec:fragments` for details. Multiple Molecules; ==================. To facilitate more elaborate computations, it is possible to provide a name for; each molecule and tell |PSIfour| which one should be used in a given; calculation. For example, consider the following input file::. molecule h2 {; H; H 1 0.9; }; ; set basis cc-pvdz; set reference rhf; energy('scf') # on H2; ; clean(). molecule h {; H; }; ; set basis cc-pvdz; set reference uhf; energy('scf') # on H. Here, two separate jobs are performed on two different molecules; the first is; performed on H\ :sub:`2`, while the second is for H atom. The last molecule to be; specified is the ""active"" molecule by default. To explicitly activate a named; molecule, the activate command is provided. With it, the above input file can be; equivalently written as follows. Alternatively, the molecule can be specified; directly to the computing function. Below, the third calculation is the same as; the first. ::. molecule h2 {; H; H 1 0.9; }; ; molecule h {; H; }; ; activate(h2); set basis cc-pvdz; set reference rhf; energy('scf') # on H2; ; clean(). activate(h); set basis cc-pvdz; set reference uhf; energy('scf') # on H. # --------------------------------------; # equivalent to previous input ends here. clean(). set reference rhf; energy('scf', molecule=h2) # on H2. :ref:`sec:jobControl` provides more details about the job control; and calculation keywords used in the above examples. .. index:: ; single: Ghost Atoms; single: molecule; ghost; .. _`sec:ghosts`:. Ghost Atom",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:6885,Performance,perform,performed,6885,":samp:`{symbol}` is the Sch\ |o_dots|\ nflies symbol; of the (Abelian) point group to use for the computation, one of one of; ``c1``, ``c2``, ``ci``, ``cs``, ``d2``, ``c2h``, ``c2v``, or ``d2h``.; This need not be specified, as the molecular symmetry is automatically; detected by |PSIfour|. See :ref:`sec:symmetry` for details. **Fragments**; A line reading ``--`` is interpreted as the separator between two non-covalently ; bound molecular fragments. See :ref:`sec:fragments` for details. Multiple Molecules; ==================. To facilitate more elaborate computations, it is possible to provide a name for; each molecule and tell |PSIfour| which one should be used in a given; calculation. For example, consider the following input file::. molecule h2 {; H; H 1 0.9; }; ; set basis cc-pvdz; set reference rhf; energy('scf') # on H2; ; clean(). molecule h {; H; }; ; set basis cc-pvdz; set reference uhf; energy('scf') # on H. Here, two separate jobs are performed on two different molecules; the first is; performed on H\ :sub:`2`, while the second is for H atom. The last molecule to be; specified is the ""active"" molecule by default. To explicitly activate a named; molecule, the activate command is provided. With it, the above input file can be; equivalently written as follows. Alternatively, the molecule can be specified; directly to the computing function. Below, the third calculation is the same as; the first. ::. molecule h2 {; H; H 1 0.9; }; ; molecule h {; H; }; ; activate(h2); set basis cc-pvdz; set reference rhf; energy('scf') # on H2; ; clean(). activate(h); set basis cc-pvdz; set reference uhf; energy('scf') # on H. # --------------------------------------; # equivalent to previous input ends here. clean(). set reference rhf; energy('scf', molecule=h2) # on H2. :ref:`sec:jobControl` provides more details about the job control; and calculation keywords used in the above examples. .. index:: ; single: Ghost Atoms; single: molecule; ghost; .. _`sec:ghosts`:. Ghost Atom",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:10333,Performance,perform,performed,10333," .. _`sec:pubchem`:. `PubChem <http://pubchem.ncbi.nlm.nih.gov/>`_ Database; ======================================================. Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, |PSIfour| can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem]_ database. For example, to run a computation on benzene, we can use the following molecule specification::. molecule benzene {; pubchem:benzene; }. If the computer is connected to the internet, the above code will instruct; |PSIfour| to search PubChem for a starting structure. The search is actually; performed for compounds whose name *contains* ""benzene"", so multiple; entries will be returned. If the name provided (""benzene"" in the above; example) exactly matches one of the results, that entry will be used. If no; exact match is found the results, along with a unique chemical identifier; (CID), are printed to the output file, prompting the user to provide a more; specific name. For example, if we know that we want to run a computation on a; compound whose name(s) contain ""benzene"", but we're not sure of the exact IUPAC; name, the following input can be used::. molecule benzene {; pubchem:benzene*; }. Appending the ""*"" prevents an exact match from being found and, at the time; of writing, the following results are displayed in the output file::. Chemical ID IUPAC Name; 241 benzene; 7371 benzenesulfonic acid; 91526 benzenesulfonate; 244 phenylmethanol; 727 1,2,3,4,5,6-hexachlorocyclohexane; 240 benzaldehyde; 65723 benzenesulfonohydrazide; 74296 N-phenylbenzenesulfonamide; 289 benzene-1,2-diol; 243 benzoic acid; 7370 ",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:12206,Performance,optimiz,optimized,12206,"727 1,2,3,4,5,6-hexachlorocyclohexane; 240 benzaldehyde; 65723 benzenesulfonohydrazide; 74296 N-phenylbenzenesulfonamide; 289 benzene-1,2-diol; 243 benzoic acid; 7370 benzenesulfonamide; 636822 1,2,4-trimethoxy-5-[(E)-prop-1-enyl]benzene; 7369 benzenesulfonyl chloride; 12932 N-[2-di(propan-2-yloxy)phosphinothioylsulfanylethyl]benzenesulfonamide; 7505 benzonitrile; 78438 N-[anilino(phenyl)phosphoryl]aniline; 12581 3-phenylpropanenitrile; 517327 sodium benzenesulfonate; 637563 1-methoxy-4-[(E)-prop-1-enyl]benzene; 252325 [(E)-prop-1-enyl]benzene. Note that some of these results do not contain the string ""benzene""; these; compounds have synonyms containing that text. We can now replace the; ""benzene*"" in the input file with one of the above compounds using either the; IUPAC name or the CID provided in the list, *viz*::. molecule benzene {; pubchem:637563; }; ; or ::; ; molecule benzene {; pubchem:1-methoxy-4-[(E)-prop-1-enyl]benzene; }. Some of the structures in the database are quite loosely optimized and do not; have the correct symmetry. Before starting the computation, |PSIfour| will; check to see if the molecule is close to having each of the possible; symmetries, and will adjust the structure accordingly so that the maximum; symmetry is utilized. The standard keywords, described in :ref:`sec:moleculeKeywords`, can be; used in conjunction to specify charge, multiplicity, symmetry to use, *etc.* . .. index:: symmetry, Cotton-ordering; .. _`sec:symmetry`:. Symmetry; ========. For efficiency, |PSIfour| can utilize the largest Abelian subgroup of the full; point group of the molecule. Concomitantly, a number of quantities, such as; |globals__socc| and |globals__docc|, are arrays whose entries pertain to irreducible; representations (irreps) of the molecular point group. Ordering of irreps; follows the convention used in Cotton's :title:`Chemical Applications of Group; Theory`, as detailed in Table :ref:`Irreps <table:irrepOrdering>`. We refer to this; convention as ""C",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:20566,Performance,perform,perform,20566," two neutral, spin-singlet fragments. It is; possible to further specify that the overall complex is neutral and spin-singlet; by inserting another :samp:`{charge} {multiplicity}` line, separated from the first; molecule block by a `--` line. If any information is missing, |PSIfour| will set the; unprovided charges and multiplicities to be consistent with those that are given.; For example, the overall charge must be simply the sum of all fragment charges.; |PSIfour| further assumes that any unpaired electrons are coupled to yield the highest; possible :math:`M_s` value. Psi will also favor neutral, spin-singlet fragments.; For anything complicated, we strongly suggest explicitly providing the charge; and multiplicity of each fragment as well as the total molecular charge and multiplicity. For details and examples, see https://github.com/MolSSI/QCElemental/blob/master/qcelemental/molparse/chgmult.py#L105-L136 . Having defined a molecule containing fragments like ``eneyne`` above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (``extract_subsets(1)`` pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (``extract_subsets(1,2)`` pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. ``extract_subsets(2,[1,3])``::. mA = eneyne.extract_subsets(1); energy('scf'); ; clean(); ; mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; ``--`` marker, the :py:func:`~psi4.driver.wrapper_autofrag.auto_fragments` function can be applied, as shown in; :srcsample:`pywrap-basis`, to return as active molecule the previous; active molecule, only fragmented. Advanced Python; ===============. A named molecule in an input file is a full-fledged ins",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:22746,Performance,load,load,22746,"cule_name}` in; :samp:`molecule {optional_molecule_name} \\{...\\}`. * The molecular geometry can be got and set and manipulated as a; :py:class:`~psi4.core.Matrix` object. Below shows how to access; coordinates in an input file in Python. ::. molecule formaldehyde {; C 0.0 0.0 0.0; O 0.0 1.2 0.0; H -0.8 -0.3 0.0; H 0.8 -0.3 0.0 # set geometry in angstroms; }. formaldehyde.update_geometry() # update the molecule internals since pre-energy()-like call; formaldehyde.print_out() # print molecule to output file; geom1psi = formaldehyde.geometry() # get coordinates in bohr as a psi4.Matrix. geom1psi.print_out() # print coordinates array to output file; geom1py = mat2arr(geom1psi) # get coordinates as a Python array; print geom1py # print coordinates to screen. geom2py = [[ 0.0, 0.0, 0.0],; [ 0.0, 1.5, 0.0],; [-0.8, -0.3, 0.0],; [ 0.8, -0.3, 0.0]] # define alternate coordinates in angstroms as Python array. geom2psi = psi4.Matrix(4, 3) # initialize psi4.Matrix; geom2psi.set(geom2py) # load Python array into psi4.Matrix; geom2psi.scale(1.0/psi_bohr2angstroms) # scale into bohr; geom2psi.print_out() # print alternate coord array to output file. formaldehyde.set_geometry(geom2psi) # load alternate coordinates into molecule; formaldehyde.update_geometry() # update the molecule internals; formaldehyde.print_out() # print new molecule to output file; compare_values(28.9950517332, formaldehyde.nuclear_repulsion_energy(), 4, ""geom2 took""). * Molecules can be initiated from XYZ files and fragmented for SAPT computations. ::. # >>> cat mol1.xyz; #7; #; #O 0.00000000 -0.05786571 -1.47979303; #N 0.00000000 0.01436394 1.46454628; #H 0.00000000 0.82293384 -1.85541474; #H 0.81348351 0.39876776 1.92934049; #H 0.00000000 0.07949567 -0.51934253; #H 0.00000000 -0.98104857 1.65344779; #H -0.81348351 0.39876776 1.92934049. # >>> cat mol2.xyz; # 6 au; # stuff; # C 0.00000000000000 0.00000000000000 5.26601138679877; # C 0.00000000000000 0.00000000000000 -3.15195886530135; # H 0.00000000000000 0.",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:22945,Performance,load,load,22945,"tes in an input file in Python. ::. molecule formaldehyde {; C 0.0 0.0 0.0; O 0.0 1.2 0.0; H -0.8 -0.3 0.0; H 0.8 -0.3 0.0 # set geometry in angstroms; }. formaldehyde.update_geometry() # update the molecule internals since pre-energy()-like call; formaldehyde.print_out() # print molecule to output file; geom1psi = formaldehyde.geometry() # get coordinates in bohr as a psi4.Matrix. geom1psi.print_out() # print coordinates array to output file; geom1py = mat2arr(geom1psi) # get coordinates as a Python array; print geom1py # print coordinates to screen. geom2py = [[ 0.0, 0.0, 0.0],; [ 0.0, 1.5, 0.0],; [-0.8, -0.3, 0.0],; [ 0.8, -0.3, 0.0]] # define alternate coordinates in angstroms as Python array. geom2psi = psi4.Matrix(4, 3) # initialize psi4.Matrix; geom2psi.set(geom2py) # load Python array into psi4.Matrix; geom2psi.scale(1.0/psi_bohr2angstroms) # scale into bohr; geom2psi.print_out() # print alternate coord array to output file. formaldehyde.set_geometry(geom2psi) # load alternate coordinates into molecule; formaldehyde.update_geometry() # update the molecule internals; formaldehyde.print_out() # print new molecule to output file; compare_values(28.9950517332, formaldehyde.nuclear_repulsion_energy(), 4, ""geom2 took""). * Molecules can be initiated from XYZ files and fragmented for SAPT computations. ::. # >>> cat mol1.xyz; #7; #; #O 0.00000000 -0.05786571 -1.47979303; #N 0.00000000 0.01436394 1.46454628; #H 0.00000000 0.82293384 -1.85541474; #H 0.81348351 0.39876776 1.92934049; #H 0.00000000 0.07949567 -0.51934253; #H 0.00000000 -0.98104857 1.65344779; #H -0.81348351 0.39876776 1.92934049. # >>> cat mol2.xyz; # 6 au; # stuff; # C 0.00000000000000 0.00000000000000 5.26601138679877; # C 0.00000000000000 0.00000000000000 -3.15195886530135; # H 0.00000000000000 0.00000000000000 7.28558683837122; # H 0.00000000000000 0.00000000000000 -1.12178201232889; # N 0.00000000000000 0.00000000000000 3.08339310458383; # N 0.00000000000000 0.00000000000000 -5.33865984413460. sapt",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:6142,Safety,detect,detected,6142," default, |Angstrom| units are used; this is changed by adding; a line that reads :samp:`units {spec}`, where :samp:`{spec}` is one; of ``ang``, ``angstrom``, ``a.u.``, ``au``, or ``bohr``. **Orientation**; Certain computations require that the molecule is not reoriented. This ; can be achieved by adding either ``no_reorient`` or ``noreorient``. ; To prevent even recentering of the molecule, add ``no_com`` or ``nocom``. **PubChem**; A line reading :samp:`pubchem:{mol}` fetches the geometry for molecule; :samp:`{mol}` from the PubChem database, where :samp:`{mol}` is either; the IUPAC molecule name or the CID number. See :ref:`sec:pubchem` for; details. **Symmetry**; The symmetry can be specified by a line reading :samp:`symmetry; {symbol}`, where :samp:`{symbol}` is the Sch\ |o_dots|\ nflies symbol; of the (Abelian) point group to use for the computation, one of one of; ``c1``, ``c2``, ``ci``, ``cs``, ``d2``, ``c2h``, ``c2v``, or ``d2h``.; This need not be specified, as the molecular symmetry is automatically; detected by |PSIfour|. See :ref:`sec:symmetry` for details. **Fragments**; A line reading ``--`` is interpreted as the separator between two non-covalently ; bound molecular fragments. See :ref:`sec:fragments` for details. Multiple Molecules; ==================. To facilitate more elaborate computations, it is possible to provide a name for; each molecule and tell |PSIfour| which one should be used in a given; calculation. For example, consider the following input file::. molecule h2 {; H; H 1 0.9; }; ; set basis cc-pvdz; set reference rhf; energy('scf') # on H2; ; clean(). molecule h {; H; }; ; set basis cc-pvdz; set reference uhf; energy('scf') # on H. Here, two separate jobs are performed on two different molecules; the first is; performed on H\ :sub:`2`, while the second is for H atom. The last molecule to be; specified is the ""active"" molecule by default. To explicitly activate a named; molecule, the activate command is provided. With it, the above input ",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:15749,Safety,detect,detect,15749,"| |; +----------------+-------------+----------------+----------------+----------------+-------------+----------------+----------------+----------------+; | :math:`C_{2h}` | :math:`A_g` | :math:`B_g` | :math:`A_u` | :math:`B_u` | | | | |; +----------------+-------------+----------------+----------------+----------------+-------------+----------------+----------------+----------------+; | :math:`D_{2h}` | :math:`A_g` | :math:`B_{1g}` | :math:`B_{2g}` | :math:`B_{3g}` | :math:`A_u` | :math:`B_{1u}` | :math:`B_{2u}` | :math:`B_{3u}` |; +----------------+-------------+----------------+----------------+----------------+-------------+----------------+----------------+----------------+. For example, water (:math:`C_{2v}` symmetry) has three doubly occupied :math:`A_1`; orbitals, as well as one each of :math:`B_1` and :math:`B_2` symmetry; the; corresponding |globals__docc| array is therefore::. DOCC = [3, 0, 1, 1]. Although |PSIfour| will detect the symmetry automatically, and use the largest; possible Abelian subgroup, the user might want to run in a lower point group.; To do this the molecule keyword :samp:`symmetry {symbol}` can be used ; (see :ref:`sec:moleculeKeywords`). In most cases the standard; Sch\ |o_dots|\ nflies symbol (one of ``c1``, ``c2``, ``ci``, ``cs``, ``d2``,; ``c2h``, ``c2v``, ``d2h`` will suffice for :samp:`{symbol}`.; For certain computations, the user might want to specify which particular; subgroup is to be used by appending a unique axis specifier. For example when; running a computation on a molecule with :math:`D_{2h}` symmetry in :math:`C_{2v}`, the; :math:`C_2` axis can be chosen as either the :math:`x`, the :math:`y`, or the :math:`z`; these can; be specified by requesting the symmetry as ``c2vx``, ``c2vy``, or ``c2vz``, respectively.; Likewise the ``c2x``, ``c2y``, ``c2z``, ``c2hx``, ``c2hy``, and ``c2hz``; labels are valid. For :math:`C_s` symmetry the labels ``csx``, ``csy``, and; ``csz`` request the :math:`yz`, :math:`xz`, and :math:`xy` ",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:21703,Security,access,accessible,21703,"_subsets(1)`` pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (``extract_subsets(1,2)`` pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. ``extract_subsets(2,[1,3])``::. mA = eneyne.extract_subsets(1); energy('scf'); ; clean(); ; mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; ``--`` marker, the :py:func:`~psi4.driver.wrapper_autofrag.auto_fragments` function can be applied, as shown in; :srcsample:`pywrap-basis`, to return as active molecule the previous; active molecule, only fragmented. Advanced Python; ===============. A named molecule in an input file is a full-fledged instance of the; powerful C++ :py:class:`~psi4.core.Molecule` class. Thus, all member; functions (that have been exported via pybind11) documented thereat; are accessible through the handle :samp:`{option_molecule_name}` in; :samp:`molecule {optional_molecule_name} \\{...\\}`. * The molecular geometry can be got and set and manipulated as a; :py:class:`~psi4.core.Matrix` object. Below shows how to access; coordinates in an input file in Python. ::. molecule formaldehyde {; C 0.0 0.0 0.0; O 0.0 1.2 0.0; H -0.8 -0.3 0.0; H 0.8 -0.3 0.0 # set geometry in angstroms; }. formaldehyde.update_geometry() # update the molecule internals since pre-energy()-like call; formaldehyde.print_out() # print molecule to output file; geom1psi = formaldehyde.geometry() # get coordinates in bohr as a psi4.Matrix. geom1psi.print_out() # print coordinates array to output file; geom1py = mat2arr(geom1psi) # get coordinates as a Python array; print geom1py # print coordinates to screen. geom2py = [[ 0.0, 0.0, 0.0],; [ 0.0, 1.5, 0.0],; [-0.8, -0.3, 0.0],; [ 0.8, -0.3, 0.0]] # define alternate coordinates in angstroms as Python array. geom2psi = psi4.Matrix(4, 3) # initialize psi",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:21944,Security,access,access,21944,"s). For beyond bimolecular; complexes, arrays can be used, e.g. ``extract_subsets(2,[1,3])``::. mA = eneyne.extract_subsets(1); energy('scf'); ; clean(); ; mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; ``--`` marker, the :py:func:`~psi4.driver.wrapper_autofrag.auto_fragments` function can be applied, as shown in; :srcsample:`pywrap-basis`, to return as active molecule the previous; active molecule, only fragmented. Advanced Python; ===============. A named molecule in an input file is a full-fledged instance of the; powerful C++ :py:class:`~psi4.core.Molecule` class. Thus, all member; functions (that have been exported via pybind11) documented thereat; are accessible through the handle :samp:`{option_molecule_name}` in; :samp:`molecule {optional_molecule_name} \\{...\\}`. * The molecular geometry can be got and set and manipulated as a; :py:class:`~psi4.core.Matrix` object. Below shows how to access; coordinates in an input file in Python. ::. molecule formaldehyde {; C 0.0 0.0 0.0; O 0.0 1.2 0.0; H -0.8 -0.3 0.0; H 0.8 -0.3 0.0 # set geometry in angstroms; }. formaldehyde.update_geometry() # update the molecule internals since pre-energy()-like call; formaldehyde.print_out() # print molecule to output file; geom1psi = formaldehyde.geometry() # get coordinates in bohr as a psi4.Matrix. geom1psi.print_out() # print coordinates array to output file; geom1py = mat2arr(geom1psi) # get coordinates as a Python array; print geom1py # print coordinates to screen. geom2py = [[ 0.0, 0.0, 0.0],; [ 0.0, 1.5, 0.0],; [-0.8, -0.3, 0.0],; [ 0.8, -0.3, 0.0]] # define alternate coordinates in angstroms as Python array. geom2psi = psi4.Matrix(4, 3) # initialize psi4.Matrix; geom2psi.set(geom2py) # load Python array into psi4.Matrix; geom2psi.scale(1.0/psi_bohr2angstroms) # scale into bohr; geom2psi.print_out() # print alternate coord array to output file. formaldehyde.set_geometry(geom2psi) # load alternat",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:24674,Security,access,accessible,24674,"000000000000 5.26601138679877; # C 0.00000000000000 0.00000000000000 -3.15195886530135; # H 0.00000000000000 0.00000000000000 7.28558683837122; # H 0.00000000000000 0.00000000000000 -1.12178201232889; # N 0.00000000000000 0.00000000000000 3.08339310458383; # N 0.00000000000000 0.00000000000000 -5.33865984413460. sapt = {'mol1': -0.0105313323529,; 'mol2': -0.00839486625709}. nre = {'mol1': 38.8138764635,; 'mol2': 72.3451968428}. set basis jun-cc-pvdz. for mol in ['mol1', 'mol2']:; filen = mol + '.xyz'; p4mol = Molecule.init_with_xyz(filen) # create molecule from file above; fragmentedmol = auto_fragments(molecule=p4mol) # fragment with BFS algorithm; activate(fragmentedmol) # activate returned molecule (for sapt). e = energy('sapt0') # run SAPT that requires 2 fragments; compare_values(sapt[mol], e, 5, '%s sapt ok' % mol); compare_values(nre[mol], p4mol.nuclear_repulsion_energy(), 4, '%s ok' % mol); clean() # clean scratch between loop calcs. * The essential element, mass and coordinate information of the molecule is accessible ::. molecule eneyne {; 0 1; C_ene 0.000000 -0.667578 -2.124659; C_ene 0.000000 0.667578 -2.124659; H_ene@2.014 0.923621 -1.232253 -2.126185; H_ene -0.923621 -1.232253 -2.126185; H_ene -0.923621 1.232253 -2.126185; Gh(H_ene) 0.923621 1.232253 -2.126185; --; 0 1; X 9.0 9.0 9.0; C_yne 0.000000 0.000000 2.900503; C_yne 0.000000 0.000000 1.693240; H_yne 0.000000 0.000000 0.627352; H_yne 0.000000 0.000000 3.963929; }. eneyne.update_geometry(). for iat in range(eneyne.natom()):; print """"""{:4} {:4} {:12} {:8.4f} {:12.6f} {:12.6f} {:12.6f} {:12.6f}"""""".format(; eneyne.Z(iat), # atomic number; eneyne.symbol(iat), # element symbol; eneyne.label(iat), # input element label; eneyne.charge(iat), # element charge; eneyne.x(iat), # x-coordinate; eneyne.y(iat), # y-coordinate; eneyne.z(iat), # z-coordinate; eneyne.mass(iat), # mass; ). # 6.0 C C_ENE 6.0000 -0.031900 -1.218981 -3.948079 12.000000; # 6.0 C C_ENE 6.0000 -0.031900 1.304098 -3.948079 12.000000; # 1.0",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:7985,Usability,simpl,simplified,7985,"cule by default. To explicitly activate a named; molecule, the activate command is provided. With it, the above input file can be; equivalently written as follows. Alternatively, the molecule can be specified; directly to the computing function. Below, the third calculation is the same as; the first. ::. molecule h2 {; H; H 1 0.9; }; ; molecule h {; H; }; ; activate(h2); set basis cc-pvdz; set reference rhf; energy('scf') # on H2; ; clean(). activate(h); set basis cc-pvdz; set reference uhf; energy('scf') # on H. # --------------------------------------; # equivalent to previous input ends here. clean(). set reference rhf; energy('scf', molecule=h2) # on H2. :ref:`sec:jobControl` provides more details about the job control; and calculation keywords used in the above examples. .. index:: ; single: Ghost Atoms; single: molecule; ghost; .. _`sec:ghosts`:. Ghost Atoms; ===========. While many common computations, particularly SAPT and counterpoise corrections, can; be greatly simplified using the notation described in :ref:`sec:fragments`,; manual specification of ghost atoms is sometimes required. Either ::. molecule he2 {; He; Gh(He) 1 2.0; }. or ::. molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer with the second atom ghosted, *i.e.*, possessing; basis functions but no electrons or nuclear charge. See :srcsample:`dfmp2-1`; and :srcsample:`ghosts` for a demonstration of both mechanisms for specifying; ghost atoms. .. index:: ; single: Isotopes; single: molecule; isotope; .. _`sec:isotope`:. Isotopic Substitution; =====================. .. caution:: Use of isotopic substitution in |PSIfour| is not well; developed, and the syntax is subject to change. At present, isotopes can only be specified at creation-time of the molecule. The syntax for a deuterium- and tritium-substituted water is below. Note; that asymmetric isotopic substitution such as this *will* change the; molecule's point group symmetry. ::. molecule dto {; units au; O 0.00000000 0.00000000 0.0",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:9635,Usability,intuit,intuitive,9635,"l; developed, and the syntax is subject to change. At present, isotopes can only be specified at creation-time of the molecule. The syntax for a deuterium- and tritium-substituted water is below. Note; that asymmetric isotopic substitution such as this *will* change the; molecule's point group symmetry. ::. molecule dto {; units au; O 0.00000000 0.00000000 0.00000000; H@2.014101779 0.00000000 1.93042809 -1.10715266; H_label@3.01604927 0.00000000 -1.93042809 -1.10715266; }. The masses used by |PSIfour| can be found at; :source:`psi4/include/psi4/masses.h`. See :srcsample:`freq-isotope2` for about; the only use to which isotopologues can presently be put in |PSIfour|. .. index:: ; single: PubChem; single: molecule; PubChem; .. _`sec:pubchem`:. `PubChem <http://pubchem.ncbi.nlm.nih.gov/>`_ Database; ======================================================. Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, |PSIfour| can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem]_ database. For example, to run a computation on benzene, we can use the following molecule specification::. molecule benzene {; pubchem:benzene; }. If the computer is connected to the internet, the above code will instruct; |PSIfour| to search PubChem for a starting structure. The search is actually; performed for compounds whose name *contains* ""benzene"", so multiple; entries will be returned. If the name provided (""benzene"" in the above; example) exactly matches one of the results, that entry will be used. If no; exact match is found the results, along with a unique chemical identifier; (CID), are",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:9739,Usability,intuit,intuitive,9739,"euterium- and tritium-substituted water is below. Note; that asymmetric isotopic substitution such as this *will* change the; molecule's point group symmetry. ::. molecule dto {; units au; O 0.00000000 0.00000000 0.00000000; H@2.014101779 0.00000000 1.93042809 -1.10715266; H_label@3.01604927 0.00000000 -1.93042809 -1.10715266; }. The masses used by |PSIfour| can be found at; :source:`psi4/include/psi4/masses.h`. See :srcsample:`freq-isotope2` for about; the only use to which isotopologues can presently be put in |PSIfour|. .. index:: ; single: PubChem; single: molecule; PubChem; .. _`sec:pubchem`:. `PubChem <http://pubchem.ncbi.nlm.nih.gov/>`_ Database; ======================================================. Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, |PSIfour| can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem]_ database. For example, to run a computation on benzene, we can use the following molecule specification::. molecule benzene {; pubchem:benzene; }. If the computer is connected to the internet, the above code will instruct; |PSIfour| to search PubChem for a starting structure. The search is actually; performed for compounds whose name *contains* ""benzene"", so multiple; entries will be returned. If the name provided (""benzene"" in the above; example) exactly matches one of the results, that entry will be used. If no; exact match is found the results, along with a unique chemical identifier; (CID), are printed to the output file, prompting the user to provide a more; specific name. For example, if we know that we want to run a computation on a; ",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:18846,Usability,simpl,simple,18846," [1, 0]. which is the same occupation as the :math:`^2A_1` state. In this case, the; :math:`^2A_1` state is lower in energy, and is not problematic. The distorted; geometries for the :math:`^2B_2` state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it's easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. .. index:: molecule; multiple fragments; .. _`sec:fragments`:. Non-Covalently Bonded Molecule Fragments; ========================================. |PSIfour| has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. |PSIfour| provides a very simple mechanism; for doing so: simply define the complex's geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragments. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block::. molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. This specifies that there are two neutral, spin-singlet fragments. It is; possible to further specify that the overall complex is neutral and spin-singlet; by inserting another :samp:`{charge} {multiplicity}` line, separated from the first; molecule block by a `--` line. If any information is missing, |PSIfour| will set the; unprovided charges and multiplicities to be consistent with those that are given.; For exa",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:18878,Usability,simpl,simply,18878," [1, 0]. which is the same occupation as the :math:`^2A_1` state. In this case, the; :math:`^2A_1` state is lower in energy, and is not problematic. The distorted; geometries for the :math:`^2B_2` state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it's easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. .. index:: molecule; multiple fragments; .. _`sec:fragments`:. Non-Covalently Bonded Molecule Fragments; ========================================. |PSIfour| has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. |PSIfour| provides a very simple mechanism; for doing so: simply define the complex's geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragments. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block::. molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. This specifies that there are two neutral, spin-singlet fragments. It is; possible to further specify that the overall complex is neutral and spin-singlet; by inserting another :samp:`{charge} {multiplicity}` line, separated from the first; molecule block by a `--` line. If any information is missing, |PSIfour| will set the; unprovided charges and multiplicities to be consistent with those that are given.; For exa",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:19966,Usability,simpl,simply,19966,"re thereof, specifications and then place two; dashes between nonbonded fragments. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block::. molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. This specifies that there are two neutral, spin-singlet fragments. It is; possible to further specify that the overall complex is neutral and spin-singlet; by inserting another :samp:`{charge} {multiplicity}` line, separated from the first; molecule block by a `--` line. If any information is missing, |PSIfour| will set the; unprovided charges and multiplicities to be consistent with those that are given.; For example, the overall charge must be simply the sum of all fragment charges.; |PSIfour| further assumes that any unpaired electrons are coupled to yield the highest; possible :math:`M_s` value. Psi will also favor neutral, spin-singlet fragments.; For anything complicated, we strongly suggest explicitly providing the charge; and multiplicity of each fragment as well as the total molecular charge and multiplicity. For details and examples, see https://github.com/MolSSI/QCElemental/blob/master/qcelemental/molparse/chgmult.py#L105-L136 . Having defined a molecule containing fragments like ``eneyne`` above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (``extract_subsets(1)`` pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (``extract_subsets(1,2)`` pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For ",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst:20549,Usability,simpl,simple,20549," two neutral, spin-singlet fragments. It is; possible to further specify that the overall complex is neutral and spin-singlet; by inserting another :samp:`{charge} {multiplicity}` line, separated from the first; molecule block by a `--` line. If any information is missing, |PSIfour| will set the; unprovided charges and multiplicities to be consistent with those that are given.; For example, the overall charge must be simply the sum of all fragment charges.; |PSIfour| further assumes that any unpaired electrons are coupled to yield the highest; possible :math:`M_s` value. Psi will also favor neutral, spin-singlet fragments.; For anything complicated, we strongly suggest explicitly providing the charge; and multiplicity of each fragment as well as the total molecular charge and multiplicity. For details and examples, see https://github.com/MolSSI/QCElemental/blob/master/qcelemental/molparse/chgmult.py#L105-L136 . Having defined a molecule containing fragments like ``eneyne`` above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (``extract_subsets(1)`` pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (``extract_subsets(1,2)`` pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. ``extract_subsets(2,[1,3])``::. mA = eneyne.extract_subsets(1); energy('scf'); ; clean(); ; mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; ``--`` marker, the :py:func:`~psi4.driver.wrapper_autofrag.auto_fragments` function can be applied, as shown in; :srcsample:`pywrap-basis`, to return as active molecule the previous; active molecule, only fragmented. Advanced Python; ===============. A named molecule in an input file is a full-fledged ins",MatchSource.DOCS,doc/sphinxman/source/psithonmol.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/psithonmol.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst:1578,Availability,avail,available,1578,"OUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index::; pair: method alias; adding new. .. _`sec:methodAlias`:. Defining a Method Alias; =======================. .. note:: No recompile of the |PSIfour| program is necessary for changes made to; files in ``$PSIDATADIR`` aka :source:`psi4/share/psi4`, including those described below. .. caution:: As of 1.0, the below, while essentially still correct, is so aged; as to be difficult to follow. Since quantum chemical methods in |PSIfour| are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; :source:`psi4/driver/aliases.py` file is intended for editing by the user for; this purpose. As an example, the MP2.5 method; (which admittedly is already built in to |PSIfour|); is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy. ::. def run_mp2_5(name, **kwargs):; ; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); ; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; ; print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); ; return e_mp25. Compare the above to the method that resides ",MatchSource.DOCS,doc/sphinxman/source/quickaddalias.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst:1935,Availability,avail,available,1935," USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index::; pair: method alias; adding new. .. _`sec:methodAlias`:. Defining a Method Alias; =======================. .. note:: No recompile of the |PSIfour| program is necessary for changes made to; files in ``$PSIDATADIR`` aka :source:`psi4/share/psi4`, including those described below. .. caution:: As of 1.0, the below, while essentially still correct, is so aged; as to be difficult to follow. Since quantum chemical methods in |PSIfour| are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; :source:`psi4/driver/aliases.py` file is intended for editing by the user for; this purpose. As an example, the MP2.5 method; (which admittedly is already built in to |PSIfour|); is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy. ::. def run_mp2_5(name, **kwargs):; ; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); ; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; ; print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); ; return e_mp25. Compare the above to the method that resides in :source:`psi4/driver/aliases.py`.; The rationale for the changes is indicated in the comments below. ::. def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names; ; # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variab",MatchSource.DOCS,doc/sphinxman/source/quickaddalias.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst:2114,Energy Efficiency,energy,energy,2114,"thodAlias`:. Defining a Method Alias; =======================. .. note:: No recompile of the |PSIfour| program is necessary for changes made to; files in ``$PSIDATADIR`` aka :source:`psi4/share/psi4`, including those described below. .. caution:: As of 1.0, the below, while essentially still correct, is so aged; as to be difficult to follow. Since quantum chemical methods in |PSIfour| are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; :source:`psi4/driver/aliases.py` file is intended for editing by the user for; this purpose. As an example, the MP2.5 method; (which admittedly is already built in to |PSIfour|); is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy. ::. def run_mp2_5(name, **kwargs):; ; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); ; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; ; print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); ; return e_mp25. Compare the above to the method that resides in :source:`psi4/driver/aliases.py`.; The rationale for the changes is indicated in the comments below. ::. def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names; ; # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_m",MatchSource.DOCS,doc/sphinxman/source/quickaddalias.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst:2160,Energy Efficiency,energy,energy,2160,"================. .. note:: No recompile of the |PSIfour| program is necessary for changes made to; files in ``$PSIDATADIR`` aka :source:`psi4/share/psi4`, including those described below. .. caution:: As of 1.0, the below, while essentially still correct, is so aged; as to be difficult to follow. Since quantum chemical methods in |PSIfour| are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; :source:`psi4/driver/aliases.py` file is intended for editing by the user for; this purpose. As an example, the MP2.5 method; (which admittedly is already built in to |PSIfour|); is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy. ::. def run_mp2_5(name, **kwargs):; ; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); ; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; ; print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); ; return e_mp25. Compare the above to the method that resides in :source:`psi4/driver/aliases.py`.; The rationale for the changes is indicated in the comments below. ::. def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names; ; # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 tota",MatchSource.DOCS,doc/sphinxman/source/quickaddalias.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst:2427,Energy Efficiency,energy,energy,2427," as to be difficult to follow. Since quantum chemical methods in |PSIfour| are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; :source:`psi4/driver/aliases.py` file is intended for editing by the user for; this purpose. As an example, the MP2.5 method; (which admittedly is already built in to |PSIfour|); is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy. ::. def run_mp2_5(name, **kwargs):; ; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); ; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; ; print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); ; return e_mp25. Compare the above to the method that resides in :source:`psi4/driver/aliases.py`.; The rationale for the changes is indicated in the comments below. ::. def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names; ; # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3; ; # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('M",MatchSource.DOCS,doc/sphinxman/source/quickaddalias.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst:2487,Energy Efficiency,energy,energy,2487,"hods in |PSIfour| are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; :source:`psi4/driver/aliases.py` file is intended for editing by the user for; this purpose. As an example, the MP2.5 method; (which admittedly is already built in to |PSIfour|); is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy. ::. def run_mp2_5(name, **kwargs):; ; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); ; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; ; print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); ; return e_mp25. Compare the above to the method that resides in :source:`psi4/driver/aliases.py`.; The rationale for the changes is indicated in the comments below. ::. def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names; ; # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3; ; # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository;",MatchSource.DOCS,doc/sphinxman/source/quickaddalias.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst:2934,Energy Efficiency,energy,energy,2934,"s already built in to |PSIfour|); is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy. ::. def run_mp2_5(name, **kwargs):; ; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); ; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; ; print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); ; return e_mp25. Compare the above to the method that resides in :source:`psi4/driver/aliases.py`.; The rationale for the changes is indicated in the comments below. ::. def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names; ; # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3; ; # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations ; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out(",MatchSource.DOCS,doc/sphinxman/source/quickaddalias.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst:3924,Energy Efficiency,energy,energy,3924,"un_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names; ; # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3; ; # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations ; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners; ; tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file; ; return e_mp25 . One final step is necessary. At the end of the ``aliases.py`` file, add ; the following line. ::. procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command. ::. energy('mp2.5'). ",MatchSource.DOCS,doc/sphinxman/source/quickaddalias.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst:3979,Energy Efficiency,energy,energy,3979,"un_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names; ; # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3; ; # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations ; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners; ; tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file; ; return e_mp25 . One final step is necessary. At the end of the ``aliases.py`` file, add ; the following line. ::. procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command. ::. energy('mp2.5'). ",MatchSource.DOCS,doc/sphinxman/source/quickaddalias.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst:4036,Energy Efficiency,energy,energy,4036,"un_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names; ; # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3; ; # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations ; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners; ; tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file; ; return e_mp25 . One final step is necessary. At the end of the ``aliases.py`` file, add ; the following line. ::. procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command. ::. energy('mp2.5'). ",MatchSource.DOCS,doc/sphinxman/source/quickaddalias.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst:4092,Energy Efficiency,energy,energy,4092,"un_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names; ; # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3; ; # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations ; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners; ; tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file; ; return e_mp25 . One final step is necessary. At the end of the ``aliases.py`` file, add ; the following line. ::. procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command. ::. energy('mp2.5'). ",MatchSource.DOCS,doc/sphinxman/source/quickaddalias.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst:4155,Energy Efficiency,energy,energy,4155,"un_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names; ; # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3; ; # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations ; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners; ; tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file; ; return e_mp25 . One final step is necessary. At the end of the ``aliases.py`` file, add ; the following line. ::. procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command. ::. energy('mp2.5'). ",MatchSource.DOCS,doc/sphinxman/source/quickaddalias.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst:4219,Energy Efficiency,energy,energy,4219,"un_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names; ; # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3; ; # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations ; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners; ; tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file; ; return e_mp25 . One final step is necessary. At the end of the ``aliases.py`` file, add ; the following line. ::. procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command. ::. energy('mp2.5'). ",MatchSource.DOCS,doc/sphinxman/source/quickaddalias.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst:4282,Energy Efficiency,energy,energy,4282,"un_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names; ; # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3; ; # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations ; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners; ; tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file; ; return e_mp25 . One final step is necessary. At the end of the ``aliases.py`` file, add ; the following line. ::. procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command. ::. energy('mp2.5'). ",MatchSource.DOCS,doc/sphinxman/source/quickaddalias.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst:4539,Energy Efficiency,energy,energy,4539,"un_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names; ; # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3; ; # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations ; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners; ; tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file; ; return e_mp25 . One final step is necessary. At the end of the ``aliases.py`` file, add ; the following line. ::. procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command. ::. energy('mp2.5'). ",MatchSource.DOCS,doc/sphinxman/source/quickaddalias.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst:4678,Energy Efficiency,energy,energy,4678,"un_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names; ; # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3; ; # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations ; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners; ; tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file; ; return e_mp25 . One final step is necessary. At the end of the ``aliases.py`` file, add ; the following line. ::. procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command. ::. energy('mp2.5'). ",MatchSource.DOCS,doc/sphinxman/source/quickaddalias.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst:1595,Modifiability,variab,variables,1595,"OUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index::; pair: method alias; adding new. .. _`sec:methodAlias`:. Defining a Method Alias; =======================. .. note:: No recompile of the |PSIfour| program is necessary for changes made to; files in ``$PSIDATADIR`` aka :source:`psi4/share/psi4`, including those described below. .. caution:: As of 1.0, the below, while essentially still correct, is so aged; as to be difficult to follow. Since quantum chemical methods in |PSIfour| are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; :source:`psi4/driver/aliases.py` file is intended for editing by the user for; this purpose. As an example, the MP2.5 method; (which admittedly is already built in to |PSIfour|); is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy. ::. def run_mp2_5(name, **kwargs):; ; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); ; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; ; print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); ; return e_mp25. Compare the above to the method that resides ",MatchSource.DOCS,doc/sphinxman/source/quickaddalias.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst:2035,Modifiability,variab,variables,2035," USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index::; pair: method alias; adding new. .. _`sec:methodAlias`:. Defining a Method Alias; =======================. .. note:: No recompile of the |PSIfour| program is necessary for changes made to; files in ``$PSIDATADIR`` aka :source:`psi4/share/psi4`, including those described below. .. caution:: As of 1.0, the below, while essentially still correct, is so aged; as to be difficult to follow. Since quantum chemical methods in |PSIfour| are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; :source:`psi4/driver/aliases.py` file is intended for editing by the user for; this purpose. As an example, the MP2.5 method; (which admittedly is already built in to |PSIfour|); is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy. ::. def run_mp2_5(name, **kwargs):; ; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); ; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; ; print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); ; return e_mp25. Compare the above to the method that resides in :source:`psi4/driver/aliases.py`.; The rationale for the changes is indicated in the comments below. ::. def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names; ; # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variab",MatchSource.DOCS,doc/sphinxman/source/quickaddalias.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst:2755,Modifiability,variab,variable,2755,"s already built in to |PSIfour|); is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy. ::. def run_mp2_5(name, **kwargs):; ; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); ; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; ; print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); ; return e_mp25. Compare the above to the method that resides in :source:`psi4/driver/aliases.py`.; The rationale for the changes is indicated in the comments below. ::. def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names; ; # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3; ; # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations ; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out(",MatchSource.DOCS,doc/sphinxman/source/quickaddalias.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst:3466,Modifiability,variab,variable,3466,"nt """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); ; return e_mp25. Compare the above to the method that resides in :source:`psi4/driver/aliases.py`.; The rationale for the changes is indicated in the comments below. ::. def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names; ; # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3; ; # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations ; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners; ; tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file; ; return e_mp25 . One final step is necessary. At t",MatchSource.DOCS,doc/sphinxman/source/quickaddalias.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst:3622,Modifiability,variab,variable,3622,"/driver/aliases.py`.; The rationale for the changes is indicated in the comments below. ::. def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names; ; # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3; ; # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations ; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners; ; tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file; ; return e_mp25 . One final step is necessary. At the end of the ``aliases.py`` file, add ; the following line. ::. procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly define",MatchSource.DOCS,doc/sphinxman/source/quickaddalias.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst:3600,Performance,optimiz,optimizer,3600,"/driver/aliases.py`.; The rationale for the changes is indicated in the comments below. ::. def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names; ; # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3; ; # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations ; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners; ; tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file; ; return e_mp25 . One final step is necessary. At the end of the ``aliases.py`` file, add ; the following line. ::. procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly define",MatchSource.DOCS,doc/sphinxman/source/quickaddalias.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst:3667,Performance,optimiz,optimizations,3667,"un_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names; ; # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3; ; # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations ; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners; ; tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file; ; return e_mp25 . One final step is necessary. At the end of the ``aliases.py`` file, add ; the following line. ::. procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command. ::. energy('mp2.5'). ",MatchSource.DOCS,doc/sphinxman/source/quickaddalias.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst:1508,Security,access,accessed,1508,"OUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index::; pair: method alias; adding new. .. _`sec:methodAlias`:. Defining a Method Alias; =======================. .. note:: No recompile of the |PSIfour| program is necessary for changes made to; files in ``$PSIDATADIR`` aka :source:`psi4/share/psi4`, including those described below. .. caution:: As of 1.0, the below, while essentially still correct, is so aged; as to be difficult to follow. Since quantum chemical methods in |PSIfour| are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; :source:`psi4/driver/aliases.py` file is intended for editing by the user for; this purpose. As an example, the MP2.5 method; (which admittedly is already built in to |PSIfour|); is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy. ::. def run_mp2_5(name, **kwargs):; ; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); ; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; ; print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); ; return e_mp25. Compare the above to the method that resides ",MatchSource.DOCS,doc/sphinxman/source/quickaddalias.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickaddalias.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickadddatabase.rst:2451,Availability,avail,available,2451,"le molecular system; (may be a dimer) whose geometry you are possession of and whose electronic; energy may be of interest. A reaction is a combination of one or more; reagent energies whose value you are interested in and a reference value; for which you may or may not be in possession of. A few examples follow.; In a database of interaction energies, the reagents are dimers and their; component monomers (usually derived from the dimer geometry), and the; reactions are the dimer less monomers energies. In a database of barrier; heights, the reagents are reactants, products, and transition-state; structures, and the reactions are the transition-states less; minimum-energy structures. Possibly you may have a collection of; structures to simply be acted upon in parallel, in which case the; structures are both the reagents and the reactions. The role of the; database.py file is to collect arrays and dictionaries that define the; geometries of reagents (GEOS), their combination into reactions (RXNM &; ACTV), available reference values for reactions (BIND), and brief comments; for reagents and reactions (TAGL). The journey from reagent geometries to; functional database.py file is largely automated, in a process described; below. * Prepare geometry files; Assemble xyz files for all intended reagent systems in a directory.; Follow the rules below for best results. The filename for each xyz; file should be the name of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as python won't allow them. If you're determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an example. - The first line for each xyz file should be the number of atoms in the system. - The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything",MatchSource.DOCS,doc/sphinxman/source/quickadddatabase.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickadddatabase.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickadddatabase.rst:1528,Energy Efficiency,energy,energy,1528,"tion, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index::; pair: database(); adding new. .. _`sec:createDatabase`:. Creating a Database; ===================. .. note:: No recompile of the PSI program is necessary for changes made to; files in ``$PSIDATADIR``, including those described below. A necessary consideration in constructing a database is the distinction; between reagents and reactions. A reagent is a single molecular system; (may be a dimer) whose geometry you are possession of and whose electronic; energy may be of interest. A reaction is a combination of one or more; reagent energies whose value you are interested in and a reference value; for which you may or may not be in possession of. A few examples follow.; In a database of interaction energies, the reagents are dimers and their; component monomers (usually derived from the dimer geometry), and the; reactions are the dimer less monomers energies. In a database of barrier; heights, the reagents are reactants, products, and transition-state; structures, and the reactions are the transition-states less; minimum-energy structures. Possibly you may have a collection of; structures to simply be acted upon in parallel, in which case the; structures are both the reagents and the reactions. The role of the; database.py file is to collect arrays and dictionaries that define the; geometries of reagents (GEOS), their combination into reactions (RXNM &; ACTV), available reference values for r",MatchSource.DOCS,doc/sphinxman/source/quickadddatabase.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickadddatabase.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickadddatabase.rst:2105,Energy Efficiency,energy,energy,2105,": autodoc_abbr_options_c.rst. .. index::; pair: database(); adding new. .. _`sec:createDatabase`:. Creating a Database; ===================. .. note:: No recompile of the PSI program is necessary for changes made to; files in ``$PSIDATADIR``, including those described below. A necessary consideration in constructing a database is the distinction; between reagents and reactions. A reagent is a single molecular system; (may be a dimer) whose geometry you are possession of and whose electronic; energy may be of interest. A reaction is a combination of one or more; reagent energies whose value you are interested in and a reference value; for which you may or may not be in possession of. A few examples follow.; In a database of interaction energies, the reagents are dimers and their; component monomers (usually derived from the dimer geometry), and the; reactions are the dimer less monomers energies. In a database of barrier; heights, the reagents are reactants, products, and transition-state; structures, and the reactions are the transition-states less; minimum-energy structures. Possibly you may have a collection of; structures to simply be acted upon in parallel, in which case the; structures are both the reagents and the reactions. The role of the; database.py file is to collect arrays and dictionaries that define the; geometries of reagents (GEOS), their combination into reactions (RXNM &; ACTV), available reference values for reactions (BIND), and brief comments; for reagents and reactions (TAGL). The journey from reagent geometries to; functional database.py file is largely automated, in a process described; below. * Prepare geometry files; Assemble xyz files for all intended reagent systems in a directory.; Follow the rules below for best results. The filename for each xyz; file should be the name of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as python won't allow them. If you're de",MatchSource.DOCS,doc/sphinxman/source/quickadddatabase.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickadddatabase.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickadddatabase.rst:3448,Energy Efficiency,charge,charge,3448,"ts (GEOS), their combination into reactions (RXNM &; ACTV), available reference values for reactions (BIND), and brief comments; for reagents and reactions (TAGL). The journey from reagent geometries to; functional database.py file is largely automated, in a process described; below. * Prepare geometry files; Assemble xyz files for all intended reagent systems in a directory.; Follow the rules below for best results. The filename for each xyz; file should be the name of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as python won't allow them. If you're determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an example. - The first line for each xyz file should be the number of atoms in the system. - The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment). - The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what's the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. * Run script :source:`psi4/share/psi4/scripts/ixyz2database.py`. Move into the directory where all your xyz files are located. Run the; script. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is pr",MatchSource.DOCS,doc/sphinxman/source/quickadddatabase.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickadddatabase.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickadddatabase.rst:3952,Energy Efficiency,charge,charge,3952," of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as python won't allow them. If you're determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an example. - The first line for each xyz file should be the number of atoms in the system. - The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment). - The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what's the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. * Run script :source:`psi4/share/psi4/scripts/ixyz2database.py`. Move into the directory where all your xyz files are located. Run the; script. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. * Edit file database.py. According to your responses in to questions in the ixyz2database.py script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into :source:`psi4/share/psi4/databases`.; Alternately, append the directory containing your new database into; :envvar:`PSIPATH`. ",MatchSource.DOCS,doc/sphinxman/source/quickadddatabase.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickadddatabase.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickadddatabase.rst:4036,Energy Efficiency,charge,charge,4036," of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as python won't allow them. If you're determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an example. - The first line for each xyz file should be the number of atoms in the system. - The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment). - The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what's the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. * Run script :source:`psi4/share/psi4/scripts/ixyz2database.py`. Move into the directory where all your xyz files are located. Run the; script. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. * Edit file database.py. According to your responses in to questions in the ixyz2database.py script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into :source:`psi4/share/psi4/databases`.; Alternately, append the directory containing your new database into; :envvar:`PSIPATH`. ",MatchSource.DOCS,doc/sphinxman/source/quickadddatabase.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickadddatabase.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickadddatabase.rst:4486,Integrability,rout,route,4486," of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as python won't allow them. If you're determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an example. - The first line for each xyz file should be the number of atoms in the system. - The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment). - The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what's the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. * Run script :source:`psi4/share/psi4/scripts/ixyz2database.py`. Move into the directory where all your xyz files are located. Run the; script. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. * Edit file database.py. According to your responses in to questions in the ixyz2database.py script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into :source:`psi4/share/psi4/databases`.; Alternately, append the directory containing your new database into; :envvar:`PSIPATH`. ",MatchSource.DOCS,doc/sphinxman/source/quickadddatabase.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickadddatabase.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickadddatabase.rst:4493,Modifiability,variab,variable,4493," of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as python won't allow them. If you're determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an example. - The first line for each xyz file should be the number of atoms in the system. - The second line for each xyz file can be blank (interpreted as no comment), anything (interpreted as a comment), or two integers and anything (interpreted as charge, multiplicity, and remainder as comment). - The third and subsequent lines have four fields: the element symbol and the three cartesian coordinates in angstroms. The atom lines should not contain any dummy atoms (what's the use in cartesian form). For dimer systems, an algorithm is used to apportion the atoms into two fragments; thus the atoms need not be arranged with all fragmentA atoms before all fragmentB atoms. The algorithm will fail for very closely arranged fragments. For dimers, any charge and multiplicity from the second line will be applied to fragmentA (python); charge and multiplicity may need to be redistributed later in the editing step. * Run script :source:`psi4/share/psi4/scripts/ixyz2database.py`. Move into the directory where all your xyz files are located. Run the; script. It will ask a number of; questions about your intended database and generate a python file; named for your database. Uppercase is preferable for database names; (according to Sherrill lab convention). Note your choice for the route; variable for the next step. * Edit file database.py. According to your responses in to questions in the ixyz2database.py script,; several bullets will be printed of edits you necessarily or optionally; should make. Copy your new database into :source:`psi4/share/psi4/databases`.; Alternately, append the directory containing your new database into; :envvar:`PSIPATH`. ",MatchSource.DOCS,doc/sphinxman/source/quickadddatabase.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickadddatabase.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickadddatabase.rst:2177,Usability,simpl,simply,2177,"PSI program is necessary for changes made to; files in ``$PSIDATADIR``, including those described below. A necessary consideration in constructing a database is the distinction; between reagents and reactions. A reagent is a single molecular system; (may be a dimer) whose geometry you are possession of and whose electronic; energy may be of interest. A reaction is a combination of one or more; reagent energies whose value you are interested in and a reference value; for which you may or may not be in possession of. A few examples follow.; In a database of interaction energies, the reagents are dimers and their; component monomers (usually derived from the dimer geometry), and the; reactions are the dimer less monomers energies. In a database of barrier; heights, the reagents are reactants, products, and transition-state; structures, and the reactions are the transition-states less; minimum-energy structures. Possibly you may have a collection of; structures to simply be acted upon in parallel, in which case the; structures are both the reagents and the reactions. The role of the; database.py file is to collect arrays and dictionaries that define the; geometries of reagents (GEOS), their combination into reactions (RXNM &; ACTV), available reference values for reactions (BIND), and brief comments; for reagents and reactions (TAGL). The journey from reagent geometries to; functional database.py file is largely automated, in a process described; below. * Prepare geometry files; Assemble xyz files for all intended reagent systems in a directory.; Follow the rules below for best results. The filename for each xyz; file should be the name of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as python won't allow them. If you're determined to; have dashes and dots, they must be replaced by other characters in the; process_input line, then translated back in the GEOS section; see; NBC10.py for an exa",MatchSource.DOCS,doc/sphinxman/source/quickadddatabase.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/quickadddatabase.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst:1685,Energy Efficiency,energy,energy,1685," Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index::; relativistic. .. _`sec:relativistic`:. Scalar relativistic Hamiltonians; ================================. .. codeauthor:: Prakash Verma and Francesco A. Evangelista; .. sectionauthor:: Prakash Verma, Wallace D. Derricotte, and Francesco A. Evangelista. The exact-two-component (X2C) approach is a convenient way to introduce scalar; relativistic effects in DFT and wave function-based methods.; |PSIfour| implements the spin-free one-electron version of X2C, which produces; a modified one-electron Hamiltonian :math:`H_{\rm X2C}`:. .. math:: H_{\rm X2C} = T_{\rm X2C} + V_{\rm X2C}. that is a sum of a kinetic energy (:math:`T_{\rm X2C}`) and potential energy; (:math:`V_{\rm X2C}`) operator.; Our implementation is equivalent to the one reported by Cheng and Gauss [Cheng:084114]_.; X2C calculations require the use of special (alternatively fully uncontracted) basis sets designed for relativistic; calculations. Common choices include the Dunning Douglass--Kroll basis sets; (cc-pVXZ-DK, cc-pCVXZ-DK, cc-pwCVXZ-DK) and Roos' ANO basis sets. .. note:: See also :ref:`sec:DKH` for another relativistic Hamiltonian. .. _`sec:ScalarRelativistic`:. A First Example; ^^^^^^^^^^^^^^^. The following is a simple input that will perform a Hartree--Fock calculation; using the X2C Hamiltonian. ::. molecule {; H; F 1 0.92; }. set {; scf_type pk; basis cc-pvdz; relativistic x2c; }. energy('hf'). This computation yields the following result::. @RHF Final Energy: -100.10007984692388. => Energetics <=. Nuclear Repulsion Energy = 5.1767335622934780; One-Electron Energy = -150.7611816259664579; Two-Electron Energy = 45.4843682167491039; Total E",MatchSource.DOCS,doc/sphinxman/source/relativistic.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst:1728,Energy Efficiency,energy,energy,1728," Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index::; relativistic. .. _`sec:relativistic`:. Scalar relativistic Hamiltonians; ================================. .. codeauthor:: Prakash Verma and Francesco A. Evangelista; .. sectionauthor:: Prakash Verma, Wallace D. Derricotte, and Francesco A. Evangelista. The exact-two-component (X2C) approach is a convenient way to introduce scalar; relativistic effects in DFT and wave function-based methods.; |PSIfour| implements the spin-free one-electron version of X2C, which produces; a modified one-electron Hamiltonian :math:`H_{\rm X2C}`:. .. math:: H_{\rm X2C} = T_{\rm X2C} + V_{\rm X2C}. that is a sum of a kinetic energy (:math:`T_{\rm X2C}`) and potential energy; (:math:`V_{\rm X2C}`) operator.; Our implementation is equivalent to the one reported by Cheng and Gauss [Cheng:084114]_.; X2C calculations require the use of special (alternatively fully uncontracted) basis sets designed for relativistic; calculations. Common choices include the Dunning Douglass--Kroll basis sets; (cc-pVXZ-DK, cc-pCVXZ-DK, cc-pwCVXZ-DK) and Roos' ANO basis sets. .. note:: See also :ref:`sec:DKH` for another relativistic Hamiltonian. .. _`sec:ScalarRelativistic`:. A First Example; ^^^^^^^^^^^^^^^. The following is a simple input that will perform a Hartree--Fock calculation; using the X2C Hamiltonian. ::. molecule {; H; F 1 0.92; }. set {; scf_type pk; basis cc-pvdz; relativistic x2c; }. energy('hf'). This computation yields the following result::. @RHF Final Energy: -100.10007984692388. => Energetics <=. Nuclear Repulsion Energy = 5.1767335622934780; One-Electron Energy = -150.7611816259664579; Two-Electron Energy = 45.4843682167491039; Total E",MatchSource.DOCS,doc/sphinxman/source/relativistic.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst:2450,Energy Efficiency,energy,energy,2450,"ed methods.; |PSIfour| implements the spin-free one-electron version of X2C, which produces; a modified one-electron Hamiltonian :math:`H_{\rm X2C}`:. .. math:: H_{\rm X2C} = T_{\rm X2C} + V_{\rm X2C}. that is a sum of a kinetic energy (:math:`T_{\rm X2C}`) and potential energy; (:math:`V_{\rm X2C}`) operator.; Our implementation is equivalent to the one reported by Cheng and Gauss [Cheng:084114]_.; X2C calculations require the use of special (alternatively fully uncontracted) basis sets designed for relativistic; calculations. Common choices include the Dunning Douglass--Kroll basis sets; (cc-pVXZ-DK, cc-pCVXZ-DK, cc-pwCVXZ-DK) and Roos' ANO basis sets. .. note:: See also :ref:`sec:DKH` for another relativistic Hamiltonian. .. _`sec:ScalarRelativistic`:. A First Example; ^^^^^^^^^^^^^^^. The following is a simple input that will perform a Hartree--Fock calculation; using the X2C Hamiltonian. ::. molecule {; H; F 1 0.92; }. set {; scf_type pk; basis cc-pvdz; relativistic x2c; }. energy('hf'). This computation yields the following result::. @RHF Final Energy: -100.10007984692388. => Energetics <=. Nuclear Repulsion Energy = 5.1767335622934780; One-Electron Energy = -150.7611816259664579; Two-Electron Energy = 45.4843682167491039; Total Energy = -100.1000798469238902. while a non-relativistic calculation yields the following energy::. @RHF Final Energy: -100.01928891411315. => Energetics <=. Nuclear Repulsion Energy = 5.1767335622934780; One-Electron Energy = -150.6645256529074572; Two-Electron Energy = 45.4685031765008461; Total Energy = -100.0192889141131474. Basis sets options; ^^^^^^^^^^^^^^^^^^. The X2C module in |PSIfour| supports different combinations of basis set.; By default, if the input file specifies only |mints__basis|, then the X2C; module will solve the modified Dirac equation in an uncontracted basis and then; recontract the X2C Hamiltonian in the original basis.; Alternatively, the user can use |globals__basis_relativistic| to specify a different; ba",MatchSource.DOCS,doc/sphinxman/source/relativistic.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst:2801,Energy Efficiency,energy,energy,2801,"lementation is equivalent to the one reported by Cheng and Gauss [Cheng:084114]_.; X2C calculations require the use of special (alternatively fully uncontracted) basis sets designed for relativistic; calculations. Common choices include the Dunning Douglass--Kroll basis sets; (cc-pVXZ-DK, cc-pCVXZ-DK, cc-pwCVXZ-DK) and Roos' ANO basis sets. .. note:: See also :ref:`sec:DKH` for another relativistic Hamiltonian. .. _`sec:ScalarRelativistic`:. A First Example; ^^^^^^^^^^^^^^^. The following is a simple input that will perform a Hartree--Fock calculation; using the X2C Hamiltonian. ::. molecule {; H; F 1 0.92; }. set {; scf_type pk; basis cc-pvdz; relativistic x2c; }. energy('hf'). This computation yields the following result::. @RHF Final Energy: -100.10007984692388. => Energetics <=. Nuclear Repulsion Energy = 5.1767335622934780; One-Electron Energy = -150.7611816259664579; Two-Electron Energy = 45.4843682167491039; Total Energy = -100.1000798469238902. while a non-relativistic calculation yields the following energy::. @RHF Final Energy: -100.01928891411315. => Energetics <=. Nuclear Repulsion Energy = 5.1767335622934780; One-Electron Energy = -150.6645256529074572; Two-Electron Energy = 45.4685031765008461; Total Energy = -100.0192889141131474. Basis sets options; ^^^^^^^^^^^^^^^^^^. The X2C module in |PSIfour| supports different combinations of basis set.; By default, if the input file specifies only |mints__basis|, then the X2C; module will solve the modified Dirac equation in an uncontracted basis and then; recontract the X2C Hamiltonian in the original basis.; Alternatively, the user can use |globals__basis_relativistic| to specify a different; basis set to solve the modified Dirac equation. ::. set {; basis cc-pvdz-dk; basis_relativistic cc-pvtz-dk; relativistic x2c; }. It is recommended that when employing the X2C relativistic Hamiltonian, that you use a fully; decontracted basis set. This can be done simply in the input by adding ""-decon"" to the ; name of th",MatchSource.DOCS,doc/sphinxman/source/relativistic.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst:4063,Energy Efficiency,energy,energy,4063,"our| supports different combinations of basis set.; By default, if the input file specifies only |mints__basis|, then the X2C; module will solve the modified Dirac equation in an uncontracted basis and then; recontract the X2C Hamiltonian in the original basis.; Alternatively, the user can use |globals__basis_relativistic| to specify a different; basis set to solve the modified Dirac equation. ::. set {; basis cc-pvdz-dk; basis_relativistic cc-pvtz-dk; relativistic x2c; }. It is recommended that when employing the X2C relativistic Hamiltonian, that you use a fully; decontracted basis set. This can be done simply in the input by adding ""-decon"" to the ; name of the primary basis you want to use for the calculation as detailed in ; :ref:`Decontracted Basis Sets <sec:basisDecontracted>`. Publications resulting from the use ; of X2C should cite the following publication: [Verma:2015]_. Theory; ^^^^^^. X2C is based on exact decoupling of ; positive-energy ( :math:`h^{FW}_{\rm ++}`; ) and negative-energy (:math:`h^{FW}_{\rm --}` ); blocks of the Dirac Hamiltonian (:math:`h^{D}`). . .. math:: ; U^\dagger h^{\rm D} U = ; U^\dagger; \begin{pmatrix}; h_{LL} & h_{LS} \\; h_{SL} & h_{SS}; \end{pmatrix}; U; =; \begin{pmatrix}; h^{\rm FW}_{++} & 0 \\; 0 & h^{\rm FW}_{--}; \end{pmatrix}. The transformation ( :math:`U` ) is obtained from the solutions of the Dirac equation in kinetically balanced basis [Kutzelnigg:1984]_ treatment. ; In the X2C treatment, the positive-energy block of the Hamiltonian ( :math:`h^{FW}_{\rm ++}` ); is given by the sum; of a transformed kinetic (:math:`T_{\rm X2C}`) and potential energy ( :math:`V_{\rm X2C}` ) contribution.; Relativistic kinetic energy ( :math:`T_{\rm X2C}` ) and nuclear-electron interaction potential ( :math:`V_{\rm X2C}` ) is given in terms of non-relativisitc kinetic (:math:`T=\hat{p}^2/2`) energy and nuclear-electron interaction potential (:math:`V`), coupling matrix ( :math:`X`) and renormalization matrix ( :math:`R`). . .. math::;",MatchSource.DOCS,doc/sphinxman/source/relativistic.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst:4112,Energy Efficiency,energy,energy,4112,"our| supports different combinations of basis set.; By default, if the input file specifies only |mints__basis|, then the X2C; module will solve the modified Dirac equation in an uncontracted basis and then; recontract the X2C Hamiltonian in the original basis.; Alternatively, the user can use |globals__basis_relativistic| to specify a different; basis set to solve the modified Dirac equation. ::. set {; basis cc-pvdz-dk; basis_relativistic cc-pvtz-dk; relativistic x2c; }. It is recommended that when employing the X2C relativistic Hamiltonian, that you use a fully; decontracted basis set. This can be done simply in the input by adding ""-decon"" to the ; name of the primary basis you want to use for the calculation as detailed in ; :ref:`Decontracted Basis Sets <sec:basisDecontracted>`. Publications resulting from the use ; of X2C should cite the following publication: [Verma:2015]_. Theory; ^^^^^^. X2C is based on exact decoupling of ; positive-energy ( :math:`h^{FW}_{\rm ++}`; ) and negative-energy (:math:`h^{FW}_{\rm --}` ); blocks of the Dirac Hamiltonian (:math:`h^{D}`). . .. math:: ; U^\dagger h^{\rm D} U = ; U^\dagger; \begin{pmatrix}; h_{LL} & h_{LS} \\; h_{SL} & h_{SS}; \end{pmatrix}; U; =; \begin{pmatrix}; h^{\rm FW}_{++} & 0 \\; 0 & h^{\rm FW}_{--}; \end{pmatrix}. The transformation ( :math:`U` ) is obtained from the solutions of the Dirac equation in kinetically balanced basis [Kutzelnigg:1984]_ treatment. ; In the X2C treatment, the positive-energy block of the Hamiltonian ( :math:`h^{FW}_{\rm ++}` ); is given by the sum; of a transformed kinetic (:math:`T_{\rm X2C}`) and potential energy ( :math:`V_{\rm X2C}` ) contribution.; Relativistic kinetic energy ( :math:`T_{\rm X2C}` ) and nuclear-electron interaction potential ( :math:`V_{\rm X2C}` ) is given in terms of non-relativisitc kinetic (:math:`T=\hat{p}^2/2`) energy and nuclear-electron interaction potential (:math:`V`), coupling matrix ( :math:`X`) and renormalization matrix ( :math:`R`). . .. math::;",MatchSource.DOCS,doc/sphinxman/source/relativistic.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst:4582,Energy Efficiency,energy,energy,4582,"hat you use a fully; decontracted basis set. This can be done simply in the input by adding ""-decon"" to the ; name of the primary basis you want to use for the calculation as detailed in ; :ref:`Decontracted Basis Sets <sec:basisDecontracted>`. Publications resulting from the use ; of X2C should cite the following publication: [Verma:2015]_. Theory; ^^^^^^. X2C is based on exact decoupling of ; positive-energy ( :math:`h^{FW}_{\rm ++}`; ) and negative-energy (:math:`h^{FW}_{\rm --}` ); blocks of the Dirac Hamiltonian (:math:`h^{D}`). . .. math:: ; U^\dagger h^{\rm D} U = ; U^\dagger; \begin{pmatrix}; h_{LL} & h_{LS} \\; h_{SL} & h_{SS}; \end{pmatrix}; U; =; \begin{pmatrix}; h^{\rm FW}_{++} & 0 \\; 0 & h^{\rm FW}_{--}; \end{pmatrix}. The transformation ( :math:`U` ) is obtained from the solutions of the Dirac equation in kinetically balanced basis [Kutzelnigg:1984]_ treatment. ; In the X2C treatment, the positive-energy block of the Hamiltonian ( :math:`h^{FW}_{\rm ++}` ); is given by the sum; of a transformed kinetic (:math:`T_{\rm X2C}`) and potential energy ( :math:`V_{\rm X2C}` ) contribution.; Relativistic kinetic energy ( :math:`T_{\rm X2C}` ) and nuclear-electron interaction potential ( :math:`V_{\rm X2C}` ) is given in terms of non-relativisitc kinetic (:math:`T=\hat{p}^2/2`) energy and nuclear-electron interaction potential (:math:`V`), coupling matrix ( :math:`X`) and renormalization matrix ( :math:`R`). . .. math::; T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R . .. math::; V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R. The coupling matrix ( :math:`{X} = C^{S} (C^{L})^{-1}` ) is obtained from the large (:math:`C^{\rm L}`) and small (:math:`C^{\rm S}`) components of the :math:`N` positive energy solutions of the Dirac equation.; The renormalization matrix ; :math:`{R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}`,; depends on the modified overlap matrix; :math:`\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX`. ",MatchSource.DOCS,doc/sphinxman/source/relativistic.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst:4725,Energy Efficiency,energy,energy,4725,"hat you use a fully; decontracted basis set. This can be done simply in the input by adding ""-decon"" to the ; name of the primary basis you want to use for the calculation as detailed in ; :ref:`Decontracted Basis Sets <sec:basisDecontracted>`. Publications resulting from the use ; of X2C should cite the following publication: [Verma:2015]_. Theory; ^^^^^^. X2C is based on exact decoupling of ; positive-energy ( :math:`h^{FW}_{\rm ++}`; ) and negative-energy (:math:`h^{FW}_{\rm --}` ); blocks of the Dirac Hamiltonian (:math:`h^{D}`). . .. math:: ; U^\dagger h^{\rm D} U = ; U^\dagger; \begin{pmatrix}; h_{LL} & h_{LS} \\; h_{SL} & h_{SS}; \end{pmatrix}; U; =; \begin{pmatrix}; h^{\rm FW}_{++} & 0 \\; 0 & h^{\rm FW}_{--}; \end{pmatrix}. The transformation ( :math:`U` ) is obtained from the solutions of the Dirac equation in kinetically balanced basis [Kutzelnigg:1984]_ treatment. ; In the X2C treatment, the positive-energy block of the Hamiltonian ( :math:`h^{FW}_{\rm ++}` ); is given by the sum; of a transformed kinetic (:math:`T_{\rm X2C}`) and potential energy ( :math:`V_{\rm X2C}` ) contribution.; Relativistic kinetic energy ( :math:`T_{\rm X2C}` ) and nuclear-electron interaction potential ( :math:`V_{\rm X2C}` ) is given in terms of non-relativisitc kinetic (:math:`T=\hat{p}^2/2`) energy and nuclear-electron interaction potential (:math:`V`), coupling matrix ( :math:`X`) and renormalization matrix ( :math:`R`). . .. math::; T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R . .. math::; V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R. The coupling matrix ( :math:`{X} = C^{S} (C^{L})^{-1}` ) is obtained from the large (:math:`C^{\rm L}`) and small (:math:`C^{\rm S}`) components of the :math:`N` positive energy solutions of the Dirac equation.; The renormalization matrix ; :math:`{R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}`,; depends on the modified overlap matrix; :math:`\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX`. ",MatchSource.DOCS,doc/sphinxman/source/relativistic.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst:4792,Energy Efficiency,energy,energy,4792,"he use ; of X2C should cite the following publication: [Verma:2015]_. Theory; ^^^^^^. X2C is based on exact decoupling of ; positive-energy ( :math:`h^{FW}_{\rm ++}`; ) and negative-energy (:math:`h^{FW}_{\rm --}` ); blocks of the Dirac Hamiltonian (:math:`h^{D}`). . .. math:: ; U^\dagger h^{\rm D} U = ; U^\dagger; \begin{pmatrix}; h_{LL} & h_{LS} \\; h_{SL} & h_{SS}; \end{pmatrix}; U; =; \begin{pmatrix}; h^{\rm FW}_{++} & 0 \\; 0 & h^{\rm FW}_{--}; \end{pmatrix}. The transformation ( :math:`U` ) is obtained from the solutions of the Dirac equation in kinetically balanced basis [Kutzelnigg:1984]_ treatment. ; In the X2C treatment, the positive-energy block of the Hamiltonian ( :math:`h^{FW}_{\rm ++}` ); is given by the sum; of a transformed kinetic (:math:`T_{\rm X2C}`) and potential energy ( :math:`V_{\rm X2C}` ) contribution.; Relativistic kinetic energy ( :math:`T_{\rm X2C}` ) and nuclear-electron interaction potential ( :math:`V_{\rm X2C}` ) is given in terms of non-relativisitc kinetic (:math:`T=\hat{p}^2/2`) energy and nuclear-electron interaction potential (:math:`V`), coupling matrix ( :math:`X`) and renormalization matrix ( :math:`R`). . .. math::; T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R . .. math::; V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R. The coupling matrix ( :math:`{X} = C^{S} (C^{L})^{-1}` ) is obtained from the large (:math:`C^{\rm L}`) and small (:math:`C^{\rm S}`) components of the :math:`N` positive energy solutions of the Dirac equation.; The renormalization matrix ; :math:`{R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}`,; depends on the modified overlap matrix; :math:`\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX`. The integrals :math:`W^{\rm SF}_{\mu\nu} = \langle {\chi_\mu} | \hat{p}\cdot (\hat{V}\hat{p}) |{\chi_\nu}\rangle` can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic str",MatchSource.DOCS,doc/sphinxman/source/relativistic.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst:4960,Energy Efficiency,energy,energy,4960,"he use ; of X2C should cite the following publication: [Verma:2015]_. Theory; ^^^^^^. X2C is based on exact decoupling of ; positive-energy ( :math:`h^{FW}_{\rm ++}`; ) and negative-energy (:math:`h^{FW}_{\rm --}` ); blocks of the Dirac Hamiltonian (:math:`h^{D}`). . .. math:: ; U^\dagger h^{\rm D} U = ; U^\dagger; \begin{pmatrix}; h_{LL} & h_{LS} \\; h_{SL} & h_{SS}; \end{pmatrix}; U; =; \begin{pmatrix}; h^{\rm FW}_{++} & 0 \\; 0 & h^{\rm FW}_{--}; \end{pmatrix}. The transformation ( :math:`U` ) is obtained from the solutions of the Dirac equation in kinetically balanced basis [Kutzelnigg:1984]_ treatment. ; In the X2C treatment, the positive-energy block of the Hamiltonian ( :math:`h^{FW}_{\rm ++}` ); is given by the sum; of a transformed kinetic (:math:`T_{\rm X2C}`) and potential energy ( :math:`V_{\rm X2C}` ) contribution.; Relativistic kinetic energy ( :math:`T_{\rm X2C}` ) and nuclear-electron interaction potential ( :math:`V_{\rm X2C}` ) is given in terms of non-relativisitc kinetic (:math:`T=\hat{p}^2/2`) energy and nuclear-electron interaction potential (:math:`V`), coupling matrix ( :math:`X`) and renormalization matrix ( :math:`R`). . .. math::; T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R . .. math::; V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R. The coupling matrix ( :math:`{X} = C^{S} (C^{L})^{-1}` ) is obtained from the large (:math:`C^{\rm L}`) and small (:math:`C^{\rm S}`) components of the :math:`N` positive energy solutions of the Dirac equation.; The renormalization matrix ; :math:`{R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}`,; depends on the modified overlap matrix; :math:`\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX`. The integrals :math:`W^{\rm SF}_{\mu\nu} = \langle {\chi_\mu} | \hat{p}\cdot (\hat{V}\hat{p}) |{\chi_\nu}\rangle` can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic str",MatchSource.DOCS,doc/sphinxman/source/relativistic.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst:5434,Energy Efficiency,energy,energy,5434,"h^{\rm FW}_{--}; \end{pmatrix}. The transformation ( :math:`U` ) is obtained from the solutions of the Dirac equation in kinetically balanced basis [Kutzelnigg:1984]_ treatment. ; In the X2C treatment, the positive-energy block of the Hamiltonian ( :math:`h^{FW}_{\rm ++}` ); is given by the sum; of a transformed kinetic (:math:`T_{\rm X2C}`) and potential energy ( :math:`V_{\rm X2C}` ) contribution.; Relativistic kinetic energy ( :math:`T_{\rm X2C}` ) and nuclear-electron interaction potential ( :math:`V_{\rm X2C}` ) is given in terms of non-relativisitc kinetic (:math:`T=\hat{p}^2/2`) energy and nuclear-electron interaction potential (:math:`V`), coupling matrix ( :math:`X`) and renormalization matrix ( :math:`R`). . .. math::; T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R . .. math::; V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R. The coupling matrix ( :math:`{X} = C^{S} (C^{L})^{-1}` ) is obtained from the large (:math:`C^{\rm L}`) and small (:math:`C^{\rm S}`) components of the :math:`N` positive energy solutions of the Dirac equation.; The renormalization matrix ; :math:`{R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}`,; depends on the modified overlap matrix; :math:`\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX`. The integrals :math:`W^{\rm SF}_{\mu\nu} = \langle {\chi_\mu} | \hat{p}\cdot (\hat{V}\hat{p}) |{\chi_\nu}\rangle` can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic structure code can be extended to include scalar relativistic effects; treated with the X2C method by replacing nonrelativistic kinetic and potential energy with the corresponding; X2C operators :math:`T_{X2C}` and :math:`V_{X2C}`. It is important to note that fully uncontracted basis in needed for the construction of X2C Hamiltonian as Foldy-Wouthuysen (FW [FW:1950]_) transformation is obtained in kinetically balance basis. Keywords; ~",MatchSource.DOCS,doc/sphinxman/source/relativistic.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst:6078,Energy Efficiency,energy,energy,6078," balanced basis [Kutzelnigg:1984]_ treatment. ; In the X2C treatment, the positive-energy block of the Hamiltonian ( :math:`h^{FW}_{\rm ++}` ); is given by the sum; of a transformed kinetic (:math:`T_{\rm X2C}`) and potential energy ( :math:`V_{\rm X2C}` ) contribution.; Relativistic kinetic energy ( :math:`T_{\rm X2C}` ) and nuclear-electron interaction potential ( :math:`V_{\rm X2C}` ) is given in terms of non-relativisitc kinetic (:math:`T=\hat{p}^2/2`) energy and nuclear-electron interaction potential (:math:`V`), coupling matrix ( :math:`X`) and renormalization matrix ( :math:`R`). . .. math::; T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R . .. math::; V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R. The coupling matrix ( :math:`{X} = C^{S} (C^{L})^{-1}` ) is obtained from the large (:math:`C^{\rm L}`) and small (:math:`C^{\rm S}`) components of the :math:`N` positive energy solutions of the Dirac equation.; The renormalization matrix ; :math:`{R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}`,; depends on the modified overlap matrix; :math:`\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX`. The integrals :math:`W^{\rm SF}_{\mu\nu} = \langle {\chi_\mu} | \hat{p}\cdot (\hat{V}\hat{p}) |{\chi_\nu}\rangle` can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic structure code can be extended to include scalar relativistic effects; treated with the X2C method by replacing nonrelativistic kinetic and potential energy with the corresponding; X2C operators :math:`T_{X2C}` and :math:`V_{X2C}`. It is important to note that fully uncontracted basis in needed for the construction of X2C Hamiltonian as Foldy-Wouthuysen (FW [FW:1950]_) transformation is obtained in kinetically balance basis. Keywords; ~~~~~~~~. .. include:: autodir_options_c/globals__relativistic.rst; .. include:: autodir_options_c/globals__basis_relativistic.rst. ",MatchSource.DOCS,doc/sphinxman/source/relativistic.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst:5568,Integrability,depend,depends,5568," balanced basis [Kutzelnigg:1984]_ treatment. ; In the X2C treatment, the positive-energy block of the Hamiltonian ( :math:`h^{FW}_{\rm ++}` ); is given by the sum; of a transformed kinetic (:math:`T_{\rm X2C}`) and potential energy ( :math:`V_{\rm X2C}` ) contribution.; Relativistic kinetic energy ( :math:`T_{\rm X2C}` ) and nuclear-electron interaction potential ( :math:`V_{\rm X2C}` ) is given in terms of non-relativisitc kinetic (:math:`T=\hat{p}^2/2`) energy and nuclear-electron interaction potential (:math:`V`), coupling matrix ( :math:`X`) and renormalization matrix ( :math:`R`). . .. math::; T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R . .. math::; V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R. The coupling matrix ( :math:`{X} = C^{S} (C^{L})^{-1}` ) is obtained from the large (:math:`C^{\rm L}`) and small (:math:`C^{\rm S}`) components of the :math:`N` positive energy solutions of the Dirac equation.; The renormalization matrix ; :math:`{R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}`,; depends on the modified overlap matrix; :math:`\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX`. The integrals :math:`W^{\rm SF}_{\mu\nu} = \langle {\chi_\mu} | \hat{p}\cdot (\hat{V}\hat{p}) |{\chi_\nu}\rangle` can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic structure code can be extended to include scalar relativistic effects; treated with the X2C method by replacing nonrelativistic kinetic and potential energy with the corresponding; X2C operators :math:`T_{X2C}` and :math:`V_{X2C}`. It is important to note that fully uncontracted basis in needed for the construction of X2C Hamiltonian as Foldy-Wouthuysen (FW [FW:1950]_) transformation is obtained in kinetically balance basis. Keywords; ~~~~~~~~. .. include:: autodir_options_c/globals__relativistic.rst; .. include:: autodir_options_c/globals__basis_relativistic.rst. ",MatchSource.DOCS,doc/sphinxman/source/relativistic.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst:5023,Modifiability,coupling,coupling,5023,"he use ; of X2C should cite the following publication: [Verma:2015]_. Theory; ^^^^^^. X2C is based on exact decoupling of ; positive-energy ( :math:`h^{FW}_{\rm ++}`; ) and negative-energy (:math:`h^{FW}_{\rm --}` ); blocks of the Dirac Hamiltonian (:math:`h^{D}`). . .. math:: ; U^\dagger h^{\rm D} U = ; U^\dagger; \begin{pmatrix}; h_{LL} & h_{LS} \\; h_{SL} & h_{SS}; \end{pmatrix}; U; =; \begin{pmatrix}; h^{\rm FW}_{++} & 0 \\; 0 & h^{\rm FW}_{--}; \end{pmatrix}. The transformation ( :math:`U` ) is obtained from the solutions of the Dirac equation in kinetically balanced basis [Kutzelnigg:1984]_ treatment. ; In the X2C treatment, the positive-energy block of the Hamiltonian ( :math:`h^{FW}_{\rm ++}` ); is given by the sum; of a transformed kinetic (:math:`T_{\rm X2C}`) and potential energy ( :math:`V_{\rm X2C}` ) contribution.; Relativistic kinetic energy ( :math:`T_{\rm X2C}` ) and nuclear-electron interaction potential ( :math:`V_{\rm X2C}` ) is given in terms of non-relativisitc kinetic (:math:`T=\hat{p}^2/2`) energy and nuclear-electron interaction potential (:math:`V`), coupling matrix ( :math:`X`) and renormalization matrix ( :math:`R`). . .. math::; T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R . .. math::; V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R. The coupling matrix ( :math:`{X} = C^{S} (C^{L})^{-1}` ) is obtained from the large (:math:`C^{\rm L}`) and small (:math:`C^{\rm S}`) components of the :math:`N` positive energy solutions of the Dirac equation.; The renormalization matrix ; :math:`{R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}`,; depends on the modified overlap matrix; :math:`\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX`. The integrals :math:`W^{\rm SF}_{\mu\nu} = \langle {\chi_\mu} | \hat{p}\cdot (\hat{V}\hat{p}) |{\chi_\nu}\rangle` can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic str",MatchSource.DOCS,doc/sphinxman/source/relativistic.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst:5267,Modifiability,coupling,coupling,5267,"h^{\rm FW}_{--}; \end{pmatrix}. The transformation ( :math:`U` ) is obtained from the solutions of the Dirac equation in kinetically balanced basis [Kutzelnigg:1984]_ treatment. ; In the X2C treatment, the positive-energy block of the Hamiltonian ( :math:`h^{FW}_{\rm ++}` ); is given by the sum; of a transformed kinetic (:math:`T_{\rm X2C}`) and potential energy ( :math:`V_{\rm X2C}` ) contribution.; Relativistic kinetic energy ( :math:`T_{\rm X2C}` ) and nuclear-electron interaction potential ( :math:`V_{\rm X2C}` ) is given in terms of non-relativisitc kinetic (:math:`T=\hat{p}^2/2`) energy and nuclear-electron interaction potential (:math:`V`), coupling matrix ( :math:`X`) and renormalization matrix ( :math:`R`). . .. math::; T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R . .. math::; V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R. The coupling matrix ( :math:`{X} = C^{S} (C^{L})^{-1}` ) is obtained from the large (:math:`C^{\rm L}`) and small (:math:`C^{\rm S}`) components of the :math:`N` positive energy solutions of the Dirac equation.; The renormalization matrix ; :math:`{R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}`,; depends on the modified overlap matrix; :math:`\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX`. The integrals :math:`W^{\rm SF}_{\mu\nu} = \langle {\chi_\mu} | \hat{p}\cdot (\hat{V}\hat{p}) |{\chi_\nu}\rangle` can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic structure code can be extended to include scalar relativistic effects; treated with the X2C method by replacing nonrelativistic kinetic and potential energy with the corresponding; X2C operators :math:`T_{X2C}` and :math:`V_{X2C}`. It is important to note that fully uncontracted basis in needed for the construction of X2C Hamiltonian as Foldy-Wouthuysen (FW [FW:1950]_) transformation is obtained in kinetically balance basis. Keywords; ~",MatchSource.DOCS,doc/sphinxman/source/relativistic.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst:5950,Modifiability,extend,extended,5950," balanced basis [Kutzelnigg:1984]_ treatment. ; In the X2C treatment, the positive-energy block of the Hamiltonian ( :math:`h^{FW}_{\rm ++}` ); is given by the sum; of a transformed kinetic (:math:`T_{\rm X2C}`) and potential energy ( :math:`V_{\rm X2C}` ) contribution.; Relativistic kinetic energy ( :math:`T_{\rm X2C}` ) and nuclear-electron interaction potential ( :math:`V_{\rm X2C}` ) is given in terms of non-relativisitc kinetic (:math:`T=\hat{p}^2/2`) energy and nuclear-electron interaction potential (:math:`V`), coupling matrix ( :math:`X`) and renormalization matrix ( :math:`R`). . .. math::; T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R . .. math::; V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R. The coupling matrix ( :math:`{X} = C^{S} (C^{L})^{-1}` ) is obtained from the large (:math:`C^{\rm L}`) and small (:math:`C^{\rm S}`) components of the :math:`N` positive energy solutions of the Dirac equation.; The renormalization matrix ; :math:`{R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}`,; depends on the modified overlap matrix; :math:`\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX`. The integrals :math:`W^{\rm SF}_{\mu\nu} = \langle {\chi_\mu} | \hat{p}\cdot (\hat{V}\hat{p}) |{\chi_\nu}\rangle` can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic structure code can be extended to include scalar relativistic effects; treated with the X2C method by replacing nonrelativistic kinetic and potential energy with the corresponding; X2C operators :math:`T_{X2C}` and :math:`V_{X2C}`. It is important to note that fully uncontracted basis in needed for the construction of X2C Hamiltonian as Foldy-Wouthuysen (FW [FW:1950]_) transformation is obtained in kinetically balance basis. Keywords; ~~~~~~~~. .. include:: autodir_options_c/globals__relativistic.rst; .. include:: autodir_options_c/globals__basis_relativistic.rst. ",MatchSource.DOCS,doc/sphinxman/source/relativistic.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst:2298,Performance,perform,perform,2298,"co A. Evangelista. The exact-two-component (X2C) approach is a convenient way to introduce scalar; relativistic effects in DFT and wave function-based methods.; |PSIfour| implements the spin-free one-electron version of X2C, which produces; a modified one-electron Hamiltonian :math:`H_{\rm X2C}`:. .. math:: H_{\rm X2C} = T_{\rm X2C} + V_{\rm X2C}. that is a sum of a kinetic energy (:math:`T_{\rm X2C}`) and potential energy; (:math:`V_{\rm X2C}`) operator.; Our implementation is equivalent to the one reported by Cheng and Gauss [Cheng:084114]_.; X2C calculations require the use of special (alternatively fully uncontracted) basis sets designed for relativistic; calculations. Common choices include the Dunning Douglass--Kroll basis sets; (cc-pVXZ-DK, cc-pCVXZ-DK, cc-pwCVXZ-DK) and Roos' ANO basis sets. .. note:: See also :ref:`sec:DKH` for another relativistic Hamiltonian. .. _`sec:ScalarRelativistic`:. A First Example; ^^^^^^^^^^^^^^^. The following is a simple input that will perform a Hartree--Fock calculation; using the X2C Hamiltonian. ::. molecule {; H; F 1 0.92; }. set {; scf_type pk; basis cc-pvdz; relativistic x2c; }. energy('hf'). This computation yields the following result::. @RHF Final Energy: -100.10007984692388. => Energetics <=. Nuclear Repulsion Energy = 5.1767335622934780; One-Electron Energy = -150.7611816259664579; Two-Electron Energy = 45.4843682167491039; Total Energy = -100.1000798469238902. while a non-relativistic calculation yields the following energy::. @RHF Final Energy: -100.01928891411315. => Energetics <=. Nuclear Repulsion Energy = 5.1767335622934780; One-Electron Energy = -150.6645256529074572; Two-Electron Energy = 45.4685031765008461; Total Energy = -100.0192889141131474. Basis sets options; ^^^^^^^^^^^^^^^^^^. The X2C module in |PSIfour| supports different combinations of basis set.; By default, if the input file specifies only |mints__basis|, then the X2C; module will solve the modified Dirac equation in an uncontracted basis and t",MatchSource.DOCS,doc/sphinxman/source/relativistic.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst:2275,Usability,simpl,simple,2275,"co A. Evangelista. The exact-two-component (X2C) approach is a convenient way to introduce scalar; relativistic effects in DFT and wave function-based methods.; |PSIfour| implements the spin-free one-electron version of X2C, which produces; a modified one-electron Hamiltonian :math:`H_{\rm X2C}`:. .. math:: H_{\rm X2C} = T_{\rm X2C} + V_{\rm X2C}. that is a sum of a kinetic energy (:math:`T_{\rm X2C}`) and potential energy; (:math:`V_{\rm X2C}`) operator.; Our implementation is equivalent to the one reported by Cheng and Gauss [Cheng:084114]_.; X2C calculations require the use of special (alternatively fully uncontracted) basis sets designed for relativistic; calculations. Common choices include the Dunning Douglass--Kroll basis sets; (cc-pVXZ-DK, cc-pCVXZ-DK, cc-pwCVXZ-DK) and Roos' ANO basis sets. .. note:: See also :ref:`sec:DKH` for another relativistic Hamiltonian. .. _`sec:ScalarRelativistic`:. A First Example; ^^^^^^^^^^^^^^^. The following is a simple input that will perform a Hartree--Fock calculation; using the X2C Hamiltonian. ::. molecule {; H; F 1 0.92; }. set {; scf_type pk; basis cc-pvdz; relativistic x2c; }. energy('hf'). This computation yields the following result::. @RHF Final Energy: -100.10007984692388. => Energetics <=. Nuclear Repulsion Energy = 5.1767335622934780; One-Electron Energy = -150.7611816259664579; Two-Electron Energy = 45.4843682167491039; Total Energy = -100.1000798469238902. while a non-relativistic calculation yields the following energy::. @RHF Final Energy: -100.01928891411315. => Energetics <=. Nuclear Repulsion Energy = 5.1767335622934780; One-Electron Energy = -150.6645256529074572; Two-Electron Energy = 45.4685031765008461; Total Energy = -100.0192889141131474. Basis sets options; ^^^^^^^^^^^^^^^^^^. The X2C module in |PSIfour| supports different combinations of basis set.; By default, if the input file specifies only |mints__basis|, then the X2C; module will solve the modified Dirac equation in an uncontracted basis and t",MatchSource.DOCS,doc/sphinxman/source/relativistic.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst:3718,Usability,simpl,simply,3718," energy::. @RHF Final Energy: -100.01928891411315. => Energetics <=. Nuclear Repulsion Energy = 5.1767335622934780; One-Electron Energy = -150.6645256529074572; Two-Electron Energy = 45.4685031765008461; Total Energy = -100.0192889141131474. Basis sets options; ^^^^^^^^^^^^^^^^^^. The X2C module in |PSIfour| supports different combinations of basis set.; By default, if the input file specifies only |mints__basis|, then the X2C; module will solve the modified Dirac equation in an uncontracted basis and then; recontract the X2C Hamiltonian in the original basis.; Alternatively, the user can use |globals__basis_relativistic| to specify a different; basis set to solve the modified Dirac equation. ::. set {; basis cc-pvdz-dk; basis_relativistic cc-pvtz-dk; relativistic x2c; }. It is recommended that when employing the X2C relativistic Hamiltonian, that you use a fully; decontracted basis set. This can be done simply in the input by adding ""-decon"" to the ; name of the primary basis you want to use for the calculation as detailed in ; :ref:`Decontracted Basis Sets <sec:basisDecontracted>`. Publications resulting from the use ; of X2C should cite the following publication: [Verma:2015]_. Theory; ^^^^^^. X2C is based on exact decoupling of ; positive-energy ( :math:`h^{FW}_{\rm ++}`; ) and negative-energy (:math:`h^{FW}_{\rm --}` ); blocks of the Dirac Hamiltonian (:math:`h^{D}`). . .. math:: ; U^\dagger h^{\rm D} U = ; U^\dagger; \begin{pmatrix}; h_{LL} & h_{LS} \\; h_{SL} & h_{SS}; \end{pmatrix}; U; =; \begin{pmatrix}; h^{\rm FW}_{++} & 0 \\; 0 & h^{\rm FW}_{--}; \end{pmatrix}. The transformation ( :math:`U` ) is obtained from the solutions of the Dirac equation in kinetically balanced basis [Kutzelnigg:1984]_ treatment. ; In the X2C treatment, the positive-energy block of the Hamiltonian ( :math:`h^{FW}_{\rm ++}` ); is given by the sum; of a transformed kinetic (:math:`T_{\rm X2C}`) and potential energy ( :math:`V_{\rm X2C}` ) contribution.; Relativistic kinetic energy (",MatchSource.DOCS,doc/sphinxman/source/relativistic.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/relativistic.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:5677,Availability,avail,available,5677,"physically meaningful components: *i.e.*,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the ; Hamiltonian of the dimer is partitioned into contributions from each ; monomer and the interaction. .. math:: H=F_A+W_A+F_B+W_B+V. Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, :math:`F`, the fluctuation potential of each monomer, :math:`W`, and the; interaction potential, :math:`V`. The monomer Fock operators, :math:`F_A+F_B`, are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of :math:`V`, :math:`W_A`, and :math:`W_B`. ; Through first-order in :math:`V`, electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in :math:`V`. For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887]_. Several truncations of the closed-shell SAPT expansion are available in the SAPT; module of |PSIfour|. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. :eq:`SAPT0`. .. math:: E_{SAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + E_{exch-disp}^{(20)} + \delta_{HF}^{(2)}; :label: SAPT0. In this notation, :math:`E^{(vw)}` defines the order in :math:`V` and in :math:`W_A+W_B`; the; subscript, :math:`resp`, indicates that orbital relaxation effects are included. .. math:: E_{SAPT2} = E_{SAPT0} + E_{elst,resp}^{(12)} + E_{exch}^{(11)} +; E_{exch}^{(12)} + \; ^{t}\!E_{ind}^{(22)} + \; ^{t}\!E_{exch-ind}^{(22)}; :label: SAPT2. .. math:: E_{SAPT2+} = E_{SAPT2} + E_{disp}^{(21)} + E_{disp}^{(22)}; :label: SAPT2p. .. math:: E_{SAPT2+(3)} = E_{SAPT2+} + E_{elst,resp}^{(13)} + E_{disp}^{(30)}; :label: SAPT2pparen3. .. math:: E_{SAPT2+3} = E_{SAPT2+(3)}; + E_{exch-ind}^{(30)} + E_{ind,resp}^{(30)}; + E_{exch-disp}^{(30)} + E_{ind-disp}^{(30)} + E_{exch-ind-disp}^{(30)}",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:8423,Availability,avail,available,8423,")}; :label: SAPTDFT; .. math:: E_{disp,resp}^{(20)} = -\frac{1}{2\pi}\int_0^\infty d\omega \int d\mathbf{r}_A d\mathbf{r}'_A d\mathbf{r}_B d\mathbf{r}'_B \frac{1}{\left|\mathbf{r}_A-\mathbf{r}_B\right|}\frac{1}{\left|\mathbf{r}'_A-\mathbf{r}'_B\right|}\chi^A_{coup}\left(\mathbf{r}_A,\mathbf{r}'_A|i\omega\right)\chi^B_{coup}\left(\mathbf{r}_B,\mathbf{r}'_B|i\omega\right). .. math:: \chi_{coup}\left(\mathbf{r},\mathbf{r}'|\omega\right) = \chi_0\left(\mathbf{r},\mathbf{r}'|\omega\right) + \int d\omega d\mathbf{r}_1 d\mathbf{r}_2 \chi_0\left(\mathbf{r},\mathbf{r}_1|\omega\right)\left[\frac{1}{r_{12}} + f_{xc}\left(\mathbf{r}_1,\mathbf{r}_2,\omega\right)\right]\chi\left(\mathbf{r}_2,\mathbf{r}'|\omega\right). The :math:`\delta_{HF}^{(2)}` and :math:`\delta_{HF}^{(3)}` terms take into; account higher-order induction effects and are included in the definition; of SAPT terms. They are computed from the Hartree--Fock supermolecular interaction energy; :math:`E_{int}^{HF}` and are only available in dimer-centered basis SAPT; computations, which is the default (see below for monomer-centered basis ; computations). They are defined by:. .. math:: \delta_{HF}^{(2)} = E_{int}^{HF} - (E_{elst}^{(10)} + E_{exch}^{(10)} ; + E_{ind,resp}^{(20)} + E_{exch-ind,resp}^{(20)}); :label: dHF2. .. math:: \delta_{HF}^{(3)} = \delta_{HF}^{(2)} - (E_{exch-ind}^{(30)} ; + E_{ind,resp}^{(30)}); :label: dHF3. Additionally, high-order coupling between induction and dispersion can be ; extracted from the supermolecular MP2 interaction energy:. .. math:: \delta_{MP2}^{(2)} = E_{int}^{MP2, corr} - (E_{elst}^{(12)} +; E_{exch}^{(11)} + E_{exch}^{(12)} + \; ^{t}\!E_{ind}^{(22)}; + \; ^{t}\!E_{exch-ind}^{(22)} + E_{disp}^{(20)} + E_{exch-disp}^{(20)}). .. math:: \delta_{MP2}^{(3)} = \delta_{MP2}^{(2)} - (E_{ind-disp}^{(30)} + E_{exch-ind-disp}^{(30)}). where :math:`E_{int}^{MP2, corr}` is the correlation part of the supermolecular MP2 ; interaction energy. :math:`\delta_{MP2}^{(2)}` and :math:`\delta_{MP",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:10433,Availability,error,errors,10433,"nd :math:`\delta_{MP2}^{(3)}` also improve the ; description of electrostatically dominated complexes. :math:`\delta_{MP2}^{(2)}`; can be applied to SAPT2+ or SAPT2+(3) energies whereas :math:`\delta_{MP2}^{(3)}` ; should be applied to SAPT2+3 energies. A thorough analysis of the performance of these truncations of closed-shell SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs]_,; and a systematic study of the accuracy of these truncations (with and ; without an improved CCD treatment of dispersion) using different basis sets; is reported in [Parker:2014:094106]_. The closed-shell SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in |PSIfour|, assumes the use of density-fitted; two-electron integrals, therefore, the closed-shell SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligible errors into the SAPT energy ; (often less than 0.01 kcal/mol for small dimers) and greatly; improves efficiency. . The latest addition to the SAPT code is the SAPT0 method for open-shell ; monomers [Gonthier:2016:134106]_. This code is available for both exact and density fitted integrals, ; except for the dispersion terms which implementation relies on a density fitting; factorization. Both ``UHF`` and ``ROHF`` |scf__reference| can be used, but coupled; induction computations are currently not supported with ``ROHF``. This means that orbital; relaxation is not included for ``ROHF`` and the uncoupled induction term is computed instead.; If both monomers are open-shell, their coupling is assumed to be high spin, i.e.; two doublets would interact to form a triplet. The *S*\ :superscript:`2` approximation and scaling; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. All exchange terms in SAPT arise from the antisymmetrization; of the wavefunctions of monomers A and",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:10669,Availability,avail,available,10669,"ell SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs]_,; and a systematic study of the accuracy of these truncations (with and ; without an improved CCD treatment of dispersion) using different basis sets; is reported in [Parker:2014:094106]_. The closed-shell SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in |PSIfour|, assumes the use of density-fitted; two-electron integrals, therefore, the closed-shell SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligible errors into the SAPT energy ; (often less than 0.01 kcal/mol for small dimers) and greatly; improves efficiency. . The latest addition to the SAPT code is the SAPT0 method for open-shell ; monomers [Gonthier:2016:134106]_. This code is available for both exact and density fitted integrals, ; except for the dispersion terms which implementation relies on a density fitting; factorization. Both ``UHF`` and ``ROHF`` |scf__reference| can be used, but coupled; induction computations are currently not supported with ``ROHF``. This means that orbital; relaxation is not included for ``ROHF`` and the uncoupled induction term is computed instead.; If both monomers are open-shell, their coupling is assumed to be high spin, i.e.; two doublets would interact to form a triplet. The *S*\ :superscript:`2` approximation and scaling; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. All exchange terms in SAPT arise from the antisymmetrization; of the wavefunctions of monomers A and B. Taking into account exchange of all possible; electron pairs between the two monomers yields to complicated formulae.; For this reason, exchange terms are often evaluated in the :math:`S^{2}`; approximation, that can be interpreted as the exchange of a single electron ; pair between monomers. The :math:`S^{2}` approximat",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:11783,Availability,down,down,11783,"es on a density fitting; factorization. Both ``UHF`` and ``ROHF`` |scf__reference| can be used, but coupled; induction computations are currently not supported with ``ROHF``. This means that orbital; relaxation is not included for ``ROHF`` and the uncoupled induction term is computed instead.; If both monomers are open-shell, their coupling is assumed to be high spin, i.e.; two doublets would interact to form a triplet. The *S*\ :superscript:`2` approximation and scaling; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. All exchange terms in SAPT arise from the antisymmetrization; of the wavefunctions of monomers A and B. Taking into account exchange of all possible; electron pairs between the two monomers yields to complicated formulae.; For this reason, exchange terms are often evaluated in the :math:`S^{2}`; approximation, that can be interpreted as the exchange of a single electron ; pair between monomers. The :math:`S^{2}` approximation is usually pretty good, but may ; break down for short intermolecular distance, particularly in high-order; terms. To compensate for these deviations, in 2014 Parker et al. [Parker:2014:094106]_ ; recommended to scale all :math:`S^{2}` approximated exchange terms by the ratio:. .. math:: p_{EX}(\alpha) = \left( \frac{E_{exch}^{(10)}}{E_{exch}^{(10)}(S^{2})} \right)^{\alpha}. and recommended using the ratio with exponent :math:`\alpha = 1`. To obtain SAPT energies with this scaling,; simply set the keyword ``exch_scale_alpha true``. Alternatively, another value for :math:`\alpha`; can be specified by setting |sapt__exch_scale_alpha| to a value. For example, ::. set exch_scale_alpha 1.0. will set :math:`\alpha = 1.0` and scale exchange energies with :math:`p_{EX}(1.0)`. However, as pointed out by Schaffer and Jansen [Schaffer:2013:2570]_; in the context of DFT-based SAPT, the ratios :math:`E_{exch}^{(1)}(S^{2})/E_{exch}^{(1)}`,; :math:`E_{\rm exch-ind}^{(2)}(S^2)/E_{\rm exch-ind}^{(2)}`, and ; :math:`E_{\rm exch-disp}^{(2)}(S^2",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:13865,Availability,avail,available,13865,"ing of all :math:`S^{2}` approximated terms; was turned off by default. Finally, in 2014 Parker et al. [Parker:2014:094106]_ empirically discovered that ; SAPT0 energies for van der Waals dimers with close contacts benefit from a slightly modified ; recipe that involves an empirically adjusted exponent :math:`\alpha = 3.0`. ; To distinguish it from its unscaled counterpart, this energy is denoted sSAPT0 (see [Parker:2014:094106]_). .. math:: E_{sSAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; p_{EX}(3.0) E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + p_{EX}(3.0) E_{exch-disp}^{(20)} ; + \delta_{HF}^{(2)}; :label: sSAPT0. where :math:`\delta_{HF}^{(2)}` is computed *without* any scaling. Please note that ; sSAPT0 is thus not the same as requesting ``exch_scale_alpha 3.0``, and that the; scaling is automatically performed by requesting ``energy('ssapt0')``. A First Example; ^^^^^^^^^^^^^^^. The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods,; not all of them). ::. 	molecule water_dimer {; 	 0 1; 	 O -1.551007 -0.114520 0.000000; 	 H -1.934259 0.762503 0.000000; 	 H -0.599677 0.040712 0.000000; 	 --; 	 0 1; 	 O 1.350625 0.111469 0.000000; 	 H 1.680398 -0.373741 -0.758561; 	 H 1.680398 -0.373741 0.758561; 	; 	 units angstrom; 	 no_reorient; 	 symmetry c1; 	}; 	; 	set basis aug-cc-pvdz; 	; 	energy('sapt0'); 	energy('sapt2'); 	energy('sapt2+'); 	energy('sapt2+(3)'); 	energy('sapt2+3'). The SAPT module uses the standard |PSIfour| partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the ``no_reorient`` and ``symmetry; c1`` molecule keywords, as in the example above. As a reminder, only; SAPT0 can handle the interaction of both closed- and o",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:14945,Availability,avail,available,14945,":. 	molecule water_dimer {; 	 0 1; 	 O -1.551007 -0.114520 0.000000; 	 H -1.934259 0.762503 0.000000; 	 H -0.599677 0.040712 0.000000; 	 --; 	 0 1; 	 O 1.350625 0.111469 0.000000; 	 H 1.680398 -0.373741 -0.758561; 	 H 1.680398 -0.373741 0.758561; 	; 	 units angstrom; 	 no_reorient; 	 symmetry c1; 	}; 	; 	set basis aug-cc-pvdz; 	; 	energy('sapt0'); 	energy('sapt2'); 	energy('sapt2+'); 	energy('sapt2+(3)'); 	energy('sapt2+3'). The SAPT module uses the standard |PSIfour| partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the ``no_reorient`` and ``symmetry; c1`` molecule keywords, as in the example above. As a reminder, only; SAPT0 can handle the interaction of both closed- and open-shell monomers.; Higher-order SAPT and SAPT(DFT) are currently available only ; for computation of interactions between; closed-shell singlets. The SAPT codes in |PSIfour| have been written; to utilize density fitting, which is much faster than using conventional; 4-index electron repulsion integrals. This happens automatically and; does not require any additional keywords to be specified (both the ; SAPT computations and the underlying Hartree-Fock computations will; utilize density fitting). For SAPT(DFT), the user will need to manually specify the GRAC shift of ; both monomers, defined by the difference of ionization potential (IP) and; Kohn-Sham HOMO energy. The ionization potential data for many common molecules ; is available in NIST Chemistry Webbook. Alternatively, one can estimate the; ionization potential of molecule by computing the energy difference between; the molecule as given, and the molecule after one electron has been removed; (e.g., the energy difference between a neutral molecule and its cation). The values of GRAC shifts should be given in H",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:15614,Availability,avail,available,15614,"tions.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the ``no_reorient`` and ``symmetry; c1`` molecule keywords, as in the example above. As a reminder, only; SAPT0 can handle the interaction of both closed- and open-shell monomers.; Higher-order SAPT and SAPT(DFT) are currently available only ; for computation of interactions between; closed-shell singlets. The SAPT codes in |PSIfour| have been written; to utilize density fitting, which is much faster than using conventional; 4-index electron repulsion integrals. This happens automatically and; does not require any additional keywords to be specified (both the ; SAPT computations and the underlying Hartree-Fock computations will; utilize density fitting). For SAPT(DFT), the user will need to manually specify the GRAC shift of ; both monomers, defined by the difference of ionization potential (IP) and; Kohn-Sham HOMO energy. The ionization potential data for many common molecules ; is available in NIST Chemistry Webbook. Alternatively, one can estimate the; ionization potential of molecule by computing the energy difference between; the molecule as given, and the molecule after one electron has been removed; (e.g., the energy difference between a neutral molecule and its cation). The values of GRAC shifts should be given in Hartree. For the example above,; the GRAC shift value of both molecules are calculated to be 0.1307 (using experimental; IP from CCCBDB), and the user would specify them using the following keywords::. set globals {; sapt_dft_grac_shift_a 0.1307; sapt_dft_grac_shift_b 0.1307 ; }. A complete, minimal example of a SAPT(DFT) computation is given below. ::. molecule {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; }; ; set {; basis aug-cc-pVDZ; sapt_dft_grac_shift_a 0.1",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:16874,Availability,error,errors,16874,"e between a neutral molecule and its cation). The values of GRAC shifts should be given in Hartree. For the example above,; the GRAC shift value of both molecules are calculated to be 0.1307 (using experimental; IP from CCCBDB), and the user would specify them using the following keywords::. set globals {; sapt_dft_grac_shift_a 0.1307; sapt_dft_grac_shift_b 0.1307 ; }. A complete, minimal example of a SAPT(DFT) computation is given below. ::. molecule {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; }; ; set {; basis aug-cc-pVDZ; sapt_dft_grac_shift_a 0.1307; sapt_dft_grac_shift_b 0.1307; }; ; energy('sapt(dft)'). As already mentioned above, the SAPT0 module for open-shell cases can also; use exact integrals for all terms except for dispersion. In practice,; density fitting is considerably faster and introduces negligible errors, thus; it is the preferred method for open-shell cases as well.; Below, you can find a minimum example of open-shell SAPT0 computation. ::. molecule {; 0 1; O 0.000000 0.000000 6.000000; H 0.000000 1.431500 4.890600; H 0.000000 -1.431500 4.890600; --; 0 2; O 0.000000 0.000000 0.000000; O 0.000000 2.503900 0.000000; H 0.000000 -0.424700 -1.839500; units bohr; symmetry c1; no_reorient; no_com; }; ; set {; reference uhf; scf_type df; basis aug-cc-pVDZ; }; ; energy('sapt0'); ; . |scf__reference| needs to be ``UHF`` or ``ROHF`` for the open-shell computation to proceed. Advanced example; ^^^^^^^^^^^^^^^^. Open-shell computations can be difficult to converge in certain cases, thus you may; want to have more control over the SCF procedure. You have the option of ; doing the driver job in the input file, by performing the dimer and monomer computations; yourself. In the example below, we do a stability analysis for the open-shell monomer only ::. molecule {; 0 2; O 0.000000 0.00000",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:20172,Availability,error,error,20172,"dimer.set_basisset(""DF_BASIS_ELST"", aux_basis); ; psi4.sapt(wfn_dimer,wfn_monA,wfn_monB). In this way, any of the SCF options can be tweaked for individual fragments.; For optimal efficiency, the example uses ``set df_ints_io save`` to keep file 97,; which contains the three-index integrals for density fitting. ``set df_ints_io load``; then instructs the program to read these integrals from disk instead of recomputing; them. For each SCF computation, we use ``psi4.IO.set_default_namespace`` to uniquely; name scratch files. In the following SCF step, only file 97 is renamed using; ``psi4.IO.change_file_namespace`` so that integrals can be read from it.; For more information on stability analysis, see the :ref:`stability <sec:scfstability_doc>`; documentation. .. index:: SAPT; SAPT0. SAPT0; ^^^^^. Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of closed-shell SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ'). We do not recommend using SAPT0 with large basis sets; like aug-cc-pVTZ. A systematic study of the accuracy of closed-shell SAPT0 and other SAPT ; truncations, using different basis sets, is reported in ; [Parker:2014:094106]_. In particular, an empirical recipe for scaled SAPT0; can yield improved performance and has been included in the output file as; the sSAPT0 interaction energy. sSAPT0 is a free by-product and is automatically ; computed when SAPT0 is requested (see above for more details).; The SAPT module has been used to perform SAPT0 computations with over; 200 atoms and 2800 basis functions; this code should be scalable to 4000; basis functions. Publications resulting from the use of the SAPT0 code ; should cite the following publications: [Hohenstein:2010:184111]_ and ; [Hohenstein:2011:174107]_. If the open-shell SAPT0 code is used,; [Gonthier:2016:134106]_ shou",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:23305,Availability,recover,recover,23305,"c open-shell SAPT0 keywords; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__sapt_mem_safety.rst; .. include:: autodir_options_c/sapt__coupled_induction.rst. .. index:: SAPT; SAPT(DFT). .. _`sec:saptdft`:. SAPT(DFT); ^^^^^^^^^. In general, SAPT(DFT) should provide more accurate interaction energy ; components, and overall interaction energies, than SAPT0. The drawback ; is SAPT(DFT) method is more computationally demanding than SAPT0, ; SAPT(DFT) can still be applied to medium-sized or large systems. The ; SAPT(DFT) module was employed successfully in computations of systems ; with up to 2000 basis functions, and the code should be scalable to ; 3000 basis functions. Like higher-order SAPT, SAPT(DFT) requires ; sufficient memory to hold :math:`2ovN_aux` doubles. SAPT(DFT) requires a few special treatments to obtain accurate; result. The DFT functionals used in SAPT(DFT) need to be asymptotically; corrected with Gradient Regulated Asymptotic Correction scheme (GRAC),; in order to recover the correct long-range asymptotic behavior; (approaching :math:`-1/r` as :math:`r` approaches infinity). The program; requires manual input of GRAC shift parameter for each monomer through; keywords |sapt__sapt_dft_grac_shift_a| and |sapt__sapt_dft_grac_shift_b|,; which should be equal to the difference of the actual ionization; potential and the corresponding Kohn-Sham HOMO energy. The dispersion; term needs to be computed with orbital response for good accuracy,; and it is recommended to enable |sapt__sapt_dft_do_hybrid| (set to; ``True`` by default). The coupled exchange-dispersion energy is usually; estimated by scaling from the uncoupled value either by a fitted fixed; value (suggested initially by [Hesselmann:2014:094107]_ for a local Hartree--Fock (LHF) formulation and then revised; by [Xie:2022:024801]_ for non-LHF) or; by the ratio of; coupled and uncoupled dispersion energy (suggested by [Podeszwa:2006:400]_ ). ; This can be controlled by keyword |s",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:26769,Availability,error,errors,26769,"st; .. include:: autodir_options_c/sapt__sapt_dft_mp2_disp_alg.rst; .. include:: autodir_options_c/sapt__sapt_quiet.rst. .. index:: SAPT; higher-order. Higher-Order SAPT; ^^^^^^^^^^^^^^^^^. For smaller systems (up to the size of a nucleic acid base pair), more; accurate interaction energies can be obtained through higher-order SAPT; computations. The SAPT module can perform density-fitted evaluations; of SAPT2, SAPT2+, SAPT2+(3), and SAPT2+3 energies for closed-shell systems ; only. Publications resulting from the use of the higher-order SAPT code ; should cite the following: ; [Hohenstein:2010:014101]_. For methods SAPT2+ and above, one can replace the many-body treatment of; dispersion by an improved method based on coupled-cluster doubles (CCD).; This approach tends to give good improvements when dispersion effects; are very large, as in the PCCP dimer (see [Hohenstein:2011:2842]_).; As shown in [Parker:2014:094106]_, whether or not CCD dispersion offers; more accurate interaction energies tends to depend on the SAPT truncation; and basis set employed, due to cancellations of errors. Thanks to; natural orbital methods [Parrish:2013:174102]_, the SAPT code; is able to include CCD dispersion with only a modest additional cost.; Computations employing CCD dispersion should cite [Parrish:2013:174102]_. ; To request CCD dispersion treatment in a SAPT computation, simply append; ``(ccd)`` to the name of the method, as in the following examples ::. 	energy('sapt2+(ccd)'); 	energy('sapt2+(3)(ccd)'); 	energy('sapt2+3(ccd)'). The :math:`\delta_{MP2}` corrections can also be computed automatically; by appending ``dmp2`` to the name of the method, with or without CCD dispersion ::. 	energy('sapt2+dmp2'); 	energy('sapt2+(3)dmp2'); 	energy('sapt2+3dmp2'); 	energy('sapt2+(ccd)dmp2'); 	energy('sapt2+(3)(ccd)dmp2'); 	energy('sapt2+3(ccd)dmp2'). A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficie",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:30570,Availability,avail,available,30570,"_c/sapt__nat_orbs_t3.rst; .. include:: autodir_options_c/sapt__nat_orbs_v4.rst; .. include:: autodir_options_c/sapt__occ_tolerance.rst. .. comment Advanced Keywords Controlling MP2 NO Approximations; .. comment ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. comment .. include:: autodir_options_c/sapt__nat_orbs_t2.rst. .. index:: SAPT; charge-transfer. .. _`sec:saptct`:. Charge-Transfer in SAPT; ^^^^^^^^^^^^^^^^^^^^^^^. It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy ; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201]_. Charge-transfer energies can be obtained from the following calls to the; energy function. ::. energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'); energy('sapt2+(ccd)-ct'); energy('sapt2+(3)(ccd)-ct'); energy('sapt2+3(ccd)-ct'). For now, charge transfer computations are not available with open-shell SAPT0. A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results::. SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed with ; SAPT0/aug-cc-pVDZ. . .. index:: ; pair: SAPT; output. Monomer-Centered Basis Computations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Th",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:32800,Availability,error,error,32800,"ssible to run a closed-shell SAPT computation at any; level using only the monomer-centered basis. To do this, simply add; ``sapt_basis='monomer'`` to the energy function, such as ::. energy('sapt2',sapt_basis='monomer'). This procedure leads to faster compuations, but it converges more slowly; towards the complete basis set limit than the default procedure, which uses; the dimer-centered basis set. Hence, monomer-centered basis SAPT; computations are not recommended. The open-shell SAPT0 code is not; compatible yet with monomer-centered computations. Computations with Mid-bonds; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. SAPT computations with midbonds can be accomplished by adding a third ghost; monomer to the computation. For example ::. molecule dimer {; 0 1; He 0 0 5; --; 0 1; He 0 0 -5; --; 0 1; @He 0 0 0; }. Here the functions of the third monomer will be added to the virtual space of; the entire computation. Note that an error will be thrown if each atom in the; third monomer is not a ghost to prevent confusion with three-body SAPT which is; not currently supported by Psi4. Interpreting SAPT Results; ^^^^^^^^^^^^^^^^^^^^^^^^^. We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following ; input::. molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561; units angstrom; }; ; set globals {; basis aug-cc-pvdz; guess sad; scf_type df; }; ; set sapt {; print 1; nat_orbs_t2 true; freeze_core true; }; ; energy('sapt2+3'). To reiterate some of the options mentioned above: the; |sapt__nat_orbs_t2| option will compute MP2 natural orbitals and use; them in the evaluation of the triples correction to dispersion, and the; |sapt__freeze_core| option will freeze the core throughout the SAPT; computation. This SAPT2+3/aug-cc-pVDZ computation prod",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:37542,Availability,avail,available,37542,"7.18054663 [mEh] -4.50586123 [kcal/mol] -18.85252518 [kJ/mol]. Special recipe for scaled SAPT0 (see Manual):; Electrostatics sSAPT0 -13.37542977 [mEh] -8.39320925 [kcal/mol] -35.11719087 [kJ/mol]; Exchange sSAPT0 11.21822294 [mEh] 7.03954147 [kcal/mol] 29.45344432 [kJ/mol]; Induction sSAPT0 -3.47550008 [mEh] -2.18090932 [kcal/mol] -9.12492546 [kJ/mol]; Dispersion sSAPT0 -2.88342055 [mEh] -1.80937379 [kcal/mol] -7.57042064 [kJ/mol]; Total sSAPT0 -8.51612746 [mEh] -5.34395089 [kcal/mol] -22.35909265 [kJ/mol]; --------------------------------------------------------------------------------------------------------. At the bottom of this output are the total SAPT energies (defined above),; they are composed of subsets of the individual terms printed above. The; individual terms are grouped according to the component of the interaction; to which they contribute. The total component energies (*i.e.*,; electrostatics, exchange, induction, and dispersion) represent what we; regard as the best estimate available at a given level of SAPT computed; from a subset of the terms of that grouping. The groupings shown above are; not unique and are certainly not rigorously defined. We regard the groupings ; used in |PSIfour| as a ""chemist's grouping"" as opposed to a more; mathematically based grouping, which would group all exchange terms ; (*i.e.* :math:`E_{exch-ind,resp}^{(20)}`, :math:`E_{exch-disp}^{(20)}`, *etc.*) in; the exchange component. A final note is that both ``Disp22(T)``; and ``Est.Disp22(T)`` results appear if MP2 natural orbitals are ; used to evaluate the triples correction to dispersion. The ``Disp22(T)`` ; result is the triples correction as computed in the truncated NO basis; ; ``Est.Disp22(T)`` is a scaled result that attempts to recover; the effect of the truncated virtual space and is our best estimate. The ``Est.Disp22(T)``; value is used in the SAPT energy and dispersion component (see [Hohenstein:2010:104107]_ ; for details). Finally, this part of the output ",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:38297,Availability,recover,recover,38297," terms are grouped according to the component of the interaction; to which they contribute. The total component energies (*i.e.*,; electrostatics, exchange, induction, and dispersion) represent what we; regard as the best estimate available at a given level of SAPT computed; from a subset of the terms of that grouping. The groupings shown above are; not unique and are certainly not rigorously defined. We regard the groupings ; used in |PSIfour| as a ""chemist's grouping"" as opposed to a more; mathematically based grouping, which would group all exchange terms ; (*i.e.* :math:`E_{exch-ind,resp}^{(20)}`, :math:`E_{exch-disp}^{(20)}`, *etc.*) in; the exchange component. A final note is that both ``Disp22(T)``; and ``Est.Disp22(T)`` results appear if MP2 natural orbitals are ; used to evaluate the triples correction to dispersion. The ``Disp22(T)`` ; result is the triples correction as computed in the truncated NO basis; ; ``Est.Disp22(T)`` is a scaled result that attempts to recover; the effect of the truncated virtual space and is our best estimate. The ``Est.Disp22(T)``; value is used in the SAPT energy and dispersion component (see [Hohenstein:2010:104107]_ ; for details). Finally, this part of the output file contains sSAPT0, a special scaling; scheme of the SAPT0 energy that can yield improved results and was described in more details; above. The corresponding scaled total component energies are printed as well. As mentioned above, SAPT results with scaled exchange are also optionally available; by setting the |sapt__exch_scale_alpha| keyword. When activated, the unscaled results are; printed first as reported above, and then repeated with exchange scaling for all ; relevant terms: :: . SAPT Results ==> ALL S2 TERMS SCALED (see Manual) <==. Scaling factor (Exch10/Exch10(S^2))^{Alpha} = 1.007200; with Alpha = 1.000000; --------------------------------------------------------------------------------------------------------; Electrostatics -13.06509118 [mEh] -8.198468",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:38822,Availability,avail,available,38822,"atically based grouping, which would group all exchange terms ; (*i.e.* :math:`E_{exch-ind,resp}^{(20)}`, :math:`E_{exch-disp}^{(20)}`, *etc.*) in; the exchange component. A final note is that both ``Disp22(T)``; and ``Est.Disp22(T)`` results appear if MP2 natural orbitals are ; used to evaluate the triples correction to dispersion. The ``Disp22(T)`` ; result is the triples correction as computed in the truncated NO basis; ; ``Est.Disp22(T)`` is a scaled result that attempts to recover; the effect of the truncated virtual space and is our best estimate. The ``Est.Disp22(T)``; value is used in the SAPT energy and dispersion component (see [Hohenstein:2010:104107]_ ; for details). Finally, this part of the output file contains sSAPT0, a special scaling; scheme of the SAPT0 energy that can yield improved results and was described in more details; above. The corresponding scaled total component energies are printed as well. As mentioned above, SAPT results with scaled exchange are also optionally available; by setting the |sapt__exch_scale_alpha| keyword. When activated, the unscaled results are; printed first as reported above, and then repeated with exchange scaling for all ; relevant terms: :: . SAPT Results ==> ALL S2 TERMS SCALED (see Manual) <==. Scaling factor (Exch10/Exch10(S^2))^{Alpha} = 1.007200; with Alpha = 1.000000; --------------------------------------------------------------------------------------------------------; Electrostatics -13.06509118 [mEh] -8.19846883 [kcal/mol] -34.30239689 [kJ/mol]; Elst10,r -13.37542977 [mEh] -8.39320925 [kcal/mol] -35.11719087 [kJ/mol]; Elst12,r 0.04490350 [mEh] 0.02817737 [kcal/mol] 0.11789413 [kJ/mol]; Elst13,r 0.26543510 [mEh] 0.16656305 [kcal/mol] 0.69689985 [kJ/mol]. Exchange sc. 13.43351854 [mEh] 8.42966050 [kcal/mol] 35.26970292 [kJ/mol]; Exch10 11.21822294 [mEh] 7.03954147 [kcal/mol] 29.45344432 [kJ/mol]; Exch10(S^2) 11.13802706 [mEh] 6.98921779 [kcal/mol] 29.24289005 [kJ/mol]; Exch11(S^2) sc. 0.04591732 [mEh] 0.0",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:47355,Availability,avail,available,47355," scaling the uncoupled term for; :math:`E_{exch-ind,resp}^{(30)}`. S^inf Keywords; ~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__do_ind_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_disp_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_ind30_exch_sinf.rst. .. _`sec:saptd`:. SAPT0-D; ~~~~~~~. In SAPT0, the computation of :math:`E_{disp}^{(20)} + E_{exch-disp}^{(20)}` represents; the computational bottleneck. One can avoid this bottleneck by replacing these; dispersion terms with the empirical D3 corrections developed by Grimme.; ; :ref:`Grimme's dispersion corrections are discussed here. <sec:dftd3>`. The corresponding method, termed SAPT0-D, thus relies on empirically fit parameters; specific to SAPT0/jun-cc-pVDZ. While SAPT0-D can be used with any of the -D ; variants using default parameters optimized for Hartee--Fock interaction energies, ; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]_. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters. ; A simple water dimer computation using SAPT0-D may look like::. 	molecule water_dimer {; 	 0 1; 	 O -1.551007 -0.114520 0.000000; 	 H -1.934259 0.762503 0.000000; 	 H -0.599677 0.040712 0.000000; 	 --; 	 0 1; 	 O 1.350625 0.111469 0.000000; 	 H 1.680398 -0.373741 -0.758561; 	 H 1.680398 -0.373741 0.758561; 	; 	 units angstrom; 	 no_reorient; 	 symmetry c1; 	}; 	; 	set basis jun-cc-pvdz. 	energy('sapt0-d3mbj') # runs the recommended dispersion correction; energy('sapt0-d3') # tests an alternative damping scheme/parameterization. Given the naturally pairwise-atomic nature of these empirical dispersion corrections,; integration with existing FSAPT functionality is also available simply by calling; ``energy(""fsapt0-d3mbj"")``. See :ref:`FSAPT <sec:fisapt>` documentation for more details on using FSAPT; for functional group analyses.; ",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:47301,Deployability,integrat,integration,47301," scaling the uncoupled term for; :math:`E_{exch-ind,resp}^{(30)}`. S^inf Keywords; ~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__do_ind_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_disp_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_ind30_exch_sinf.rst. .. _`sec:saptd`:. SAPT0-D; ~~~~~~~. In SAPT0, the computation of :math:`E_{disp}^{(20)} + E_{exch-disp}^{(20)}` represents; the computational bottleneck. One can avoid this bottleneck by replacing these; dispersion terms with the empirical D3 corrections developed by Grimme.; ; :ref:`Grimme's dispersion corrections are discussed here. <sec:dftd3>`. The corresponding method, termed SAPT0-D, thus relies on empirically fit parameters; specific to SAPT0/jun-cc-pVDZ. While SAPT0-D can be used with any of the -D ; variants using default parameters optimized for Hartee--Fock interaction energies, ; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]_. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters. ; A simple water dimer computation using SAPT0-D may look like::. 	molecule water_dimer {; 	 0 1; 	 O -1.551007 -0.114520 0.000000; 	 H -1.934259 0.762503 0.000000; 	 H -0.599677 0.040712 0.000000; 	 --; 	 0 1; 	 O 1.350625 0.111469 0.000000; 	 H 1.680398 -0.373741 -0.758561; 	 H 1.680398 -0.373741 0.758561; 	; 	 units angstrom; 	 no_reorient; 	 symmetry c1; 	}; 	; 	set basis jun-cc-pvdz. 	energy('sapt0-d3mbj') # runs the recommended dispersion correction; energy('sapt0-d3') # tests an alternative damping scheme/parameterization. Given the naturally pairwise-atomic nature of these empirical dispersion corrections,; integration with existing FSAPT functionality is also available simply by calling; ``energy(""fsapt0-d3mbj"")``. See :ref:`FSAPT <sec:fisapt>` documentation for more details on using FSAPT; for functional group analyses.; ",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:2355,Energy Efficiency,energy,energy,2355,"ectionauthor:: Edward G. Hohenstein and J\ |e_acute|\ r\ |o_circumflex|\ me F. Gonthier. *Module:* :ref:`Keywords <apdx:sapt>`, :ref:`PSI Variables <apdx:sapt_psivar>`, :source:`LIBSAPT_SOLVER <psi4/src/psi4/libsapt_solver>`. .. warning:: In rare cases with systems having a high degree of symmetry, ; |Psifour| gives (very obviously) wrong answers for SAPT computations ; when the specification is in Z-matrix format. Use a Cartesian representation ; to avoid this problem. .. caution:: In early versions (notably |Psifour| alpha circa 2011; and before), frozen core was implemented incompletely and for; only selected terms. Comparisons with papers published using early; |PSIfour| SAPT code may show discrepancies of 0.01-0.10 kcal/mol in; individual terms, particularly :math:`E_{exch}^{(11)}` and :math:`E_{exch}^{(12)}`. .. caution:: January 28th 2016, the default for all NAT_ORBS options; was changed to true. Hence the code now by default uses natural; orbital truncation to speed up the evaluation of energy terms; wherever possible, according to literature recommendations.; In early July 2016, some total SAPT energy psivars were renamed. .. caution:: February 7, 2020, a missing term in :math:`E^{(30)}_{ind}` was added, causing; possible discrepancies with prior versions of the code on the order of; 0.01 kcal/mol. See https://github.com/psi4/psi4/issues/1677. .. caution:: August 2021, the number of frozen core orbitals used in the dMP2 computations; is now standardized. Specifically, we now rigorously enforce that the number of core orbitals ; frozen in dimer computations is equal to the sum of frozen orbitals of each monomer. Prior to; this, a discrepency between these values was possible when one of the monomers was (exclusively) ; a charged alkali metal. . .. _`sec:saptfitA`:. .. caution:: May 2022 c. v1.6, the default for |sapt__df_basis_elst|; changed from the value of |sapt__df_basis_sapt| (which itself; defaults to the RI of the orbital basis) to the JKFIT of the or",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:2466,Energy Efficiency,energy,energy,2466,"dx:sapt>`, :ref:`PSI Variables <apdx:sapt_psivar>`, :source:`LIBSAPT_SOLVER <psi4/src/psi4/libsapt_solver>`. .. warning:: In rare cases with systems having a high degree of symmetry, ; |Psifour| gives (very obviously) wrong answers for SAPT computations ; when the specification is in Z-matrix format. Use a Cartesian representation ; to avoid this problem. .. caution:: In early versions (notably |Psifour| alpha circa 2011; and before), frozen core was implemented incompletely and for; only selected terms. Comparisons with papers published using early; |PSIfour| SAPT code may show discrepancies of 0.01-0.10 kcal/mol in; individual terms, particularly :math:`E_{exch}^{(11)}` and :math:`E_{exch}^{(12)}`. .. caution:: January 28th 2016, the default for all NAT_ORBS options; was changed to true. Hence the code now by default uses natural; orbital truncation to speed up the evaluation of energy terms; wherever possible, according to literature recommendations.; In early July 2016, some total SAPT energy psivars were renamed. .. caution:: February 7, 2020, a missing term in :math:`E^{(30)}_{ind}` was added, causing; possible discrepancies with prior versions of the code on the order of; 0.01 kcal/mol. See https://github.com/psi4/psi4/issues/1677. .. caution:: August 2021, the number of frozen core orbitals used in the dMP2 computations; is now standardized. Specifically, we now rigorously enforce that the number of core orbitals ; frozen in dimer computations is equal to the sum of frozen orbitals of each monomer. Prior to; this, a discrepency between these values was possible when one of the monomers was (exclusively) ; a charged alkali metal. . .. _`sec:saptfitA`:. .. caution:: May 2022 c. v1.6, the default for |sapt__df_basis_elst|; changed from the value of |sapt__df_basis_sapt| (which itself; defaults to the RI of the orbital basis) to the JKFIT of the orbital; basis. This affects SAPT0 and sSAPT0 computed with the :ref:`SAPT; module<sec:sapt>` (the default code for ``",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:3104,Energy Efficiency,charge,charged,3104,"es of 0.01-0.10 kcal/mol in; individual terms, particularly :math:`E_{exch}^{(11)}` and :math:`E_{exch}^{(12)}`. .. caution:: January 28th 2016, the default for all NAT_ORBS options; was changed to true. Hence the code now by default uses natural; orbital truncation to speed up the evaluation of energy terms; wherever possible, according to literature recommendations.; In early July 2016, some total SAPT energy psivars were renamed. .. caution:: February 7, 2020, a missing term in :math:`E^{(30)}_{ind}` was added, causing; possible discrepancies with prior versions of the code on the order of; 0.01 kcal/mol. See https://github.com/psi4/psi4/issues/1677. .. caution:: August 2021, the number of frozen core orbitals used in the dMP2 computations; is now standardized. Specifically, we now rigorously enforce that the number of core orbitals ; frozen in dimer computations is equal to the sum of frozen orbitals of each monomer. Prior to; this, a discrepency between these values was possible when one of the monomers was (exclusively) ; a charged alkali metal. . .. _`sec:saptfitA`:. .. caution:: May 2022 c. v1.6, the default for |sapt__df_basis_elst|; changed from the value of |sapt__df_basis_sapt| (which itself; defaults to the RI of the orbital basis) to the JKFIT of the orbital; basis. This affects SAPT0 and sSAPT0 computed with the :ref:`SAPT; module<sec:sapt>` (the default code for ``energy(""sapt0"")`` that; can also compute higher-order SAPT). Electostatics, exchange,; and induction terms for SAPT0 and sSAPT0 accessed through; ``energy(""sapt0"")`` or ``energy(""ssapt0"")`` change; the dispersion; term does not change. The SAPT0 and sSAPT0 terms accessed as; subsidiary calculations of higher-order SAPT do not change; that is,; the :ref:`SAPT module<sec:sapt>` breaks the consistency of its SAPT0; results. The reasoning and reward behind this change is that the JKFIT; basis better describes the physics (see :ref:`fitting changes <sec:saptfitB>` ) and the; default SAPT0 results",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:3461,Energy Efficiency,energy,energy,3461,"July 2016, some total SAPT energy psivars were renamed. .. caution:: February 7, 2020, a missing term in :math:`E^{(30)}_{ind}` was added, causing; possible discrepancies with prior versions of the code on the order of; 0.01 kcal/mol. See https://github.com/psi4/psi4/issues/1677. .. caution:: August 2021, the number of frozen core orbitals used in the dMP2 computations; is now standardized. Specifically, we now rigorously enforce that the number of core orbitals ; frozen in dimer computations is equal to the sum of frozen orbitals of each monomer. Prior to; this, a discrepency between these values was possible when one of the monomers was (exclusively) ; a charged alkali metal. . .. _`sec:saptfitA`:. .. caution:: May 2022 c. v1.6, the default for |sapt__df_basis_elst|; changed from the value of |sapt__df_basis_sapt| (which itself; defaults to the RI of the orbital basis) to the JKFIT of the orbital; basis. This affects SAPT0 and sSAPT0 computed with the :ref:`SAPT; module<sec:sapt>` (the default code for ``energy(""sapt0"")`` that; can also compute higher-order SAPT). Electostatics, exchange,; and induction terms for SAPT0 and sSAPT0 accessed through; ``energy(""sapt0"")`` or ``energy(""ssapt0"")`` change; the dispersion; term does not change. The SAPT0 and sSAPT0 terms accessed as; subsidiary calculations of higher-order SAPT do not change; that is,; the :ref:`SAPT module<sec:sapt>` breaks the consistency of its SAPT0; results. The reasoning and reward behind this change is that the JKFIT; basis better describes the physics (see :ref:`fitting changes <sec:saptfitB>` ) and the; default SAPT0 results from the :ref:`SAPT module<sec:sapt>` are now; consistent with those from the :ref:`FISAPT module<sec:fisapt>` and; the sapt(dft) module. See :srcsample:`sapt-compare` for an example.; To reproduce former behavior, set |sapt__df_basis_elst| to the; orbital basis set's RI auxiliary basis. Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the non",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:3609,Energy Efficiency,energy,energy,3609,"s with prior versions of the code on the order of; 0.01 kcal/mol. See https://github.com/psi4/psi4/issues/1677. .. caution:: August 2021, the number of frozen core orbitals used in the dMP2 computations; is now standardized. Specifically, we now rigorously enforce that the number of core orbitals ; frozen in dimer computations is equal to the sum of frozen orbitals of each monomer. Prior to; this, a discrepency between these values was possible when one of the monomers was (exclusively) ; a charged alkali metal. . .. _`sec:saptfitA`:. .. caution:: May 2022 c. v1.6, the default for |sapt__df_basis_elst|; changed from the value of |sapt__df_basis_sapt| (which itself; defaults to the RI of the orbital basis) to the JKFIT of the orbital; basis. This affects SAPT0 and sSAPT0 computed with the :ref:`SAPT; module<sec:sapt>` (the default code for ``energy(""sapt0"")`` that; can also compute higher-order SAPT). Electostatics, exchange,; and induction terms for SAPT0 and sSAPT0 accessed through; ``energy(""sapt0"")`` or ``energy(""ssapt0"")`` change; the dispersion; term does not change. The SAPT0 and sSAPT0 terms accessed as; subsidiary calculations of higher-order SAPT do not change; that is,; the :ref:`SAPT module<sec:sapt>` breaks the consistency of its SAPT0; results. The reasoning and reward behind this change is that the JKFIT; basis better describes the physics (see :ref:`fitting changes <sec:saptfitB>` ) and the; default SAPT0 results from the :ref:`SAPT module<sec:sapt>` are now; consistent with those from the :ref:`FISAPT module<sec:fisapt>` and; the sapt(dft) module. See :srcsample:`sapt-compare` for an example.; To reproduce former behavior, set |sapt__df_basis_elst| to the; orbital basis set's RI auxiliary basis. Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAP",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:3632,Energy Efficiency,energy,energy,3632,"s with prior versions of the code on the order of; 0.01 kcal/mol. See https://github.com/psi4/psi4/issues/1677. .. caution:: August 2021, the number of frozen core orbitals used in the dMP2 computations; is now standardized. Specifically, we now rigorously enforce that the number of core orbitals ; frozen in dimer computations is equal to the sum of frozen orbitals of each monomer. Prior to; this, a discrepency between these values was possible when one of the monomers was (exclusively) ; a charged alkali metal. . .. _`sec:saptfitA`:. .. caution:: May 2022 c. v1.6, the default for |sapt__df_basis_elst|; changed from the value of |sapt__df_basis_sapt| (which itself; defaults to the RI of the orbital basis) to the JKFIT of the orbital; basis. This affects SAPT0 and sSAPT0 computed with the :ref:`SAPT; module<sec:sapt>` (the default code for ``energy(""sapt0"")`` that; can also compute higher-order SAPT). Electostatics, exchange,; and induction terms for SAPT0 and sSAPT0 accessed through; ``energy(""sapt0"")`` or ``energy(""ssapt0"")`` change; the dispersion; term does not change. The SAPT0 and sSAPT0 terms accessed as; subsidiary calculations of higher-order SAPT do not change; that is,; the :ref:`SAPT module<sec:sapt>` breaks the consistency of its SAPT0; results. The reasoning and reward behind this change is that the JKFIT; basis better describes the physics (see :ref:`fitting changes <sec:saptfitB>` ) and the; default SAPT0 results from the :ref:`SAPT module<sec:sapt>` are now; consistent with those from the :ref:`FISAPT module<sec:fisapt>` and; the sapt(dft) module. See :srcsample:`sapt-compare` for an example.; To reproduce former behavior, set |sapt__df_basis_elst| to the; orbital basis set's RI auxiliary basis. Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAP",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:4358,Energy Efficiency,adapt,adapted,4358,"apt0"")`` that; can also compute higher-order SAPT). Electostatics, exchange,; and induction terms for SAPT0 and sSAPT0 accessed through; ``energy(""sapt0"")`` or ``energy(""ssapt0"")`` change; the dispersion; term does not change. The SAPT0 and sSAPT0 terms accessed as; subsidiary calculations of higher-order SAPT do not change; that is,; the :ref:`SAPT module<sec:sapt>` breaks the consistency of its SAPT0; results. The reasoning and reward behind this change is that the JKFIT; basis better describes the physics (see :ref:`fitting changes <sec:saptfitB>` ) and the; default SAPT0 results from the :ref:`SAPT module<sec:sapt>` are now; consistent with those from the :ref:`FISAPT module<sec:fisapt>` and; the sapt(dft) module. See :srcsample:`sapt-compare` for an example.; To reproduce former behavior, set |sapt__df_basis_elst| to the; orbital basis set's RI auxiliary basis. Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: *i.e.*,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the ; Hamiltonian of the dimer is partitioned into contributions from each ; monomer and the interaction. .. math:: H=F_A+W_A+F_B+W_B+V. Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, :math:`F`, the fluctuation potential of each monomer, :math:`W`, and the; interaction potential, :math:`V`. The monomer Fock operators, :math:`F_A+F_B`, are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of :math:`V`, :math:`W_A`, and :math:`W_B`. ; Through first-order in :math:`V`, electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in :math:`V`. ",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:4510,Energy Efficiency,energy,energy,4510,"apt0"")`` that; can also compute higher-order SAPT). Electostatics, exchange,; and induction terms for SAPT0 and sSAPT0 accessed through; ``energy(""sapt0"")`` or ``energy(""ssapt0"")`` change; the dispersion; term does not change. The SAPT0 and sSAPT0 terms accessed as; subsidiary calculations of higher-order SAPT do not change; that is,; the :ref:`SAPT module<sec:sapt>` breaks the consistency of its SAPT0; results. The reasoning and reward behind this change is that the JKFIT; basis better describes the physics (see :ref:`fitting changes <sec:saptfitB>` ) and the; default SAPT0 results from the :ref:`SAPT module<sec:sapt>` are now; consistent with those from the :ref:`FISAPT module<sec:fisapt>` and; the sapt(dft) module. See :srcsample:`sapt-compare` for an example.; To reproduce former behavior, set |sapt__df_basis_elst| to the; orbital basis set's RI auxiliary basis. Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: *i.e.*,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the ; Hamiltonian of the dimer is partitioned into contributions from each ; monomer and the interaction. .. math:: H=F_A+W_A+F_B+W_B+V. Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, :math:`F`, the fluctuation potential of each monomer, :math:`W`, and the; interaction potential, :math:`V`. The monomer Fock operators, :math:`F_A+F_B`, are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of :math:`V`, :math:`W_A`, and :math:`W_B`. ; Through first-order in :math:`V`, electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in :math:`V`. ",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:4559,Energy Efficiency,energy,energy,4559,"apt0"")`` that; can also compute higher-order SAPT). Electostatics, exchange,; and induction terms for SAPT0 and sSAPT0 accessed through; ``energy(""sapt0"")`` or ``energy(""ssapt0"")`` change; the dispersion; term does not change. The SAPT0 and sSAPT0 terms accessed as; subsidiary calculations of higher-order SAPT do not change; that is,; the :ref:`SAPT module<sec:sapt>` breaks the consistency of its SAPT0; results. The reasoning and reward behind this change is that the JKFIT; basis better describes the physics (see :ref:`fitting changes <sec:saptfitB>` ) and the; default SAPT0 results from the :ref:`SAPT module<sec:sapt>` are now; consistent with those from the :ref:`FISAPT module<sec:fisapt>` and; the sapt(dft) module. See :srcsample:`sapt-compare` for an example.; To reproduce former behavior, set |sapt__df_basis_elst| to the; orbital basis set's RI auxiliary basis. Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: *i.e.*,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the ; Hamiltonian of the dimer is partitioned into contributions from each ; monomer and the interaction. .. math:: H=F_A+W_A+F_B+W_B+V. Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, :math:`F`, the fluctuation potential of each monomer, :math:`W`, and the; interaction potential, :math:`V`. The monomer Fock operators, :math:`F_A+F_B`, are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of :math:`V`, :math:`W_A`, and :math:`W_B`. ; Through first-order in :math:`V`, electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in :math:`V`. ",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:4656,Energy Efficiency,energy,energy,4656,"`` change; the dispersion; term does not change. The SAPT0 and sSAPT0 terms accessed as; subsidiary calculations of higher-order SAPT do not change; that is,; the :ref:`SAPT module<sec:sapt>` breaks the consistency of its SAPT0; results. The reasoning and reward behind this change is that the JKFIT; basis better describes the physics (see :ref:`fitting changes <sec:saptfitB>` ) and the; default SAPT0 results from the :ref:`SAPT module<sec:sapt>` are now; consistent with those from the :ref:`FISAPT module<sec:fisapt>` and; the sapt(dft) module. See :srcsample:`sapt-compare` for an example.; To reproduce former behavior, set |sapt__df_basis_elst| to the; orbital basis set's RI auxiliary basis. Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: *i.e.*,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the ; Hamiltonian of the dimer is partitioned into contributions from each ; monomer and the interaction. .. math:: H=F_A+W_A+F_B+W_B+V. Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, :math:`F`, the fluctuation potential of each monomer, :math:`W`, and the; interaction potential, :math:`V`. The monomer Fock operators, :math:`F_A+F_B`, are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of :math:`V`, :math:`W_A`, and :math:`W_B`. ; Through first-order in :math:`V`, electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in :math:`V`. For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887]_. Several truncations of the clos",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:5213,Energy Efficiency,energy,energy,5213,"sample:`sapt-compare` for an example.; To reproduce former behavior, set |sapt__df_basis_elst| to the; orbital basis set's RI auxiliary basis. Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: *i.e.*,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the ; Hamiltonian of the dimer is partitioned into contributions from each ; monomer and the interaction. .. math:: H=F_A+W_A+F_B+W_B+V. Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, :math:`F`, the fluctuation potential of each monomer, :math:`W`, and the; interaction potential, :math:`V`. The monomer Fock operators, :math:`F_A+F_B`, are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of :math:`V`, :math:`W_A`, and :math:`W_B`. ; Through first-order in :math:`V`, electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in :math:`V`. For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887]_. Several truncations of the closed-shell SAPT expansion are available in the SAPT; module of |PSIfour|. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. :eq:`SAPT0`. .. math:: E_{SAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + E_{exch-disp}^{(20)} + \delta_{HF}^{(2)}; :label: SAPT0. In this notation, :math:`E^{(vw)}` defines the order in :math:`V` and in :math:`W_A+W_B`; the; subscript, :math:`resp`, indicates that orbital relaxation effects are included. .. math:: E_{SAPT2} = E_{SAPT0} + E_{elst,re",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:7077,Energy Efficiency,energy,energy,7077," :math:`V` and in :math:`W_A+W_B`; the; subscript, :math:`resp`, indicates that orbital relaxation effects are included. .. math:: E_{SAPT2} = E_{SAPT0} + E_{elst,resp}^{(12)} + E_{exch}^{(11)} +; E_{exch}^{(12)} + \; ^{t}\!E_{ind}^{(22)} + \; ^{t}\!E_{exch-ind}^{(22)}; :label: SAPT2. .. math:: E_{SAPT2+} = E_{SAPT2} + E_{disp}^{(21)} + E_{disp}^{(22)}; :label: SAPT2p. .. math:: E_{SAPT2+(3)} = E_{SAPT2+} + E_{elst,resp}^{(13)} + E_{disp}^{(30)}; :label: SAPT2pparen3. .. math:: E_{SAPT2+3} = E_{SAPT2+(3)}; + E_{exch-ind}^{(30)} + E_{ind,resp}^{(30)}; + E_{exch-disp}^{(30)} + E_{ind-disp}^{(30)} + E_{exch-ind-disp}^{(30)}; - \delta_{HF}^{(2)} + \delta_{HF}^{(3)}; :label: SAPT2p3. For SAPT(DFT), the SAPT expansion is truncated at the same level of SAPT0, but the zeroth-order Hamiltonian is chosen to be :math:`K_A+K_B`, the monomer Kohn-Sham operators, instead of the Fock operators. The dispersion term needs to be computed with orbital relaxation for the result to be reasonable, and this is possible by computing dispersion energy through coupled frequency-dependent density susceptibility (FDDS). The exchange-dispersion term is estimated by scaling the uncoupled exchange-dispersion energy. . .. math:: E_{SAPT(DFT)} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; E_{exch-ind,resp}^{(20)} + E_{disp,resp}^{(20)} + E_{exch-disp,resp}^{(20)}(est.) + \delta_{HF}^{(2)}; :label: SAPTDFT; .. math:: E_{disp,resp}^{(20)} = -\frac{1}{2\pi}\int_0^\infty d\omega \int d\mathbf{r}_A d\mathbf{r}'_A d\mathbf{r}_B d\mathbf{r}'_B \frac{1}{\left|\mathbf{r}_A-\mathbf{r}_B\right|}\frac{1}{\left|\mathbf{r}'_A-\mathbf{r}'_B\right|}\chi^A_{coup}\left(\mathbf{r}_A,\mathbf{r}'_A|i\omega\right)\chi^B_{coup}\left(\mathbf{r}_B,\mathbf{r}'_B|i\omega\right). .. math:: \chi_{coup}\left(\mathbf{r},\mathbf{r}'|\omega\right) = \chi_0\left(\mathbf{r},\mathbf{r}'|\omega\right) + \int d\omega d\mathbf{r}_1 d\mathbf{r}_2 \chi_0\left(\mathbf{r},\mathbf{r}_1|\omega\right)\left[\frac{1}{r_{12}} + f_{x",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:7238,Energy Efficiency,energy,energy,7238,"_{elst,resp}^{(12)} + E_{exch}^{(11)} +; E_{exch}^{(12)} + \; ^{t}\!E_{ind}^{(22)} + \; ^{t}\!E_{exch-ind}^{(22)}; :label: SAPT2. .. math:: E_{SAPT2+} = E_{SAPT2} + E_{disp}^{(21)} + E_{disp}^{(22)}; :label: SAPT2p. .. math:: E_{SAPT2+(3)} = E_{SAPT2+} + E_{elst,resp}^{(13)} + E_{disp}^{(30)}; :label: SAPT2pparen3. .. math:: E_{SAPT2+3} = E_{SAPT2+(3)}; + E_{exch-ind}^{(30)} + E_{ind,resp}^{(30)}; + E_{exch-disp}^{(30)} + E_{ind-disp}^{(30)} + E_{exch-ind-disp}^{(30)}; - \delta_{HF}^{(2)} + \delta_{HF}^{(3)}; :label: SAPT2p3. For SAPT(DFT), the SAPT expansion is truncated at the same level of SAPT0, but the zeroth-order Hamiltonian is chosen to be :math:`K_A+K_B`, the monomer Kohn-Sham operators, instead of the Fock operators. The dispersion term needs to be computed with orbital relaxation for the result to be reasonable, and this is possible by computing dispersion energy through coupled frequency-dependent density susceptibility (FDDS). The exchange-dispersion term is estimated by scaling the uncoupled exchange-dispersion energy. . .. math:: E_{SAPT(DFT)} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; E_{exch-ind,resp}^{(20)} + E_{disp,resp}^{(20)} + E_{exch-disp,resp}^{(20)}(est.) + \delta_{HF}^{(2)}; :label: SAPTDFT; .. math:: E_{disp,resp}^{(20)} = -\frac{1}{2\pi}\int_0^\infty d\omega \int d\mathbf{r}_A d\mathbf{r}'_A d\mathbf{r}_B d\mathbf{r}'_B \frac{1}{\left|\mathbf{r}_A-\mathbf{r}_B\right|}\frac{1}{\left|\mathbf{r}'_A-\mathbf{r}'_B\right|}\chi^A_{coup}\left(\mathbf{r}_A,\mathbf{r}'_A|i\omega\right)\chi^B_{coup}\left(\mathbf{r}_B,\mathbf{r}'_B|i\omega\right). .. math:: \chi_{coup}\left(\mathbf{r},\mathbf{r}'|\omega\right) = \chi_0\left(\mathbf{r},\mathbf{r}'|\omega\right) + \int d\omega d\mathbf{r}_1 d\mathbf{r}_2 \chi_0\left(\mathbf{r},\mathbf{r}_1|\omega\right)\left[\frac{1}{r_{12}} + f_{xc}\left(\mathbf{r}_1,\mathbf{r}_2,\omega\right)\right]\chi\left(\mathbf{r}_2,\mathbf{r}'|\omega\right). The :math:`\delta_{HF}^{(2)}` and :math:`\delta_{HF}",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:8381,Energy Efficiency,energy,energy,8381,")}; :label: SAPTDFT; .. math:: E_{disp,resp}^{(20)} = -\frac{1}{2\pi}\int_0^\infty d\omega \int d\mathbf{r}_A d\mathbf{r}'_A d\mathbf{r}_B d\mathbf{r}'_B \frac{1}{\left|\mathbf{r}_A-\mathbf{r}_B\right|}\frac{1}{\left|\mathbf{r}'_A-\mathbf{r}'_B\right|}\chi^A_{coup}\left(\mathbf{r}_A,\mathbf{r}'_A|i\omega\right)\chi^B_{coup}\left(\mathbf{r}_B,\mathbf{r}'_B|i\omega\right). .. math:: \chi_{coup}\left(\mathbf{r},\mathbf{r}'|\omega\right) = \chi_0\left(\mathbf{r},\mathbf{r}'|\omega\right) + \int d\omega d\mathbf{r}_1 d\mathbf{r}_2 \chi_0\left(\mathbf{r},\mathbf{r}_1|\omega\right)\left[\frac{1}{r_{12}} + f_{xc}\left(\mathbf{r}_1,\mathbf{r}_2,\omega\right)\right]\chi\left(\mathbf{r}_2,\mathbf{r}'|\omega\right). The :math:`\delta_{HF}^{(2)}` and :math:`\delta_{HF}^{(3)}` terms take into; account higher-order induction effects and are included in the definition; of SAPT terms. They are computed from the Hartree--Fock supermolecular interaction energy; :math:`E_{int}^{HF}` and are only available in dimer-centered basis SAPT; computations, which is the default (see below for monomer-centered basis ; computations). They are defined by:. .. math:: \delta_{HF}^{(2)} = E_{int}^{HF} - (E_{elst}^{(10)} + E_{exch}^{(10)} ; + E_{ind,resp}^{(20)} + E_{exch-ind,resp}^{(20)}); :label: dHF2. .. math:: \delta_{HF}^{(3)} = \delta_{HF}^{(2)} - (E_{exch-ind}^{(30)} ; + E_{ind,resp}^{(30)}); :label: dHF3. Additionally, high-order coupling between induction and dispersion can be ; extracted from the supermolecular MP2 interaction energy:. .. math:: \delta_{MP2}^{(2)} = E_{int}^{MP2, corr} - (E_{elst}^{(12)} +; E_{exch}^{(11)} + E_{exch}^{(12)} + \; ^{t}\!E_{ind}^{(22)}; + \; ^{t}\!E_{exch-ind}^{(22)} + E_{disp}^{(20)} + E_{exch-disp}^{(20)}). .. math:: \delta_{MP2}^{(3)} = \delta_{MP2}^{(2)} - (E_{ind-disp}^{(30)} + E_{exch-ind-disp}^{(30)}). where :math:`E_{int}^{MP2, corr}` is the correlation part of the supermolecular MP2 ; interaction energy. :math:`\delta_{MP2}^{(2)}` and :math:`\delta_{MP",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:8959,Energy Efficiency,energy,energy,8959,"hbf{r}'|\omega\right) + \int d\omega d\mathbf{r}_1 d\mathbf{r}_2 \chi_0\left(\mathbf{r},\mathbf{r}_1|\omega\right)\left[\frac{1}{r_{12}} + f_{xc}\left(\mathbf{r}_1,\mathbf{r}_2,\omega\right)\right]\chi\left(\mathbf{r}_2,\mathbf{r}'|\omega\right). The :math:`\delta_{HF}^{(2)}` and :math:`\delta_{HF}^{(3)}` terms take into; account higher-order induction effects and are included in the definition; of SAPT terms. They are computed from the Hartree--Fock supermolecular interaction energy; :math:`E_{int}^{HF}` and are only available in dimer-centered basis SAPT; computations, which is the default (see below for monomer-centered basis ; computations). They are defined by:. .. math:: \delta_{HF}^{(2)} = E_{int}^{HF} - (E_{elst}^{(10)} + E_{exch}^{(10)} ; + E_{ind,resp}^{(20)} + E_{exch-ind,resp}^{(20)}); :label: dHF2. .. math:: \delta_{HF}^{(3)} = \delta_{HF}^{(2)} - (E_{exch-ind}^{(30)} ; + E_{ind,resp}^{(30)}); :label: dHF3. Additionally, high-order coupling between induction and dispersion can be ; extracted from the supermolecular MP2 interaction energy:. .. math:: \delta_{MP2}^{(2)} = E_{int}^{MP2, corr} - (E_{elst}^{(12)} +; E_{exch}^{(11)} + E_{exch}^{(12)} + \; ^{t}\!E_{ind}^{(22)}; + \; ^{t}\!E_{exch-ind}^{(22)} + E_{disp}^{(20)} + E_{exch-disp}^{(20)}). .. math:: \delta_{MP2}^{(3)} = \delta_{MP2}^{(2)} - (E_{ind-disp}^{(30)} + E_{exch-ind-disp}^{(30)}). where :math:`E_{int}^{MP2, corr}` is the correlation part of the supermolecular MP2 ; interaction energy. :math:`\delta_{MP2}^{(2)}` and :math:`\delta_{MP2}^{(3)}` also improve the ; description of electrostatically dominated complexes. :math:`\delta_{MP2}^{(2)}`; can be applied to SAPT2+ or SAPT2+(3) energies whereas :math:`\delta_{MP2}^{(3)}` ; should be applied to SAPT2+3 energies. A thorough analysis of the performance of these truncations of closed-shell SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs]_,; and a systematic study of the accuracy of these truncations (with and ; w",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:9376,Energy Efficiency,energy,energy,9376," from the Hartree--Fock supermolecular interaction energy; :math:`E_{int}^{HF}` and are only available in dimer-centered basis SAPT; computations, which is the default (see below for monomer-centered basis ; computations). They are defined by:. .. math:: \delta_{HF}^{(2)} = E_{int}^{HF} - (E_{elst}^{(10)} + E_{exch}^{(10)} ; + E_{ind,resp}^{(20)} + E_{exch-ind,resp}^{(20)}); :label: dHF2. .. math:: \delta_{HF}^{(3)} = \delta_{HF}^{(2)} - (E_{exch-ind}^{(30)} ; + E_{ind,resp}^{(30)}); :label: dHF3. Additionally, high-order coupling between induction and dispersion can be ; extracted from the supermolecular MP2 interaction energy:. .. math:: \delta_{MP2}^{(2)} = E_{int}^{MP2, corr} - (E_{elst}^{(12)} +; E_{exch}^{(11)} + E_{exch}^{(12)} + \; ^{t}\!E_{ind}^{(22)}; + \; ^{t}\!E_{exch-ind}^{(22)} + E_{disp}^{(20)} + E_{exch-disp}^{(20)}). .. math:: \delta_{MP2}^{(3)} = \delta_{MP2}^{(2)} - (E_{ind-disp}^{(30)} + E_{exch-ind-disp}^{(30)}). where :math:`E_{int}^{MP2, corr}` is the correlation part of the supermolecular MP2 ; interaction energy. :math:`\delta_{MP2}^{(2)}` and :math:`\delta_{MP2}^{(3)}` also improve the ; description of electrostatically dominated complexes. :math:`\delta_{MP2}^{(2)}`; can be applied to SAPT2+ or SAPT2+(3) energies whereas :math:`\delta_{MP2}^{(3)}` ; should be applied to SAPT2+3 energies. A thorough analysis of the performance of these truncations of closed-shell SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs]_,; and a systematic study of the accuracy of these truncations (with and ; without an improved CCD treatment of dispersion) using different basis sets; is reported in [Parker:2014:094106]_. The closed-shell SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in |PSIfour|, assumes the use of density-fitted; two-electron integrals, therefore, the closed-shell SAPT module cannot be run with; exa",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:10158,Energy Efficiency,energy,energy,10158,"-disp}^{(30)} + E_{exch-ind-disp}^{(30)}). where :math:`E_{int}^{MP2, corr}` is the correlation part of the supermolecular MP2 ; interaction energy. :math:`\delta_{MP2}^{(2)}` and :math:`\delta_{MP2}^{(3)}` also improve the ; description of electrostatically dominated complexes. :math:`\delta_{MP2}^{(2)}`; can be applied to SAPT2+ or SAPT2+(3) energies whereas :math:`\delta_{MP2}^{(3)}` ; should be applied to SAPT2+3 energies. A thorough analysis of the performance of these truncations of closed-shell SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs]_,; and a systematic study of the accuracy of these truncations (with and ; without an improved CCD treatment of dispersion) using different basis sets; is reported in [Parker:2014:094106]_. The closed-shell SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in |PSIfour|, assumes the use of density-fitted; two-electron integrals, therefore, the closed-shell SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligible errors into the SAPT energy ; (often less than 0.01 kcal/mol for small dimers) and greatly; improves efficiency. . The latest addition to the SAPT code is the SAPT0 method for open-shell ; monomers [Gonthier:2016:134106]_. This code is available for both exact and density fitted integrals, ; except for the dispersion terms which implementation relies on a density fitting; factorization. Both ``UHF`` and ``ROHF`` |scf__reference| can be used, but coupled; induction computations are currently not supported with ``ROHF``. This means that orbital; relaxation is not included for ``ROHF`` and the uncoupled induction term is computed instead.; If both monomers are open-shell, their coupling is assumed to be high spin, i.e.; two doublets would interact to form a triplet. The *S*\ :superscript:`2` ap",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:10454,Energy Efficiency,energy,energy,10454,"nd :math:`\delta_{MP2}^{(3)}` also improve the ; description of electrostatically dominated complexes. :math:`\delta_{MP2}^{(2)}`; can be applied to SAPT2+ or SAPT2+(3) energies whereas :math:`\delta_{MP2}^{(3)}` ; should be applied to SAPT2+3 energies. A thorough analysis of the performance of these truncations of closed-shell SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs]_,; and a systematic study of the accuracy of these truncations (with and ; without an improved CCD treatment of dispersion) using different basis sets; is reported in [Parker:2014:094106]_. The closed-shell SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in |PSIfour|, assumes the use of density-fitted; two-electron integrals, therefore, the closed-shell SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligible errors into the SAPT energy ; (often less than 0.01 kcal/mol for small dimers) and greatly; improves efficiency. . The latest addition to the SAPT code is the SAPT0 method for open-shell ; monomers [Gonthier:2016:134106]_. This code is available for both exact and density fitted integrals, ; except for the dispersion terms which implementation relies on a density fitting; factorization. Both ``UHF`` and ``ROHF`` |scf__reference| can be used, but coupled; induction computations are currently not supported with ``ROHF``. This means that orbital; relaxation is not included for ``ROHF`` and the uncoupled induction term is computed instead.; If both monomers are open-shell, their coupling is assumed to be high spin, i.e.; two doublets would interact to form a triplet. The *S*\ :superscript:`2` approximation and scaling; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. All exchange terms in SAPT arise from the antisymmetrization; of the wavefunctions of monomers A and",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:13259,Energy Efficiency,energy,energy,13259,"xch_scale_alpha true``. Alternatively, another value for :math:`\alpha`; can be specified by setting |sapt__exch_scale_alpha| to a value. For example, ::. set exch_scale_alpha 1.0. will set :math:`\alpha = 1.0` and scale exchange energies with :math:`p_{EX}(1.0)`. However, as pointed out by Schaffer and Jansen [Schaffer:2013:2570]_; in the context of DFT-based SAPT, the ratios :math:`E_{exch}^{(1)}(S^{2})/E_{exch}^{(1)}`,; :math:`E_{\rm exch-ind}^{(2)}(S^2)/E_{\rm exch-ind}^{(2)}`, and ; :math:`E_{\rm exch-disp}^{(2)}(S^2)/E_{\rm exch-disp}^{(2)}` are not very similar to; each other. Hence, in 2016 universal scaling of all :math:`S^{2}` approximated terms; was turned off by default. Finally, in 2014 Parker et al. [Parker:2014:094106]_ empirically discovered that ; SAPT0 energies for van der Waals dimers with close contacts benefit from a slightly modified ; recipe that involves an empirically adjusted exponent :math:`\alpha = 3.0`. ; To distinguish it from its unscaled counterpart, this energy is denoted sSAPT0 (see [Parker:2014:094106]_). .. math:: E_{sSAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; p_{EX}(3.0) E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + p_{EX}(3.0) E_{exch-disp}^{(20)} ; + \delta_{HF}^{(2)}; :label: sSAPT0. where :math:`\delta_{HF}^{(2)}` is computed *without* any scaling. Please note that ; sSAPT0 is thus not the same as requesting ``exch_scale_alpha 3.0``, and that the; scaling is automatically performed by requesting ``energy('ssapt0')``. A First Example; ^^^^^^^^^^^^^^^. The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods,; not all of them). ::. 	molecule water_dimer {; 	 0 1; 	 O -1.551007 -0.114520 0.000000; 	 H -1.934259 0.762503 0.000000; 	 H -0.599677 0.040712 0.000000; 	 --; 	 0 1; 	 O 1.350625 0.111469 0.000000; 	 H 1.680398 -0.373741 -0.758561; 	 H 1.680398 -0.373741 0.758561; 	; 	 units angstrom; 	 no_reorient; 	 symmetry c1",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:13743,Energy Efficiency,energy,energy,13743,")/E_{\rm exch-ind}^{(2)}`, and ; :math:`E_{\rm exch-disp}^{(2)}(S^2)/E_{\rm exch-disp}^{(2)}` are not very similar to; each other. Hence, in 2016 universal scaling of all :math:`S^{2}` approximated terms; was turned off by default. Finally, in 2014 Parker et al. [Parker:2014:094106]_ empirically discovered that ; SAPT0 energies for van der Waals dimers with close contacts benefit from a slightly modified ; recipe that involves an empirically adjusted exponent :math:`\alpha = 3.0`. ; To distinguish it from its unscaled counterpart, this energy is denoted sSAPT0 (see [Parker:2014:094106]_). .. math:: E_{sSAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; p_{EX}(3.0) E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + p_{EX}(3.0) E_{exch-disp}^{(20)} ; + \delta_{HF}^{(2)}; :label: sSAPT0. where :math:`\delta_{HF}^{(2)}` is computed *without* any scaling. Please note that ; sSAPT0 is thus not the same as requesting ``exch_scale_alpha 3.0``, and that the; scaling is automatically performed by requesting ``energy('ssapt0')``. A First Example; ^^^^^^^^^^^^^^^. The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods,; not all of them). ::. 	molecule water_dimer {; 	 0 1; 	 O -1.551007 -0.114520 0.000000; 	 H -1.934259 0.762503 0.000000; 	 H -0.599677 0.040712 0.000000; 	 --; 	 0 1; 	 O 1.350625 0.111469 0.000000; 	 H 1.680398 -0.373741 -0.758561; 	 H 1.680398 -0.373741 0.758561; 	; 	 units angstrom; 	 no_reorient; 	 symmetry c1; 	}; 	; 	set basis aug-cc-pvdz; 	; 	energy('sapt0'); 	energy('sapt2'); 	energy('sapt2+'); 	energy('sapt2+(3)'); 	energy('sapt2+3'). The SAPT module uses the standard |PSIfour| partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with ",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:14294,Energy Efficiency,energy,energy,14294,"er:2014:094106]_). .. math:: E_{sSAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; p_{EX}(3.0) E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + p_{EX}(3.0) E_{exch-disp}^{(20)} ; + \delta_{HF}^{(2)}; :label: sSAPT0. where :math:`\delta_{HF}^{(2)}` is computed *without* any scaling. Please note that ; sSAPT0 is thus not the same as requesting ``exch_scale_alpha 3.0``, and that the; scaling is automatically performed by requesting ``energy('ssapt0')``. A First Example; ^^^^^^^^^^^^^^^. The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods,; not all of them). ::. 	molecule water_dimer {; 	 0 1; 	 O -1.551007 -0.114520 0.000000; 	 H -1.934259 0.762503 0.000000; 	 H -0.599677 0.040712 0.000000; 	 --; 	 0 1; 	 O 1.350625 0.111469 0.000000; 	 H 1.680398 -0.373741 -0.758561; 	 H 1.680398 -0.373741 0.758561; 	; 	 units angstrom; 	 no_reorient; 	 symmetry c1; 	}; 	; 	set basis aug-cc-pvdz; 	; 	energy('sapt0'); 	energy('sapt2'); 	energy('sapt2+'); 	energy('sapt2+(3)'); 	energy('sapt2+3'). The SAPT module uses the standard |PSIfour| partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the ``no_reorient`` and ``symmetry; c1`` molecule keywords, as in the example above. As a reminder, only; SAPT0 can handle the interaction of both closed- and open-shell monomers.; Higher-order SAPT and SAPT(DFT) are currently available only ; for computation of interactions between; closed-shell singlets. The SAPT codes in |PSIfour| have been written; to utilize density fitting, which is much faster than using conventional; 4-index electron repulsion integrals. This happens automatically and; does not require any additional keywords to be specified (both the ; SAPT comp",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:14312,Energy Efficiency,energy,energy,14312,"er:2014:094106]_). .. math:: E_{sSAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; p_{EX}(3.0) E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + p_{EX}(3.0) E_{exch-disp}^{(20)} ; + \delta_{HF}^{(2)}; :label: sSAPT0. where :math:`\delta_{HF}^{(2)}` is computed *without* any scaling. Please note that ; sSAPT0 is thus not the same as requesting ``exch_scale_alpha 3.0``, and that the; scaling is automatically performed by requesting ``energy('ssapt0')``. A First Example; ^^^^^^^^^^^^^^^. The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods,; not all of them). ::. 	molecule water_dimer {; 	 0 1; 	 O -1.551007 -0.114520 0.000000; 	 H -1.934259 0.762503 0.000000; 	 H -0.599677 0.040712 0.000000; 	 --; 	 0 1; 	 O 1.350625 0.111469 0.000000; 	 H 1.680398 -0.373741 -0.758561; 	 H 1.680398 -0.373741 0.758561; 	; 	 units angstrom; 	 no_reorient; 	 symmetry c1; 	}; 	; 	set basis aug-cc-pvdz; 	; 	energy('sapt0'); 	energy('sapt2'); 	energy('sapt2+'); 	energy('sapt2+(3)'); 	energy('sapt2+3'). The SAPT module uses the standard |PSIfour| partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the ``no_reorient`` and ``symmetry; c1`` molecule keywords, as in the example above. As a reminder, only; SAPT0 can handle the interaction of both closed- and open-shell monomers.; Higher-order SAPT and SAPT(DFT) are currently available only ; for computation of interactions between; closed-shell singlets. The SAPT codes in |PSIfour| have been written; to utilize density fitting, which is much faster than using conventional; 4-index electron repulsion integrals. This happens automatically and; does not require any additional keywords to be specified (both the ; SAPT comp",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:14330,Energy Efficiency,energy,energy,14330,"er:2014:094106]_). .. math:: E_{sSAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; p_{EX}(3.0) E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + p_{EX}(3.0) E_{exch-disp}^{(20)} ; + \delta_{HF}^{(2)}; :label: sSAPT0. where :math:`\delta_{HF}^{(2)}` is computed *without* any scaling. Please note that ; sSAPT0 is thus not the same as requesting ``exch_scale_alpha 3.0``, and that the; scaling is automatically performed by requesting ``energy('ssapt0')``. A First Example; ^^^^^^^^^^^^^^^. The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods,; not all of them). ::. 	molecule water_dimer {; 	 0 1; 	 O -1.551007 -0.114520 0.000000; 	 H -1.934259 0.762503 0.000000; 	 H -0.599677 0.040712 0.000000; 	 --; 	 0 1; 	 O 1.350625 0.111469 0.000000; 	 H 1.680398 -0.373741 -0.758561; 	 H 1.680398 -0.373741 0.758561; 	; 	 units angstrom; 	 no_reorient; 	 symmetry c1; 	}; 	; 	set basis aug-cc-pvdz; 	; 	energy('sapt0'); 	energy('sapt2'); 	energy('sapt2+'); 	energy('sapt2+(3)'); 	energy('sapt2+3'). The SAPT module uses the standard |PSIfour| partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the ``no_reorient`` and ``symmetry; c1`` molecule keywords, as in the example above. As a reminder, only; SAPT0 can handle the interaction of both closed- and open-shell monomers.; Higher-order SAPT and SAPT(DFT) are currently available only ; for computation of interactions between; closed-shell singlets. The SAPT codes in |PSIfour| have been written; to utilize density fitting, which is much faster than using conventional; 4-index electron repulsion integrals. This happens automatically and; does not require any additional keywords to be specified (both the ; SAPT comp",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:14349,Energy Efficiency,energy,energy,14349,"er:2014:094106]_). .. math:: E_{sSAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; p_{EX}(3.0) E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + p_{EX}(3.0) E_{exch-disp}^{(20)} ; + \delta_{HF}^{(2)}; :label: sSAPT0. where :math:`\delta_{HF}^{(2)}` is computed *without* any scaling. Please note that ; sSAPT0 is thus not the same as requesting ``exch_scale_alpha 3.0``, and that the; scaling is automatically performed by requesting ``energy('ssapt0')``. A First Example; ^^^^^^^^^^^^^^^. The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods,; not all of them). ::. 	molecule water_dimer {; 	 0 1; 	 O -1.551007 -0.114520 0.000000; 	 H -1.934259 0.762503 0.000000; 	 H -0.599677 0.040712 0.000000; 	 --; 	 0 1; 	 O 1.350625 0.111469 0.000000; 	 H 1.680398 -0.373741 -0.758561; 	 H 1.680398 -0.373741 0.758561; 	; 	 units angstrom; 	 no_reorient; 	 symmetry c1; 	}; 	; 	set basis aug-cc-pvdz; 	; 	energy('sapt0'); 	energy('sapt2'); 	energy('sapt2+'); 	energy('sapt2+(3)'); 	energy('sapt2+3'). The SAPT module uses the standard |PSIfour| partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the ``no_reorient`` and ``symmetry; c1`` molecule keywords, as in the example above. As a reminder, only; SAPT0 can handle the interaction of both closed- and open-shell monomers.; Higher-order SAPT and SAPT(DFT) are currently available only ; for computation of interactions between; closed-shell singlets. The SAPT codes in |PSIfour| have been written; to utilize density fitting, which is much faster than using conventional; 4-index electron repulsion integrals. This happens automatically and; does not require any additional keywords to be specified (both the ; SAPT comp",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:14371,Energy Efficiency,energy,energy,14371,"er:2014:094106]_). .. math:: E_{sSAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; p_{EX}(3.0) E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + p_{EX}(3.0) E_{exch-disp}^{(20)} ; + \delta_{HF}^{(2)}; :label: sSAPT0. where :math:`\delta_{HF}^{(2)}` is computed *without* any scaling. Please note that ; sSAPT0 is thus not the same as requesting ``exch_scale_alpha 3.0``, and that the; scaling is automatically performed by requesting ``energy('ssapt0')``. A First Example; ^^^^^^^^^^^^^^^. The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods,; not all of them). ::. 	molecule water_dimer {; 	 0 1; 	 O -1.551007 -0.114520 0.000000; 	 H -1.934259 0.762503 0.000000; 	 H -0.599677 0.040712 0.000000; 	 --; 	 0 1; 	 O 1.350625 0.111469 0.000000; 	 H 1.680398 -0.373741 -0.758561; 	 H 1.680398 -0.373741 0.758561; 	; 	 units angstrom; 	 no_reorient; 	 symmetry c1; 	}; 	; 	set basis aug-cc-pvdz; 	; 	energy('sapt0'); 	energy('sapt2'); 	energy('sapt2+'); 	energy('sapt2+(3)'); 	energy('sapt2+3'). The SAPT module uses the standard |PSIfour| partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the ``no_reorient`` and ``symmetry; c1`` molecule keywords, as in the example above. As a reminder, only; SAPT0 can handle the interaction of both closed- and open-shell monomers.; Higher-order SAPT and SAPT(DFT) are currently available only ; for computation of interactions between; closed-shell singlets. The SAPT codes in |PSIfour| have been written; to utilize density fitting, which is much faster than using conventional; 4-index electron repulsion integrals. This happens automatically and; does not require any additional keywords to be specified (both the ; SAPT comp",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:15545,Energy Efficiency,energy,energy,15545,"monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the ``no_reorient`` and ``symmetry; c1`` molecule keywords, as in the example above. As a reminder, only; SAPT0 can handle the interaction of both closed- and open-shell monomers.; Higher-order SAPT and SAPT(DFT) are currently available only ; for computation of interactions between; closed-shell singlets. The SAPT codes in |PSIfour| have been written; to utilize density fitting, which is much faster than using conventional; 4-index electron repulsion integrals. This happens automatically and; does not require any additional keywords to be specified (both the ; SAPT computations and the underlying Hartree-Fock computations will; utilize density fitting). For SAPT(DFT), the user will need to manually specify the GRAC shift of ; both monomers, defined by the difference of ionization potential (IP) and; Kohn-Sham HOMO energy. The ionization potential data for many common molecules ; is available in NIST Chemistry Webbook. Alternatively, one can estimate the; ionization potential of molecule by computing the energy difference between; the molecule as given, and the molecule after one electron has been removed; (e.g., the energy difference between a neutral molecule and its cation). The values of GRAC shifts should be given in Hartree. For the example above,; the GRAC shift value of both molecules are calculated to be 0.1307 (using experimental; IP from CCCBDB), and the user would specify them using the following keywords::. set globals {; sapt_dft_grac_shift_a 0.1307; sapt_dft_grac_shift_b 0.1307 ; }. A complete, minimal example of a SAPT(DFT) computation is given below. ::. molecule {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; ",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:15738,Energy Efficiency,energy,energy,15738,"metry; c1`` molecule keywords, as in the example above. As a reminder, only; SAPT0 can handle the interaction of both closed- and open-shell monomers.; Higher-order SAPT and SAPT(DFT) are currently available only ; for computation of interactions between; closed-shell singlets. The SAPT codes in |PSIfour| have been written; to utilize density fitting, which is much faster than using conventional; 4-index electron repulsion integrals. This happens automatically and; does not require any additional keywords to be specified (both the ; SAPT computations and the underlying Hartree-Fock computations will; utilize density fitting). For SAPT(DFT), the user will need to manually specify the GRAC shift of ; both monomers, defined by the difference of ionization potential (IP) and; Kohn-Sham HOMO energy. The ionization potential data for many common molecules ; is available in NIST Chemistry Webbook. Alternatively, one can estimate the; ionization potential of molecule by computing the energy difference between; the molecule as given, and the molecule after one electron has been removed; (e.g., the energy difference between a neutral molecule and its cation). The values of GRAC shifts should be given in Hartree. For the example above,; the GRAC shift value of both molecules are calculated to be 0.1307 (using experimental; IP from CCCBDB), and the user would specify them using the following keywords::. set globals {; sapt_dft_grac_shift_a 0.1307; sapt_dft_grac_shift_b 0.1307 ; }. A complete, minimal example of a SAPT(DFT) computation is given below. ::. molecule {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; }; ; set {; basis aug-cc-pVDZ; sapt_dft_grac_shift_a 0.1307; sapt_dft_grac_shift_b 0.1307; }; ; energy('sapt(dft)'). As already mentioned above, the SAPT0 module for open-shell cases can also; use exact ",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:15853,Energy Efficiency,energy,energy,15853,"n-shell monomers.; Higher-order SAPT and SAPT(DFT) are currently available only ; for computation of interactions between; closed-shell singlets. The SAPT codes in |PSIfour| have been written; to utilize density fitting, which is much faster than using conventional; 4-index electron repulsion integrals. This happens automatically and; does not require any additional keywords to be specified (both the ; SAPT computations and the underlying Hartree-Fock computations will; utilize density fitting). For SAPT(DFT), the user will need to manually specify the GRAC shift of ; both monomers, defined by the difference of ionization potential (IP) and; Kohn-Sham HOMO energy. The ionization potential data for many common molecules ; is available in NIST Chemistry Webbook. Alternatively, one can estimate the; ionization potential of molecule by computing the energy difference between; the molecule as given, and the molecule after one electron has been removed; (e.g., the energy difference between a neutral molecule and its cation). The values of GRAC shifts should be given in Hartree. For the example above,; the GRAC shift value of both molecules are calculated to be 0.1307 (using experimental; IP from CCCBDB), and the user would specify them using the following keywords::. set globals {; sapt_dft_grac_shift_a 0.1307; sapt_dft_grac_shift_b 0.1307 ; }. A complete, minimal example of a SAPT(DFT) computation is given below. ::. molecule {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; }; ; set {; basis aug-cc-pVDZ; sapt_dft_grac_shift_a 0.1307; sapt_dft_grac_shift_b 0.1307; }; ; energy('sapt(dft)'). As already mentioned above, the SAPT0 module for open-shell cases can also; use exact integrals for all terms except for dispersion. In practice,; density fitting is considerably faster and introduces negligible errors,",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:16641,Energy Efficiency,energy,energy,16641,"book. Alternatively, one can estimate the; ionization potential of molecule by computing the energy difference between; the molecule as given, and the molecule after one electron has been removed; (e.g., the energy difference between a neutral molecule and its cation). The values of GRAC shifts should be given in Hartree. For the example above,; the GRAC shift value of both molecules are calculated to be 0.1307 (using experimental; IP from CCCBDB), and the user would specify them using the following keywords::. set globals {; sapt_dft_grac_shift_a 0.1307; sapt_dft_grac_shift_b 0.1307 ; }. A complete, minimal example of a SAPT(DFT) computation is given below. ::. molecule {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; }; ; set {; basis aug-cc-pVDZ; sapt_dft_grac_shift_a 0.1307; sapt_dft_grac_shift_b 0.1307; }; ; energy('sapt(dft)'). As already mentioned above, the SAPT0 module for open-shell cases can also; use exact integrals for all terms except for dispersion. In practice,; density fitting is considerably faster and introduces negligible errors, thus; it is the preferred method for open-shell cases as well.; Below, you can find a minimum example of open-shell SAPT0 computation. ::. molecule {; 0 1; O 0.000000 0.000000 6.000000; H 0.000000 1.431500 4.890600; H 0.000000 -1.431500 4.890600; --; 0 2; O 0.000000 0.000000 0.000000; O 0.000000 2.503900 0.000000; H 0.000000 -0.424700 -1.839500; units bohr; symmetry c1; no_reorient; no_com; }; ; set {; reference uhf; scf_type df; basis aug-cc-pVDZ; }; ; energy('sapt0'); ; . |scf__reference| needs to be ``UHF`` or ``ROHF`` for the open-shell computation to proceed. Advanced example; ^^^^^^^^^^^^^^^^. Open-shell computations can be difficult to converge in certain cases, thus you may; want to have more control over the SCF procedure. You have the option of",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:17340,Energy Efficiency,energy,energy,17340,"tion is given below. ::. molecule {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; }; ; set {; basis aug-cc-pVDZ; sapt_dft_grac_shift_a 0.1307; sapt_dft_grac_shift_b 0.1307; }; ; energy('sapt(dft)'). As already mentioned above, the SAPT0 module for open-shell cases can also; use exact integrals for all terms except for dispersion. In practice,; density fitting is considerably faster and introduces negligible errors, thus; it is the preferred method for open-shell cases as well.; Below, you can find a minimum example of open-shell SAPT0 computation. ::. molecule {; 0 1; O 0.000000 0.000000 6.000000; H 0.000000 1.431500 4.890600; H 0.000000 -1.431500 4.890600; --; 0 2; O 0.000000 0.000000 0.000000; O 0.000000 2.503900 0.000000; H 0.000000 -0.424700 -1.839500; units bohr; symmetry c1; no_reorient; no_com; }; ; set {; reference uhf; scf_type df; basis aug-cc-pVDZ; }; ; energy('sapt0'); ; . |scf__reference| needs to be ``UHF`` or ``ROHF`` for the open-shell computation to proceed. Advanced example; ^^^^^^^^^^^^^^^^. Open-shell computations can be difficult to converge in certain cases, thus you may; want to have more control over the SCF procedure. You have the option of ; doing the driver job in the input file, by performing the dimer and monomer computations; yourself. In the example below, we do a stability analysis for the open-shell monomer only ::. molecule {; 0 2; O 0.000000 0.000000 0.000000; O 0.000000 2.503900 0.000000; H 0.000000 -0.424700 -1.839500; --; 0 1; O 0.000000 0.000000 6.000000; H 0.000000 1.431500 4.890600; H 0.000000 -1.431500 4.890600; units bohr; symmetry c1; no_reorient; no_com; }; ; dimer = psi4.get_active_molecule() ; ; set {; reference uhf; scf_type df; basis cc-pVDZ; df_basis_sapt cc-pVDZ-ri; guess sad; }; ; dimer = psi4.get_active_molecule(); ; set df_ints_io save; psi4.IO",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:18342,Energy Efficiency,energy,energy,18342," |scf__reference| needs to be ``UHF`` or ``ROHF`` for the open-shell computation to proceed. Advanced example; ^^^^^^^^^^^^^^^^. Open-shell computations can be difficult to converge in certain cases, thus you may; want to have more control over the SCF procedure. You have the option of ; doing the driver job in the input file, by performing the dimer and monomer computations; yourself. In the example below, we do a stability analysis for the open-shell monomer only ::. molecule {; 0 2; O 0.000000 0.000000 0.000000; O 0.000000 2.503900 0.000000; H 0.000000 -0.424700 -1.839500; --; 0 1; O 0.000000 0.000000 6.000000; H 0.000000 1.431500 4.890600; H 0.000000 -1.431500 4.890600; units bohr; symmetry c1; no_reorient; no_com; }; ; dimer = psi4.get_active_molecule() ; ; set {; reference uhf; scf_type df; basis cc-pVDZ; df_basis_sapt cc-pVDZ-ri; guess sad; }; ; dimer = psi4.get_active_molecule(); ; set df_ints_io save; psi4.IO.set_default_namespace('dimer'); Edim, wfn_dimer = energy('scf',molecule=dimer,return_wfn=True); set df_ints_io load; ; monomerA = dimer.extract_subsets(1,2); psi4.IO.change_file_namespace(97, 'dimer', 'monomerA'); psi4.IO.set_default_namespace('monomerA'); set {; stability_analysis follow; }; EmonA, wfn_monA = energy('scf',molecule=monomerA,return_wfn=True); ; monomerB = dimer.extract_subsets(2,1); psi4.IO.change_file_namespace(97, 'monomerA', 'monomerB'); psi4.IO.set_default_namespace('monomerB'); set {; stability_analysis none; }; EmonB, wfn_monB = energy('scf',molecule=monomerB,return_wfn=True); ; psi4.IO.change_file_namespace(97, 'monomerB', 'dimer'); psi4.IO.set_default_namespace('dimer'); ; aux_basis = psi4.core.BasisSet.build(wfn_dimer.molecule(), ""DF_BASIS_SAPT"",; psi4.core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", psi4.core.get_global_option(""BASIS"")); wfn_dimer.set_basisset(""DF_BASIS_SAPT"", aux_basis); wfn_dimer.set_basisset(""DF_BASIS_ELST"", aux_basis); ; psi4.sapt(wfn_dimer,wfn_monA,wfn_monB). In this way, any of the SCF options can be t",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:18604,Energy Efficiency,energy,energy,18604,"ontrol over the SCF procedure. You have the option of ; doing the driver job in the input file, by performing the dimer and monomer computations; yourself. In the example below, we do a stability analysis for the open-shell monomer only ::. molecule {; 0 2; O 0.000000 0.000000 0.000000; O 0.000000 2.503900 0.000000; H 0.000000 -0.424700 -1.839500; --; 0 1; O 0.000000 0.000000 6.000000; H 0.000000 1.431500 4.890600; H 0.000000 -1.431500 4.890600; units bohr; symmetry c1; no_reorient; no_com; }; ; dimer = psi4.get_active_molecule() ; ; set {; reference uhf; scf_type df; basis cc-pVDZ; df_basis_sapt cc-pVDZ-ri; guess sad; }; ; dimer = psi4.get_active_molecule(); ; set df_ints_io save; psi4.IO.set_default_namespace('dimer'); Edim, wfn_dimer = energy('scf',molecule=dimer,return_wfn=True); set df_ints_io load; ; monomerA = dimer.extract_subsets(1,2); psi4.IO.change_file_namespace(97, 'dimer', 'monomerA'); psi4.IO.set_default_namespace('monomerA'); set {; stability_analysis follow; }; EmonA, wfn_monA = energy('scf',molecule=monomerA,return_wfn=True); ; monomerB = dimer.extract_subsets(2,1); psi4.IO.change_file_namespace(97, 'monomerA', 'monomerB'); psi4.IO.set_default_namespace('monomerB'); set {; stability_analysis none; }; EmonB, wfn_monB = energy('scf',molecule=monomerB,return_wfn=True); ; psi4.IO.change_file_namespace(97, 'monomerB', 'dimer'); psi4.IO.set_default_namespace('dimer'); ; aux_basis = psi4.core.BasisSet.build(wfn_dimer.molecule(), ""DF_BASIS_SAPT"",; psi4.core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", psi4.core.get_global_option(""BASIS"")); wfn_dimer.set_basisset(""DF_BASIS_SAPT"", aux_basis); wfn_dimer.set_basisset(""DF_BASIS_ELST"", aux_basis); ; psi4.sapt(wfn_dimer,wfn_monA,wfn_monB). In this way, any of the SCF options can be tweaked for individual fragments.; For optimal efficiency, the example uses ``set df_ints_io save`` to keep file 97,; which contains the three-index integrals for density fitting. ``set df_ints_io load``; then instructs the program to",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:18849,Energy Efficiency,energy,energy,18849," molecule {; 0 2; O 0.000000 0.000000 0.000000; O 0.000000 2.503900 0.000000; H 0.000000 -0.424700 -1.839500; --; 0 1; O 0.000000 0.000000 6.000000; H 0.000000 1.431500 4.890600; H 0.000000 -1.431500 4.890600; units bohr; symmetry c1; no_reorient; no_com; }; ; dimer = psi4.get_active_molecule() ; ; set {; reference uhf; scf_type df; basis cc-pVDZ; df_basis_sapt cc-pVDZ-ri; guess sad; }; ; dimer = psi4.get_active_molecule(); ; set df_ints_io save; psi4.IO.set_default_namespace('dimer'); Edim, wfn_dimer = energy('scf',molecule=dimer,return_wfn=True); set df_ints_io load; ; monomerA = dimer.extract_subsets(1,2); psi4.IO.change_file_namespace(97, 'dimer', 'monomerA'); psi4.IO.set_default_namespace('monomerA'); set {; stability_analysis follow; }; EmonA, wfn_monA = energy('scf',molecule=monomerA,return_wfn=True); ; monomerB = dimer.extract_subsets(2,1); psi4.IO.change_file_namespace(97, 'monomerA', 'monomerB'); psi4.IO.set_default_namespace('monomerB'); set {; stability_analysis none; }; EmonB, wfn_monB = energy('scf',molecule=monomerB,return_wfn=True); ; psi4.IO.change_file_namespace(97, 'monomerB', 'dimer'); psi4.IO.set_default_namespace('dimer'); ; aux_basis = psi4.core.BasisSet.build(wfn_dimer.molecule(), ""DF_BASIS_SAPT"",; psi4.core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", psi4.core.get_global_option(""BASIS"")); wfn_dimer.set_basisset(""DF_BASIS_SAPT"", aux_basis); wfn_dimer.set_basisset(""DF_BASIS_ELST"", aux_basis); ; psi4.sapt(wfn_dimer,wfn_monA,wfn_monB). In this way, any of the SCF options can be tweaked for individual fragments.; For optimal efficiency, the example uses ``set df_ints_io save`` to keep file 97,; which contains the three-index integrals for density fitting. ``set df_ints_io load``; then instructs the program to read these integrals from disk instead of recomputing; them. For each SCF computation, we use ``psi4.IO.set_default_namespace`` to uniquely; name scratch files. In the following SCF step, only file 97 is renamed using; ``psi4.IO.change_fil",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:20719,Energy Efficiency,energy,energy,20719,"g; them. For each SCF computation, we use ``psi4.IO.set_default_namespace`` to uniquely; name scratch files. In the following SCF step, only file 97 is renamed using; ``psi4.IO.change_file_namespace`` so that integrals can be read from it.; For more information on stability analysis, see the :ref:`stability <sec:scfstability_doc>`; documentation. .. index:: SAPT; SAPT0. SAPT0; ^^^^^. Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of closed-shell SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ'). We do not recommend using SAPT0 with large basis sets; like aug-cc-pVTZ. A systematic study of the accuracy of closed-shell SAPT0 and other SAPT ; truncations, using different basis sets, is reported in ; [Parker:2014:094106]_. In particular, an empirical recipe for scaled SAPT0; can yield improved performance and has been included in the output file as; the sSAPT0 interaction energy. sSAPT0 is a free by-product and is automatically ; computed when SAPT0 is requested (see above for more details).; The SAPT module has been used to perform SAPT0 computations with over; 200 atoms and 2800 basis functions; this code should be scalable to 4000; basis functions. Publications resulting from the use of the SAPT0 code ; should cite the following publications: [Hohenstein:2010:184111]_ and ; [Hohenstein:2011:174107]_. If the open-shell SAPT0 code is used,; [Gonthier:2016:134106]_ should be additionally cited. Basic SAPT0 Keywords; ~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__sapt_level.rst; .. include:: autodir_options_c/sapt__basis.rst; .. include:: autodir_options_c/sapt__df_basis_sapt.rst; .. include:: autodir_options_c/sapt__df_basis_elst.rst; .. include:: autodir_options_c/sapt__freeze_core.rst; .. include:: autodir_options_c/sapt__d_convergence.rst; .. include:: autodir_option",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:22602,Energy Efficiency,energy,energy,22602,"onvergence.rst; .. include:: autodir_options_c/sapt__e_convergence.rst; .. include:: autodir_options_c/sapt__maxiter.rst; .. include:: autodir_options_c/sapt__print.rst. Advanced SAPT0 Keywords; ~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__aio_cphf.rst; .. include:: autodir_options_c/sapt__aio_df_ints.rst; .. include:: autodir_options_c/sapt__coupled_induction.rst; .. include:: autodir_options_c/sapt__exch_scale_alpha.rst; .. include:: autodir_options_c/sapt__ints_tolerance.rst; .. include:: autodir_options_c/sapt__denominator_delta.rst; .. include:: autodir_options_c/sapt__denominator_algorithm.rst; .. include:: autodir_options_c/globals__debug.rst. Specific open-shell SAPT0 keywords; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__sapt_mem_safety.rst; .. include:: autodir_options_c/sapt__coupled_induction.rst. .. index:: SAPT; SAPT(DFT). .. _`sec:saptdft`:. SAPT(DFT); ^^^^^^^^^. In general, SAPT(DFT) should provide more accurate interaction energy ; components, and overall interaction energies, than SAPT0. The drawback ; is SAPT(DFT) method is more computationally demanding than SAPT0, ; SAPT(DFT) can still be applied to medium-sized or large systems. The ; SAPT(DFT) module was employed successfully in computations of systems ; with up to 2000 basis functions, and the code should be scalable to ; 3000 basis functions. Like higher-order SAPT, SAPT(DFT) requires ; sufficient memory to hold :math:`2ovN_aux` doubles. SAPT(DFT) requires a few special treatments to obtain accurate; result. The DFT functionals used in SAPT(DFT) need to be asymptotically; corrected with Gradient Regulated Asymptotic Correction scheme (GRAC),; in order to recover the correct long-range asymptotic behavior; (approaching :math:`-1/r` as :math:`r` approaches infinity). The program; requires manual input of GRAC shift parameter for each monomer through; keywords |sapt__sapt_dft_grac_shift_a| and |sapt__sapt_dft_grac_shift_b|,; which should be equal to ",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:23691,Energy Efficiency,energy,energy,23691,"FT) should provide more accurate interaction energy ; components, and overall interaction energies, than SAPT0. The drawback ; is SAPT(DFT) method is more computationally demanding than SAPT0, ; SAPT(DFT) can still be applied to medium-sized or large systems. The ; SAPT(DFT) module was employed successfully in computations of systems ; with up to 2000 basis functions, and the code should be scalable to ; 3000 basis functions. Like higher-order SAPT, SAPT(DFT) requires ; sufficient memory to hold :math:`2ovN_aux` doubles. SAPT(DFT) requires a few special treatments to obtain accurate; result. The DFT functionals used in SAPT(DFT) need to be asymptotically; corrected with Gradient Regulated Asymptotic Correction scheme (GRAC),; in order to recover the correct long-range asymptotic behavior; (approaching :math:`-1/r` as :math:`r` approaches infinity). The program; requires manual input of GRAC shift parameter for each monomer through; keywords |sapt__sapt_dft_grac_shift_a| and |sapt__sapt_dft_grac_shift_b|,; which should be equal to the difference of the actual ionization; potential and the corresponding Kohn-Sham HOMO energy. The dispersion; term needs to be computed with orbital response for good accuracy,; and it is recommended to enable |sapt__sapt_dft_do_hybrid| (set to; ``True`` by default). The coupled exchange-dispersion energy is usually; estimated by scaling from the uncoupled value either by a fitted fixed; value (suggested initially by [Hesselmann:2014:094107]_ for a local Hartree--Fock (LHF) formulation and then revised; by [Xie:2022:024801]_ for non-LHF) or; by the ratio of; coupled and uncoupled dispersion energy (suggested by [Podeszwa:2006:400]_ ). ; This can be controlled by keyword |sapt__sapt_dft_exch_disp_scale_scheme|, ; with ``FIXED`` using the Hesselmann/Xie approach (|PSIfours| default prior ; to Nov 2022), ``DISP`` using the Podeszwa approach (|PSIfours| default after Nov 2022),; or ``NONE`` for not scaling and using the uncoupled exchange-disp",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:23905,Energy Efficiency,energy,energy,23905,"math:`2ovN_aux` doubles. SAPT(DFT) requires a few special treatments to obtain accurate; result. The DFT functionals used in SAPT(DFT) need to be asymptotically; corrected with Gradient Regulated Asymptotic Correction scheme (GRAC),; in order to recover the correct long-range asymptotic behavior; (approaching :math:`-1/r` as :math:`r` approaches infinity). The program; requires manual input of GRAC shift parameter for each monomer through; keywords |sapt__sapt_dft_grac_shift_a| and |sapt__sapt_dft_grac_shift_b|,; which should be equal to the difference of the actual ionization; potential and the corresponding Kohn-Sham HOMO energy. The dispersion; term needs to be computed with orbital response for good accuracy,; and it is recommended to enable |sapt__sapt_dft_do_hybrid| (set to; ``True`` by default). The coupled exchange-dispersion energy is usually; estimated by scaling from the uncoupled value either by a fitted fixed; value (suggested initially by [Hesselmann:2014:094107]_ for a local Hartree--Fock (LHF) formulation and then revised; by [Xie:2022:024801]_ for non-LHF) or; by the ratio of; coupled and uncoupled dispersion energy (suggested by [Podeszwa:2006:400]_ ). ; This can be controlled by keyword |sapt__sapt_dft_exch_disp_scale_scheme|, ; with ``FIXED`` using the Hesselmann/Xie approach (|PSIfours| default prior ; to Nov 2022), ``DISP`` using the Podeszwa approach (|PSIfours| default after Nov 2022),; or ``NONE`` for not scaling and using the uncoupled exchange-dispersion ; energy directly. .. warning:: Since Nov 2022, the defaults of options |sapt__sapt_dft_exch_disp_scale_scheme| and |sapt__sapt_dft_exch_disp_fixed_scale|; have been changed. Before, the former defaulted to ``FIXED`` with Hesselmann value of 0.686 for the latter. Now, the former defaults to ``DISP`` and should you instead select ``FIXED``, the default for the latter is the Xie value of 0.770. This might cause; an older version of |PSIfour| to produce a different value of; exchange-dispersio",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:24203,Energy Efficiency,energy,energy,24203,"math:`2ovN_aux` doubles. SAPT(DFT) requires a few special treatments to obtain accurate; result. The DFT functionals used in SAPT(DFT) need to be asymptotically; corrected with Gradient Regulated Asymptotic Correction scheme (GRAC),; in order to recover the correct long-range asymptotic behavior; (approaching :math:`-1/r` as :math:`r` approaches infinity). The program; requires manual input of GRAC shift parameter for each monomer through; keywords |sapt__sapt_dft_grac_shift_a| and |sapt__sapt_dft_grac_shift_b|,; which should be equal to the difference of the actual ionization; potential and the corresponding Kohn-Sham HOMO energy. The dispersion; term needs to be computed with orbital response for good accuracy,; and it is recommended to enable |sapt__sapt_dft_do_hybrid| (set to; ``True`` by default). The coupled exchange-dispersion energy is usually; estimated by scaling from the uncoupled value either by a fitted fixed; value (suggested initially by [Hesselmann:2014:094107]_ for a local Hartree--Fock (LHF) formulation and then revised; by [Xie:2022:024801]_ for non-LHF) or; by the ratio of; coupled and uncoupled dispersion energy (suggested by [Podeszwa:2006:400]_ ). ; This can be controlled by keyword |sapt__sapt_dft_exch_disp_scale_scheme|, ; with ``FIXED`` using the Hesselmann/Xie approach (|PSIfours| default prior ; to Nov 2022), ``DISP`` using the Podeszwa approach (|PSIfours| default after Nov 2022),; or ``NONE`` for not scaling and using the uncoupled exchange-dispersion ; energy directly. .. warning:: Since Nov 2022, the defaults of options |sapt__sapt_dft_exch_disp_scale_scheme| and |sapt__sapt_dft_exch_disp_fixed_scale|; have been changed. Before, the former defaulted to ``FIXED`` with Hesselmann value of 0.686 for the latter. Now, the former defaults to ``DISP`` and should you instead select ``FIXED``, the default for the latter is the Xie value of 0.770. This might cause; an older version of |PSIfour| to produce a different value of; exchange-dispersio",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:24567,Energy Efficiency,energy,energy,24567,"). The program; requires manual input of GRAC shift parameter for each monomer through; keywords |sapt__sapt_dft_grac_shift_a| and |sapt__sapt_dft_grac_shift_b|,; which should be equal to the difference of the actual ionization; potential and the corresponding Kohn-Sham HOMO energy. The dispersion; term needs to be computed with orbital response for good accuracy,; and it is recommended to enable |sapt__sapt_dft_do_hybrid| (set to; ``True`` by default). The coupled exchange-dispersion energy is usually; estimated by scaling from the uncoupled value either by a fitted fixed; value (suggested initially by [Hesselmann:2014:094107]_ for a local Hartree--Fock (LHF) formulation and then revised; by [Xie:2022:024801]_ for non-LHF) or; by the ratio of; coupled and uncoupled dispersion energy (suggested by [Podeszwa:2006:400]_ ). ; This can be controlled by keyword |sapt__sapt_dft_exch_disp_scale_scheme|, ; with ``FIXED`` using the Hesselmann/Xie approach (|PSIfours| default prior ; to Nov 2022), ``DISP`` using the Podeszwa approach (|PSIfours| default after Nov 2022),; or ``NONE`` for not scaling and using the uncoupled exchange-dispersion ; energy directly. .. warning:: Since Nov 2022, the defaults of options |sapt__sapt_dft_exch_disp_scale_scheme| and |sapt__sapt_dft_exch_disp_fixed_scale|; have been changed. Before, the former defaulted to ``FIXED`` with Hesselmann value of 0.686 for the latter. Now, the former defaults to ``DISP`` and should you instead select ``FIXED``, the default for the latter is the Xie value of 0.770. This might cause; an older version of |PSIfour| to produce a different value of; exchange-dispersion energy from the latest version. Basic Keywords for SAPT(DFT) ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__sapt_dft_grac_shift_a.rst; .. include:: autodir_options_c/sapt__sapt_dft_grac_shift_b.rst; .. include:: autodir_options_c/sapt__sapt_dft_do_dhf.rst; .. include:: autodir_options_c/sapt__sapt_dft_exch_disp_scale_scheme.rst. ",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:25062,Energy Efficiency,energy,energy,25062,"[Hesselmann:2014:094107]_ for a local Hartree--Fock (LHF) formulation and then revised; by [Xie:2022:024801]_ for non-LHF) or; by the ratio of; coupled and uncoupled dispersion energy (suggested by [Podeszwa:2006:400]_ ). ; This can be controlled by keyword |sapt__sapt_dft_exch_disp_scale_scheme|, ; with ``FIXED`` using the Hesselmann/Xie approach (|PSIfours| default prior ; to Nov 2022), ``DISP`` using the Podeszwa approach (|PSIfours| default after Nov 2022),; or ``NONE`` for not scaling and using the uncoupled exchange-dispersion ; energy directly. .. warning:: Since Nov 2022, the defaults of options |sapt__sapt_dft_exch_disp_scale_scheme| and |sapt__sapt_dft_exch_disp_fixed_scale|; have been changed. Before, the former defaulted to ``FIXED`` with Hesselmann value of 0.686 for the latter. Now, the former defaults to ``DISP`` and should you instead select ``FIXED``, the default for the latter is the Xie value of 0.770. This might cause; an older version of |PSIfour| to produce a different value of; exchange-dispersion energy from the latest version. Basic Keywords for SAPT(DFT) ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__sapt_dft_grac_shift_a.rst; .. include:: autodir_options_c/sapt__sapt_dft_grac_shift_b.rst; .. include:: autodir_options_c/sapt__sapt_dft_do_dhf.rst; .. include:: autodir_options_c/sapt__sapt_dft_exch_disp_scale_scheme.rst. Advanced Keywords for SAPT(DFT); ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__sapt_dft_functional.rst; .. include:: autodir_options_c/sapt__sapt_dft_do_hybrid.rst; .. include:: autodir_options_c/sapt__sapt_dft_exch_disp_fixed_scale.rst; .. include:: autodir_options_c/sapt__sapt_dft_mp2_disp_alg.rst; .. include:: autodir_options_c/sapt__sapt_quiet.rst. .. index:: SAPT; higher-order. Higher-Order SAPT; ^^^^^^^^^^^^^^^^^. For smaller systems (up to the size of a nucleic acid base pair), more; accurate interaction energies can be obtained through higher-order SAPT; computations. The S",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:27143,Energy Efficiency,energy,energy,27143,"ting from the use of the higher-order SAPT code ; should cite the following: ; [Hohenstein:2010:014101]_. For methods SAPT2+ and above, one can replace the many-body treatment of; dispersion by an improved method based on coupled-cluster doubles (CCD).; This approach tends to give good improvements when dispersion effects; are very large, as in the PCCP dimer (see [Hohenstein:2011:2842]_).; As shown in [Parker:2014:094106]_, whether or not CCD dispersion offers; more accurate interaction energies tends to depend on the SAPT truncation; and basis set employed, due to cancellations of errors. Thanks to; natural orbital methods [Parrish:2013:174102]_, the SAPT code; is able to include CCD dispersion with only a modest additional cost.; Computations employing CCD dispersion should cite [Parrish:2013:174102]_. ; To request CCD dispersion treatment in a SAPT computation, simply append; ``(ccd)`` to the name of the method, as in the following examples ::. 	energy('sapt2+(ccd)'); 	energy('sapt2+(3)(ccd)'); 	energy('sapt2+3(ccd)'). The :math:`\delta_{MP2}` corrections can also be computed automatically; by appending ``dmp2`` to the name of the method, with or without CCD dispersion ::. 	energy('sapt2+dmp2'); 	energy('sapt2+(3)dmp2'); 	energy('sapt2+3dmp2'); 	energy('sapt2+(ccd)dmp2'); 	energy('sapt2+(3)(ccd)dmp2'); 	energy('sapt2+3(ccd)dmp2'). A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold :math:`3o^2v^2+v^2N_{aux}` arrays in core. With this; requirement computations on the adenine-thymine complex can be performed; with an aug-cc-pVTZ basis in less than 64GB of memory. Higher-order SAPT is treated separately from the highly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of keywords. ; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAPT; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_opti",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:27167,Energy Efficiency,energy,energy,27167,"ting from the use of the higher-order SAPT code ; should cite the following: ; [Hohenstein:2010:014101]_. For methods SAPT2+ and above, one can replace the many-body treatment of; dispersion by an improved method based on coupled-cluster doubles (CCD).; This approach tends to give good improvements when dispersion effects; are very large, as in the PCCP dimer (see [Hohenstein:2011:2842]_).; As shown in [Parker:2014:094106]_, whether or not CCD dispersion offers; more accurate interaction energies tends to depend on the SAPT truncation; and basis set employed, due to cancellations of errors. Thanks to; natural orbital methods [Parrish:2013:174102]_, the SAPT code; is able to include CCD dispersion with only a modest additional cost.; Computations employing CCD dispersion should cite [Parrish:2013:174102]_. ; To request CCD dispersion treatment in a SAPT computation, simply append; ``(ccd)`` to the name of the method, as in the following examples ::. 	energy('sapt2+(ccd)'); 	energy('sapt2+(3)(ccd)'); 	energy('sapt2+3(ccd)'). The :math:`\delta_{MP2}` corrections can also be computed automatically; by appending ``dmp2`` to the name of the method, with or without CCD dispersion ::. 	energy('sapt2+dmp2'); 	energy('sapt2+(3)dmp2'); 	energy('sapt2+3dmp2'); 	energy('sapt2+(ccd)dmp2'); 	energy('sapt2+(3)(ccd)dmp2'); 	energy('sapt2+3(ccd)dmp2'). A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold :math:`3o^2v^2+v^2N_{aux}` arrays in core. With this; requirement computations on the adenine-thymine complex can be performed; with an aug-cc-pVTZ basis in less than 64GB of memory. Higher-order SAPT is treated separately from the highly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of keywords. ; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAPT; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_opti",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:27194,Energy Efficiency,energy,energy,27194,"ting from the use of the higher-order SAPT code ; should cite the following: ; [Hohenstein:2010:014101]_. For methods SAPT2+ and above, one can replace the many-body treatment of; dispersion by an improved method based on coupled-cluster doubles (CCD).; This approach tends to give good improvements when dispersion effects; are very large, as in the PCCP dimer (see [Hohenstein:2011:2842]_).; As shown in [Parker:2014:094106]_, whether or not CCD dispersion offers; more accurate interaction energies tends to depend on the SAPT truncation; and basis set employed, due to cancellations of errors. Thanks to; natural orbital methods [Parrish:2013:174102]_, the SAPT code; is able to include CCD dispersion with only a modest additional cost.; Computations employing CCD dispersion should cite [Parrish:2013:174102]_. ; To request CCD dispersion treatment in a SAPT computation, simply append; ``(ccd)`` to the name of the method, as in the following examples ::. 	energy('sapt2+(ccd)'); 	energy('sapt2+(3)(ccd)'); 	energy('sapt2+3(ccd)'). The :math:`\delta_{MP2}` corrections can also be computed automatically; by appending ``dmp2`` to the name of the method, with or without CCD dispersion ::. 	energy('sapt2+dmp2'); 	energy('sapt2+(3)dmp2'); 	energy('sapt2+3dmp2'); 	energy('sapt2+(ccd)dmp2'); 	energy('sapt2+(3)(ccd)dmp2'); 	energy('sapt2+3(ccd)dmp2'). A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold :math:`3o^2v^2+v^2N_{aux}` arrays in core. With this; requirement computations on the adenine-thymine complex can be performed; with an aug-cc-pVTZ basis in less than 64GB of memory. Higher-order SAPT is treated separately from the highly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of keywords. ; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAPT; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_opti",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:27376,Energy Efficiency,energy,energy,27376,"o give good improvements when dispersion effects; are very large, as in the PCCP dimer (see [Hohenstein:2011:2842]_).; As shown in [Parker:2014:094106]_, whether or not CCD dispersion offers; more accurate interaction energies tends to depend on the SAPT truncation; and basis set employed, due to cancellations of errors. Thanks to; natural orbital methods [Parrish:2013:174102]_, the SAPT code; is able to include CCD dispersion with only a modest additional cost.; Computations employing CCD dispersion should cite [Parrish:2013:174102]_. ; To request CCD dispersion treatment in a SAPT computation, simply append; ``(ccd)`` to the name of the method, as in the following examples ::. 	energy('sapt2+(ccd)'); 	energy('sapt2+(3)(ccd)'); 	energy('sapt2+3(ccd)'). The :math:`\delta_{MP2}` corrections can also be computed automatically; by appending ``dmp2`` to the name of the method, with or without CCD dispersion ::. 	energy('sapt2+dmp2'); 	energy('sapt2+(3)dmp2'); 	energy('sapt2+3dmp2'); 	energy('sapt2+(ccd)dmp2'); 	energy('sapt2+(3)(ccd)dmp2'); 	energy('sapt2+3(ccd)dmp2'). A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold :math:`3o^2v^2+v^2N_{aux}` arrays in core. With this; requirement computations on the adenine-thymine complex can be performed; with an aug-cc-pVTZ basis in less than 64GB of memory. Higher-order SAPT is treated separately from the highly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of keywords. ; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAPT; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__basis.rst; .. include:: autodir_options_c/sapt__df_basis_sapt.rst; .. include:: autodir_options_c/globals__freeze_core.rst; .. include:: autodir_options_c/sapt__print.rst. Advanced Keywords for Higher-order SAPT; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:27399,Energy Efficiency,energy,energy,27399,"o give good improvements when dispersion effects; are very large, as in the PCCP dimer (see [Hohenstein:2011:2842]_).; As shown in [Parker:2014:094106]_, whether or not CCD dispersion offers; more accurate interaction energies tends to depend on the SAPT truncation; and basis set employed, due to cancellations of errors. Thanks to; natural orbital methods [Parrish:2013:174102]_, the SAPT code; is able to include CCD dispersion with only a modest additional cost.; Computations employing CCD dispersion should cite [Parrish:2013:174102]_. ; To request CCD dispersion treatment in a SAPT computation, simply append; ``(ccd)`` to the name of the method, as in the following examples ::. 	energy('sapt2+(ccd)'); 	energy('sapt2+(3)(ccd)'); 	energy('sapt2+3(ccd)'). The :math:`\delta_{MP2}` corrections can also be computed automatically; by appending ``dmp2`` to the name of the method, with or without CCD dispersion ::. 	energy('sapt2+dmp2'); 	energy('sapt2+(3)dmp2'); 	energy('sapt2+3dmp2'); 	energy('sapt2+(ccd)dmp2'); 	energy('sapt2+(3)(ccd)dmp2'); 	energy('sapt2+3(ccd)dmp2'). A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold :math:`3o^2v^2+v^2N_{aux}` arrays in core. With this; requirement computations on the adenine-thymine complex can be performed; with an aug-cc-pVTZ basis in less than 64GB of memory. Higher-order SAPT is treated separately from the highly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of keywords. ; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAPT; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__basis.rst; .. include:: autodir_options_c/sapt__df_basis_sapt.rst; .. include:: autodir_options_c/globals__freeze_core.rst; .. include:: autodir_options_c/sapt__print.rst. Advanced Keywords for Higher-order SAPT; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:27425,Energy Efficiency,energy,energy,27425,"o give good improvements when dispersion effects; are very large, as in the PCCP dimer (see [Hohenstein:2011:2842]_).; As shown in [Parker:2014:094106]_, whether or not CCD dispersion offers; more accurate interaction energies tends to depend on the SAPT truncation; and basis set employed, due to cancellations of errors. Thanks to; natural orbital methods [Parrish:2013:174102]_, the SAPT code; is able to include CCD dispersion with only a modest additional cost.; Computations employing CCD dispersion should cite [Parrish:2013:174102]_. ; To request CCD dispersion treatment in a SAPT computation, simply append; ``(ccd)`` to the name of the method, as in the following examples ::. 	energy('sapt2+(ccd)'); 	energy('sapt2+(3)(ccd)'); 	energy('sapt2+3(ccd)'). The :math:`\delta_{MP2}` corrections can also be computed automatically; by appending ``dmp2`` to the name of the method, with or without CCD dispersion ::. 	energy('sapt2+dmp2'); 	energy('sapt2+(3)dmp2'); 	energy('sapt2+3dmp2'); 	energy('sapt2+(ccd)dmp2'); 	energy('sapt2+(3)(ccd)dmp2'); 	energy('sapt2+3(ccd)dmp2'). A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold :math:`3o^2v^2+v^2N_{aux}` arrays in core. With this; requirement computations on the adenine-thymine complex can be performed; with an aug-cc-pVTZ basis in less than 64GB of memory. Higher-order SAPT is treated separately from the highly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of keywords. ; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAPT; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__basis.rst; .. include:: autodir_options_c/sapt__df_basis_sapt.rst; .. include:: autodir_options_c/globals__freeze_core.rst; .. include:: autodir_options_c/sapt__print.rst. Advanced Keywords for Higher-order SAPT; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:27449,Energy Efficiency,energy,energy,27449,"o give good improvements when dispersion effects; are very large, as in the PCCP dimer (see [Hohenstein:2011:2842]_).; As shown in [Parker:2014:094106]_, whether or not CCD dispersion offers; more accurate interaction energies tends to depend on the SAPT truncation; and basis set employed, due to cancellations of errors. Thanks to; natural orbital methods [Parrish:2013:174102]_, the SAPT code; is able to include CCD dispersion with only a modest additional cost.; Computations employing CCD dispersion should cite [Parrish:2013:174102]_. ; To request CCD dispersion treatment in a SAPT computation, simply append; ``(ccd)`` to the name of the method, as in the following examples ::. 	energy('sapt2+(ccd)'); 	energy('sapt2+(3)(ccd)'); 	energy('sapt2+3(ccd)'). The :math:`\delta_{MP2}` corrections can also be computed automatically; by appending ``dmp2`` to the name of the method, with or without CCD dispersion ::. 	energy('sapt2+dmp2'); 	energy('sapt2+(3)dmp2'); 	energy('sapt2+3dmp2'); 	energy('sapt2+(ccd)dmp2'); 	energy('sapt2+(3)(ccd)dmp2'); 	energy('sapt2+3(ccd)dmp2'). A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold :math:`3o^2v^2+v^2N_{aux}` arrays in core. With this; requirement computations on the adenine-thymine complex can be performed; with an aug-cc-pVTZ basis in less than 64GB of memory. Higher-order SAPT is treated separately from the highly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of keywords. ; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAPT; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__basis.rst; .. include:: autodir_options_c/sapt__df_basis_sapt.rst; .. include:: autodir_options_c/globals__freeze_core.rst; .. include:: autodir_options_c/sapt__print.rst. Advanced Keywords for Higher-order SAPT; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:27477,Energy Efficiency,energy,energy,27477,"o give good improvements when dispersion effects; are very large, as in the PCCP dimer (see [Hohenstein:2011:2842]_).; As shown in [Parker:2014:094106]_, whether or not CCD dispersion offers; more accurate interaction energies tends to depend on the SAPT truncation; and basis set employed, due to cancellations of errors. Thanks to; natural orbital methods [Parrish:2013:174102]_, the SAPT code; is able to include CCD dispersion with only a modest additional cost.; Computations employing CCD dispersion should cite [Parrish:2013:174102]_. ; To request CCD dispersion treatment in a SAPT computation, simply append; ``(ccd)`` to the name of the method, as in the following examples ::. 	energy('sapt2+(ccd)'); 	energy('sapt2+(3)(ccd)'); 	energy('sapt2+3(ccd)'). The :math:`\delta_{MP2}` corrections can also be computed automatically; by appending ``dmp2`` to the name of the method, with or without CCD dispersion ::. 	energy('sapt2+dmp2'); 	energy('sapt2+(3)dmp2'); 	energy('sapt2+3dmp2'); 	energy('sapt2+(ccd)dmp2'); 	energy('sapt2+(3)(ccd)dmp2'); 	energy('sapt2+3(ccd)dmp2'). A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold :math:`3o^2v^2+v^2N_{aux}` arrays in core. With this; requirement computations on the adenine-thymine complex can be performed; with an aug-cc-pVTZ basis in less than 64GB of memory. Higher-order SAPT is treated separately from the highly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of keywords. ; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAPT; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__basis.rst; .. include:: autodir_options_c/sapt__df_basis_sapt.rst; .. include:: autodir_options_c/globals__freeze_core.rst; .. include:: autodir_options_c/sapt__print.rst. Advanced Keywords for Higher-order SAPT; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:27508,Energy Efficiency,energy,energy,27508,"o give good improvements when dispersion effects; are very large, as in the PCCP dimer (see [Hohenstein:2011:2842]_).; As shown in [Parker:2014:094106]_, whether or not CCD dispersion offers; more accurate interaction energies tends to depend on the SAPT truncation; and basis set employed, due to cancellations of errors. Thanks to; natural orbital methods [Parrish:2013:174102]_, the SAPT code; is able to include CCD dispersion with only a modest additional cost.; Computations employing CCD dispersion should cite [Parrish:2013:174102]_. ; To request CCD dispersion treatment in a SAPT computation, simply append; ``(ccd)`` to the name of the method, as in the following examples ::. 	energy('sapt2+(ccd)'); 	energy('sapt2+(3)(ccd)'); 	energy('sapt2+3(ccd)'). The :math:`\delta_{MP2}` corrections can also be computed automatically; by appending ``dmp2`` to the name of the method, with or without CCD dispersion ::. 	energy('sapt2+dmp2'); 	energy('sapt2+(3)dmp2'); 	energy('sapt2+3dmp2'); 	energy('sapt2+(ccd)dmp2'); 	energy('sapt2+(3)(ccd)dmp2'); 	energy('sapt2+3(ccd)dmp2'). A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold :math:`3o^2v^2+v^2N_{aux}` arrays in core. With this; requirement computations on the adenine-thymine complex can be performed; with an aug-cc-pVTZ basis in less than 64GB of memory. Higher-order SAPT is treated separately from the highly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of keywords. ; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAPT; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__basis.rst; .. include:: autodir_options_c/sapt__df_basis_sapt.rst; .. include:: autodir_options_c/globals__freeze_core.rst; .. include:: autodir_options_c/sapt__print.rst. Advanced Keywords for Higher-order SAPT; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:29118,Energy Efficiency,energy,energy,29118,"for higher-order SAPT. Basic Keywords for Higher-order SAPT; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__basis.rst; .. include:: autodir_options_c/sapt__df_basis_sapt.rst; .. include:: autodir_options_c/globals__freeze_core.rst; .. include:: autodir_options_c/sapt__print.rst. Advanced Keywords for Higher-order SAPT; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__do_ccd_disp.rst; .. include:: autodir_options_c/sapt__do_mbpt_disp.rst; .. include:: autodir_options_c/sapt__do_third_order.rst; .. include:: autodir_options_c/sapt__ints_tolerance.rst; .. include:: autodir_options_c/sapt__sapt_mem_check.rst; .. include:: autodir_options_c/globals__debug.rst. MP2 Natural Orbitals; ^^^^^^^^^^^^^^^^^^^^. One of the unique features of the SAPT module is its ability to use; MP2 natural orbitals (NOs) to speed up the evaluation of the triples; contribution to dispersion. By transforming to the MP2 NO basis, we can; throw away virtual orbitals that are expected to contribute little to the; dispersion energy. Speedups in excess of :math:`50 \times` are possible. In; practice, this approximation is very good and should always be applied.; Publications resulting from the use of MP2 NO-based approximations should ; cite the following: [Hohenstein:2010:104107]_. Basic Keywords Controlling MP2 NO Approximations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__nat_orbs_t2.rst; .. include:: autodir_options_c/sapt__nat_orbs_t3.rst; .. include:: autodir_options_c/sapt__nat_orbs_v4.rst; .. include:: autodir_options_c/sapt__occ_tolerance.rst. .. comment Advanced Keywords Controlling MP2 NO Approximations; .. comment ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. comment .. include:: autodir_options_c/sapt__nat_orbs_t2.rst. .. index:: SAPT; charge-transfer. .. _`sec:saptct`:. Charge-Transfer in SAPT; ^^^^^^^^^^^^^^^^^^^^^^^. It is possible to obtain the stabilization energy of a complex",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:29908,Energy Efficiency,charge,charge-transfer,29908,"s (NOs) to speed up the evaluation of the triples; contribution to dispersion. By transforming to the MP2 NO basis, we can; throw away virtual orbitals that are expected to contribute little to the; dispersion energy. Speedups in excess of :math:`50 \times` are possible. In; practice, this approximation is very good and should always be applied.; Publications resulting from the use of MP2 NO-based approximations should ; cite the following: [Hohenstein:2010:104107]_. Basic Keywords Controlling MP2 NO Approximations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__nat_orbs_t2.rst; .. include:: autodir_options_c/sapt__nat_orbs_t3.rst; .. include:: autodir_options_c/sapt__nat_orbs_v4.rst; .. include:: autodir_options_c/sapt__occ_tolerance.rst. .. comment Advanced Keywords Controlling MP2 NO Approximations; .. comment ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. comment .. include:: autodir_options_c/sapt__nat_orbs_t2.rst. .. index:: SAPT; charge-transfer. .. _`sec:saptct`:. Charge-Transfer in SAPT; ^^^^^^^^^^^^^^^^^^^^^^^. It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy ; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201]_. Charge-transfer energies can be obtained from the following calls to the; energy function. ::. energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'); energy('sapt2+(ccd)-ct'); energy('sapt2+(3)(ccd)-ct'); energy('sapt2+3(ccd)-ct'). For now, charge transfer computations are not available with open-shell SAPT0. A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in t",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:30037,Energy Efficiency,energy,energy,30037,"bitals that are expected to contribute little to the; dispersion energy. Speedups in excess of :math:`50 \times` are possible. In; practice, this approximation is very good and should always be applied.; Publications resulting from the use of MP2 NO-based approximations should ; cite the following: [Hohenstein:2010:104107]_. Basic Keywords Controlling MP2 NO Approximations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__nat_orbs_t2.rst; .. include:: autodir_options_c/sapt__nat_orbs_t3.rst; .. include:: autodir_options_c/sapt__nat_orbs_v4.rst; .. include:: autodir_options_c/sapt__occ_tolerance.rst. .. comment Advanced Keywords Controlling MP2 NO Approximations; .. comment ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. comment .. include:: autodir_options_c/sapt__nat_orbs_t2.rst. .. index:: SAPT; charge-transfer. .. _`sec:saptct`:. Charge-Transfer in SAPT; ^^^^^^^^^^^^^^^^^^^^^^^. It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy ; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201]_. Charge-transfer energies can be obtained from the following calls to the; energy function. ::. energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'); energy('sapt2+(ccd)-ct'); energy('sapt2+(3)(ccd)-ct'); energy('sapt2+3(ccd)-ct'). For now, charge transfer computations are not available with open-shell SAPT0. A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results::. SAPT Charge Transfer Analysis; ---------------------------",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:30065,Energy Efficiency,charge,charge-transfer,30065,"bitals that are expected to contribute little to the; dispersion energy. Speedups in excess of :math:`50 \times` are possible. In; practice, this approximation is very good and should always be applied.; Publications resulting from the use of MP2 NO-based approximations should ; cite the following: [Hohenstein:2010:104107]_. Basic Keywords Controlling MP2 NO Approximations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__nat_orbs_t2.rst; .. include:: autodir_options_c/sapt__nat_orbs_t3.rst; .. include:: autodir_options_c/sapt__nat_orbs_v4.rst; .. include:: autodir_options_c/sapt__occ_tolerance.rst. .. comment Advanced Keywords Controlling MP2 NO Approximations; .. comment ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. comment .. include:: autodir_options_c/sapt__nat_orbs_t2.rst. .. index:: SAPT; charge-transfer. .. _`sec:saptct`:. Charge-Transfer in SAPT; ^^^^^^^^^^^^^^^^^^^^^^^. It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy ; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201]_. Charge-transfer energies can be obtained from the following calls to the; energy function. ::. energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'); energy('sapt2+(ccd)-ct'); energy('sapt2+(3)(ccd)-ct'); energy('sapt2+3(ccd)-ct'). For now, charge transfer computations are not available with open-shell SAPT0. A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results::. SAPT Charge Transfer Analysis; ---------------------------",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:30118,Energy Efficiency,charge,charge-transfer,30118,"le. In; practice, this approximation is very good and should always be applied.; Publications resulting from the use of MP2 NO-based approximations should ; cite the following: [Hohenstein:2010:104107]_. Basic Keywords Controlling MP2 NO Approximations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__nat_orbs_t2.rst; .. include:: autodir_options_c/sapt__nat_orbs_t3.rst; .. include:: autodir_options_c/sapt__nat_orbs_v4.rst; .. include:: autodir_options_c/sapt__occ_tolerance.rst. .. comment Advanced Keywords Controlling MP2 NO Approximations; .. comment ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. comment .. include:: autodir_options_c/sapt__nat_orbs_t2.rst. .. index:: SAPT; charge-transfer. .. _`sec:saptct`:. Charge-Transfer in SAPT; ^^^^^^^^^^^^^^^^^^^^^^^. It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy ; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201]_. Charge-transfer energies can be obtained from the following calls to the; energy function. ::. energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'); energy('sapt2+(ccd)-ct'); energy('sapt2+(3)(ccd)-ct'); energy('sapt2+3(ccd)-ct'). For now, charge transfer computations are not available with open-shell SAPT0. A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results::. SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:30134,Energy Efficiency,energy,energy,30134,"le. In; practice, this approximation is very good and should always be applied.; Publications resulting from the use of MP2 NO-based approximations should ; cite the following: [Hohenstein:2010:104107]_. Basic Keywords Controlling MP2 NO Approximations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__nat_orbs_t2.rst; .. include:: autodir_options_c/sapt__nat_orbs_t3.rst; .. include:: autodir_options_c/sapt__nat_orbs_v4.rst; .. include:: autodir_options_c/sapt__occ_tolerance.rst. .. comment Advanced Keywords Controlling MP2 NO Approximations; .. comment ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. comment .. include:: autodir_options_c/sapt__nat_orbs_t2.rst. .. index:: SAPT; charge-transfer. .. _`sec:saptct`:. Charge-Transfer in SAPT; ^^^^^^^^^^^^^^^^^^^^^^^. It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy ; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201]_. Charge-transfer energies can be obtained from the following calls to the; energy function. ::. energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'); energy('sapt2+(ccd)-ct'); energy('sapt2+(3)(ccd)-ct'); energy('sapt2+3(ccd)-ct'). For now, charge transfer computations are not available with open-shell SAPT0. A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results::. SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:30314,Energy Efficiency,energy,energy,30314," the use of MP2 NO-based approximations should ; cite the following: [Hohenstein:2010:104107]_. Basic Keywords Controlling MP2 NO Approximations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__nat_orbs_t2.rst; .. include:: autodir_options_c/sapt__nat_orbs_t3.rst; .. include:: autodir_options_c/sapt__nat_orbs_v4.rst; .. include:: autodir_options_c/sapt__occ_tolerance.rst. .. comment Advanced Keywords Controlling MP2 NO Approximations; .. comment ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. comment .. include:: autodir_options_c/sapt__nat_orbs_t2.rst. .. index:: SAPT; charge-transfer. .. _`sec:saptct`:. Charge-Transfer in SAPT; ^^^^^^^^^^^^^^^^^^^^^^^. It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy ; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201]_. Charge-transfer energies can be obtained from the following calls to the; energy function. ::. energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'); energy('sapt2+(ccd)-ct'); energy('sapt2+(3)(ccd)-ct'); energy('sapt2+3(ccd)-ct'). For now, charge transfer computations are not available with open-shell SAPT0. A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results::. SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol];",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:30335,Energy Efficiency,energy,energy,30335,"; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__nat_orbs_t2.rst; .. include:: autodir_options_c/sapt__nat_orbs_t3.rst; .. include:: autodir_options_c/sapt__nat_orbs_v4.rst; .. include:: autodir_options_c/sapt__occ_tolerance.rst. .. comment Advanced Keywords Controlling MP2 NO Approximations; .. comment ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. comment .. include:: autodir_options_c/sapt__nat_orbs_t2.rst. .. index:: SAPT; charge-transfer. .. _`sec:saptct`:. Charge-Transfer in SAPT; ^^^^^^^^^^^^^^^^^^^^^^^. It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy ; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201]_. Charge-transfer energies can be obtained from the following calls to the; energy function. ::. energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'); energy('sapt2+(ccd)-ct'); energy('sapt2+(3)(ccd)-ct'); energy('sapt2+3(ccd)-ct'). For now, charge transfer computations are not available with open-shell SAPT0. A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results::. SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed wit",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:30355,Energy Efficiency,energy,energy,30355,"; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__nat_orbs_t2.rst; .. include:: autodir_options_c/sapt__nat_orbs_t3.rst; .. include:: autodir_options_c/sapt__nat_orbs_v4.rst; .. include:: autodir_options_c/sapt__occ_tolerance.rst. .. comment Advanced Keywords Controlling MP2 NO Approximations; .. comment ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. comment .. include:: autodir_options_c/sapt__nat_orbs_t2.rst. .. index:: SAPT; charge-transfer. .. _`sec:saptct`:. Charge-Transfer in SAPT; ^^^^^^^^^^^^^^^^^^^^^^^. It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy ; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201]_. Charge-transfer energies can be obtained from the following calls to the; energy function. ::. energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'); energy('sapt2+(ccd)-ct'); energy('sapt2+(3)(ccd)-ct'); energy('sapt2+3(ccd)-ct'). For now, charge transfer computations are not available with open-shell SAPT0. A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results::. SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed wit",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:30375,Energy Efficiency,energy,energy,30375,"; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__nat_orbs_t2.rst; .. include:: autodir_options_c/sapt__nat_orbs_t3.rst; .. include:: autodir_options_c/sapt__nat_orbs_v4.rst; .. include:: autodir_options_c/sapt__occ_tolerance.rst. .. comment Advanced Keywords Controlling MP2 NO Approximations; .. comment ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. comment .. include:: autodir_options_c/sapt__nat_orbs_t2.rst. .. index:: SAPT; charge-transfer. .. _`sec:saptct`:. Charge-Transfer in SAPT; ^^^^^^^^^^^^^^^^^^^^^^^. It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy ; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201]_. Charge-transfer energies can be obtained from the following calls to the; energy function. ::. energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'); energy('sapt2+(ccd)-ct'); energy('sapt2+(3)(ccd)-ct'); energy('sapt2+3(ccd)-ct'). For now, charge transfer computations are not available with open-shell SAPT0. A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results::. SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed wit",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:30396,Energy Efficiency,energy,energy,30396,"; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__nat_orbs_t2.rst; .. include:: autodir_options_c/sapt__nat_orbs_t3.rst; .. include:: autodir_options_c/sapt__nat_orbs_v4.rst; .. include:: autodir_options_c/sapt__occ_tolerance.rst. .. comment Advanced Keywords Controlling MP2 NO Approximations; .. comment ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. comment .. include:: autodir_options_c/sapt__nat_orbs_t2.rst. .. index:: SAPT; charge-transfer. .. _`sec:saptct`:. Charge-Transfer in SAPT; ^^^^^^^^^^^^^^^^^^^^^^^. It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy ; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201]_. Charge-transfer energies can be obtained from the following calls to the; energy function. ::. energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'); energy('sapt2+(ccd)-ct'); energy('sapt2+(3)(ccd)-ct'); energy('sapt2+3(ccd)-ct'). For now, charge transfer computations are not available with open-shell SAPT0. A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results::. SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed wit",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:30420,Energy Efficiency,energy,energy,30420,"; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__nat_orbs_t2.rst; .. include:: autodir_options_c/sapt__nat_orbs_t3.rst; .. include:: autodir_options_c/sapt__nat_orbs_v4.rst; .. include:: autodir_options_c/sapt__occ_tolerance.rst. .. comment Advanced Keywords Controlling MP2 NO Approximations; .. comment ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. comment .. include:: autodir_options_c/sapt__nat_orbs_t2.rst. .. index:: SAPT; charge-transfer. .. _`sec:saptct`:. Charge-Transfer in SAPT; ^^^^^^^^^^^^^^^^^^^^^^^. It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy ; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201]_. Charge-transfer energies can be obtained from the following calls to the; energy function. ::. energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'); energy('sapt2+(ccd)-ct'); energy('sapt2+(3)(ccd)-ct'); energy('sapt2+3(ccd)-ct'). For now, charge transfer computations are not available with open-shell SAPT0. A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results::. SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed wit",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:30442,Energy Efficiency,energy,energy,30442,"; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__nat_orbs_t2.rst; .. include:: autodir_options_c/sapt__nat_orbs_t3.rst; .. include:: autodir_options_c/sapt__nat_orbs_v4.rst; .. include:: autodir_options_c/sapt__occ_tolerance.rst. .. comment Advanced Keywords Controlling MP2 NO Approximations; .. comment ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. comment .. include:: autodir_options_c/sapt__nat_orbs_t2.rst. .. index:: SAPT; charge-transfer. .. _`sec:saptct`:. Charge-Transfer in SAPT; ^^^^^^^^^^^^^^^^^^^^^^^. It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy ; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201]_. Charge-transfer energies can be obtained from the following calls to the; energy function. ::. energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'); energy('sapt2+(ccd)-ct'); energy('sapt2+(3)(ccd)-ct'); energy('sapt2+3(ccd)-ct'). For now, charge transfer computations are not available with open-shell SAPT0. A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results::. SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed wit",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:30468,Energy Efficiency,energy,energy,30468,"; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__nat_orbs_t2.rst; .. include:: autodir_options_c/sapt__nat_orbs_t3.rst; .. include:: autodir_options_c/sapt__nat_orbs_v4.rst; .. include:: autodir_options_c/sapt__occ_tolerance.rst. .. comment Advanced Keywords Controlling MP2 NO Approximations; .. comment ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. comment .. include:: autodir_options_c/sapt__nat_orbs_t2.rst. .. index:: SAPT; charge-transfer. .. _`sec:saptct`:. Charge-Transfer in SAPT; ^^^^^^^^^^^^^^^^^^^^^^^. It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy ; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201]_. Charge-transfer energies can be obtained from the following calls to the; energy function. ::. energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'); energy('sapt2+(ccd)-ct'); energy('sapt2+(3)(ccd)-ct'); energy('sapt2+3(ccd)-ct'). For now, charge transfer computations are not available with open-shell SAPT0. A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results::. SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed wit",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:30497,Energy Efficiency,energy,energy,30497,"; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__nat_orbs_t2.rst; .. include:: autodir_options_c/sapt__nat_orbs_t3.rst; .. include:: autodir_options_c/sapt__nat_orbs_v4.rst; .. include:: autodir_options_c/sapt__occ_tolerance.rst. .. comment Advanced Keywords Controlling MP2 NO Approximations; .. comment ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. comment .. include:: autodir_options_c/sapt__nat_orbs_t2.rst. .. index:: SAPT; charge-transfer. .. _`sec:saptct`:. Charge-Transfer in SAPT; ^^^^^^^^^^^^^^^^^^^^^^^. It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy ; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201]_. Charge-transfer energies can be obtained from the following calls to the; energy function. ::. energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'); energy('sapt2+(ccd)-ct'); energy('sapt2+(3)(ccd)-ct'); energy('sapt2+3(ccd)-ct'). For now, charge transfer computations are not available with open-shell SAPT0. A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results::. SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed wit",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:30533,Energy Efficiency,charge,charge,30533,"_c/sapt__nat_orbs_t3.rst; .. include:: autodir_options_c/sapt__nat_orbs_v4.rst; .. include:: autodir_options_c/sapt__occ_tolerance.rst. .. comment Advanced Keywords Controlling MP2 NO Approximations; .. comment ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. comment .. include:: autodir_options_c/sapt__nat_orbs_t2.rst. .. index:: SAPT; charge-transfer. .. _`sec:saptct`:. Charge-Transfer in SAPT; ^^^^^^^^^^^^^^^^^^^^^^^. It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy ; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201]_. Charge-transfer energies can be obtained from the following calls to the; energy function. ::. energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'); energy('sapt2+(ccd)-ct'); energy('sapt2+(3)(ccd)-ct'); energy('sapt2+3(ccd)-ct'). For now, charge transfer computations are not available with open-shell SAPT0. A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results::. SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed with ; SAPT0/aug-cc-pVDZ. . .. index:: ; pair: SAPT; output. Monomer-Centered Basis Computations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Th",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:30610,Energy Efficiency,charge,charge-transfer,30610,"d Keywords Controlling MP2 NO Approximations; .. comment ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. comment .. include:: autodir_options_c/sapt__nat_orbs_t2.rst. .. index:: SAPT; charge-transfer. .. _`sec:saptct`:. Charge-Transfer in SAPT; ^^^^^^^^^^^^^^^^^^^^^^^. It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy ; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201]_. Charge-transfer energies can be obtained from the following calls to the; energy function. ::. energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'); energy('sapt2+(ccd)-ct'); energy('sapt2+(3)(ccd)-ct'); energy('sapt2+3(ccd)-ct'). For now, charge transfer computations are not available with open-shell SAPT0. A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results::. SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed with ; SAPT0/aug-cc-pVDZ. . .. index:: ; pair: SAPT; output. Monomer-Centered Basis Computations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The charge-transfer analysis above is carried out by taking the; difference between SAPT induction as calculated in the dimer-centered; basis (*i.e.*, each ",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:30968,Energy Efficiency,charge,charge-transfer,30968,"in SAPT; ^^^^^^^^^^^^^^^^^^^^^^^. It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy ; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201]_. Charge-transfer energies can be obtained from the following calls to the; energy function. ::. energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'); energy('sapt2+(ccd)-ct'); energy('sapt2+(3)(ccd)-ct'); energy('sapt2+3(ccd)-ct'). For now, charge transfer computations are not available with open-shell SAPT0. A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results::. SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed with ; SAPT0/aug-cc-pVDZ. . .. index:: ; pair: SAPT; output. Monomer-Centered Basis Computations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The charge-transfer analysis above is carried out by taking the; difference between SAPT induction as calculated in the dimer-centered; basis (*i.e.*, each monomer sees the basis functions on both monomers); vs. the monomer-centered basis (*i.e.*, each monomer utilizes only its; own basis set). It is also possible to run a closed-shell SAPT computation at any; level using only the monomer-centere",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:31565,Energy Efficiency,charge,charge-transfer,31565,"s will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results::. SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed with ; SAPT0/aug-cc-pVDZ. . .. index:: ; pair: SAPT; output. Monomer-Centered Basis Computations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The charge-transfer analysis above is carried out by taking the; difference between SAPT induction as calculated in the dimer-centered; basis (*i.e.*, each monomer sees the basis functions on both monomers); vs. the monomer-centered basis (*i.e.*, each monomer utilizes only its; own basis set). It is also possible to run a closed-shell SAPT computation at any; level using only the monomer-centered basis. To do this, simply add; ``sapt_basis='monomer'`` to the energy function, such as ::. energy('sapt2',sapt_basis='monomer'). This procedure leads to faster compuations, but it converges more slowly; towards the complete basis set limit than the default procedure, which uses; the dimer-centered basis set. Hence, monomer-centered basis SAPT; computations are not recommended. The open-shell SAPT0 code is not; compatible yet with monomer-centered computations. Computations with Mid-bonds; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. SAPT computations with midbonds can be accomplished by adding a third ghost; monomer to the computation. For example ::. molecule dimer {; 0 1; He ",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:32025,Energy Efficiency,energy,energy,32025,"nsfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed with ; SAPT0/aug-cc-pVDZ. . .. index:: ; pair: SAPT; output. Monomer-Centered Basis Computations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The charge-transfer analysis above is carried out by taking the; difference between SAPT induction as calculated in the dimer-centered; basis (*i.e.*, each monomer sees the basis functions on both monomers); vs. the monomer-centered basis (*i.e.*, each monomer utilizes only its; own basis set). It is also possible to run a closed-shell SAPT computation at any; level using only the monomer-centered basis. To do this, simply add; ``sapt_basis='monomer'`` to the energy function, such as ::. energy('sapt2',sapt_basis='monomer'). This procedure leads to faster compuations, but it converges more slowly; towards the complete basis set limit than the default procedure, which uses; the dimer-centered basis set. Hence, monomer-centered basis SAPT; computations are not recommended. The open-shell SAPT0 code is not; compatible yet with monomer-centered computations. Computations with Mid-bonds; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. SAPT computations with midbonds can be accomplished by adding a third ghost; monomer to the computation. For example ::. molecule dimer {; 0 1; He 0 0 5; --; 0 1; He 0 0 -5; --; 0 1; @He 0 0 0; }. Here the functions of the third monomer will be added to the virtual space of; the entire computation. Note that an error will be thrown if each atom in the; third monomer is not a ghost to prevent confusion with three-body SAPT which is; not currently supported by Psi4. Interpreting SAPT Results; ^^^^^^^^^^^^^^^^^^^^^^^^^. W",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:32054,Energy Efficiency,energy,energy,32054,"--------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed with ; SAPT0/aug-cc-pVDZ. . .. index:: ; pair: SAPT; output. Monomer-Centered Basis Computations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The charge-transfer analysis above is carried out by taking the; difference between SAPT induction as calculated in the dimer-centered; basis (*i.e.*, each monomer sees the basis functions on both monomers); vs. the monomer-centered basis (*i.e.*, each monomer utilizes only its; own basis set). It is also possible to run a closed-shell SAPT computation at any; level using only the monomer-centered basis. To do this, simply add; ``sapt_basis='monomer'`` to the energy function, such as ::. energy('sapt2',sapt_basis='monomer'). This procedure leads to faster compuations, but it converges more slowly; towards the complete basis set limit than the default procedure, which uses; the dimer-centered basis set. Hence, monomer-centered basis SAPT; computations are not recommended. The open-shell SAPT0 code is not; compatible yet with monomer-centered computations. Computations with Mid-bonds; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. SAPT computations with midbonds can be accomplished by adding a third ghost; monomer to the computation. For example ::. molecule dimer {; 0 1; He 0 0 5; --; 0 1; He 0 0 -5; --; 0 1; @He 0 0 0; }. Here the functions of the third monomer will be added to the virtual space of; the entire computation. Note that an error will be thrown if each atom in the; third monomer is not a ghost to prevent confusion with three-body SAPT which is; not currently supported by Psi4. Interpreting SAPT Results; ^^^^^^^^^^^^^^^^^^^^^^^^^. We will examine the results of a SAPT2+3/aug-cc-pVDZ computati",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:33531,Energy Efficiency,energy,energy,33531,"^^^^^^^^^^^^^^^^^^^^^^. SAPT computations with midbonds can be accomplished by adding a third ghost; monomer to the computation. For example ::. molecule dimer {; 0 1; He 0 0 5; --; 0 1; He 0 0 -5; --; 0 1; @He 0 0 0; }. Here the functions of the third monomer will be added to the virtual space of; the entire computation. Note that an error will be thrown if each atom in the; third monomer is not a ghost to prevent confusion with three-body SAPT which is; not currently supported by Psi4. Interpreting SAPT Results; ^^^^^^^^^^^^^^^^^^^^^^^^^. We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following ; input::. molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561; units angstrom; }; ; set globals {; basis aug-cc-pvdz; guess sad; scf_type df; }; ; set sapt {; print 1; nat_orbs_t2 true; freeze_core true; }; ; energy('sapt2+3'). To reiterate some of the options mentioned above: the; |sapt__nat_orbs_t2| option will compute MP2 natural orbitals and use; them in the evaluation of the triples correction to dispersion, and the; |sapt__freeze_core| option will freeze the core throughout the SAPT; computation. This SAPT2+3/aug-cc-pVDZ computation produces the following; results::. SAPT Results; --------------------------------------------------------------------------------------------------------; Electrostatics -13.06509118 [mEh] -8.19846883 [kcal/mol] -34.30239689 [kJ/mol]; Elst10,r -13.37542977 [mEh] -8.39320925 [kcal/mol] -35.11719087 [kJ/mol]; Elst12,r 0.04490350 [mEh] 0.02817737 [kcal/mol] 0.11789413 [kJ/mol]; Elst13,r 0.26543510 [mEh] 0.16656305 [kcal/mol] 0.69689985 [kJ/mol]. Exchange 13.41768202 [mEh] 8.41972294 [kcal/mol] 35.22812415 [kJ/mol]; Exch10 11.21822294 [mEh] 7.03954147 [kcal/mol] 29.45344432 [kJ/mol]; Exch10(S^",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:38423,Energy Efficiency,energy,energy,38423,"electrostatics, exchange, induction, and dispersion) represent what we; regard as the best estimate available at a given level of SAPT computed; from a subset of the terms of that grouping. The groupings shown above are; not unique and are certainly not rigorously defined. We regard the groupings ; used in |PSIfour| as a ""chemist's grouping"" as opposed to a more; mathematically based grouping, which would group all exchange terms ; (*i.e.* :math:`E_{exch-ind,resp}^{(20)}`, :math:`E_{exch-disp}^{(20)}`, *etc.*) in; the exchange component. A final note is that both ``Disp22(T)``; and ``Est.Disp22(T)`` results appear if MP2 natural orbitals are ; used to evaluate the triples correction to dispersion. The ``Disp22(T)`` ; result is the triples correction as computed in the truncated NO basis; ; ``Est.Disp22(T)`` is a scaled result that attempts to recover; the effect of the truncated virtual space and is our best estimate. The ``Est.Disp22(T)``; value is used in the SAPT energy and dispersion component (see [Hohenstein:2010:104107]_ ; for details). Finally, this part of the output file contains sSAPT0, a special scaling; scheme of the SAPT0 energy that can yield improved results and was described in more details; above. The corresponding scaled total component energies are printed as well. As mentioned above, SAPT results with scaled exchange are also optionally available; by setting the |sapt__exch_scale_alpha| keyword. When activated, the unscaled results are; printed first as reported above, and then repeated with exchange scaling for all ; relevant terms: :: . SAPT Results ==> ALL S2 TERMS SCALED (see Manual) <==. Scaling factor (Exch10/Exch10(S^2))^{Alpha} = 1.007200; with Alpha = 1.000000; --------------------------------------------------------------------------------------------------------; Electrostatics -13.06509118 [mEh] -8.19846883 [kcal/mol] -34.30239689 [kJ/mol]; Elst10,r -13.37542977 [mEh] -8.39320925 [kcal/mol] -35.11719087 [kJ/mol]; Elst12,r 0.04490350 [",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:38596,Energy Efficiency,energy,energy,38596,"rom a subset of the terms of that grouping. The groupings shown above are; not unique and are certainly not rigorously defined. We regard the groupings ; used in |PSIfour| as a ""chemist's grouping"" as opposed to a more; mathematically based grouping, which would group all exchange terms ; (*i.e.* :math:`E_{exch-ind,resp}^{(20)}`, :math:`E_{exch-disp}^{(20)}`, *etc.*) in; the exchange component. A final note is that both ``Disp22(T)``; and ``Est.Disp22(T)`` results appear if MP2 natural orbitals are ; used to evaluate the triples correction to dispersion. The ``Disp22(T)`` ; result is the triples correction as computed in the truncated NO basis; ; ``Est.Disp22(T)`` is a scaled result that attempts to recover; the effect of the truncated virtual space and is our best estimate. The ``Est.Disp22(T)``; value is used in the SAPT energy and dispersion component (see [Hohenstein:2010:104107]_ ; for details). Finally, this part of the output file contains sSAPT0, a special scaling; scheme of the SAPT0 energy that can yield improved results and was described in more details; above. The corresponding scaled total component energies are printed as well. As mentioned above, SAPT results with scaled exchange are also optionally available; by setting the |sapt__exch_scale_alpha| keyword. When activated, the unscaled results are; printed first as reported above, and then repeated with exchange scaling for all ; relevant terms: :: . SAPT Results ==> ALL S2 TERMS SCALED (see Manual) <==. Scaling factor (Exch10/Exch10(S^2))^{Alpha} = 1.007200; with Alpha = 1.000000; --------------------------------------------------------------------------------------------------------; Electrostatics -13.06509118 [mEh] -8.19846883 [kcal/mol] -34.30239689 [kJ/mol]; Elst10,r -13.37542977 [mEh] -8.39320925 [kcal/mol] -35.11719087 [kJ/mol]; Elst12,r 0.04490350 [mEh] 0.02817737 [kcal/mol] 0.11789413 [kJ/mol]; Elst13,r 0.26543510 [mEh] 0.16656305 [kcal/mol] 0.69689985 [kJ/mol]. Exchange sc. 13.43351854 [mEh",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:44125,Energy Efficiency,energy,energy,44125,"`, there is; no workaround; on-the-fly construction of an auxiliary basis through; Cholesky decomposition (not implemented) is the long-term solution. .. _`sec:sfsapt`:. Spin-Flip SAPT; ^^^^^^^^^^^^^^. SAPT0 with two open-shell references will always yield a high-spin complex. In; order to obtain a SAPT-based estimate of the splittings between different spin; states of a complex the first-order exchange energies for all multiplets can be; shown to be a linear combination of two matrix elements: a diagonal exchange; term that determines the spin-averaged effect and a spin-flip term responsible; for the splittings between the states. The numerical factors in this linear; combination are determined solely by the Clebsch-Gordan coefficients:; accordingly, the :math:`S^{2}` approximation implies a Heisenberg Hamiltonian; picture with a single coupling strength parameter determining all the; splittings. This method can be invoked with `energy(""SF-SAPT"")` and; publications resulting from the use of the SF-SAPT code should cite the; following publications: [Patkowski:2018:164110]_. .. _`sec:saptinf`:. Higher-Order Exchange Terms without Single-Exchange Approximation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Recently, several SAPT higher-order exchange terms have been derived without; the :math:`S^{2}` approximation: :math:`E_{exch-ind}^{(20)}` [Schaffer:2012:1235]_, ; :math:`E_{exch-disp}^{(20)}` [Schaffer:2013:2570]_, and :math:`E_{exch-ind}^{(30)}` ; [Waldrop:2021:024103]_. The second-order terms can be computed with the following; settings::. set SAPT_DFT_FUNCTIONAL HF; set DO_IND_EXCH_SINF true # calculate Exch-Ind20 (S^inf) ; set SAPT_DFT_MP2_DISP_ALG fisapt ; set DO_DISP_EXCH_SINF true # calculate Exch-Disp20 (S^inf); energy('sapt(dft)'); ; and the third-order exchange-induction term is computed as follows::. set DO_IND30_EXCH_SINF true # calculate Exch-Ind30 (S^inf) ; energy('sapt2+3'); ; These calculations are performed with the atomic orbi",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:44953,Energy Efficiency,energy,energy,44953,"-Gordan coefficients:; accordingly, the :math:`S^{2}` approximation implies a Heisenberg Hamiltonian; picture with a single coupling strength parameter determining all the; splittings. This method can be invoked with `energy(""SF-SAPT"")` and; publications resulting from the use of the SF-SAPT code should cite the; following publications: [Patkowski:2018:164110]_. .. _`sec:saptinf`:. Higher-Order Exchange Terms without Single-Exchange Approximation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Recently, several SAPT higher-order exchange terms have been derived without; the :math:`S^{2}` approximation: :math:`E_{exch-ind}^{(20)}` [Schaffer:2012:1235]_, ; :math:`E_{exch-disp}^{(20)}` [Schaffer:2013:2570]_, and :math:`E_{exch-ind}^{(30)}` ; [Waldrop:2021:024103]_. The second-order terms can be computed with the following; settings::. set SAPT_DFT_FUNCTIONAL HF; set DO_IND_EXCH_SINF true # calculate Exch-Ind20 (S^inf) ; set SAPT_DFT_MP2_DISP_ALG fisapt ; set DO_DISP_EXCH_SINF true # calculate Exch-Disp20 (S^inf); energy('sapt(dft)'); ; and the third-order exchange-induction term is computed as follows::. set DO_IND30_EXCH_SINF true # calculate Exch-Ind30 (S^inf) ; energy('sapt2+3'); ; These calculations are performed with the atomic orbital and ; density-fitting scheme described in the Supplementary Material to; [Smith:2020:184108]_ for the second-order terms and in [Waldrop:2021:024103]_; for the third-order exchange induction. The coupled (response) version of the; exchange-induction corrections are also calculated, exactly for ; :math:`E_{exch-ind,resp}^{(20)}` and by scaling the uncoupled term for; :math:`E_{exch-ind,resp}^{(30)}`. S^inf Keywords; ~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__do_ind_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_disp_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_ind30_exch_sinf.rst. .. _`sec:saptd`:. SAPT0-D; ~~~~~~~. In SAPT0, the computation of :math:`E_{disp}^{(20)} + E_{exch-disp}^{(20",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:45107,Energy Efficiency,energy,energy,45107,"d cite the; following publications: [Patkowski:2018:164110]_. .. _`sec:saptinf`:. Higher-Order Exchange Terms without Single-Exchange Approximation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Recently, several SAPT higher-order exchange terms have been derived without; the :math:`S^{2}` approximation: :math:`E_{exch-ind}^{(20)}` [Schaffer:2012:1235]_, ; :math:`E_{exch-disp}^{(20)}` [Schaffer:2013:2570]_, and :math:`E_{exch-ind}^{(30)}` ; [Waldrop:2021:024103]_. The second-order terms can be computed with the following; settings::. set SAPT_DFT_FUNCTIONAL HF; set DO_IND_EXCH_SINF true # calculate Exch-Ind20 (S^inf) ; set SAPT_DFT_MP2_DISP_ALG fisapt ; set DO_DISP_EXCH_SINF true # calculate Exch-Disp20 (S^inf); energy('sapt(dft)'); ; and the third-order exchange-induction term is computed as follows::. set DO_IND30_EXCH_SINF true # calculate Exch-Ind30 (S^inf) ; energy('sapt2+3'); ; These calculations are performed with the atomic orbital and ; density-fitting scheme described in the Supplementary Material to; [Smith:2020:184108]_ for the second-order terms and in [Waldrop:2021:024103]_; for the third-order exchange induction. The coupled (response) version of the; exchange-induction corrections are also calculated, exactly for ; :math:`E_{exch-ind,resp}^{(20)}` and by scaling the uncoupled term for; :math:`E_{exch-ind,resp}^{(30)}`. S^inf Keywords; ~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__do_ind_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_disp_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_ind30_exch_sinf.rst. .. _`sec:saptd`:. SAPT0-D; ~~~~~~~. In SAPT0, the computation of :math:`E_{disp}^{(20)} + E_{exch-disp}^{(20)}` represents; the computational bottleneck. One can avoid this bottleneck by replacing these; dispersion terms with the empirical D3 corrections developed by Grimme.; ; :ref:`Grimme's dispersion corrections are discussed here. <sec:dftd3>`. The corresponding method, termed SAPT0-D, thus relies on emp",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:47071,Energy Efficiency,energy,energy,47071," scaling the uncoupled term for; :math:`E_{exch-ind,resp}^{(30)}`. S^inf Keywords; ~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__do_ind_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_disp_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_ind30_exch_sinf.rst. .. _`sec:saptd`:. SAPT0-D; ~~~~~~~. In SAPT0, the computation of :math:`E_{disp}^{(20)} + E_{exch-disp}^{(20)}` represents; the computational bottleneck. One can avoid this bottleneck by replacing these; dispersion terms with the empirical D3 corrections developed by Grimme.; ; :ref:`Grimme's dispersion corrections are discussed here. <sec:dftd3>`. The corresponding method, termed SAPT0-D, thus relies on empirically fit parameters; specific to SAPT0/jun-cc-pVDZ. While SAPT0-D can be used with any of the -D ; variants using default parameters optimized for Hartee--Fock interaction energies, ; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]_. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters. ; A simple water dimer computation using SAPT0-D may look like::. 	molecule water_dimer {; 	 0 1; 	 O -1.551007 -0.114520 0.000000; 	 H -1.934259 0.762503 0.000000; 	 H -0.599677 0.040712 0.000000; 	 --; 	 0 1; 	 O 1.350625 0.111469 0.000000; 	 H 1.680398 -0.373741 -0.758561; 	 H 1.680398 -0.373741 0.758561; 	; 	 units angstrom; 	 no_reorient; 	 symmetry c1; 	}; 	; 	set basis jun-cc-pvdz. 	energy('sapt0-d3mbj') # runs the recommended dispersion correction; energy('sapt0-d3') # tests an alternative damping scheme/parameterization. Given the naturally pairwise-atomic nature of these empirical dispersion corrections,; integration with existing FSAPT functionality is also available simply by calling; ``energy(""fsapt0-d3mbj"")``. See :ref:`FSAPT <sec:fisapt>` documentation for more details on using FSAPT; for functional group analyses.; ",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:47139,Energy Efficiency,energy,energy,47139," scaling the uncoupled term for; :math:`E_{exch-ind,resp}^{(30)}`. S^inf Keywords; ~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__do_ind_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_disp_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_ind30_exch_sinf.rst. .. _`sec:saptd`:. SAPT0-D; ~~~~~~~. In SAPT0, the computation of :math:`E_{disp}^{(20)} + E_{exch-disp}^{(20)}` represents; the computational bottleneck. One can avoid this bottleneck by replacing these; dispersion terms with the empirical D3 corrections developed by Grimme.; ; :ref:`Grimme's dispersion corrections are discussed here. <sec:dftd3>`. The corresponding method, termed SAPT0-D, thus relies on empirically fit parameters; specific to SAPT0/jun-cc-pVDZ. While SAPT0-D can be used with any of the -D ; variants using default parameters optimized for Hartee--Fock interaction energies, ; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]_. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters. ; A simple water dimer computation using SAPT0-D may look like::. 	molecule water_dimer {; 	 0 1; 	 O -1.551007 -0.114520 0.000000; 	 H -1.934259 0.762503 0.000000; 	 H -0.599677 0.040712 0.000000; 	 --; 	 0 1; 	 O 1.350625 0.111469 0.000000; 	 H 1.680398 -0.373741 -0.758561; 	 H 1.680398 -0.373741 0.758561; 	; 	 units angstrom; 	 no_reorient; 	 symmetry c1; 	}; 	; 	set basis jun-cc-pvdz. 	energy('sapt0-d3mbj') # runs the recommended dispersion correction; energy('sapt0-d3') # tests an alternative damping scheme/parameterization. Given the naturally pairwise-atomic nature of these empirical dispersion corrections,; integration with existing FSAPT functionality is also available simply by calling; ``energy(""fsapt0-d3mbj"")``. See :ref:`FSAPT <sec:fisapt>` documentation for more details on using FSAPT; for functional group analyses.; ",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:47386,Energy Efficiency,energy,energy,47386," scaling the uncoupled term for; :math:`E_{exch-ind,resp}^{(30)}`. S^inf Keywords; ~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__do_ind_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_disp_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_ind30_exch_sinf.rst. .. _`sec:saptd`:. SAPT0-D; ~~~~~~~. In SAPT0, the computation of :math:`E_{disp}^{(20)} + E_{exch-disp}^{(20)}` represents; the computational bottleneck. One can avoid this bottleneck by replacing these; dispersion terms with the empirical D3 corrections developed by Grimme.; ; :ref:`Grimme's dispersion corrections are discussed here. <sec:dftd3>`. The corresponding method, termed SAPT0-D, thus relies on empirically fit parameters; specific to SAPT0/jun-cc-pVDZ. While SAPT0-D can be used with any of the -D ; variants using default parameters optimized for Hartee--Fock interaction energies, ; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]_. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters. ; A simple water dimer computation using SAPT0-D may look like::. 	molecule water_dimer {; 	 0 1; 	 O -1.551007 -0.114520 0.000000; 	 H -1.934259 0.762503 0.000000; 	 H -0.599677 0.040712 0.000000; 	 --; 	 0 1; 	 O 1.350625 0.111469 0.000000; 	 H 1.680398 -0.373741 -0.758561; 	 H 1.680398 -0.373741 0.758561; 	; 	 units angstrom; 	 no_reorient; 	 symmetry c1; 	}; 	; 	set basis jun-cc-pvdz. 	energy('sapt0-d3mbj') # runs the recommended dispersion correction; energy('sapt0-d3') # tests an alternative damping scheme/parameterization. Given the naturally pairwise-atomic nature of these empirical dispersion corrections,; integration with existing FSAPT functionality is also available simply by calling; ``energy(""fsapt0-d3mbj"")``. See :ref:`FSAPT <sec:fisapt>` documentation for more details on using FSAPT; for functional group analyses.; ",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:7110,Integrability,depend,dependent,7110," :math:`V` and in :math:`W_A+W_B`; the; subscript, :math:`resp`, indicates that orbital relaxation effects are included. .. math:: E_{SAPT2} = E_{SAPT0} + E_{elst,resp}^{(12)} + E_{exch}^{(11)} +; E_{exch}^{(12)} + \; ^{t}\!E_{ind}^{(22)} + \; ^{t}\!E_{exch-ind}^{(22)}; :label: SAPT2. .. math:: E_{SAPT2+} = E_{SAPT2} + E_{disp}^{(21)} + E_{disp}^{(22)}; :label: SAPT2p. .. math:: E_{SAPT2+(3)} = E_{SAPT2+} + E_{elst,resp}^{(13)} + E_{disp}^{(30)}; :label: SAPT2pparen3. .. math:: E_{SAPT2+3} = E_{SAPT2+(3)}; + E_{exch-ind}^{(30)} + E_{ind,resp}^{(30)}; + E_{exch-disp}^{(30)} + E_{ind-disp}^{(30)} + E_{exch-ind-disp}^{(30)}; - \delta_{HF}^{(2)} + \delta_{HF}^{(3)}; :label: SAPT2p3. For SAPT(DFT), the SAPT expansion is truncated at the same level of SAPT0, but the zeroth-order Hamiltonian is chosen to be :math:`K_A+K_B`, the monomer Kohn-Sham operators, instead of the Fock operators. The dispersion term needs to be computed with orbital relaxation for the result to be reasonable, and this is possible by computing dispersion energy through coupled frequency-dependent density susceptibility (FDDS). The exchange-dispersion term is estimated by scaling the uncoupled exchange-dispersion energy. . .. math:: E_{SAPT(DFT)} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; E_{exch-ind,resp}^{(20)} + E_{disp,resp}^{(20)} + E_{exch-disp,resp}^{(20)}(est.) + \delta_{HF}^{(2)}; :label: SAPTDFT; .. math:: E_{disp,resp}^{(20)} = -\frac{1}{2\pi}\int_0^\infty d\omega \int d\mathbf{r}_A d\mathbf{r}'_A d\mathbf{r}_B d\mathbf{r}'_B \frac{1}{\left|\mathbf{r}_A-\mathbf{r}_B\right|}\frac{1}{\left|\mathbf{r}'_A-\mathbf{r}'_B\right|}\chi^A_{coup}\left(\mathbf{r}_A,\mathbf{r}'_A|i\omega\right)\chi^B_{coup}\left(\mathbf{r}_B,\mathbf{r}'_B|i\omega\right). .. math:: \chi_{coup}\left(\mathbf{r},\mathbf{r}'|\omega\right) = \chi_0\left(\mathbf{r},\mathbf{r}'|\omega\right) + \int d\omega d\mathbf{r}_1 d\mathbf{r}_2 \chi_0\left(\mathbf{r},\mathbf{r}_1|\omega\right)\left[\frac{1}{r_{12}} + f_{x",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:26690,Integrability,depend,depend,26690,"st; .. include:: autodir_options_c/sapt__sapt_dft_mp2_disp_alg.rst; .. include:: autodir_options_c/sapt__sapt_quiet.rst. .. index:: SAPT; higher-order. Higher-Order SAPT; ^^^^^^^^^^^^^^^^^. For smaller systems (up to the size of a nucleic acid base pair), more; accurate interaction energies can be obtained through higher-order SAPT; computations. The SAPT module can perform density-fitted evaluations; of SAPT2, SAPT2+, SAPT2+(3), and SAPT2+3 energies for closed-shell systems ; only. Publications resulting from the use of the higher-order SAPT code ; should cite the following: ; [Hohenstein:2010:014101]_. For methods SAPT2+ and above, one can replace the many-body treatment of; dispersion by an improved method based on coupled-cluster doubles (CCD).; This approach tends to give good improvements when dispersion effects; are very large, as in the PCCP dimer (see [Hohenstein:2011:2842]_).; As shown in [Parker:2014:094106]_, whether or not CCD dispersion offers; more accurate interaction energies tends to depend on the SAPT truncation; and basis set employed, due to cancellations of errors. Thanks to; natural orbital methods [Parrish:2013:174102]_, the SAPT code; is able to include CCD dispersion with only a modest additional cost.; Computations employing CCD dispersion should cite [Parrish:2013:174102]_. ; To request CCD dispersion treatment in a SAPT computation, simply append; ``(ccd)`` to the name of the method, as in the following examples ::. 	energy('sapt2+(ccd)'); 	energy('sapt2+(3)(ccd)'); 	energy('sapt2+3(ccd)'). The :math:`\delta_{MP2}` corrections can also be computed automatically; by appending ``dmp2`` to the name of the method, with or without CCD dispersion ::. 	energy('sapt2+dmp2'); 	energy('sapt2+(3)dmp2'); 	energy('sapt2+3dmp2'); 	energy('sapt2+(ccd)dmp2'); 	energy('sapt2+(3)(ccd)dmp2'); 	energy('sapt2+3(ccd)dmp2'). A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficie",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:47301,Integrability,integrat,integration,47301," scaling the uncoupled term for; :math:`E_{exch-ind,resp}^{(30)}`. S^inf Keywords; ~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__do_ind_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_disp_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_ind30_exch_sinf.rst. .. _`sec:saptd`:. SAPT0-D; ~~~~~~~. In SAPT0, the computation of :math:`E_{disp}^{(20)} + E_{exch-disp}^{(20)}` represents; the computational bottleneck. One can avoid this bottleneck by replacing these; dispersion terms with the empirical D3 corrections developed by Grimme.; ; :ref:`Grimme's dispersion corrections are discussed here. <sec:dftd3>`. The corresponding method, termed SAPT0-D, thus relies on empirically fit parameters; specific to SAPT0/jun-cc-pVDZ. While SAPT0-D can be used with any of the -D ; variants using default parameters optimized for Hartee--Fock interaction energies, ; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]_. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters. ; A simple water dimer computation using SAPT0-D may look like::. 	molecule water_dimer {; 	 0 1; 	 O -1.551007 -0.114520 0.000000; 	 H -1.934259 0.762503 0.000000; 	 H -0.599677 0.040712 0.000000; 	 --; 	 0 1; 	 O 1.350625 0.111469 0.000000; 	 H 1.680398 -0.373741 -0.758561; 	 H 1.680398 -0.373741 0.758561; 	; 	 units angstrom; 	 no_reorient; 	 symmetry c1; 	}; 	; 	set basis jun-cc-pvdz. 	energy('sapt0-d3mbj') # runs the recommended dispersion correction; energy('sapt0-d3') # tests an alternative damping scheme/parameterization. Given the naturally pairwise-atomic nature of these empirical dispersion corrections,; integration with existing FSAPT functionality is also available simply by calling; ``energy(""fsapt0-d3mbj"")``. See :ref:`FSAPT <sec:fisapt>` documentation for more details on using FSAPT; for functional group analyses.; ",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:4358,Modifiability,adapt,adapted,4358,"apt0"")`` that; can also compute higher-order SAPT). Electostatics, exchange,; and induction terms for SAPT0 and sSAPT0 accessed through; ``energy(""sapt0"")`` or ``energy(""ssapt0"")`` change; the dispersion; term does not change. The SAPT0 and sSAPT0 terms accessed as; subsidiary calculations of higher-order SAPT do not change; that is,; the :ref:`SAPT module<sec:sapt>` breaks the consistency of its SAPT0; results. The reasoning and reward behind this change is that the JKFIT; basis better describes the physics (see :ref:`fitting changes <sec:saptfitB>` ) and the; default SAPT0 results from the :ref:`SAPT module<sec:sapt>` are now; consistent with those from the :ref:`FISAPT module<sec:fisapt>` and; the sapt(dft) module. See :srcsample:`sapt-compare` for an example.; To reproduce former behavior, set |sapt__df_basis_elst| to the; orbital basis set's RI auxiliary basis. Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: *i.e.*,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the ; Hamiltonian of the dimer is partitioned into contributions from each ; monomer and the interaction. .. math:: H=F_A+W_A+F_B+W_B+V. Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, :math:`F`, the fluctuation potential of each monomer, :math:`W`, and the; interaction potential, :math:`V`. The monomer Fock operators, :math:`F_A+F_B`, are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of :math:`V`, :math:`W_A`, and :math:`W_B`. ; Through first-order in :math:`V`, electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in :math:`V`. ",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:8858,Modifiability,coupling,coupling,8858,"hbf{r}'|\omega\right) + \int d\omega d\mathbf{r}_1 d\mathbf{r}_2 \chi_0\left(\mathbf{r},\mathbf{r}_1|\omega\right)\left[\frac{1}{r_{12}} + f_{xc}\left(\mathbf{r}_1,\mathbf{r}_2,\omega\right)\right]\chi\left(\mathbf{r}_2,\mathbf{r}'|\omega\right). The :math:`\delta_{HF}^{(2)}` and :math:`\delta_{HF}^{(3)}` terms take into; account higher-order induction effects and are included in the definition; of SAPT terms. They are computed from the Hartree--Fock supermolecular interaction energy; :math:`E_{int}^{HF}` and are only available in dimer-centered basis SAPT; computations, which is the default (see below for monomer-centered basis ; computations). They are defined by:. .. math:: \delta_{HF}^{(2)} = E_{int}^{HF} - (E_{elst}^{(10)} + E_{exch}^{(10)} ; + E_{ind,resp}^{(20)} + E_{exch-ind,resp}^{(20)}); :label: dHF2. .. math:: \delta_{HF}^{(3)} = \delta_{HF}^{(2)} - (E_{exch-ind}^{(30)} ; + E_{ind,resp}^{(30)}); :label: dHF3. Additionally, high-order coupling between induction and dispersion can be ; extracted from the supermolecular MP2 interaction energy:. .. math:: \delta_{MP2}^{(2)} = E_{int}^{MP2, corr} - (E_{elst}^{(12)} +; E_{exch}^{(11)} + E_{exch}^{(12)} + \; ^{t}\!E_{ind}^{(22)}; + \; ^{t}\!E_{exch-ind}^{(22)} + E_{disp}^{(20)} + E_{exch-disp}^{(20)}). .. math:: \delta_{MP2}^{(3)} = \delta_{MP2}^{(2)} - (E_{ind-disp}^{(30)} + E_{exch-ind-disp}^{(30)}). where :math:`E_{int}^{MP2, corr}` is the correlation part of the supermolecular MP2 ; interaction energy. :math:`\delta_{MP2}^{(2)}` and :math:`\delta_{MP2}^{(3)}` also improve the ; description of electrostatically dominated complexes. :math:`\delta_{MP2}^{(2)}`; can be applied to SAPT2+ or SAPT2+(3) energies whereas :math:`\delta_{MP2}^{(3)}` ; should be applied to SAPT2+3 energies. A thorough analysis of the performance of these truncations of closed-shell SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs]_,; and a systematic study of the accuracy of these truncations (with and ; w",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:11117,Modifiability,coupling,coupling,11117," integrals. The factorization of the SAPT energy; expressions, as implemented in |PSIfour|, assumes the use of density-fitted; two-electron integrals, therefore, the closed-shell SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligible errors into the SAPT energy ; (often less than 0.01 kcal/mol for small dimers) and greatly; improves efficiency. . The latest addition to the SAPT code is the SAPT0 method for open-shell ; monomers [Gonthier:2016:134106]_. This code is available for both exact and density fitted integrals, ; except for the dispersion terms which implementation relies on a density fitting; factorization. Both ``UHF`` and ``ROHF`` |scf__reference| can be used, but coupled; induction computations are currently not supported with ``ROHF``. This means that orbital; relaxation is not included for ``ROHF`` and the uncoupled induction term is computed instead.; If both monomers are open-shell, their coupling is assumed to be high spin, i.e.; two doublets would interact to form a triplet. The *S*\ :superscript:`2` approximation and scaling; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. All exchange terms in SAPT arise from the antisymmetrization; of the wavefunctions of monomers A and B. Taking into account exchange of all possible; electron pairs between the two monomers yields to complicated formulae.; For this reason, exchange terms are often evaluated in the :math:`S^{2}`; approximation, that can be interpreted as the exchange of a single electron ; pair between monomers. The :math:`S^{2}` approximation is usually pretty good, but may ; break down for short intermolecular distance, particularly in high-order; terms. To compensate for these deviations, in 2014 Parker et al. [Parker:2014:094106]_ ; recommended to scale all :math:`S^{2}` approximated exchange terms by the ratio:. .. math:: p_{EX}(\alpha) = \left( \frac{E_{exch}^{(10)}}{E_{exch}^{(10)}(S^{2})} \right)^{\alp",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:43114,Modifiability,flexible,flexible,43114,"0072``) together with the ; :math:`\alpha` parameter. All terms that are scaled are indicated by the ``sc.``; label. Note that if Exch10 is less than :math:`10^{-5}`, the scaling factor is; set to :math:`1.0`. .. _`sec:saptfitB`:. .. caution:: To density fit the dispersion terms in SAPT, the RI auxiliary; basis set (*e.g.*, aug-cc-pVDZ-RI) controlled through; |sapt__df_basis_sapt| performs well. For Fock-type terms (*i.e.*,; electrostatics, exchange, induction, and core Fock matrix elements in; exchange-dispersion), the JKFIT density-fitting auxiliary basis; (*e.g.*, aug-cc-pVDZ-JKFIT) is more appropriate. The :ref:`FISAPT; module<sec:fisapt>` has always used JKFIT in this role. The; :ref:`SAPT module<sec:sapt>` newly (see :ref:`fitting notes <sec:saptfitA>` ) uses; JKFIT for computations targeting SAPT0 and sSAPT0 methods. But the; :ref:`SAPT module<sec:sapt>` still uses the RI basis for higher-order; SAPT. For heavier elements (*i.e.*, second-row and beyond), the RI; auxiliary basis is unsound for this role (insufficiently flexible).; For higher-order methods in :ref:`SAPT module<sec:sapt>`, there is; no workaround; on-the-fly construction of an auxiliary basis through; Cholesky decomposition (not implemented) is the long-term solution. .. _`sec:sfsapt`:. Spin-Flip SAPT; ^^^^^^^^^^^^^^. SAPT0 with two open-shell references will always yield a high-spin complex. In; order to obtain a SAPT-based estimate of the splittings between different spin; states of a complex the first-order exchange energies for all multiplets can be; shown to be a linear combination of two matrix elements: a diagonal exchange; term that determines the spin-averaged effect and a spin-flip term responsible; for the splittings between the states. The numerical factors in this linear; combination are determined solely by the Clebsch-Gordan coefficients:; accordingly, the :math:`S^{2}` approximation implies a Heisenberg Hamiltonian; picture with a single coupling strength parameter determining al",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:44031,Modifiability,coupling,coupling,44031,"es the RI basis for higher-order; SAPT. For heavier elements (*i.e.*, second-row and beyond), the RI; auxiliary basis is unsound for this role (insufficiently flexible).; For higher-order methods in :ref:`SAPT module<sec:sapt>`, there is; no workaround; on-the-fly construction of an auxiliary basis through; Cholesky decomposition (not implemented) is the long-term solution. .. _`sec:sfsapt`:. Spin-Flip SAPT; ^^^^^^^^^^^^^^. SAPT0 with two open-shell references will always yield a high-spin complex. In; order to obtain a SAPT-based estimate of the splittings between different spin; states of a complex the first-order exchange energies for all multiplets can be; shown to be a linear combination of two matrix elements: a diagonal exchange; term that determines the spin-averaged effect and a spin-flip term responsible; for the splittings between the states. The numerical factors in this linear; combination are determined solely by the Clebsch-Gordan coefficients:; accordingly, the :math:`S^{2}` approximation implies a Heisenberg Hamiltonian; picture with a single coupling strength parameter determining all the; splittings. This method can be invoked with `energy(""SF-SAPT"")` and; publications resulting from the use of the SF-SAPT code should cite the; following publications: [Patkowski:2018:164110]_. .. _`sec:saptinf`:. Higher-Order Exchange Terms without Single-Exchange Approximation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Recently, several SAPT higher-order exchange terms have been derived without; the :math:`S^{2}` approximation: :math:`E_{exch-ind}^{(20)}` [Schaffer:2012:1235]_, ; :math:`E_{exch-disp}^{(20)}` [Schaffer:2013:2570]_, and :math:`E_{exch-ind}^{(30)}` ; [Waldrop:2021:024103]_. The second-order terms can be computed with the following; settings::. set SAPT_DFT_FUNCTIONAL HF; set DO_IND_EXCH_SINF true # calculate Exch-Ind20 (S^inf) ; set SAPT_DFT_MP2_DISP_ALG fisapt ; set DO_DISP_EXCH_SINF true # calculate Exch-Disp20 (S^inf); ene",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:47196,Modifiability,parameteriz,parameterization,47196," scaling the uncoupled term for; :math:`E_{exch-ind,resp}^{(30)}`. S^inf Keywords; ~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__do_ind_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_disp_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_ind30_exch_sinf.rst. .. _`sec:saptd`:. SAPT0-D; ~~~~~~~. In SAPT0, the computation of :math:`E_{disp}^{(20)} + E_{exch-disp}^{(20)}` represents; the computational bottleneck. One can avoid this bottleneck by replacing these; dispersion terms with the empirical D3 corrections developed by Grimme.; ; :ref:`Grimme's dispersion corrections are discussed here. <sec:dftd3>`. The corresponding method, termed SAPT0-D, thus relies on empirically fit parameters; specific to SAPT0/jun-cc-pVDZ. While SAPT0-D can be used with any of the -D ; variants using default parameters optimized for Hartee--Fock interaction energies, ; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]_. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters. ; A simple water dimer computation using SAPT0-D may look like::. 	molecule water_dimer {; 	 0 1; 	 O -1.551007 -0.114520 0.000000; 	 H -1.934259 0.762503 0.000000; 	 H -0.599677 0.040712 0.000000; 	 --; 	 0 1; 	 O 1.350625 0.111469 0.000000; 	 H 1.680398 -0.373741 -0.758561; 	 H 1.680398 -0.373741 0.758561; 	; 	 units angstrom; 	 no_reorient; 	 symmetry c1; 	}; 	; 	set basis jun-cc-pvdz. 	energy('sapt0-d3mbj') # runs the recommended dispersion correction; energy('sapt0-d3') # tests an alternative damping scheme/parameterization. Given the naturally pairwise-atomic nature of these empirical dispersion corrections,; integration with existing FSAPT functionality is also available simply by calling; ``energy(""fsapt0-d3mbj"")``. See :ref:`FSAPT <sec:fisapt>` documentation for more details on using FSAPT; for functional group analyses.; ",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:9693,Performance,perform,performance,9693,"onally, high-order coupling between induction and dispersion can be ; extracted from the supermolecular MP2 interaction energy:. .. math:: \delta_{MP2}^{(2)} = E_{int}^{MP2, corr} - (E_{elst}^{(12)} +; E_{exch}^{(11)} + E_{exch}^{(12)} + \; ^{t}\!E_{ind}^{(22)}; + \; ^{t}\!E_{exch-ind}^{(22)} + E_{disp}^{(20)} + E_{exch-disp}^{(20)}). .. math:: \delta_{MP2}^{(3)} = \delta_{MP2}^{(2)} - (E_{ind-disp}^{(30)} + E_{exch-ind-disp}^{(30)}). where :math:`E_{int}^{MP2, corr}` is the correlation part of the supermolecular MP2 ; interaction energy. :math:`\delta_{MP2}^{(2)}` and :math:`\delta_{MP2}^{(3)}` also improve the ; description of electrostatically dominated complexes. :math:`\delta_{MP2}^{(2)}`; can be applied to SAPT2+ or SAPT2+(3) energies whereas :math:`\delta_{MP2}^{(3)}` ; should be applied to SAPT2+3 energies. A thorough analysis of the performance of these truncations of closed-shell SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs]_,; and a systematic study of the accuracy of these truncations (with and ; without an improved CCD treatment of dispersion) using different basis sets; is reported in [Parker:2014:094106]_. The closed-shell SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in |PSIfour|, assumes the use of density-fitted; two-electron integrals, therefore, the closed-shell SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligible errors into the SAPT energy ; (often less than 0.01 kcal/mol for small dimers) and greatly; improves efficiency. . The latest addition to the SAPT code is the SAPT0 method for open-shell ; monomers [Gonthier:2016:134106]_. This code is available for both exact and density fitted integrals, ; except for the dispersion terms which implementation relies on a density fitting; factorization. Both ``UHF`` and",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:13717,Performance,perform,performed,13717,")/E_{\rm exch-ind}^{(2)}`, and ; :math:`E_{\rm exch-disp}^{(2)}(S^2)/E_{\rm exch-disp}^{(2)}` are not very similar to; each other. Hence, in 2016 universal scaling of all :math:`S^{2}` approximated terms; was turned off by default. Finally, in 2014 Parker et al. [Parker:2014:094106]_ empirically discovered that ; SAPT0 energies for van der Waals dimers with close contacts benefit from a slightly modified ; recipe that involves an empirically adjusted exponent :math:`\alpha = 3.0`. ; To distinguish it from its unscaled counterpart, this energy is denoted sSAPT0 (see [Parker:2014:094106]_). .. math:: E_{sSAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; p_{EX}(3.0) E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + p_{EX}(3.0) E_{exch-disp}^{(20)} ; + \delta_{HF}^{(2)}; :label: sSAPT0. where :math:`\delta_{HF}^{(2)}` is computed *without* any scaling. Please note that ; sSAPT0 is thus not the same as requesting ``exch_scale_alpha 3.0``, and that the; scaling is automatically performed by requesting ``energy('ssapt0')``. A First Example; ^^^^^^^^^^^^^^^. The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods,; not all of them). ::. 	molecule water_dimer {; 	 0 1; 	 O -1.551007 -0.114520 0.000000; 	 H -1.934259 0.762503 0.000000; 	 H -0.599677 0.040712 0.000000; 	 --; 	 0 1; 	 O 1.350625 0.111469 0.000000; 	 H 1.680398 -0.373741 -0.758561; 	 H 1.680398 -0.373741 0.758561; 	; 	 units angstrom; 	 no_reorient; 	 symmetry c1; 	}; 	; 	set basis aug-cc-pvdz; 	; 	energy('sapt0'); 	energy('sapt2'); 	energy('sapt2+'); 	energy('sapt2+(3)'); 	energy('sapt2+3'). The SAPT module uses the standard |PSIfour| partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with ",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:13852,Performance,perform,perform,13852,"ing of all :math:`S^{2}` approximated terms; was turned off by default. Finally, in 2014 Parker et al. [Parker:2014:094106]_ empirically discovered that ; SAPT0 energies for van der Waals dimers with close contacts benefit from a slightly modified ; recipe that involves an empirically adjusted exponent :math:`\alpha = 3.0`. ; To distinguish it from its unscaled counterpart, this energy is denoted sSAPT0 (see [Parker:2014:094106]_). .. math:: E_{sSAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; p_{EX}(3.0) E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + p_{EX}(3.0) E_{exch-disp}^{(20)} ; + \delta_{HF}^{(2)}; :label: sSAPT0. where :math:`\delta_{HF}^{(2)}` is computed *without* any scaling. Please note that ; sSAPT0 is thus not the same as requesting ``exch_scale_alpha 3.0``, and that the; scaling is automatically performed by requesting ``energy('ssapt0')``. A First Example; ^^^^^^^^^^^^^^^. The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods,; not all of them). ::. 	molecule water_dimer {; 	 0 1; 	 O -1.551007 -0.114520 0.000000; 	 H -1.934259 0.762503 0.000000; 	 H -0.599677 0.040712 0.000000; 	 --; 	 0 1; 	 O 1.350625 0.111469 0.000000; 	 H 1.680398 -0.373741 -0.758561; 	 H 1.680398 -0.373741 0.758561; 	; 	 units angstrom; 	 no_reorient; 	 symmetry c1; 	}; 	; 	set basis aug-cc-pvdz; 	; 	energy('sapt0'); 	energy('sapt2'); 	energy('sapt2+'); 	energy('sapt2+(3)'); 	energy('sapt2+3'). The SAPT module uses the standard |PSIfour| partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the ``no_reorient`` and ``symmetry; c1`` molecule keywords, as in the example above. As a reminder, only; SAPT0 can handle the interaction of both closed- and o",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:17692,Performance,perform,performing,17692,"ove, the SAPT0 module for open-shell cases can also; use exact integrals for all terms except for dispersion. In practice,; density fitting is considerably faster and introduces negligible errors, thus; it is the preferred method for open-shell cases as well.; Below, you can find a minimum example of open-shell SAPT0 computation. ::. molecule {; 0 1; O 0.000000 0.000000 6.000000; H 0.000000 1.431500 4.890600; H 0.000000 -1.431500 4.890600; --; 0 2; O 0.000000 0.000000 0.000000; O 0.000000 2.503900 0.000000; H 0.000000 -0.424700 -1.839500; units bohr; symmetry c1; no_reorient; no_com; }; ; set {; reference uhf; scf_type df; basis aug-cc-pVDZ; }; ; energy('sapt0'); ; . |scf__reference| needs to be ``UHF`` or ``ROHF`` for the open-shell computation to proceed. Advanced example; ^^^^^^^^^^^^^^^^. Open-shell computations can be difficult to converge in certain cases, thus you may; want to have more control over the SCF procedure. You have the option of ; doing the driver job in the input file, by performing the dimer and monomer computations; yourself. In the example below, we do a stability analysis for the open-shell monomer only ::. molecule {; 0 2; O 0.000000 0.000000 0.000000; O 0.000000 2.503900 0.000000; H 0.000000 -0.424700 -1.839500; --; 0 1; O 0.000000 0.000000 6.000000; H 0.000000 1.431500 4.890600; H 0.000000 -1.431500 4.890600; units bohr; symmetry c1; no_reorient; no_com; }; ; dimer = psi4.get_active_molecule() ; ; set {; reference uhf; scf_type df; basis cc-pVDZ; df_basis_sapt cc-pVDZ-ri; guess sad; }; ; dimer = psi4.get_active_molecule(); ; set df_ints_io save; psi4.IO.set_default_namespace('dimer'); Edim, wfn_dimer = energy('scf',molecule=dimer,return_wfn=True); set df_ints_io load; ; monomerA = dimer.extract_subsets(1,2); psi4.IO.change_file_namespace(97, 'dimer', 'monomerA'); psi4.IO.set_default_namespace('monomerA'); set {; stability_analysis follow; }; EmonA, wfn_monA = energy('scf',molecule=monomerA,return_wfn=True); ; monomerB = dimer.extract_subset",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:18403,Performance,load,load,18403," |scf__reference| needs to be ``UHF`` or ``ROHF`` for the open-shell computation to proceed. Advanced example; ^^^^^^^^^^^^^^^^. Open-shell computations can be difficult to converge in certain cases, thus you may; want to have more control over the SCF procedure. You have the option of ; doing the driver job in the input file, by performing the dimer and monomer computations; yourself. In the example below, we do a stability analysis for the open-shell monomer only ::. molecule {; 0 2; O 0.000000 0.000000 0.000000; O 0.000000 2.503900 0.000000; H 0.000000 -0.424700 -1.839500; --; 0 1; O 0.000000 0.000000 6.000000; H 0.000000 1.431500 4.890600; H 0.000000 -1.431500 4.890600; units bohr; symmetry c1; no_reorient; no_com; }; ; dimer = psi4.get_active_molecule() ; ; set {; reference uhf; scf_type df; basis cc-pVDZ; df_basis_sapt cc-pVDZ-ri; guess sad; }; ; dimer = psi4.get_active_molecule(); ; set df_ints_io save; psi4.IO.set_default_namespace('dimer'); Edim, wfn_dimer = energy('scf',molecule=dimer,return_wfn=True); set df_ints_io load; ; monomerA = dimer.extract_subsets(1,2); psi4.IO.change_file_namespace(97, 'dimer', 'monomerA'); psi4.IO.set_default_namespace('monomerA'); set {; stability_analysis follow; }; EmonA, wfn_monA = energy('scf',molecule=monomerA,return_wfn=True); ; monomerB = dimer.extract_subsets(2,1); psi4.IO.change_file_namespace(97, 'monomerA', 'monomerB'); psi4.IO.set_default_namespace('monomerB'); set {; stability_analysis none; }; EmonB, wfn_monB = energy('scf',molecule=monomerB,return_wfn=True); ; psi4.IO.change_file_namespace(97, 'monomerB', 'dimer'); psi4.IO.set_default_namespace('dimer'); ; aux_basis = psi4.core.BasisSet.build(wfn_dimer.molecule(), ""DF_BASIS_SAPT"",; psi4.core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", psi4.core.get_global_option(""BASIS"")); wfn_dimer.set_basisset(""DF_BASIS_SAPT"", aux_basis); wfn_dimer.set_basisset(""DF_BASIS_ELST"", aux_basis); ; psi4.sapt(wfn_dimer,wfn_monA,wfn_monB). In this way, any of the SCF options can be t",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:19556,Performance,load,load,19556,"_monA = energy('scf',molecule=monomerA,return_wfn=True); ; monomerB = dimer.extract_subsets(2,1); psi4.IO.change_file_namespace(97, 'monomerA', 'monomerB'); psi4.IO.set_default_namespace('monomerB'); set {; stability_analysis none; }; EmonB, wfn_monB = energy('scf',molecule=monomerB,return_wfn=True); ; psi4.IO.change_file_namespace(97, 'monomerB', 'dimer'); psi4.IO.set_default_namespace('dimer'); ; aux_basis = psi4.core.BasisSet.build(wfn_dimer.molecule(), ""DF_BASIS_SAPT"",; psi4.core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", psi4.core.get_global_option(""BASIS"")); wfn_dimer.set_basisset(""DF_BASIS_SAPT"", aux_basis); wfn_dimer.set_basisset(""DF_BASIS_ELST"", aux_basis); ; psi4.sapt(wfn_dimer,wfn_monA,wfn_monB). In this way, any of the SCF options can be tweaked for individual fragments.; For optimal efficiency, the example uses ``set df_ints_io save`` to keep file 97,; which contains the three-index integrals for density fitting. ``set df_ints_io load``; then instructs the program to read these integrals from disk instead of recomputing; them. For each SCF computation, we use ``psi4.IO.set_default_namespace`` to uniquely; name scratch files. In the following SCF step, only file 97 is renamed using; ``psi4.IO.change_file_namespace`` so that integrals can be read from it.; For more information on stability analysis, see the :ref:`stability <sec:scfstability_doc>`; documentation. .. index:: SAPT; SAPT0. SAPT0; ^^^^^. Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of closed-shell SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ'). We do not recommend using SAPT0 with large basis sets; like aug-cc-pVTZ. A systematic study of the accuracy of closed-shell SAPT0 and other SAPT ; truncations, using different basis sets, is reported in ; [Parker:2014:094106]_. In particular, an empirical r",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:20119,Performance,perform,performance,20119,"dimer.set_basisset(""DF_BASIS_ELST"", aux_basis); ; psi4.sapt(wfn_dimer,wfn_monA,wfn_monB). In this way, any of the SCF options can be tweaked for individual fragments.; For optimal efficiency, the example uses ``set df_ints_io save`` to keep file 97,; which contains the three-index integrals for density fitting. ``set df_ints_io load``; then instructs the program to read these integrals from disk instead of recomputing; them. For each SCF computation, we use ``psi4.IO.set_default_namespace`` to uniquely; name scratch files. In the following SCF step, only file 97 is renamed using; ``psi4.IO.change_file_namespace`` so that integrals can be read from it.; For more information on stability analysis, see the :ref:`stability <sec:scfstability_doc>`; documentation. .. index:: SAPT; SAPT0. SAPT0; ^^^^^. Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of closed-shell SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ'). We do not recommend using SAPT0 with large basis sets; like aug-cc-pVTZ. A systematic study of the accuracy of closed-shell SAPT0 and other SAPT ; truncations, using different basis sets, is reported in ; [Parker:2014:094106]_. In particular, an empirical recipe for scaled SAPT0; can yield improved performance and has been included in the output file as; the sSAPT0 interaction energy. sSAPT0 is a free by-product and is automatically ; computed when SAPT0 is requested (see above for more details).; The SAPT module has been used to perform SAPT0 computations with over; 200 atoms and 2800 basis functions; this code should be scalable to 4000; basis functions. Publications resulting from the use of the SAPT0 code ; should cite the following publications: [Hohenstein:2010:184111]_ and ; [Hohenstein:2011:174107]_. If the open-shell SAPT0 code is used,; [Gonthier:2016:134106]_ shou",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:20639,Performance,perform,performance,20639,"g; them. For each SCF computation, we use ``psi4.IO.set_default_namespace`` to uniquely; name scratch files. In the following SCF step, only file 97 is renamed using; ``psi4.IO.change_file_namespace`` so that integrals can be read from it.; For more information on stability analysis, see the :ref:`stability <sec:scfstability_doc>`; documentation. .. index:: SAPT; SAPT0. SAPT0; ^^^^^. Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of closed-shell SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ'). We do not recommend using SAPT0 with large basis sets; like aug-cc-pVTZ. A systematic study of the accuracy of closed-shell SAPT0 and other SAPT ; truncations, using different basis sets, is reported in ; [Parker:2014:094106]_. In particular, an empirical recipe for scaled SAPT0; can yield improved performance and has been included in the output file as; the sSAPT0 interaction energy. sSAPT0 is a free by-product and is automatically ; computed when SAPT0 is requested (see above for more details).; The SAPT module has been used to perform SAPT0 computations with over; 200 atoms and 2800 basis functions; this code should be scalable to 4000; basis functions. Publications resulting from the use of the SAPT0 code ; should cite the following publications: [Hohenstein:2010:184111]_ and ; [Hohenstein:2011:174107]_. If the open-shell SAPT0 code is used,; [Gonthier:2016:134106]_ should be additionally cited. Basic SAPT0 Keywords; ~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__sapt_level.rst; .. include:: autodir_options_c/sapt__basis.rst; .. include:: autodir_options_c/sapt__df_basis_sapt.rst; .. include:: autodir_options_c/sapt__df_basis_elst.rst; .. include:: autodir_options_c/sapt__freeze_core.rst; .. include:: autodir_options_c/sapt__d_convergence.rst; .. include:: autodir_option",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:20875,Performance,perform,perform,20875,"analysis, see the :ref:`stability <sec:scfstability_doc>`; documentation. .. index:: SAPT; SAPT0. SAPT0; ^^^^^. Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of closed-shell SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ'). We do not recommend using SAPT0 with large basis sets; like aug-cc-pVTZ. A systematic study of the accuracy of closed-shell SAPT0 and other SAPT ; truncations, using different basis sets, is reported in ; [Parker:2014:094106]_. In particular, an empirical recipe for scaled SAPT0; can yield improved performance and has been included in the output file as; the sSAPT0 interaction energy. sSAPT0 is a free by-product and is automatically ; computed when SAPT0 is requested (see above for more details).; The SAPT module has been used to perform SAPT0 computations with over; 200 atoms and 2800 basis functions; this code should be scalable to 4000; basis functions. Publications resulting from the use of the SAPT0 code ; should cite the following publications: [Hohenstein:2010:184111]_ and ; [Hohenstein:2011:174107]_. If the open-shell SAPT0 code is used,; [Gonthier:2016:134106]_ should be additionally cited. Basic SAPT0 Keywords; ~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__sapt_level.rst; .. include:: autodir_options_c/sapt__basis.rst; .. include:: autodir_options_c/sapt__df_basis_sapt.rst; .. include:: autodir_options_c/sapt__df_basis_elst.rst; .. include:: autodir_options_c/sapt__freeze_core.rst; .. include:: autodir_options_c/sapt__d_convergence.rst; .. include:: autodir_options_c/sapt__e_convergence.rst; .. include:: autodir_options_c/sapt__maxiter.rst; .. include:: autodir_options_c/sapt__print.rst. Advanced SAPT0 Keywords; ~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__aio_cphf.rst; .. include:: autodir_options_c/sapt__aio_df_ints",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:20969,Performance,scalab,scalable,20969,"analysis, see the :ref:`stability <sec:scfstability_doc>`; documentation. .. index:: SAPT; SAPT0. SAPT0; ^^^^^. Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of closed-shell SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ'). We do not recommend using SAPT0 with large basis sets; like aug-cc-pVTZ. A systematic study of the accuracy of closed-shell SAPT0 and other SAPT ; truncations, using different basis sets, is reported in ; [Parker:2014:094106]_. In particular, an empirical recipe for scaled SAPT0; can yield improved performance and has been included in the output file as; the sSAPT0 interaction energy. sSAPT0 is a free by-product and is automatically ; computed when SAPT0 is requested (see above for more details).; The SAPT module has been used to perform SAPT0 computations with over; 200 atoms and 2800 basis functions; this code should be scalable to 4000; basis functions. Publications resulting from the use of the SAPT0 code ; should cite the following publications: [Hohenstein:2010:184111]_ and ; [Hohenstein:2011:174107]_. If the open-shell SAPT0 code is used,; [Gonthier:2016:134106]_ should be additionally cited. Basic SAPT0 Keywords; ~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__sapt_level.rst; .. include:: autodir_options_c/sapt__basis.rst; .. include:: autodir_options_c/sapt__df_basis_sapt.rst; .. include:: autodir_options_c/sapt__df_basis_elst.rst; .. include:: autodir_options_c/sapt__freeze_core.rst; .. include:: autodir_options_c/sapt__d_convergence.rst; .. include:: autodir_options_c/sapt__e_convergence.rst; .. include:: autodir_options_c/sapt__maxiter.rst; .. include:: autodir_options_c/sapt__print.rst. Advanced SAPT0 Keywords; ~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__aio_cphf.rst; .. include:: autodir_options_c/sapt__aio_df_ints",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:22951,Performance,scalab,scalable,22951,"s_c/sapt__aio_df_ints.rst; .. include:: autodir_options_c/sapt__coupled_induction.rst; .. include:: autodir_options_c/sapt__exch_scale_alpha.rst; .. include:: autodir_options_c/sapt__ints_tolerance.rst; .. include:: autodir_options_c/sapt__denominator_delta.rst; .. include:: autodir_options_c/sapt__denominator_algorithm.rst; .. include:: autodir_options_c/globals__debug.rst. Specific open-shell SAPT0 keywords; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__sapt_mem_safety.rst; .. include:: autodir_options_c/sapt__coupled_induction.rst. .. index:: SAPT; SAPT(DFT). .. _`sec:saptdft`:. SAPT(DFT); ^^^^^^^^^. In general, SAPT(DFT) should provide more accurate interaction energy ; components, and overall interaction energies, than SAPT0. The drawback ; is SAPT(DFT) method is more computationally demanding than SAPT0, ; SAPT(DFT) can still be applied to medium-sized or large systems. The ; SAPT(DFT) module was employed successfully in computations of systems ; with up to 2000 basis functions, and the code should be scalable to ; 3000 basis functions. Like higher-order SAPT, SAPT(DFT) requires ; sufficient memory to hold :math:`2ovN_aux` doubles. SAPT(DFT) requires a few special treatments to obtain accurate; result. The DFT functionals used in SAPT(DFT) need to be asymptotically; corrected with Gradient Regulated Asymptotic Correction scheme (GRAC),; in order to recover the correct long-range asymptotic behavior; (approaching :math:`-1/r` as :math:`r` approaches infinity). The program; requires manual input of GRAC shift parameter for each monomer through; keywords |sapt__sapt_dft_grac_shift_a| and |sapt__sapt_dft_grac_shift_b|,; which should be equal to the difference of the actual ionization; potential and the corresponding Kohn-Sham HOMO energy. The dispersion; term needs to be computed with orbital response for good accuracy,; and it is recommended to enable |sapt__sapt_dft_do_hybrid| (set to; ``True`` by default). The coupled exchange-dispers",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:26042,Performance,perform,perform,26042,"on. Basic Keywords for SAPT(DFT) ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__sapt_dft_grac_shift_a.rst; .. include:: autodir_options_c/sapt__sapt_dft_grac_shift_b.rst; .. include:: autodir_options_c/sapt__sapt_dft_do_dhf.rst; .. include:: autodir_options_c/sapt__sapt_dft_exch_disp_scale_scheme.rst. Advanced Keywords for SAPT(DFT); ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__sapt_dft_functional.rst; .. include:: autodir_options_c/sapt__sapt_dft_do_hybrid.rst; .. include:: autodir_options_c/sapt__sapt_dft_exch_disp_fixed_scale.rst; .. include:: autodir_options_c/sapt__sapt_dft_mp2_disp_alg.rst; .. include:: autodir_options_c/sapt__sapt_quiet.rst. .. index:: SAPT; higher-order. Higher-Order SAPT; ^^^^^^^^^^^^^^^^^. For smaller systems (up to the size of a nucleic acid base pair), more; accurate interaction energies can be obtained through higher-order SAPT; computations. The SAPT module can perform density-fitted evaluations; of SAPT2, SAPT2+, SAPT2+(3), and SAPT2+3 energies for closed-shell systems ; only. Publications resulting from the use of the higher-order SAPT code ; should cite the following: ; [Hohenstein:2010:014101]_. For methods SAPT2+ and above, one can replace the many-body treatment of; dispersion by an improved method based on coupled-cluster doubles (CCD).; This approach tends to give good improvements when dispersion effects; are very large, as in the PCCP dimer (see [Hohenstein:2011:2842]_).; As shown in [Parker:2014:094106]_, whether or not CCD dispersion offers; more accurate interaction energies tends to depend on the SAPT truncation; and basis set employed, due to cancellations of errors. Thanks to; natural orbital methods [Parrish:2013:174102]_, the SAPT code; is able to include CCD dispersion with only a modest additional cost.; Computations employing CCD dispersion should cite [Parrish:2013:174102]_. ; To request CCD dispersion treatment in a SAPT computation, simply append; ``(ccd)`` to the na",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:27810,Performance,perform,performed,27810,"ethods [Parrish:2013:174102]_, the SAPT code; is able to include CCD dispersion with only a modest additional cost.; Computations employing CCD dispersion should cite [Parrish:2013:174102]_. ; To request CCD dispersion treatment in a SAPT computation, simply append; ``(ccd)`` to the name of the method, as in the following examples ::. 	energy('sapt2+(ccd)'); 	energy('sapt2+(3)(ccd)'); 	energy('sapt2+3(ccd)'). The :math:`\delta_{MP2}` corrections can also be computed automatically; by appending ``dmp2`` to the name of the method, with or without CCD dispersion ::. 	energy('sapt2+dmp2'); 	energy('sapt2+(3)dmp2'); 	energy('sapt2+3dmp2'); 	energy('sapt2+(ccd)dmp2'); 	energy('sapt2+(3)(ccd)dmp2'); 	energy('sapt2+3(ccd)dmp2'). A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold :math:`3o^2v^2+v^2N_{aux}` arrays in core. With this; requirement computations on the adenine-thymine complex can be performed; with an aug-cc-pVTZ basis in less than 64GB of memory. Higher-order SAPT is treated separately from the highly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of keywords. ; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAPT; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__basis.rst; .. include:: autodir_options_c/sapt__df_basis_sapt.rst; .. include:: autodir_options_c/globals__freeze_core.rst; .. include:: autodir_options_c/sapt__print.rst. Advanced Keywords for Higher-order SAPT; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__do_ccd_disp.rst; .. include:: autodir_options_c/sapt__do_mbpt_disp.rst; .. include:: autodir_options_c/sapt__do_third_order.rst; .. include:: autodir_options_c/sapt__ints_tolerance.rst; .. include:: autodir_options_c/sapt__sapt_mem_check.rst; .. include:: autodir_options_c/globals__debug.rst. MP2 Natural Orbitals; ^^^^^^^",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:27932,Performance,optimiz,optimized,27932,"CCD dispersion should cite [Parrish:2013:174102]_. ; To request CCD dispersion treatment in a SAPT computation, simply append; ``(ccd)`` to the name of the method, as in the following examples ::. 	energy('sapt2+(ccd)'); 	energy('sapt2+(3)(ccd)'); 	energy('sapt2+3(ccd)'). The :math:`\delta_{MP2}` corrections can also be computed automatically; by appending ``dmp2`` to the name of the method, with or without CCD dispersion ::. 	energy('sapt2+dmp2'); 	energy('sapt2+(3)dmp2'); 	energy('sapt2+3dmp2'); 	energy('sapt2+(ccd)dmp2'); 	energy('sapt2+(3)(ccd)dmp2'); 	energy('sapt2+3(ccd)dmp2'). A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold :math:`3o^2v^2+v^2N_{aux}` arrays in core. With this; requirement computations on the adenine-thymine complex can be performed; with an aug-cc-pVTZ basis in less than 64GB of memory. Higher-order SAPT is treated separately from the highly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of keywords. ; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAPT; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__basis.rst; .. include:: autodir_options_c/sapt__df_basis_sapt.rst; .. include:: autodir_options_c/globals__freeze_core.rst; .. include:: autodir_options_c/sapt__print.rst. Advanced Keywords for Higher-order SAPT; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__do_ccd_disp.rst; .. include:: autodir_options_c/sapt__do_mbpt_disp.rst; .. include:: autodir_options_c/sapt__do_third_order.rst; .. include:: autodir_options_c/sapt__ints_tolerance.rst; .. include:: autodir_options_c/sapt__sapt_mem_check.rst; .. include:: autodir_options_c/globals__debug.rst. MP2 Natural Orbitals; ^^^^^^^^^^^^^^^^^^^^. One of the unique features of the SAPT module is its ability to use; MP2 natural orbitals (NOs) to speed up the evaluation of ",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:30640,Performance,perform,perform,30640,"d Keywords Controlling MP2 NO Approximations; .. comment ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. comment .. include:: autodir_options_c/sapt__nat_orbs_t2.rst. .. index:: SAPT; charge-transfer. .. _`sec:saptct`:. Charge-Transfer in SAPT; ^^^^^^^^^^^^^^^^^^^^^^^. It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy ; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201]_. Charge-transfer energies can be obtained from the following calls to the; energy function. ::. energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'); energy('sapt2+(ccd)-ct'); energy('sapt2+(3)(ccd)-ct'); energy('sapt2+3(ccd)-ct'). For now, charge transfer computations are not available with open-shell SAPT0. A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results::. SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed with ; SAPT0/aug-cc-pVDZ. . .. index:: ; pair: SAPT; output. Monomer-Centered Basis Computations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The charge-transfer analysis above is carried out by taking the; difference between SAPT induction as calculated in the dimer-centered; basis (*i.e.*, each ",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:30841,Performance,perform,performs,30841,"orbs_t2.rst. .. index:: SAPT; charge-transfer. .. _`sec:saptct`:. Charge-Transfer in SAPT; ^^^^^^^^^^^^^^^^^^^^^^^. It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy ; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201]_. Charge-transfer energies can be obtained from the following calls to the; energy function. ::. energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'); energy('sapt2+(ccd)-ct'); energy('sapt2+(3)(ccd)-ct'); energy('sapt2+3(ccd)-ct'). For now, charge transfer computations are not available with open-shell SAPT0. A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results::. SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed with ; SAPT0/aug-cc-pVDZ. . .. index:: ; pair: SAPT; output. Monomer-Centered Basis Computations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The charge-transfer analysis above is carried out by taking the; difference between SAPT induction as calculated in the dimer-centered; basis (*i.e.*, each monomer sees the basis functions on both monomers); vs. the monomer-centered basis (*i.e.*, each monomer utilizes only its; own basis set). It is also possible to",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:33120,Performance,perform,performed,33120,"uations, but it converges more slowly; towards the complete basis set limit than the default procedure, which uses; the dimer-centered basis set. Hence, monomer-centered basis SAPT; computations are not recommended. The open-shell SAPT0 code is not; compatible yet with monomer-centered computations. Computations with Mid-bonds; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. SAPT computations with midbonds can be accomplished by adding a third ghost; monomer to the computation. For example ::. molecule dimer {; 0 1; He 0 0 5; --; 0 1; He 0 0 -5; --; 0 1; @He 0 0 0; }. Here the functions of the third monomer will be added to the virtual space of; the entire computation. Note that an error will be thrown if each atom in the; third monomer is not a ghost to prevent confusion with three-body SAPT which is; not currently supported by Psi4. Interpreting SAPT Results; ^^^^^^^^^^^^^^^^^^^^^^^^^. We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following ; input::. molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561; units angstrom; }; ; set globals {; basis aug-cc-pvdz; guess sad; scf_type df; }; ; set sapt {; print 1; nat_orbs_t2 true; freeze_core true; }; ; energy('sapt2+3'). To reiterate some of the options mentioned above: the; |sapt__nat_orbs_t2| option will compute MP2 natural orbitals and use; them in the evaluation of the triples correction to dispersion, and the; |sapt__freeze_core| option will freeze the core throughout the SAPT; computation. This SAPT2+3/aug-cc-pVDZ computation produces the following; results::. SAPT Results; --------------------------------------------------------------------------------------------------------; Electrostatics -13.06509118 [mEh] -8.19846883 [kcal/mol] -34.30239689 [kJ/mol]; Elst10,r -13.37542977 [mE",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:42457,Performance,perform,performs,42457,". Total HF -5.68662563 [mEh] -3.56841161 [kcal/mol] -14.93023559 [kJ/mol]; Total SAPT0 sc. -8.57944161 [mEh] -5.38368112 [kcal/mol] -22.52532395 [kJ/mol]; Total SAPT2 sc. -6.69968912 [mEh] -4.20411857 [kcal/mol] -17.59003378 [kJ/mol]; Total SAPT2+ sc. -7.31030140 [mEh] -4.58728357 [kcal/mol] -19.19319632 [kJ/mol]; Total SAPT2+(3) sc. -6.98526650 [mEh] -4.38332109 [kcal/mol] -18.33981720 [kJ/mol]; Total SAPT2+3 sc. -7.15142168 [mEh] -4.48758504 [kcal/mol] -18.77605762 [kJ/mol]; --------------------------------------------------------------------------------------------------------. The scaling factor is reported at the top (here ``1.0072``) together with the ; :math:`\alpha` parameter. All terms that are scaled are indicated by the ``sc.``; label. Note that if Exch10 is less than :math:`10^{-5}`, the scaling factor is; set to :math:`1.0`. .. _`sec:saptfitB`:. .. caution:: To density fit the dispersion terms in SAPT, the RI auxiliary; basis set (*e.g.*, aug-cc-pVDZ-RI) controlled through; |sapt__df_basis_sapt| performs well. For Fock-type terms (*i.e.*,; electrostatics, exchange, induction, and core Fock matrix elements in; exchange-dispersion), the JKFIT density-fitting auxiliary basis; (*e.g.*, aug-cc-pVDZ-JKFIT) is more appropriate. The :ref:`FISAPT; module<sec:fisapt>` has always used JKFIT in this role. The; :ref:`SAPT module<sec:sapt>` newly (see :ref:`fitting notes <sec:saptfitA>` ) uses; JKFIT for computations targeting SAPT0 and sSAPT0 methods. But the; :ref:`SAPT module<sec:sapt>` still uses the RI basis for higher-order; SAPT. For heavier elements (*i.e.*, second-row and beyond), the RI; auxiliary basis is unsound for this role (insufficiently flexible).; For higher-order methods in :ref:`SAPT module<sec:sapt>`, there is; no workaround; on-the-fly construction of an auxiliary basis through; Cholesky decomposition (not implemented) is the long-term solution. .. _`sec:sfsapt`:. Spin-Flip SAPT; ^^^^^^^^^^^^^^. SAPT0 with two open-shell references will always yi",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:45151,Performance,perform,performed,45151,"d cite the; following publications: [Patkowski:2018:164110]_. .. _`sec:saptinf`:. Higher-Order Exchange Terms without Single-Exchange Approximation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Recently, several SAPT higher-order exchange terms have been derived without; the :math:`S^{2}` approximation: :math:`E_{exch-ind}^{(20)}` [Schaffer:2012:1235]_, ; :math:`E_{exch-disp}^{(20)}` [Schaffer:2013:2570]_, and :math:`E_{exch-ind}^{(30)}` ; [Waldrop:2021:024103]_. The second-order terms can be computed with the following; settings::. set SAPT_DFT_FUNCTIONAL HF; set DO_IND_EXCH_SINF true # calculate Exch-Ind20 (S^inf) ; set SAPT_DFT_MP2_DISP_ALG fisapt ; set DO_DISP_EXCH_SINF true # calculate Exch-Disp20 (S^inf); energy('sapt(dft)'); ; and the third-order exchange-induction term is computed as follows::. set DO_IND30_EXCH_SINF true # calculate Exch-Ind30 (S^inf) ; energy('sapt2+3'); ; These calculations are performed with the atomic orbital and ; density-fitting scheme described in the Supplementary Material to; [Smith:2020:184108]_ for the second-order terms and in [Waldrop:2021:024103]_; for the third-order exchange induction. The coupled (response) version of the; exchange-induction corrections are also calculated, exactly for ; :math:`E_{exch-ind,resp}^{(20)}` and by scaling the uncoupled term for; :math:`E_{exch-ind,resp}^{(30)}`. S^inf Keywords; ~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__do_ind_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_disp_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_ind30_exch_sinf.rst. .. _`sec:saptd`:. SAPT0-D; ~~~~~~~. In SAPT0, the computation of :math:`E_{disp}^{(20)} + E_{exch-disp}^{(20)}` represents; the computational bottleneck. One can avoid this bottleneck by replacing these; dispersion terms with the empirical D3 corrections developed by Grimme.; ; :ref:`Grimme's dispersion corrections are discussed here. <sec:dftd3>`. The corresponding method, termed SAPT0-D, thus relies on emp",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:45942,Performance,bottleneck,bottleneck,45942,"et DO_DISP_EXCH_SINF true # calculate Exch-Disp20 (S^inf); energy('sapt(dft)'); ; and the third-order exchange-induction term is computed as follows::. set DO_IND30_EXCH_SINF true # calculate Exch-Ind30 (S^inf) ; energy('sapt2+3'); ; These calculations are performed with the atomic orbital and ; density-fitting scheme described in the Supplementary Material to; [Smith:2020:184108]_ for the second-order terms and in [Waldrop:2021:024103]_; for the third-order exchange induction. The coupled (response) version of the; exchange-induction corrections are also calculated, exactly for ; :math:`E_{exch-ind,resp}^{(20)}` and by scaling the uncoupled term for; :math:`E_{exch-ind,resp}^{(30)}`. S^inf Keywords; ~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__do_ind_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_disp_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_ind30_exch_sinf.rst. .. _`sec:saptd`:. SAPT0-D; ~~~~~~~. In SAPT0, the computation of :math:`E_{disp}^{(20)} + E_{exch-disp}^{(20)}` represents; the computational bottleneck. One can avoid this bottleneck by replacing these; dispersion terms with the empirical D3 corrections developed by Grimme.; ; :ref:`Grimme's dispersion corrections are discussed here. <sec:dftd3>`. The corresponding method, termed SAPT0-D, thus relies on empirically fit parameters; specific to SAPT0/jun-cc-pVDZ. While SAPT0-D can be used with any of the -D ; variants using default parameters optimized for Hartee--Fock interaction energies, ; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]_. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters. ; A simple water dimer computation using SAPT0-D may look like::. 	molecule water_dimer {; 	 0 1; 	 O -1.551007 -0.114520 0.000000; 	 H -1.934259 0.762503 0.000000; 	 H -0.599677 0.040712 0.000000; 	 --; 	 0 1; 	 O 1",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:45973,Performance,bottleneck,bottleneck,45973," term is computed as follows::. set DO_IND30_EXCH_SINF true # calculate Exch-Ind30 (S^inf) ; energy('sapt2+3'); ; These calculations are performed with the atomic orbital and ; density-fitting scheme described in the Supplementary Material to; [Smith:2020:184108]_ for the second-order terms and in [Waldrop:2021:024103]_; for the third-order exchange induction. The coupled (response) version of the; exchange-induction corrections are also calculated, exactly for ; :math:`E_{exch-ind,resp}^{(20)}` and by scaling the uncoupled term for; :math:`E_{exch-ind,resp}^{(30)}`. S^inf Keywords; ~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__do_ind_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_disp_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_ind30_exch_sinf.rst. .. _`sec:saptd`:. SAPT0-D; ~~~~~~~. In SAPT0, the computation of :math:`E_{disp}^{(20)} + E_{exch-disp}^{(20)}` represents; the computational bottleneck. One can avoid this bottleneck by replacing these; dispersion terms with the empirical D3 corrections developed by Grimme.; ; :ref:`Grimme's dispersion corrections are discussed here. <sec:dftd3>`. The corresponding method, termed SAPT0-D, thus relies on empirically fit parameters; specific to SAPT0/jun-cc-pVDZ. While SAPT0-D can be used with any of the -D ; variants using default parameters optimized for Hartee--Fock interaction energies, ; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]_. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters. ; A simple water dimer computation using SAPT0-D may look like::. 	molecule water_dimer {; 	 0 1; 	 O -1.551007 -0.114520 0.000000; 	 H -1.934259 0.762503 0.000000; 	 H -0.599677 0.040712 0.000000; 	 --; 	 0 1; 	 O 1.350625 0.111469 0.000000; 	 H 1.680398 -0.373741 -0.758561; 	 H 1.680398 -0.373741 0.758561; 	; 	 units angstrom; 	 no_",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:46348,Performance,optimiz,optimized,46348,"d (response) version of the; exchange-induction corrections are also calculated, exactly for ; :math:`E_{exch-ind,resp}^{(20)}` and by scaling the uncoupled term for; :math:`E_{exch-ind,resp}^{(30)}`. S^inf Keywords; ~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__do_ind_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_disp_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_ind30_exch_sinf.rst. .. _`sec:saptd`:. SAPT0-D; ~~~~~~~. In SAPT0, the computation of :math:`E_{disp}^{(20)} + E_{exch-disp}^{(20)}` represents; the computational bottleneck. One can avoid this bottleneck by replacing these; dispersion terms with the empirical D3 corrections developed by Grimme.; ; :ref:`Grimme's dispersion corrections are discussed here. <sec:dftd3>`. The corresponding method, termed SAPT0-D, thus relies on empirically fit parameters; specific to SAPT0/jun-cc-pVDZ. While SAPT0-D can be used with any of the -D ; variants using default parameters optimized for Hartee--Fock interaction energies, ; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]_. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters. ; A simple water dimer computation using SAPT0-D may look like::. 	molecule water_dimer {; 	 0 1; 	 O -1.551007 -0.114520 0.000000; 	 H -1.934259 0.762503 0.000000; 	 H -0.599677 0.040712 0.000000; 	 --; 	 0 1; 	 O 1.350625 0.111469 0.000000; 	 H 1.680398 -0.373741 -0.758561; 	 H 1.680398 -0.373741 0.758561; 	; 	 units angstrom; 	 no_reorient; 	 symmetry c1; 	}; 	; 	set basis jun-cc-pvdz. 	energy('sapt0-d3mbj') # runs the recommended dispersion correction; energy('sapt0-d3') # tests an alternative damping scheme/parameterization. Given the naturally pairwise-atomic nature of these empirical dispersion corrections,; integration with existing FSAPT functionality is also available simply by calling; ``e",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:1799,Safety,avoid,avoid,1799,"eceived a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index::; single: SAPT; pair: SAPT; theory. .. _`sec:sapt`:. SAPT: Symmetry-Adapted Perturbation Theory; ==========================================. .. codeauthor:: Edward G. Hohenstein, Rob M. Parrish, J\ |e_acute|\ r\ |o_circumflex|\ me F. Gonthier, and Daniel. G. A. Smith; .. sectionauthor:: Edward G. Hohenstein and J\ |e_acute|\ r\ |o_circumflex|\ me F. Gonthier. *Module:* :ref:`Keywords <apdx:sapt>`, :ref:`PSI Variables <apdx:sapt_psivar>`, :source:`LIBSAPT_SOLVER <psi4/src/psi4/libsapt_solver>`. .. warning:: In rare cases with systems having a high degree of symmetry, ; |Psifour| gives (very obviously) wrong answers for SAPT computations ; when the specification is in Z-matrix format. Use a Cartesian representation ; to avoid this problem. .. caution:: In early versions (notably |Psifour| alpha circa 2011; and before), frozen core was implemented incompletely and for; only selected terms. Comparisons with papers published using early; |PSIfour| SAPT code may show discrepancies of 0.01-0.10 kcal/mol in; individual terms, particularly :math:`E_{exch}^{(11)}` and :math:`E_{exch}^{(12)}`. .. caution:: January 28th 2016, the default for all NAT_ORBS options; was changed to true. Hence the code now by default uses natural; orbital truncation to speed up the evaluation of energy terms; wherever possible, according to literature recommendations.; In early July 2016, some total SAPT energy psivars were renamed. .. caution:: February 7, 2020, a missing term in :math:`E^{(30)}_{ind}` was added, causing; possible discrepancies with prior versions of the code on the order of; 0.01 kcal/mol. See https://github.com/psi4/psi4/issues/1677. .. caution:: August 2021, the number of frozen core orbitals used in t",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:23305,Safety,recover,recover,23305,"c open-shell SAPT0 keywords; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__sapt_mem_safety.rst; .. include:: autodir_options_c/sapt__coupled_induction.rst. .. index:: SAPT; SAPT(DFT). .. _`sec:saptdft`:. SAPT(DFT); ^^^^^^^^^. In general, SAPT(DFT) should provide more accurate interaction energy ; components, and overall interaction energies, than SAPT0. The drawback ; is SAPT(DFT) method is more computationally demanding than SAPT0, ; SAPT(DFT) can still be applied to medium-sized or large systems. The ; SAPT(DFT) module was employed successfully in computations of systems ; with up to 2000 basis functions, and the code should be scalable to ; 3000 basis functions. Like higher-order SAPT, SAPT(DFT) requires ; sufficient memory to hold :math:`2ovN_aux` doubles. SAPT(DFT) requires a few special treatments to obtain accurate; result. The DFT functionals used in SAPT(DFT) need to be asymptotically; corrected with Gradient Regulated Asymptotic Correction scheme (GRAC),; in order to recover the correct long-range asymptotic behavior; (approaching :math:`-1/r` as :math:`r` approaches infinity). The program; requires manual input of GRAC shift parameter for each monomer through; keywords |sapt__sapt_dft_grac_shift_a| and |sapt__sapt_dft_grac_shift_b|,; which should be equal to the difference of the actual ionization; potential and the corresponding Kohn-Sham HOMO energy. The dispersion; term needs to be computed with orbital response for good accuracy,; and it is recommended to enable |sapt__sapt_dft_do_hybrid| (set to; ``True`` by default). The coupled exchange-dispersion energy is usually; estimated by scaling from the uncoupled value either by a fitted fixed; value (suggested initially by [Hesselmann:2014:094107]_ for a local Hartree--Fock (LHF) formulation and then revised; by [Xie:2022:024801]_ for non-LHF) or; by the ratio of; coupled and uncoupled dispersion energy (suggested by [Podeszwa:2006:400]_ ). ; This can be controlled by keyword |s",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:38297,Safety,recover,recover,38297," terms are grouped according to the component of the interaction; to which they contribute. The total component energies (*i.e.*,; electrostatics, exchange, induction, and dispersion) represent what we; regard as the best estimate available at a given level of SAPT computed; from a subset of the terms of that grouping. The groupings shown above are; not unique and are certainly not rigorously defined. We regard the groupings ; used in |PSIfour| as a ""chemist's grouping"" as opposed to a more; mathematically based grouping, which would group all exchange terms ; (*i.e.* :math:`E_{exch-ind,resp}^{(20)}`, :math:`E_{exch-disp}^{(20)}`, *etc.*) in; the exchange component. A final note is that both ``Disp22(T)``; and ``Est.Disp22(T)`` results appear if MP2 natural orbitals are ; used to evaluate the triples correction to dispersion. The ``Disp22(T)`` ; result is the triples correction as computed in the truncated NO basis; ; ``Est.Disp22(T)`` is a scaled result that attempts to recover; the effect of the truncated virtual space and is our best estimate. The ``Est.Disp22(T)``; value is used in the SAPT energy and dispersion component (see [Hohenstein:2010:104107]_ ; for details). Finally, this part of the output file contains sSAPT0, a special scaling; scheme of the SAPT0 energy that can yield improved results and was described in more details; above. The corresponding scaled total component energies are printed as well. As mentioned above, SAPT results with scaled exchange are also optionally available; by setting the |sapt__exch_scale_alpha| keyword. When activated, the unscaled results are; printed first as reported above, and then repeated with exchange scaling for all ; relevant terms: :: . SAPT Results ==> ALL S2 TERMS SCALED (see Manual) <==. Scaling factor (Exch10/Exch10(S^2))^{Alpha} = 1.007200; with Alpha = 1.000000; --------------------------------------------------------------------------------------------------------; Electrostatics -13.06509118 [mEh] -8.198468",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:45962,Safety,avoid,avoid,45962," term is computed as follows::. set DO_IND30_EXCH_SINF true # calculate Exch-Ind30 (S^inf) ; energy('sapt2+3'); ; These calculations are performed with the atomic orbital and ; density-fitting scheme described in the Supplementary Material to; [Smith:2020:184108]_ for the second-order terms and in [Waldrop:2021:024103]_; for the third-order exchange induction. The coupled (response) version of the; exchange-induction corrections are also calculated, exactly for ; :math:`E_{exch-ind,resp}^{(20)}` and by scaling the uncoupled term for; :math:`E_{exch-ind,resp}^{(30)}`. S^inf Keywords; ~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__do_ind_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_disp_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_ind30_exch_sinf.rst. .. _`sec:saptd`:. SAPT0-D; ~~~~~~~. In SAPT0, the computation of :math:`E_{disp}^{(20)} + E_{exch-disp}^{(20)}` represents; the computational bottleneck. One can avoid this bottleneck by replacing these; dispersion terms with the empirical D3 corrections developed by Grimme.; ; :ref:`Grimme's dispersion corrections are discussed here. <sec:dftd3>`. The corresponding method, termed SAPT0-D, thus relies on empirically fit parameters; specific to SAPT0/jun-cc-pVDZ. While SAPT0-D can be used with any of the -D ; variants using default parameters optimized for Hartee--Fock interaction energies, ; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]_. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters. ; A simple water dimer computation using SAPT0-D may look like::. 	molecule water_dimer {; 	 0 1; 	 O -1.551007 -0.114520 0.000000; 	 H -1.934259 0.762503 0.000000; 	 H -0.599677 0.040712 0.000000; 	 --; 	 0 1; 	 O 1.350625 0.111469 0.000000; 	 H 1.680398 -0.373741 -0.758561; 	 H 1.680398 -0.373741 0.758561; 	; 	 units angstrom; 	 no_",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:3589,Security,access,accessed,3589,"s with prior versions of the code on the order of; 0.01 kcal/mol. See https://github.com/psi4/psi4/issues/1677. .. caution:: August 2021, the number of frozen core orbitals used in the dMP2 computations; is now standardized. Specifically, we now rigorously enforce that the number of core orbitals ; frozen in dimer computations is equal to the sum of frozen orbitals of each monomer. Prior to; this, a discrepency between these values was possible when one of the monomers was (exclusively) ; a charged alkali metal. . .. _`sec:saptfitA`:. .. caution:: May 2022 c. v1.6, the default for |sapt__df_basis_elst|; changed from the value of |sapt__df_basis_sapt| (which itself; defaults to the RI of the orbital basis) to the JKFIT of the orbital; basis. This affects SAPT0 and sSAPT0 computed with the :ref:`SAPT; module<sec:sapt>` (the default code for ``energy(""sapt0"")`` that; can also compute higher-order SAPT). Electostatics, exchange,; and induction terms for SAPT0 and sSAPT0 accessed through; ``energy(""sapt0"")`` or ``energy(""ssapt0"")`` change; the dispersion; term does not change. The SAPT0 and sSAPT0 terms accessed as; subsidiary calculations of higher-order SAPT do not change; that is,; the :ref:`SAPT module<sec:sapt>` breaks the consistency of its SAPT0; results. The reasoning and reward behind this change is that the JKFIT; basis better describes the physics (see :ref:`fitting changes <sec:saptfitB>` ) and the; default SAPT0 results from the :ref:`SAPT module<sec:sapt>` are now; consistent with those from the :ref:`FISAPT module<sec:fisapt>` and; the sapt(dft) module. See :srcsample:`sapt-compare` for an example.; To reproduce former behavior, set |sapt__df_basis_elst| to the; orbital basis set's RI auxiliary basis. Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAP",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:3724,Security,access,accessed,3724,"he dMP2 computations; is now standardized. Specifically, we now rigorously enforce that the number of core orbitals ; frozen in dimer computations is equal to the sum of frozen orbitals of each monomer. Prior to; this, a discrepency between these values was possible when one of the monomers was (exclusively) ; a charged alkali metal. . .. _`sec:saptfitA`:. .. caution:: May 2022 c. v1.6, the default for |sapt__df_basis_elst|; changed from the value of |sapt__df_basis_sapt| (which itself; defaults to the RI of the orbital basis) to the JKFIT of the orbital; basis. This affects SAPT0 and sSAPT0 computed with the :ref:`SAPT; module<sec:sapt>` (the default code for ``energy(""sapt0"")`` that; can also compute higher-order SAPT). Electostatics, exchange,; and induction terms for SAPT0 and sSAPT0 accessed through; ``energy(""sapt0"")`` or ``energy(""ssapt0"")`` change; the dispersion; term does not change. The SAPT0 and sSAPT0 terms accessed as; subsidiary calculations of higher-order SAPT do not change; that is,; the :ref:`SAPT module<sec:sapt>` breaks the consistency of its SAPT0; results. The reasoning and reward behind this change is that the JKFIT; basis better describes the physics (see :ref:`fitting changes <sec:saptfitB>` ) and the; default SAPT0 results from the :ref:`SAPT module<sec:sapt>` are now; consistent with those from the :ref:`FISAPT module<sec:fisapt>` and; the sapt(dft) module. See :srcsample:`sapt-compare` for an example.; To reproduce former behavior, set |sapt__df_basis_elst| to the; orbital basis set's RI auxiliary basis. Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: *i.e.*,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the ; Hamilto",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:46579,Testability,test,tested,46579," scaling the uncoupled term for; :math:`E_{exch-ind,resp}^{(30)}`. S^inf Keywords; ~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__do_ind_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_disp_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_ind30_exch_sinf.rst. .. _`sec:saptd`:. SAPT0-D; ~~~~~~~. In SAPT0, the computation of :math:`E_{disp}^{(20)} + E_{exch-disp}^{(20)}` represents; the computational bottleneck. One can avoid this bottleneck by replacing these; dispersion terms with the empirical D3 corrections developed by Grimme.; ; :ref:`Grimme's dispersion corrections are discussed here. <sec:dftd3>`. The corresponding method, termed SAPT0-D, thus relies on empirically fit parameters; specific to SAPT0/jun-cc-pVDZ. While SAPT0-D can be used with any of the -D ; variants using default parameters optimized for Hartee--Fock interaction energies, ; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]_. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters. ; A simple water dimer computation using SAPT0-D may look like::. 	molecule water_dimer {; 	 0 1; 	 O -1.551007 -0.114520 0.000000; 	 H -1.934259 0.762503 0.000000; 	 H -0.599677 0.040712 0.000000; 	 --; 	 0 1; 	 O 1.350625 0.111469 0.000000; 	 H 1.680398 -0.373741 -0.758561; 	 H 1.680398 -0.373741 0.758561; 	; 	 units angstrom; 	 no_reorient; 	 symmetry c1; 	}; 	; 	set basis jun-cc-pvdz. 	energy('sapt0-d3mbj') # runs the recommended dispersion correction; energy('sapt0-d3') # tests an alternative damping scheme/parameterization. Given the naturally pairwise-atomic nature of these empirical dispersion corrections,; integration with existing FSAPT functionality is also available simply by calling; ``energy(""fsapt0-d3mbj"")``. See :ref:`FSAPT <sec:fisapt>` documentation for more details on using FSAPT; for functional group analyses.; ",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:47160,Testability,test,tests,47160," scaling the uncoupled term for; :math:`E_{exch-ind,resp}^{(30)}`. S^inf Keywords; ~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__do_ind_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_disp_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_ind30_exch_sinf.rst. .. _`sec:saptd`:. SAPT0-D; ~~~~~~~. In SAPT0, the computation of :math:`E_{disp}^{(20)} + E_{exch-disp}^{(20)}` represents; the computational bottleneck. One can avoid this bottleneck by replacing these; dispersion terms with the empirical D3 corrections developed by Grimme.; ; :ref:`Grimme's dispersion corrections are discussed here. <sec:dftd3>`. The corresponding method, termed SAPT0-D, thus relies on empirically fit parameters; specific to SAPT0/jun-cc-pVDZ. While SAPT0-D can be used with any of the -D ; variants using default parameters optimized for Hartee--Fock interaction energies, ; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]_. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters. ; A simple water dimer computation using SAPT0-D may look like::. 	molecule water_dimer {; 	 0 1; 	 O -1.551007 -0.114520 0.000000; 	 H -1.934259 0.762503 0.000000; 	 H -0.599677 0.040712 0.000000; 	 --; 	 0 1; 	 O 1.350625 0.111469 0.000000; 	 H 1.680398 -0.373741 -0.758561; 	 H 1.680398 -0.373741 0.758561; 	; 	 units angstrom; 	 no_reorient; 	 symmetry c1; 	}; 	; 	set basis jun-cc-pvdz. 	energy('sapt0-d3mbj') # runs the recommended dispersion correction; energy('sapt0-d3') # tests an alternative damping scheme/parameterization. Given the naturally pairwise-atomic nature of these empirical dispersion corrections,; integration with existing FSAPT functionality is also available simply by calling; ``energy(""fsapt0-d3mbj"")``. See :ref:`FSAPT <sec:fisapt>` documentation for more details on using FSAPT; for functional group analyses.; ",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:5725,Usability,simpl,simplest,5725,"persion terms. In SAPT, the ; Hamiltonian of the dimer is partitioned into contributions from each ; monomer and the interaction. .. math:: H=F_A+W_A+F_B+W_B+V. Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, :math:`F`, the fluctuation potential of each monomer, :math:`W`, and the; interaction potential, :math:`V`. The monomer Fock operators, :math:`F_A+F_B`, are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of :math:`V`, :math:`W_A`, and :math:`W_B`. ; Through first-order in :math:`V`, electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in :math:`V`. For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887]_. Several truncations of the closed-shell SAPT expansion are available in the SAPT; module of |PSIfour|. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. :eq:`SAPT0`. .. math:: E_{SAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + E_{exch-disp}^{(20)} + \delta_{HF}^{(2)}; :label: SAPT0. In this notation, :math:`E^{(vw)}` defines the order in :math:`V` and in :math:`W_A+W_B`; the; subscript, :math:`resp`, indicates that orbital relaxation effects are included. .. math:: E_{SAPT2} = E_{SAPT0} + E_{elst,resp}^{(12)} + E_{exch}^{(11)} +; E_{exch}^{(12)} + \; ^{t}\!E_{ind}^{(22)} + \; ^{t}\!E_{exch-ind}^{(22)}; :label: SAPT2. .. math:: E_{SAPT2+} = E_{SAPT2} + E_{disp}^{(21)} + E_{disp}^{(22)}; :label: SAPT2p. .. math:: E_{SAPT2+(3)} = E_{SAPT2+} + E_{elst,resp}^{(13)} + E_{disp}^{(30)}; :label: SAPT2pparen3. .. math:: E_{SAPT2+3} = E_{SAPT2+(3)}; + E_{exch-ind}^{(30)} + E_{ind,resp}^{(30)}; + E_{exch-disp}^{(30)} + E_{ind-disp}^{(30)} + E_{exch-ind-disp}^{(30)}; - \delta_{HF}^{(2)} + \delta_{HF}^{(3)}; :label: SAPT2p3. For SAPT(DFT), the SAPT ex",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:12231,Usability,simpl,simply,12231,"approximation and scaling; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. All exchange terms in SAPT arise from the antisymmetrization; of the wavefunctions of monomers A and B. Taking into account exchange of all possible; electron pairs between the two monomers yields to complicated formulae.; For this reason, exchange terms are often evaluated in the :math:`S^{2}`; approximation, that can be interpreted as the exchange of a single electron ; pair between monomers. The :math:`S^{2}` approximation is usually pretty good, but may ; break down for short intermolecular distance, particularly in high-order; terms. To compensate for these deviations, in 2014 Parker et al. [Parker:2014:094106]_ ; recommended to scale all :math:`S^{2}` approximated exchange terms by the ratio:. .. math:: p_{EX}(\alpha) = \left( \frac{E_{exch}^{(10)}}{E_{exch}^{(10)}(S^{2})} \right)^{\alpha}. and recommended using the ratio with exponent :math:`\alpha = 1`. To obtain SAPT energies with this scaling,; simply set the keyword ``exch_scale_alpha true``. Alternatively, another value for :math:`\alpha`; can be specified by setting |sapt__exch_scale_alpha| to a value. For example, ::. set exch_scale_alpha 1.0. will set :math:`\alpha = 1.0` and scale exchange energies with :math:`p_{EX}(1.0)`. However, as pointed out by Schaffer and Jansen [Schaffer:2013:2570]_; in the context of DFT-based SAPT, the ratios :math:`E_{exch}^{(1)}(S^{2})/E_{exch}^{(1)}`,; :math:`E_{\rm exch-ind}^{(2)}(S^2)/E_{\rm exch-ind}^{(2)}`, and ; :math:`E_{\rm exch-disp}^{(2)}(S^2)/E_{\rm exch-disp}^{(2)}` are not very similar to; each other. Hence, in 2016 universal scaling of all :math:`S^{2}` approximated terms; was turned off by default. Finally, in 2014 Parker et al. [Parker:2014:094106]_ empirically discovered that ; SAPT0 energies for van der Waals dimers with close contacts benefit from a slightly modified ; recipe that involves an empirically adjusted exponent :math:`\alpha = 3.0`. ; To distinguish it from its u",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:13818,Usability,simpl,simplest,13818,"ing of all :math:`S^{2}` approximated terms; was turned off by default. Finally, in 2014 Parker et al. [Parker:2014:094106]_ empirically discovered that ; SAPT0 energies for van der Waals dimers with close contacts benefit from a slightly modified ; recipe that involves an empirically adjusted exponent :math:`\alpha = 3.0`. ; To distinguish it from its unscaled counterpart, this energy is denoted sSAPT0 (see [Parker:2014:094106]_). .. math:: E_{sSAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; p_{EX}(3.0) E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + p_{EX}(3.0) E_{exch-disp}^{(20)} ; + \delta_{HF}^{(2)}; :label: sSAPT0. where :math:`\delta_{HF}^{(2)}` is computed *without* any scaling. Please note that ; sSAPT0 is thus not the same as requesting ``exch_scale_alpha 3.0``, and that the; scaling is automatically performed by requesting ``energy('ssapt0')``. A First Example; ^^^^^^^^^^^^^^^. The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods,; not all of them). ::. 	molecule water_dimer {; 	 0 1; 	 O -1.551007 -0.114520 0.000000; 	 H -1.934259 0.762503 0.000000; 	 H -0.599677 0.040712 0.000000; 	 --; 	 0 1; 	 O 1.350625 0.111469 0.000000; 	 H 1.680398 -0.373741 -0.758561; 	 H 1.680398 -0.373741 0.758561; 	; 	 units angstrom; 	 no_reorient; 	 symmetry c1; 	}; 	; 	set basis aug-cc-pvdz; 	; 	energy('sapt0'); 	energy('sapt2'); 	energy('sapt2+'); 	energy('sapt2+(3)'); 	energy('sapt2+3'). The SAPT module uses the standard |PSIfour| partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the ``no_reorient`` and ``symmetry; c1`` molecule keywords, as in the example above. As a reminder, only; SAPT0 can handle the interaction of both closed- and o",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:27057,Usability,simpl,simply,27057,"luations; of SAPT2, SAPT2+, SAPT2+(3), and SAPT2+3 energies for closed-shell systems ; only. Publications resulting from the use of the higher-order SAPT code ; should cite the following: ; [Hohenstein:2010:014101]_. For methods SAPT2+ and above, one can replace the many-body treatment of; dispersion by an improved method based on coupled-cluster doubles (CCD).; This approach tends to give good improvements when dispersion effects; are very large, as in the PCCP dimer (see [Hohenstein:2011:2842]_).; As shown in [Parker:2014:094106]_, whether or not CCD dispersion offers; more accurate interaction energies tends to depend on the SAPT truncation; and basis set employed, due to cancellations of errors. Thanks to; natural orbital methods [Parrish:2013:174102]_, the SAPT code; is able to include CCD dispersion with only a modest additional cost.; Computations employing CCD dispersion should cite [Parrish:2013:174102]_. ; To request CCD dispersion treatment in a SAPT computation, simply append; ``(ccd)`` to the name of the method, as in the following examples ::. 	energy('sapt2+(ccd)'); 	energy('sapt2+(3)(ccd)'); 	energy('sapt2+3(ccd)'). The :math:`\delta_{MP2}` corrections can also be computed automatically; by appending ``dmp2`` to the name of the method, with or without CCD dispersion ::. 	energy('sapt2+dmp2'); 	energy('sapt2+(3)dmp2'); 	energy('sapt2+3dmp2'); 	energy('sapt2+(ccd)dmp2'); 	energy('sapt2+(3)(ccd)dmp2'); 	energy('sapt2+3(ccd)dmp2'). A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold :math:`3o^2v^2+v^2N_{aux}` arrays in core. With this; requirement computations on the adenine-thymine complex can be performed; with an aug-cc-pVTZ basis in less than 64GB of memory. Higher-order SAPT is treated separately from the highly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of keywords. ; The following keywords are relevant for higher-or",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:31981,Usability,simpl,simply,31981,"nsfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed with ; SAPT0/aug-cc-pVDZ. . .. index:: ; pair: SAPT; output. Monomer-Centered Basis Computations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The charge-transfer analysis above is carried out by taking the; difference between SAPT induction as calculated in the dimer-centered; basis (*i.e.*, each monomer sees the basis functions on both monomers); vs. the monomer-centered basis (*i.e.*, each monomer utilizes only its; own basis set). It is also possible to run a closed-shell SAPT computation at any; level using only the monomer-centered basis. To do this, simply add; ``sapt_basis='monomer'`` to the energy function, such as ::. energy('sapt2',sapt_basis='monomer'). This procedure leads to faster compuations, but it converges more slowly; towards the complete basis set limit than the default procedure, which uses; the dimer-centered basis set. Hence, monomer-centered basis SAPT; computations are not recommended. The open-shell SAPT0 code is not; compatible yet with monomer-centered computations. Computations with Mid-bonds; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. SAPT computations with midbonds can be accomplished by adding a third ghost; monomer to the computation. For example ::. molecule dimer {; 0 1; He 0 0 5; --; 0 1; He 0 0 -5; --; 0 1; @He 0 0 0; }. Here the functions of the third monomer will be added to the virtual space of; the entire computation. Note that an error will be thrown if each atom in the; third monomer is not a ghost to prevent confusion with three-body SAPT which is; not currently supported by Psi4. Interpreting SAPT Results; ^^^^^^^^^^^^^^^^^^^^^^^^^. W",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:46682,Usability,simpl,simple,46682," scaling the uncoupled term for; :math:`E_{exch-ind,resp}^{(30)}`. S^inf Keywords; ~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__do_ind_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_disp_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_ind30_exch_sinf.rst. .. _`sec:saptd`:. SAPT0-D; ~~~~~~~. In SAPT0, the computation of :math:`E_{disp}^{(20)} + E_{exch-disp}^{(20)}` represents; the computational bottleneck. One can avoid this bottleneck by replacing these; dispersion terms with the empirical D3 corrections developed by Grimme.; ; :ref:`Grimme's dispersion corrections are discussed here. <sec:dftd3>`. The corresponding method, termed SAPT0-D, thus relies on empirically fit parameters; specific to SAPT0/jun-cc-pVDZ. While SAPT0-D can be used with any of the -D ; variants using default parameters optimized for Hartee--Fock interaction energies, ; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]_. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters. ; A simple water dimer computation using SAPT0-D may look like::. 	molecule water_dimer {; 	 0 1; 	 O -1.551007 -0.114520 0.000000; 	 H -1.934259 0.762503 0.000000; 	 H -0.599677 0.040712 0.000000; 	 --; 	 0 1; 	 O 1.350625 0.111469 0.000000; 	 H 1.680398 -0.373741 -0.758561; 	 H 1.680398 -0.373741 0.758561; 	; 	 units angstrom; 	 no_reorient; 	 symmetry c1; 	}; 	; 	set basis jun-cc-pvdz. 	energy('sapt0-d3mbj') # runs the recommended dispersion correction; energy('sapt0-d3') # tests an alternative damping scheme/parameterization. Given the naturally pairwise-atomic nature of these empirical dispersion corrections,; integration with existing FSAPT functionality is also available simply by calling; ``energy(""fsapt0-d3mbj"")``. See :ref:`FSAPT <sec:fisapt>` documentation for more details on using FSAPT; for functional group analyses.; ",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst:47365,Usability,simpl,simply,47365," scaling the uncoupled term for; :math:`E_{exch-ind,resp}^{(30)}`. S^inf Keywords; ~~~~~~~~~~~~~~. .. include:: autodir_options_c/sapt__do_ind_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_disp_exch_sinf.rst; .. include:: autodir_options_c/sapt__do_ind30_exch_sinf.rst. .. _`sec:saptd`:. SAPT0-D; ~~~~~~~. In SAPT0, the computation of :math:`E_{disp}^{(20)} + E_{exch-disp}^{(20)}` represents; the computational bottleneck. One can avoid this bottleneck by replacing these; dispersion terms with the empirical D3 corrections developed by Grimme.; ; :ref:`Grimme's dispersion corrections are discussed here. <sec:dftd3>`. The corresponding method, termed SAPT0-D, thus relies on empirically fit parameters; specific to SAPT0/jun-cc-pVDZ. While SAPT0-D can be used with any of the -D ; variants using default parameters optimized for Hartee--Fock interaction energies, ; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]_. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters. ; A simple water dimer computation using SAPT0-D may look like::. 	molecule water_dimer {; 	 0 1; 	 O -1.551007 -0.114520 0.000000; 	 H -1.934259 0.762503 0.000000; 	 H -0.599677 0.040712 0.000000; 	 --; 	 0 1; 	 O 1.350625 0.111469 0.000000; 	 H 1.680398 -0.373741 -0.758561; 	 H 1.680398 -0.373741 0.758561; 	; 	 units angstrom; 	 no_reorient; 	 symmetry c1; 	}; 	; 	set basis jun-cc-pvdz. 	energy('sapt0-d3mbj') # runs the recommended dispersion correction; energy('sapt0-d3') # tests an alternative damping scheme/parameterization. Given the naturally pairwise-atomic nature of these empirical dispersion corrections,; integration with existing FSAPT functionality is also available simply by calling; ``energy(""fsapt0-d3mbj"")``. See :ref:`FSAPT <sec:fisapt>` documentation for more details on using FSAPT; for functional group analyses.; ",MatchSource.DOCS,doc/sphinxman/source/sapt.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sapt.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:4397,Availability,avail,available,4397,"converged.; ... @UHF iter 9: -149.62730705472407 -3.63645e-04 8.63697e-05 DIIS; @UHF iter 10: -149.62730737348096 -3.18757e-07 1.50223e-05 DIIS; @UHF iter 11: -149.62730738537113 -1.18902e-08 3.80466e-06 DIIS; @UHF iter 12: -149.62730738624032 -8.69193e-10 7.06634e-07 DIIS. The first set of iterations are from the DF portion of the computation, the; second set uses the exact (but much slower) Direct algorithm. Within the DF portion; of the computation, the zeroth-iteration uses a non-idempotent density matrix; obtained from the SAD guess, so the energy is unphysically low. However, the; first true iteration is quite close to the final DF energy, highlighting the; efficiency of the SAD guess. Pulay's DIIS procedure is then used to accelerate; SCF convergence, with the DF phase reaching convergence in eight true; iterations. When used together, SAD and DIIS are usually sufficient to converge; the SCF for all but the most difficult systems. Additional convergence; techniques are available for more difficult cases, and are detailed below. At; this point, the code switches on the requested Direct integrals technology, which; requires only four full iterations to reach convergence, starting from the DF; guess. This hybrid DF/Direct procedure can significantly accelerate SCF; computations requiring exact integrals. After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; |globals__print| option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. .. index::; pair: SCF; theory. .. _`sec:scftheory`:. Theory; ~~~~~~. The objective of Hartree--Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) :math:`\{\psi_i\}`,. .. math:: \psi_i(\vec x_1) = C_{\mu i} \phi_{\mu} (\vec x_1). Here, :math:`\{\phi_{\mu}\}",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:4940,Availability,avail,available,4940,"ess, so the energy is unphysically low. However, the; first true iteration is quite close to the final DF energy, highlighting the; efficiency of the SAD guess. Pulay's DIIS procedure is then used to accelerate; SCF convergence, with the DF phase reaching convergence in eight true; iterations. When used together, SAD and DIIS are usually sufficient to converge; the SCF for all but the most difficult systems. Additional convergence; techniques are available for more difficult cases, and are detailed below. At; this point, the code switches on the requested Direct integrals technology, which; requires only four full iterations to reach convergence, starting from the DF; guess. This hybrid DF/Direct procedure can significantly accelerate SCF; computations requiring exact integrals. After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; |globals__print| option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. .. index::; pair: SCF; theory. .. _`sec:scftheory`:. Theory; ~~~~~~. The objective of Hartree--Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) :math:`\{\psi_i\}`,. .. math:: \psi_i(\vec x_1) = C_{\mu i} \phi_{\mu} (\vec x_1). Here, :math:`\{\phi_{\mu}\}` are the basis functions, which, in |PSIfour| are; contracted Cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix :math:`C_{\mu i}` contains the MO coefficients, which are the; constrained variational parameters in Hartree--Fock. The molecular orbitals are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. .. math:: | \Psi_0 \rangle =; \frac{1}{\sqrt{N!}} \left | \begin{array}{cccc}; \psi_1 (\vec x_1) & \psi_2(\vec x_1) & \ldots & \psi_N (\vec x_1) \\; \psi",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:12411,Availability,down,down,12411,"oint group of the molecule is inferred when reading the molecule; section, and may be overridden by the :ref:`symmetry <sec:moleculeKeywords>` flag, as in::. molecule h {; 0 2; H; symmetry c1; }. or by the ``reset_point_group`` Python molecule attribute::. h.reset_point_group('c2v'). During the SCF procedure, the occupation of orbitals is typically determined by; the Aufbau principal across all spatial symmetries. This may result in the; occupation shifting between iterations. If the occupations are known *a priori*,; they may be clamped throughout the procedure by using the |globals__docc| and; |globals__socc| options. For instance, all good quantum chemists know that; :math:`C_{2v}` water is; actually,::. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; docc [3, 0, 1, 1] # 1A1 2A1 1B1 3A1 1B2; basis cc-pvdz; }. energy('scf'). .. _`sec:scfbrokensymm`:. Broken Symmetry; ~~~~~~~~~~~~~~~. For certain problems, such diradicals, allowing the spin-up and spin-down; orbitals to differ in closed-shell computations can be advantageous;; this is known as symmetry breaking. The resulting unrestricted wavefunction; will often provide superior energetics, due to the increased flexibility,; but it will suffer non-physical spin contamination from higher multiplicity states.; A convenient approach to break symmetry is to perform a UHF or UKS calculation; with the guess HOMO and LUMO orbitals mixed.; Mixing of the guess orbitals can be requested by setting the |scf__guess_mix|; keyword to true::. set reference uhf; set guess_mix true; energy('scf'). .. _`sec:scflindep`:. Orthogonalization; ~~~~~~~~~~~~~~~~~. One of the first steps in the SCF procedure is the determination of an; orthogonal basis (known as the OSO basis) from the atomic orbital; basis (known as the AO basis). The Molecular Orbital basis (MO basis); is then built as a particular unitary transformation of the OSO; basis. In |PSIfour|, the determination of the OSO basis is; accomplished via either symmetric, ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:16294,Availability,toler,tolerance,16294,"dition number of the overlap matrix to be smaller than; the machine epsilon - the partial Cholesky decomposition is undertaken; until |scf__s_cholesky_tolerance|, which defaults to 1E-8. Use of symmetric, canonical, and partial Cholesky orthogonalization; can be forced by setting the |scf__s_orthogonalization| option to; ``SYMMETRIC``, ``CANONICAL``, or ``PARTIALCHOLESKY``,; respectively. Note that in practice, the MOs and OSOs are built separately within; each irrep from the symmetry-adapted combinations of AOs known as; Unique Symmetry Orbitals (USOs). For canonical orthogonalization,; this implies that the number of MOs and OSOs per irrep may be slightly; smaller than the number of USOs per irrep. A contrived example demonstrating OSOs/MOs vs. AOs with symmetry is shown; below::. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c2 # Two irreps is easier to comprehend; }. set {; s_tolerance 0.0001 # Set an unreasonably tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eigenvalues for even H2O; print 3; }. energy('scf'). Output::. ==> Pre-Iterations <==. -------------------------------------------------------; Irrep Nso Nmo Nalpha Nbeta Ndocc Nsocc; -------------------------------------------------------; A 145 145 0 0 0 0; B 142 142 0 0 0 0; -------------------------------------------------------; Total 287 287 5 5 5 0; -------------------------------------------------------. ... Minimum eigenvalue in the overlap matrix is 1.6888063568E-05.; Using Canonical Orthogonalization with cutoff of 1.0000000000E-04.; Irrep 0, 1 of 145 possible MOs eliminated.; Irrep 1, 2 of 142 possible MOs eliminated.; Overall, 3 of 287 possible MOs eliminated. In this example, there are 287 AO basis functions after spherical harmonics are; applied. These are used to produce 287 symmetry adapted USOs, 145 of which are; assigned to irrep A, and 142 of which are assigned to irrep B. Within irrep A,; 144 OSOs fall above the eigenval",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:18549,Availability,avail,available,18549,". In each step of the SCF procedure, a new Fock or Kohn--Sham potential is built; according to the previous density, following which the potential is diagonalized; to produce new molecular orbitals, from which a new density is computed. This; procedure is continued until either convergence is reached or a preset maximum; number of iterations is exceeded. Convergence is determined by both change in; energy and root-mean-square change in density matrix values, which must be below; the user-specified |scf__e_convergence| and |scf__d_convergence|, respectively.; The maximum number of iterations is specified by the |scf__maxiter| option. It; should be noted that SCF is a chaotic process, and, as such, often requires; careful selection of initial orbitals and damping during iterations to ensure; convergence. This is particularly likely for large systems, metallic systems,; multireference systems, open-shell systems, anions, and systems with diffuse; basis sets. For initial orbital selection, several options are available. These include:. CORE; Diagonalization of the core Hamiltonian, removing even mean-field electron; repulsion. Simple, but often too far from the final solution for larger; systems. This is the default for single atoms.; SAD [:term:`Default <GUESS (SCF)>`]; Superposition of Atomic Densities. Builds the initial density as the; spin-averaged sum of atomic UHF computations in the current basis. If an; open-shell system, uniform scaling of the spin-averaged density matrices is; performed. If orbitals are needed (*e.g.*, in density fitting), a partial; Cholesky factorization of the density matrices is used. Often extremely; accurate, particularly for closed-shell systems. This is the default for; systems of more than one atom.; SADNO; Natural orbitals from Superposition of Atomic Densities. Similar; to the above, but it forms natural orbitals from the SAD density; matrix to get proper orbitals which are used to start the; calculation, see [Lehtola:2019:1593]_.;",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:21269,Availability,error,error,21269," or after small geometry; changes. At present, casting from a different molecular point; group is not supported. This becomes the default for the second; and later iterations of geometry optimizations.; SAP; Superposition of Atomic Potentials. This is essentially a; modification of the core Hamiltonian, which includes screening; effects by using a radially screened effective atomic charge. The; screening effects have been calculated at the complete basis set; limit with finite-element calculations, see [Lehtola:2019:25945]_; and [Lehtola:2020:012516]_. The guess and its implementation have; been described in [Lehtola:2019:1593]_. The guess is evaluated on a; DFT quadrature grid, so the guess energy depends slightly on the; used DFT quadrature. The current implementation is based on; exchange-only local density calculations that are but nanohartree; away from the complete basis set limit [Lehtola:2020:012516]_.; SAPGAU; Superposition of Atomic Potentials, but using error function based; fits to the atomic radial potentials as discussed in; [Lehtola:2020:144105]_. The main difference to the SAP guess; discussed above [Lehtola:2019:25945]_ is that the SAPGAU scheme is; analytic, and can be efficiently formed in terms of three-center; two-electron integrals [Lehtola:2020:144105]_. The potential in; the SAPGAU scheme is passed with the |scf__sapgau_basis|; keyword. The default potential is given by the large fit to the; HelFEM potential, sap_helfem_large, described in; [Lehtola:2020:144105]_. Note that this guess is known in the DIRAC; program as .SCRPOT and in the ERKALE program as SAPFIT. These are all set by the |scf__guess| keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis. This can be done by adding; |scf__basis_guess| = SMALL_BASIS to the options list. We recommend the; 3-21G or pcseg-0 basis for the small basis due to its efficient mix of flexibility and; compactness. An ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:23175,Availability,avail,available,23175,"f__basis_guess| = SMALL_BASIS to the options list. We recommend the; 3-21G or pcseg-0 basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below::. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; basis_guess 3-21G; guess sad; }. energy('scf'). .. _`sec:scfrestart`:. Restarting the SCF; ~~~~~~~~~~~~~~~~~~. Reading orbital data from a previous calculations is done via the ``restart_file`` option,; where the actual file is a serialized ``wfn`` object (see :ref:`saving the wfn <sec:save_wfn>`); By default, the orbital data file of the converged SCF(``psi.PID.name.180.npy``) is deleted; after |PSIfour| exits or the ``clean()`` function is called. The orbital guess is automatically; set to ``READ`` when ``restart_file`` is given a ``wfn`` file.; To write the orbitals after every iteration and keep the orbitals from the last iteration, the ``write_orbitals`` options is available: ::. energy('scf', write_orbitals='my_mos'),. which writes a ``Wavefunction`` object converted (serialized) to a numpy file called ``my_mos.npy``.; The restart can then be done as follows: ::. energy('scf', restart_file='my_mos'). Specifying the ``.npy`` suffix when writing and reading restart files is optional. Alternatively, the restart can also be done from any previously saved ``wfn`` object. ::. energy, scf_wfn = energy('scf',return_wfn=True); scf_wfn.to_file('my_wfn'); energy('scf', restart_file='my_wfn'). For advanced users manipulating or writing custom wavefunction files, note; that |PSIfour| expects the numpy file on disk to have the ``.npy`` extension, not, e.g., `.npz`. .. index:: DIIS, MOM, damping. .. _`sec:scfconv`:. Convergence Stabilization; ~~~~~~~~~~~~~~~~~~~~~~~~~. A summary of Psi's supported convergence stabilization techniques is presented below:. DIIS [On by Default]; DIIS uses previous iterates o",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:24155,Availability,error,error,24155,"` options is available: ::. energy('scf', write_orbitals='my_mos'),. which writes a ``Wavefunction`` object converted (serialized) to a numpy file called ``my_mos.npy``.; The restart can then be done as follows: ::. energy('scf', restart_file='my_mos'). Specifying the ``.npy`` suffix when writing and reading restart files is optional. Alternatively, the restart can also be done from any previously saved ``wfn`` object. ::. energy, scf_wfn = energy('scf',return_wfn=True); scf_wfn.to_file('my_wfn'); energy('scf', restart_file='my_wfn'). For advanced users manipulating or writing custom wavefunction files, note; that |PSIfour| expects the numpy file on disk to have the ``.npy`` extension, not, e.g., `.npz`. .. index:: DIIS, MOM, damping. .. _`sec:scfconv`:. Convergence Stabilization; ~~~~~~~~~~~~~~~~~~~~~~~~~. A summary of Psi's supported convergence stabilization techniques is presented below:. DIIS [On by Default]; DIIS uses previous iterates of the Fock matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via :term:`options <DIIS (SCF)>`.; ADIIS [On by Default]; ADIIS uses previous iterates of the Fock and density matrices to produce an; informed estimate of the next Fock matrix. ADIIS estimates are based on minimizing; an energy estimate rather than zeroing the residual, so this performs best in the early; iterations. By default, Psi will start using ADIIS before blending the ADIIS step with; the DIIS step, eventually using the pure DIIS step. The closely-related EDIIS procedure; may be used instead by setting |scf__scf_initial_accelerator|. This is formally identical; to ADIIS for HF, but the methods will differ for more general DFT.; MOM [Off by Default]; MOM was developed to com",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:25201,Availability,failure,failure,25201,"sed on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via :term:`options <DIIS (SCF)>`.; ADIIS [On by Default]; ADIIS uses previous iterates of the Fock and density matrices to produce an; informed estimate of the next Fock matrix. ADIIS estimates are based on minimizing; an energy estimate rather than zeroing the residual, so this performs best in the early; iterations. By default, Psi will start using ADIIS before blending the ADIIS step with; the DIIS step, eventually using the pure DIIS step. The closely-related EDIIS procedure; may be used instead by setting |scf__scf_initial_accelerator|. This is formally identical; to ADIIS for HF, but the methods will differ for more general DFT.; MOM [Off by Default]; MOM was developed to combat a particular class of convergence failure:; occupation flipping. In some cases, midway though the SCF procedure, a partially; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbital which should be; destined to be a virtual orbital. This results in the virtual orbital being; spuriously occupied for one or more iterations. Sometimes this resolves itself; without help, other times the occupation flips back and forth between two, four,; or more orbitals. This is typically visible in the output as a non-converging; SCF which eventually settles down to steady oscillation between two (or more); different total energies. This behavior can be ameliorated by choosing occupied; orbitals by ""shape"" instead of by orbital eigenvalue, *i.e.*, by choosing the set; of new orbitals which looks most like some previously known ""good"" set. The; ""good"" set is typically the occupied orbitals from one of the oscillating; itera",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:25802,Availability,down,down,25802,"y default, Psi will start using ADIIS before blending the ADIIS step with; the DIIS step, eventually using the pure DIIS step. The closely-related EDIIS procedure; may be used instead by setting |scf__scf_initial_accelerator|. This is formally identical; to ADIIS for HF, but the methods will differ for more general DFT.; MOM [Off by Default]; MOM was developed to combat a particular class of convergence failure:; occupation flipping. In some cases, midway though the SCF procedure, a partially; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbital which should be; destined to be a virtual orbital. This results in the virtual orbital being; spuriously occupied for one or more iterations. Sometimes this resolves itself; without help, other times the occupation flips back and forth between two, four,; or more orbitals. This is typically visible in the output as a non-converging; SCF which eventually settles down to steady oscillation between two (or more); different total energies. This behavior can be ameliorated by choosing occupied; orbitals by ""shape"" instead of by orbital eigenvalue, *i.e.*, by choosing the set; of new orbitals which looks most like some previously known ""good"" set. The; ""good"" set is typically the occupied orbitals from one of the oscillating; iterations with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations :math:`N,N+2,\ldots`, invoking; |scf__mom_start| ``N`` can often rescue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent; iterations can quench oscillations. This mixing, known as; ""damping"" can be activated by setting the; |scf__damping_percentage| keyword to a nonzero percent. Damping is; turned off when the D",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:26798,Availability,error,error,26798,"wn to steady oscillation between two (or more); different total energies. This behavior can be ameliorated by choosing occupied; orbitals by ""shape"" instead of by orbital eigenvalue, *i.e.*, by choosing the set; of new orbitals which looks most like some previously known ""good"" set. The; ""good"" set is typically the occupied orbitals from one of the oscillating; iterations with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations :math:`N,N+2,\ldots`, invoking; |scf__mom_start| ``N`` can often rescue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent; iterations can quench oscillations. This mixing, known as; ""damping"" can be activated by setting the; |scf__damping_percentage| keyword to a nonzero percent. Damping is; turned off when the DIIS error is smaller than; |scf__damping_convergence|.; Level shifting [Off by default]; A commonly used alternative to damping is to use level shifting,; which decreases the mixing of occupied and unoccupied orbitals in; the SCF update by moving the unoccupied orbitals up in energy. It; can be shown that the SCF procedure always converges with a; suitably large level shift; however, the larger the shift is, the; slower the convergence becomes, and the calculation may end up; converging onto a higher lying SCF solution. Because of this, in; practice level shifting is most useful in the initial phase of the; calculation to reduce the orbital error enough for DIIS to work; well. The level shift is controlled by the parameter; |scf__level_shift|, and it is turned off when the DIIS error is; smaller than |scf__level_shift_cutoff|. Reasonable values for; the shift and convergence threshold are 5.0 and 1e-2,; respectively.; SOSCF [Off by Default]; See :ref:`sec:soscf`. .. _`sec:scferi`:. ERI Algorithm",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:27443,Availability,error,error,27443,"used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent; iterations can quench oscillations. This mixing, known as; ""damping"" can be activated by setting the; |scf__damping_percentage| keyword to a nonzero percent. Damping is; turned off when the DIIS error is smaller than; |scf__damping_convergence|.; Level shifting [Off by default]; A commonly used alternative to damping is to use level shifting,; which decreases the mixing of occupied and unoccupied orbitals in; the SCF update by moving the unoccupied orbitals up in energy. It; can be shown that the SCF procedure always converges with a; suitably large level shift; however, the larger the shift is, the; slower the convergence becomes, and the calculation may end up; converging onto a higher lying SCF solution. Because of this, in; practice level shifting is most useful in the initial phase of the; calculation to reduce the orbital error enough for DIIS to work; well. The level shift is controlled by the parameter; |scf__level_shift|, and it is turned off when the DIIS error is; smaller than |scf__level_shift_cutoff|. Reasonable values for; the shift and convergence threshold are 5.0 and 1e-2,; respectively.; SOSCF [Off by Default]; See :ref:`sec:soscf`. .. _`sec:scferi`:. ERI Algorithms; ~~~~~~~~~~~~~~. The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; |PSIfour| for these terms. The algorithm is selected by the |globals__scf_type|; keyword. Most consist of a single algorithm applied to; the construction of both the Coulomb and Exchange parts; of the Fock Matrix:. PK [:ref:`Default <table:conv_scf>`]; An out-of-core, presorted algorithm using exact ERIs. Quite fast for a; zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:27583,Availability,error,error,27583,"a static mixing of Fock Matrices from adjacent; iterations can quench oscillations. This mixing, known as; ""damping"" can be activated by setting the; |scf__damping_percentage| keyword to a nonzero percent. Damping is; turned off when the DIIS error is smaller than; |scf__damping_convergence|.; Level shifting [Off by default]; A commonly used alternative to damping is to use level shifting,; which decreases the mixing of occupied and unoccupied orbitals in; the SCF update by moving the unoccupied orbitals up in energy. It; can be shown that the SCF procedure always converges with a; suitably large level shift; however, the larger the shift is, the; slower the convergence becomes, and the calculation may end up; converging onto a higher lying SCF solution. Because of this, in; practice level shifting is most useful in the initial phase of the; calculation to reduce the orbital error enough for DIIS to work; well. The level shift is controlled by the parameter; |scf__level_shift|, and it is turned off when the DIIS error is; smaller than |scf__level_shift_cutoff|. Reasonable values for; the shift and convergence threshold are 5.0 and 1e-2,; respectively.; SOSCF [Off by Default]; See :ref:`sec:soscf`. .. _`sec:scferi`:. ERI Algorithms; ~~~~~~~~~~~~~~. The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; |PSIfour| for these terms. The algorithm is selected by the |globals__scf_type|; keyword. Most consist of a single algorithm applied to; the construction of both the Coulomb and Exchange parts; of the Fock Matrix:. PK [:ref:`Default <table:conv_scf>`]; An out-of-core, presorted algorithm using exact ERIs. Quite fast for a; zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of; integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact ERIs. Overcomes the; memory bottleneck of the curre",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:27960,Availability,avail,available,27960,"he mixing of occupied and unoccupied orbitals in; the SCF update by moving the unoccupied orbitals up in energy. It; can be shown that the SCF procedure always converges with a; suitably large level shift; however, the larger the shift is, the; slower the convergence becomes, and the calculation may end up; converging onto a higher lying SCF solution. Because of this, in; practice level shifting is most useful in the initial phase of the; calculation to reduce the orbital error enough for DIIS to work; well. The level shift is controlled by the parameter; |scf__level_shift|, and it is turned off when the DIIS error is; smaller than |scf__level_shift_cutoff|. Reasonable values for; the shift and convergence threshold are 5.0 and 1e-2,; respectively.; SOSCF [Off by Default]; See :ref:`sec:soscf`. .. _`sec:scferi`:. ERI Algorithms; ~~~~~~~~~~~~~~. The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; |PSIfour| for these terms. The algorithm is selected by the |globals__scf_type|; keyword. Most consist of a single algorithm applied to; the construction of both the Coulomb and Exchange parts; of the Fock Matrix:. PK [:ref:`Default <table:conv_scf>`]; An out-of-core, presorted algorithm using exact ERIs. Quite fast for a; zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of; integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact ERIs. Overcomes the; memory bottleneck of the current PK algorithm. Integrals are generated; only once, and symmetry is utilized to reduce number of integrals.; DIRECT; A threaded, sieved, integral-direct algorithm, with full permutational; symmetry. This algorithm is brand new, but seems to be reasonably fast; up to 1500 basis functions, uses zero disk (if DF pre-iterations are; turned off), and can obtain significant; speedups with negligible error loss i",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:28304,Availability,error,error,28304,"ion. Because of this, in; practice level shifting is most useful in the initial phase of the; calculation to reduce the orbital error enough for DIIS to work; well. The level shift is controlled by the parameter; |scf__level_shift|, and it is turned off when the DIIS error is; smaller than |scf__level_shift_cutoff|. Reasonable values for; the shift and convergence threshold are 5.0 and 1e-2,; respectively.; SOSCF [Off by Default]; See :ref:`sec:soscf`. .. _`sec:scferi`:. ERI Algorithms; ~~~~~~~~~~~~~~. The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; |PSIfour| for these terms. The algorithm is selected by the |globals__scf_type|; keyword. Most consist of a single algorithm applied to; the construction of both the Coulomb and Exchange parts; of the Fock Matrix:. PK [:ref:`Default <table:conv_scf>`]; An out-of-core, presorted algorithm using exact ERIs. Quite fast for a; zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of; integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact ERIs. Overcomes the; memory bottleneck of the current PK algorithm. Integrals are generated; only once, and symmetry is utilized to reduce number of integrals.; DIRECT; A threaded, sieved, integral-direct algorithm, with full permutational; symmetry. This algorithm is brand new, but seems to be reasonably fast; up to 1500 basis functions, uses zero disk (if DF pre-iterations are; turned off), and can obtain significant; speedups with negligible error loss if |scf__ints_tolerance|; is set to 1.0E-8 or so.; DF [:ref:`Default <table:conv_scf>`]; A density-fitted algorithm designed for computations with thousands of; basis functions. This algorithm is highly optimized, and is threaded; with a mixture of parallel BLAS and OpenMP. Note that this algorithm; should use the -JKFIT series of auxiliary bases, ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:28340,Availability,avail,available,28340,"ion. Because of this, in; practice level shifting is most useful in the initial phase of the; calculation to reduce the orbital error enough for DIIS to work; well. The level shift is controlled by the parameter; |scf__level_shift|, and it is turned off when the DIIS error is; smaller than |scf__level_shift_cutoff|. Reasonable values for; the shift and convergence threshold are 5.0 and 1e-2,; respectively.; SOSCF [Off by Default]; See :ref:`sec:soscf`. .. _`sec:scferi`:. ERI Algorithms; ~~~~~~~~~~~~~~. The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; |PSIfour| for these terms. The algorithm is selected by the |globals__scf_type|; keyword. Most consist of a single algorithm applied to; the construction of both the Coulomb and Exchange parts; of the Fock Matrix:. PK [:ref:`Default <table:conv_scf>`]; An out-of-core, presorted algorithm using exact ERIs. Quite fast for a; zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of; integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact ERIs. Overcomes the; memory bottleneck of the current PK algorithm. Integrals are generated; only once, and symmetry is utilized to reduce number of integrals.; DIRECT; A threaded, sieved, integral-direct algorithm, with full permutational; symmetry. This algorithm is brand new, but seems to be reasonably fast; up to 1500 basis functions, uses zero disk (if DF pre-iterations are; turned off), and can obtain significant; speedups with negligible error loss if |scf__ints_tolerance|; is set to 1.0E-8 or so.; DF [:ref:`Default <table:conv_scf>`]; A density-fitted algorithm designed for computations with thousands of; basis functions. This algorithm is highly optimized, and is threaded; with a mixture of parallel BLAS and OpenMP. Note that this algorithm; should use the -JKFIT series of auxiliary bases, ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:28954,Availability,error,error,28954,"the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; |PSIfour| for these terms. The algorithm is selected by the |globals__scf_type|; keyword. Most consist of a single algorithm applied to; the construction of both the Coulomb and Exchange parts; of the Fock Matrix:. PK [:ref:`Default <table:conv_scf>`]; An out-of-core, presorted algorithm using exact ERIs. Quite fast for a; zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of; integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact ERIs. Overcomes the; memory bottleneck of the current PK algorithm. Integrals are generated; only once, and symmetry is utilized to reduce number of integrals.; DIRECT; A threaded, sieved, integral-direct algorithm, with full permutational; symmetry. This algorithm is brand new, but seems to be reasonably fast; up to 1500 basis functions, uses zero disk (if DF pre-iterations are; turned off), and can obtain significant; speedups with negligible error loss if |scf__ints_tolerance|; is set to 1.0E-8 or so.; DF [:ref:`Default <table:conv_scf>`]; A density-fitted algorithm designed for computations with thousands of; basis functions. This algorithm is highly optimized, and is threaded; with a mixture of parallel BLAS and OpenMP. Note that this algorithm; should use the -JKFIT series of auxiliary bases, *not* the -RI or; -MP2FIT bases. The default guess for auxiliary basis set should work; for most bases, otherwise the |scf__df_basis_scf| keyword can; be used to manually specify the auxiliary basis. This algorithm is; preferred unless either absolute accuracy is required; [:math:`\gtrsim`\ CCSD(T)] or a -JKFIT auxiliary basis is unavailable; for the orbital basis/atoms involved.; CD; A threaded algorithm using approximate ERIs obtained by Cholesky; decomposition of the ERI tensor. The accuracy of the Cholesky; decomposition is controlled by the keyword |scf",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:30598,Availability,redundant,redundant,30598,"gtrsim`\ CCSD(T)] or a -JKFIT auxiliary basis is unavailable; for the orbital basis/atoms involved.; CD; A threaded algorithm using approximate ERIs obtained by Cholesky; decomposition of the ERI tensor. The accuracy of the Cholesky; decomposition is controlled by the keyword |scf__cholesky_tolerance|.; This algorithm is similar to the DF algorithm, but it is not suitable; for gradient computations. The algorithm to obtain the Cholesky; vectors is not designed for computations with thousands of basis; functions. |PSIfour| also features the capability to use ""composite"" Fock matrix build; algorithms - arbitrary combinations of specialized algorithms that construct; either the Coulomb or the Exchange matrix separately. In general, since; separate Coulomb and Exchange matrix build algorithms exploit properties specific to; their respective matrix, composite algorithms display lower; scaling factors than their combined Fock build counterparts. However, composite algorithms also; introduce redundant ERI computations into the calculation. Therefore, composite Fock build; algorithms tend to perform better for larger systems, but worse for smaller systems. Arbitrary; composite algorithms can be accessed by setting |globals__scf_type| to ``J_alg+K_alg``,; where *J_alg* and *K_alg* are the names of the separate Coulomb; and Exchange construction algorithms to use, respectively. Alternatively, if one is using; DFT with non-hybrid functionals, a composite Coulomb construction algorithm can be; specified solo by setting |globals__scf_type| to ``J_alg``, without the need to set ; an associated ``K_alg``. Specialized algorithms available to construct the Coulomb term within a composite framework ; are as follows:. DFDIRJ; An integral-direct algorithm constructing the Coulomb term based on [Weigend:2002:4285]_; The DFDIRJ algorithm combines the benefits of integral-direct SCF approaches ; with that of density-fitting. Specifically, DFJ utilizes no I/O and displays ; strong performan",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:31239,Availability,avail,available,31239," either the Coulomb or the Exchange matrix separately. In general, since; separate Coulomb and Exchange matrix build algorithms exploit properties specific to; their respective matrix, composite algorithms display lower; scaling factors than their combined Fock build counterparts. However, composite algorithms also; introduce redundant ERI computations into the calculation. Therefore, composite Fock build; algorithms tend to perform better for larger systems, but worse for smaller systems. Arbitrary; composite algorithms can be accessed by setting |globals__scf_type| to ``J_alg+K_alg``,; where *J_alg* and *K_alg* are the names of the separate Coulomb; and Exchange construction algorithms to use, respectively. Alternatively, if one is using; DFT with non-hybrid functionals, a composite Coulomb construction algorithm can be; specified solo by setting |globals__scf_type| to ``J_alg``, without the need to set ; an associated ``K_alg``. Specialized algorithms available to construct the Coulomb term within a composite framework ; are as follows:. DFDIRJ; An integral-direct algorithm constructing the Coulomb term based on [Weigend:2002:4285]_; The DFDIRJ algorithm combines the benefits of integral-direct SCF approaches ; with that of density-fitting. Specifically, DFJ utilizes no I/O and displays ; strong performance with large system size through a combination of ; effective parallelization and utilization of density-fitting to minimize ; ERI computational cost. See the :ref:`sec:scfddfj` section for more information. Specialized algorithms available to construct the Exchange term within a composite framework; are as follows:. COSX; An algorithm based on the semi-numerical ""chain of spheres exchange"" (COSX); approach described in [Neese:2009:98]_. The coulomb term is computed with a; direct density-fitting algorithm. The COSX algorithm uses no I/O, scales; well with system size, and requires minimal memory, making it ideal for; large systems and multi-core CPUs. See :ref:`",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:31831,Availability,avail,available,31831,",; where *J_alg* and *K_alg* are the names of the separate Coulomb; and Exchange construction algorithms to use, respectively. Alternatively, if one is using; DFT with non-hybrid functionals, a composite Coulomb construction algorithm can be; specified solo by setting |globals__scf_type| to ``J_alg``, without the need to set ; an associated ``K_alg``. Specialized algorithms available to construct the Coulomb term within a composite framework ; are as follows:. DFDIRJ; An integral-direct algorithm constructing the Coulomb term based on [Weigend:2002:4285]_; The DFDIRJ algorithm combines the benefits of integral-direct SCF approaches ; with that of density-fitting. Specifically, DFJ utilizes no I/O and displays ; strong performance with large system size through a combination of ; effective parallelization and utilization of density-fitting to minimize ; ERI computational cost. See the :ref:`sec:scfddfj` section for more information. Specialized algorithms available to construct the Exchange term within a composite framework; are as follows:. COSX; An algorithm based on the semi-numerical ""chain of spheres exchange"" (COSX); approach described in [Neese:2009:98]_. The coulomb term is computed with a; direct density-fitting algorithm. The COSX algorithm uses no I/O, scales; well with system size, and requires minimal memory, making it ideal for; large systems and multi-core CPUs. See :ref:`sec:scfcosx` for more information.; LINK; An implementation of the linear-scaling ""Linear Exchange"" (LinK); algorithm described in [Ochsenfeld:1998:1663]_. The LINK algorithm provides ; many of the benefits of integral-direct SCF algorithms, including no disk I/O, ; low memory usage, and effective parallelization. Additionally, the; LINK implementation scales well with system size ; while simultaneously providing a formally-exact computation of the ; Exchange term. See :ref:`sec:scflink` for more information. In some cases the above algorithms have multiple implementations that return;",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:37677,Availability,avail,available,37677,"ity-Fitted Coulomb Construction; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. The Resolution of the Identity (RI) can be used to decompose the normally 4-center ERI tensor into a combination of 3-center and 2-center components.; By reducing the dimensionality of the ERI tensor, application of the RI (often referred to as density-fitting, or DF) can be used to greatly speed up; SCF calculations. The reduction in ERI tensor rank also makes DF an appealing option for conventional SCF calculations, where the ERIs are stored ; in core or on disk. However, even when using DF, I/O becomes a significant bottleneck for systems of a sufficient size when performing conventional SCF; calculations. In principle, though, DF approaches can be utilized in an integral-direct context, gaining the benefits of DF methods without suffering the; I/O bottlenecks that conventional DF methods will eventually run into. One such approach, outlined by Weigend in [Weigend:2002:4285]_,; is available for use in Psi4 for the separate construction of the Coulomb contribution to the Fock matrix. This implementation can be used alongside ; Psi4's separate Exchange construction algorithms for composite Fock matrix construction by using the keyword DFDIRJ as the Coulomb construction ; algorithm when specifying |globals__scf_type| to use a composite algorithm combination (``DFDIRJ+K_alg`` in general, ; or ``DFDIRJ`` for DFT with non-hybrid functionals). . DFDIRJ supports multiple capabilities to improve performance. Specifically, DFDIRJ allows for a combination of density-matrix based ERI ; screening (set |globals__screening| to ``DENSITY``) and incremental Fock matrix construction (set |scf__incfock| to ``TRUE``). These two, when combined,; enable more aggressive screening of ERI contributions to the Coulomb matrix and thus greatly improve performance. .. _`sec:scfcosx`:. COSX Exchange; ~~~~~~~~~~~~~. The semi-numerical COSX algorithm described in [Neese:2009:98]_ evaluates; two-electron ERIs a",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:39526,Availability,error,errors,39526,"ormance. .. _`sec:scfcosx`:. COSX Exchange; ~~~~~~~~~~~~~. The semi-numerical COSX algorithm described in [Neese:2009:98]_ evaluates; two-electron ERIs analytically over one electron coordinate and numerically; over the other electron coordinate, and belongs to the family of pseudospectral ; methods originally suggested by Friesner. In COSX, numerical integration is performed on standard; DFT quadrature grids, which are described in :ref:`sec:dft`.; Both the accuracy of the COSX algorithm and also the computational; cost are directly determined by the size of the integration grid, so selection; of the grid is important. This COSX implementation uses two separate grids.; By default, the SCF algorithm is first converged on a smaller grid, followed by a; number of SCF iterations up to a maximum value (controlled by the |scf__cosx_maxiter_final| keyword); on a larger grid. By default, |scf__cosx_maxiter_final| is set to 1, a single; SCF iteration, which results in numerical errors comparable to; performing the entire SCF on the expensive larger grid at a computational cost; much closer to the smaller grid. Setting |scf__cosx_maxiter_final| to 0 disables the; larger grid entirely. Setting |scf__cosx_maxiter_final| to -1 allows; for the SCF to fully converge on the larger grid, useful for the study of wavefunction; properties such as gradients. The size of the initial grid is controlled by the keywords; |scf__cosx_radial_points_initial| and |scf__cosx_spherical_points_initial|.; The final grid is controlled by |scf__cosx_radial_points_final| and; |scf__cosx_spherical_points_final|. Currently, the default grids are very crude,; allowing for high performance at the cost of accuracy. If high-accuracy calculations; are desired with COSX, the grid sizes should be increased. Screening thresholds over integrals, densities, and basis extents are set; with the |scf__cosx_ints_tolerance|, |scf__cosx_density_tolerance|, and; |scf__cosx_basis_tolerance| keywords, respectively. |scf__",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:41465,Availability,error,errors,41465,"ensity_tolerance|, and; |scf__cosx_basis_tolerance| keywords, respectively. |scf__cosx_ints_tolerance|; is the most consequential of the three thresholds in both cost and accuracy.; This keyword determines screening of negligible one-electron integrals.; |scf__cosx_density_tolerance| controls the threshold for significant; shell pairs in the density matrix. Lastly, |scf__cosx_basis_tolerance| is; a cutoff for the value of basis functions at grid points. This keyword is; used to determine the radial extent of the each basis shell, and it is the; COSX analogue to |scf__dft_basis_tolerance|. The |scf__incfock| keyword (defaults to ``false``) increases performance; by constructing the Fock matrix from differences in the density matrix, which; are more amenable to screening. This option is disabled by default because of; potential SCF convergence issues, particularly when using diffuse basis functions.; The |scf__cosx_overlap_fitting| keyword (defaults to ``true``) reduces numerical; integration errors using the method described in [Izsak:2011:144105]_ and is; always recommended. .. _`sec:scflink`:. Linear Exchange; ~~~~~~~~~~~~~~~. Large SCF calculations can benefit from specialized screening procedures that further reduce the scaling of the ERI contribution to the Fock matrix.; LinK, the linear-scaling exchange method described in [Ochsenfeld:1998:1663]_, is available in Psi4 in conjunction with composite algorithms that build J (|globals__scf_type| set to ``J_alg+LINK``).; LinK achieves linear-scaling by exploiting shell pair sparsity in the density matrix and overlap sparsity between shell pairs. Specifically, LinK exploits the fact that the Exchange term; requires only a linear-scaling number of significant elements through reformulating the; shell quartet screening process to scale linearly with system size.; LinK is most competitive when used with non-diffuse orbital basis sets, since orbital and density overlaps decay slower with diffuse functions.; LinK is especi",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:41837,Availability,avail,available,41837,"| is; a cutoff for the value of basis functions at grid points. This keyword is; used to determine the radial extent of the each basis shell, and it is the; COSX analogue to |scf__dft_basis_tolerance|. The |scf__incfock| keyword (defaults to ``false``) increases performance; by constructing the Fock matrix from differences in the density matrix, which; are more amenable to screening. This option is disabled by default because of; potential SCF convergence issues, particularly when using diffuse basis functions.; The |scf__cosx_overlap_fitting| keyword (defaults to ``true``) reduces numerical; integration errors using the method described in [Izsak:2011:144105]_ and is; always recommended. .. _`sec:scflink`:. Linear Exchange; ~~~~~~~~~~~~~~~. Large SCF calculations can benefit from specialized screening procedures that further reduce the scaling of the ERI contribution to the Fock matrix.; LinK, the linear-scaling exchange method described in [Ochsenfeld:1998:1663]_, is available in Psi4 in conjunction with composite algorithms that build J (|globals__scf_type| set to ``J_alg+LINK``).; LinK achieves linear-scaling by exploiting shell pair sparsity in the density matrix and overlap sparsity between shell pairs. Specifically, LinK exploits the fact that the Exchange term; requires only a linear-scaling number of significant elements through reformulating the; shell quartet screening process to scale linearly with system size.; LinK is most competitive when used with non-diffuse orbital basis sets, since orbital and density overlaps decay slower with diffuse functions.; LinK is especially powerful when combined with density-matrix based ERI screening (set |globals__screening| to ``DENSITY``) and incremental Fock builds (set |scf__incfock| to ``TRUE``), which decrease the number of significant two-electron integrals to calculate. To control the LinK algorithm, here are the list of options provided.; ; |scf__linK_ints_tolerance|: The integral screening tolerance used for ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:42834,Availability,toler,tolerance,42834,"is available in Psi4 in conjunction with composite algorithms that build J (|globals__scf_type| set to ``J_alg+LINK``).; LinK achieves linear-scaling by exploiting shell pair sparsity in the density matrix and overlap sparsity between shell pairs. Specifically, LinK exploits the fact that the Exchange term; requires only a linear-scaling number of significant elements through reformulating the; shell quartet screening process to scale linearly with system size.; LinK is most competitive when used with non-diffuse orbital basis sets, since orbital and density overlaps decay slower with diffuse functions.; LinK is especially powerful when combined with density-matrix based ERI screening (set |globals__screening| to ``DENSITY``) and incremental Fock builds (set |scf__incfock| to ``TRUE``), which decrease the number of significant two-electron integrals to calculate. To control the LinK algorithm, here are the list of options provided.; ; |scf__linK_ints_tolerance|: The integral screening tolerance used for sparsity-prep in the LinK algorithm. Defaults to the |scf__ints_tolerance| option. .. index::; single: SOSCF. .. _`sec:soscf`:. Second-order Convergence; ~~~~~~~~~~~~~~~~~~~~~~~~. Second-order convergence takes into account both the gradient and Hessian to; take a full Newton step with respect to the orbital parameters. This results in; quadratic convergence with respect to density for SCF methods. For cases where; normal acceleration methods either fail or take many iterations to converge,; second-order can reduce the total time to solution. Solving second-order (SO) methods exactly would require an inversion of the; orbital Hessian (an expensive :math:`\mathbb{N}^6` operation); however, these; equations are normally solved iteratively where each iteration costs the same; as a normal Fock build (:math:`\mathbb{N}^4`). The overall SOSCF operation is; thus broken down into micro- and macroiterations where the microiterations; refer to solving the SOSCF equations and m",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:43728,Availability,down,down,43728,"e|: The integral screening tolerance used for sparsity-prep in the LinK algorithm. Defaults to the |scf__ints_tolerance| option. .. index::; single: SOSCF. .. _`sec:soscf`:. Second-order Convergence; ~~~~~~~~~~~~~~~~~~~~~~~~. Second-order convergence takes into account both the gradient and Hessian to; take a full Newton step with respect to the orbital parameters. This results in; quadratic convergence with respect to density for SCF methods. For cases where; normal acceleration methods either fail or take many iterations to converge,; second-order can reduce the total time to solution. Solving second-order (SO) methods exactly would require an inversion of the; orbital Hessian (an expensive :math:`\mathbb{N}^6` operation); however, these; equations are normally solved iteratively where each iteration costs the same; as a normal Fock build (:math:`\mathbb{N}^4`). The overall SOSCF operation is; thus broken down into micro- and macroiterations where the microiterations; refer to solving the SOSCF equations and macroiterations are the construction; of a new Fock matrix based on the orbitals from a SOSCF step. SOSCF requires that all elements of the gradient to be less than one before the; method is valid. To this end, pre-SOSCF SCF iterations use normal; gradient-based extrapolation procedures (*e.g.*, DIIS) until the gradient; conditions are met. Note that while the total number of macroiterations will be; less for SOSCF than gradient-based convergence acceleration, the cost of solving; the microiterations typically results in the overall cost being greater for; SOSCF than for gradient-based methods. Therefore, SOSCF should only be used if; it is difficult to locate a stable minimum. SOSCF is available for all HF and DFT references with the exception of meta-; GGA functionals. To enable, set the option |scf__soscf| to ``true``.; Additional options to modify the number of microiterations taken are as; follows:. |scf__soscf_start_convergence|: when to start SOSCF based",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:44529,Availability,avail,available,44529,"s are normally solved iteratively where each iteration costs the same; as a normal Fock build (:math:`\mathbb{N}^4`). The overall SOSCF operation is; thus broken down into micro- and macroiterations where the microiterations; refer to solving the SOSCF equations and macroiterations are the construction; of a new Fock matrix based on the orbitals from a SOSCF step. SOSCF requires that all elements of the gradient to be less than one before the; method is valid. To this end, pre-SOSCF SCF iterations use normal; gradient-based extrapolation procedures (*e.g.*, DIIS) until the gradient; conditions are met. Note that while the total number of macroiterations will be; less for SOSCF than gradient-based convergence acceleration, the cost of solving; the microiterations typically results in the overall cost being greater for; SOSCF than for gradient-based methods. Therefore, SOSCF should only be used if; it is difficult to locate a stable minimum. SOSCF is available for all HF and DFT references with the exception of meta-; GGA functionals. To enable, set the option |scf__soscf| to ``true``.; Additional options to modify the number of microiterations taken are as; follows:. |scf__soscf_start_convergence|: when to start SOSCF based on the current density RMS. |scf__soscf_max_iter|: the maximum number of SOSCF microiterations per macroiteration. |scf__soscf_conv|: the relative convergence tolerance of the SOSCF microiterations. |scf__soscf_print|: option to print the microiterations or not. .. _`sec:scfstability_doc`:. Stability Analysis; ~~~~~~~~~~~~~~~~~~. SCF algorithms attempt to minimize the gradient of the energy with respect; to orbital variation parameters. At convergence, the gradient should be approximately zero; given a convergence criterion. Although this is enough to make sure the SCF converged to a; stationary point, this is not a sufficient condition for a minimal SCF solution. It may be; a saddle point or a maximum. To ensure that a minimum has been found, the ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:44968,Availability,toler,tolerance,44968," of the gradient to be less than one before the; method is valid. To this end, pre-SOSCF SCF iterations use normal; gradient-based extrapolation procedures (*e.g.*, DIIS) until the gradient; conditions are met. Note that while the total number of macroiterations will be; less for SOSCF than gradient-based convergence acceleration, the cost of solving; the microiterations typically results in the overall cost being greater for; SOSCF than for gradient-based methods. Therefore, SOSCF should only be used if; it is difficult to locate a stable minimum. SOSCF is available for all HF and DFT references with the exception of meta-; GGA functionals. To enable, set the option |scf__soscf| to ``true``.; Additional options to modify the number of microiterations taken are as; follows:. |scf__soscf_start_convergence|: when to start SOSCF based on the current density RMS. |scf__soscf_max_iter|: the maximum number of SOSCF microiterations per macroiteration. |scf__soscf_conv|: the relative convergence tolerance of the SOSCF microiterations. |scf__soscf_print|: option to print the microiterations or not. .. _`sec:scfstability_doc`:. Stability Analysis; ~~~~~~~~~~~~~~~~~~. SCF algorithms attempt to minimize the gradient of the energy with respect; to orbital variation parameters. At convergence, the gradient should be approximately zero; given a convergence criterion. Although this is enough to make sure the SCF converged to a; stationary point, this is not a sufficient condition for a minimal SCF solution. It may be; a saddle point or a maximum. To ensure that a minimum has been found, the electronic Hessian, *i.e.* the matrix of second; derivatives of the energy with respect to orbital variation parameters, must be computed.; If one or more eigenvalues of the electronic Hessian are negative, the SCF solution is not a minimum.; In that case, orbital parameters can be varied along the lowest Hessian eigenvector to lower the energy. Orbital variation parameters are usually constrain",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:48160,Availability,avail,available,48160,"tion, you can tune the scale factor for the orbital; rotation through the keyword |scf__follow_step_scale|.; The rotation angle is :math:`\frac{\pi}{2}\mbox{ } \cdot` (|scf__follow_step_scale|). The default value of; 0.5 usually provides a good guess, and modification is only recommended in difficult cases.; The default behavior for the stability code is to stop after trying to reoptimize the orbitals once; if the instability still exists. For more attempts, set |scf__max_attempts|;; the default value of 1 is recommended. In case the SCF ends up in the same minimum, modification; of |scf__follow_step_scale| is recommended over increasing |scf__max_attempts|. .. note:: Setting the option |scf__stability_analysis| to ``FOLLOW`` is only avalible for UHF. When using; RHF and ROHF instabilities can be checked, but not followed. If you want to attempt to find a lower energy solution; you should re-run the calculation with |scf__reference| set to ``UHF``. The main algorithm available in |PSIfour| is the Direct Inversion algorithm. It can *only*; work with |globals__scf_type| ``PK``, and it explicitly builds the full electronic Hessian; matrix before explicitly inverting it. As such, this algorithm is very slow and it should; be avoided whenever possible. Direct Inversion is automatically invoked if the newer algorithm; is not available. The Davidson algorithm for stability analysis was implemented recently.; Only the lowest eigenvalues of the electronic Hessian are computed, and Hessian-vector; products are computed instead of the full Hessian. This algorithm is thus; much more efficient than the Direct Inversion, but at present, it is only available for UHF :math:`\rightarrow` UHF stability; analysis. The capabilities of both algorithms are summarized below:. .. _`table:stab_methods`:. .. table:: Stability analysis methods available in |PSIfour|. +------------------+------------------+----------------------------------------------+---------------------------+--------------",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:48519,Availability,avail,available,48519," The default behavior for the stability code is to stop after trying to reoptimize the orbitals once; if the instability still exists. For more attempts, set |scf__max_attempts|;; the default value of 1 is recommended. In case the SCF ends up in the same minimum, modification; of |scf__follow_step_scale| is recommended over increasing |scf__max_attempts|. .. note:: Setting the option |scf__stability_analysis| to ``FOLLOW`` is only avalible for UHF. When using; RHF and ROHF instabilities can be checked, but not followed. If you want to attempt to find a lower energy solution; you should re-run the calculation with |scf__reference| set to ``UHF``. The main algorithm available in |PSIfour| is the Direct Inversion algorithm. It can *only*; work with |globals__scf_type| ``PK``, and it explicitly builds the full electronic Hessian; matrix before explicitly inverting it. As such, this algorithm is very slow and it should; be avoided whenever possible. Direct Inversion is automatically invoked if the newer algorithm; is not available. The Davidson algorithm for stability analysis was implemented recently.; Only the lowest eigenvalues of the electronic Hessian are computed, and Hessian-vector; products are computed instead of the full Hessian. This algorithm is thus; much more efficient than the Direct Inversion, but at present, it is only available for UHF :math:`\rightarrow` UHF stability; analysis. The capabilities of both algorithms are summarized below:. .. _`table:stab_methods`:. .. table:: Stability analysis methods available in |PSIfour|. +------------------+------------------+----------------------------------------------+---------------------------+---------------------+; | Algorithm | |scf__reference| | Stability checked | |scf__stability_analysis| | |globals__scf_type| |; +==================+==================+==============================================+===========================+=====================+; | | RHF | Internal, External (:math:`\rightarrow` UHF) |",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:48840,Availability,avail,available,48840,"ng |scf__max_attempts|. .. note:: Setting the option |scf__stability_analysis| to ``FOLLOW`` is only avalible for UHF. When using; RHF and ROHF instabilities can be checked, but not followed. If you want to attempt to find a lower energy solution; you should re-run the calculation with |scf__reference| set to ``UHF``. The main algorithm available in |PSIfour| is the Direct Inversion algorithm. It can *only*; work with |globals__scf_type| ``PK``, and it explicitly builds the full electronic Hessian; matrix before explicitly inverting it. As such, this algorithm is very slow and it should; be avoided whenever possible. Direct Inversion is automatically invoked if the newer algorithm; is not available. The Davidson algorithm for stability analysis was implemented recently.; Only the lowest eigenvalues of the electronic Hessian are computed, and Hessian-vector; products are computed instead of the full Hessian. This algorithm is thus; much more efficient than the Direct Inversion, but at present, it is only available for UHF :math:`\rightarrow` UHF stability; analysis. The capabilities of both algorithms are summarized below:. .. _`table:stab_methods`:. .. table:: Stability analysis methods available in |PSIfour|. +------------------+------------------+----------------------------------------------+---------------------------+---------------------+; | Algorithm | |scf__reference| | Stability checked | |scf__stability_analysis| | |globals__scf_type| |; +==================+==================+==============================================+===========================+=====================+; | | RHF | Internal, External (:math:`\rightarrow` UHF) | ``CHECK`` | PK only |; + +------------------+----------------------------------------------+---------------------------+---------------------+; | Direct Inversion | ROHF | Internal | ``CHECK`` | PK only |; +------------------+------------------+----------------------------------------------+---------------------------+--------------",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:49027,Availability,avail,available,49027,"want to attempt to find a lower energy solution; you should re-run the calculation with |scf__reference| set to ``UHF``. The main algorithm available in |PSIfour| is the Direct Inversion algorithm. It can *only*; work with |globals__scf_type| ``PK``, and it explicitly builds the full electronic Hessian; matrix before explicitly inverting it. As such, this algorithm is very slow and it should; be avoided whenever possible. Direct Inversion is automatically invoked if the newer algorithm; is not available. The Davidson algorithm for stability analysis was implemented recently.; Only the lowest eigenvalues of the electronic Hessian are computed, and Hessian-vector; products are computed instead of the full Hessian. This algorithm is thus; much more efficient than the Direct Inversion, but at present, it is only available for UHF :math:`\rightarrow` UHF stability; analysis. The capabilities of both algorithms are summarized below:. .. _`table:stab_methods`:. .. table:: Stability analysis methods available in |PSIfour|. +------------------+------------------+----------------------------------------------+---------------------------+---------------------+; | Algorithm | |scf__reference| | Stability checked | |scf__stability_analysis| | |globals__scf_type| |; +==================+==================+==============================================+===========================+=====================+; | | RHF | Internal, External (:math:`\rightarrow` UHF) | ``CHECK`` | PK only |; + +------------------+----------------------------------------------+---------------------------+---------------------+; | Direct Inversion | ROHF | Internal | ``CHECK`` | PK only |; +------------------+------------------+----------------------------------------------+---------------------------+---------------------+; | Davidson | UHF | Internal | ``CHECK`` or ``FOLLOW`` | Anything |; +------------------+------------------+----------------------------------------------+---------------------------+-------",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:50191,Availability,avail,available,50191,"|scf__stability_analysis| | |globals__scf_type| |; +==================+==================+==============================================+===========================+=====================+; | | RHF | Internal, External (:math:`\rightarrow` UHF) | ``CHECK`` | PK only |; + +------------------+----------------------------------------------+---------------------------+---------------------+; | Direct Inversion | ROHF | Internal | ``CHECK`` | PK only |; +------------------+------------------+----------------------------------------------+---------------------------+---------------------+; | Davidson | UHF | Internal | ``CHECK`` or ``FOLLOW`` | Anything |; +------------------+------------------+----------------------------------------------+---------------------------+---------------------+. The best algorithm is automatically selected, *i.e.* Davidson for UHF :math:`\rightarrow` UHF and Direct Inversion otherwise. In addition to the options available for Direct Inversion, the Davidson algorithm can automatically; adapt |scf__follow_step_scale| to find a new SCF minimum. If |scf__max_attempts| > 1, additional attempts; will automatically increment |scf__follow_step_scale| by 0.2 every time the SCF falls back to the previously; found unstable minimum. The increment can be adjusted by setting |scf__follow_step_increment|.; The default value is 0.2; adjust if needed to try different values of |scf__follow_step_scale| in a single computation. The Davidson solver for the eigenvalues is controlled through several keywords. |scf__solver_maxiter|: maximum number of iterations. |scf__solver_convergence|: eigenvector convergence threshold. |scf__solver_n_root|: Solve for N eigenvectors in each irreducible representation. |scf__solver_roots_per_irrep|: The number of eigenvectors to solve in each irreducible representation. An array of as many integers as there are irreducible representations. |scf__solver_n_guess|: Use N guess vectors, this needs to be larger than the number of roots ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:51283,Availability,reliab,reliably,51283,"n, the Davidson algorithm can automatically; adapt |scf__follow_step_scale| to find a new SCF minimum. If |scf__max_attempts| > 1, additional attempts; will automatically increment |scf__follow_step_scale| by 0.2 every time the SCF falls back to the previously; found unstable minimum. The increment can be adjusted by setting |scf__follow_step_increment|.; The default value is 0.2; adjust if needed to try different values of |scf__follow_step_scale| in a single computation. The Davidson solver for the eigenvalues is controlled through several keywords. |scf__solver_maxiter|: maximum number of iterations. |scf__solver_convergence|: eigenvector convergence threshold. |scf__solver_n_root|: Solve for N eigenvectors in each irreducible representation. |scf__solver_roots_per_irrep|: The number of eigenvectors to solve in each irreducible representation. An array of as many integers as there are irreducible representations. |scf__solver_n_guess|: Use N guess vectors, this needs to be larger than the number of roots so that the lowest ones can be captured reliably. Defaults to 4 guess vectors per root. .. warning:: Prior to Dec 2022, v1.7, Psi4 had a different set of keywords controlling instability analysis, and those were included in the CPHF module rather than the SCF module.; .. warning:: Extending Davidson instability analysis to Kohn-Sham references is under development. As of 1.7, only LDA functionals are currently supported. In case convergence problems are encountered during the Davidson procedure, file a bug report.; If the solver seems to converge on the wrong eigenvalue, try increasing |scf__solver_n_guess|.; Otherwise, if the solver is almost converged but reaches the maximum number of iterations, try increasing; |scf__solver_maxiter|. .. _`sec:scf-ecps`:. Effective core potentials (ECPs); ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. |PSIfour| supports the use of effective core potentials to describe the; innermost electrons in heavy elements.; ECPs are only available if |P",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:52206,Availability,avail,available,52206,"ts so that the lowest ones can be captured reliably. Defaults to 4 guess vectors per root. .. warning:: Prior to Dec 2022, v1.7, Psi4 had a different set of keywords controlling instability analysis, and those were included in the CPHF module rather than the SCF module.; .. warning:: Extending Davidson instability analysis to Kohn-Sham references is under development. As of 1.7, only LDA functionals are currently supported. In case convergence problems are encountered during the Davidson procedure, file a bug report.; If the solver seems to converge on the wrong eigenvalue, try increasing |scf__solver_n_guess|.; Otherwise, if the solver is almost converged but reaches the maximum number of iterations, try increasing; |scf__solver_maxiter|. .. _`sec:scf-ecps`:. Effective core potentials (ECPs); ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. |PSIfour| supports the use of effective core potentials to describe the; innermost electrons in heavy elements.; ECPs are only available if |PSIfour| is compiled with the :ref:`LibECPInt <cmake:ecpint>` library.; If a basis set is designed to use an; effective core potential, the ECP definition should be simply placed alongside; the orbital basis set definition, *c.f.* :ref:`sec:basissets-ecps`. All; information related to the definition and number of core electrons will; automatically be detected and no further input is required to use the; ECP-containing basis set. See :srcsample:`scf-ecp` and :srcsample:`dfmp2-ecp`; for examples of computations with ECP-containing basis sets. .. warning:: Prior to May 2022, v1.6, Psi4 used a built-in ECP code. Analytic derivatives of ECPs were not available. The HF and DFT derivatives were implemented in a semi-numerical scheme, where numerical ECP gradients were added to analytic SCF gradients. For post-SCF methods, the entire gradient computation needed to be run as finite difference of energies. .. warning:: As of May 2022, v1.6, Psi4 uses the LibECPInt library, and analytic derivatives and Hessians of E",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:52874,Availability,avail,available,52874," Otherwise, if the solver is almost converged but reaches the maximum number of iterations, try increasing; |scf__solver_maxiter|. .. _`sec:scf-ecps`:. Effective core potentials (ECPs); ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. |PSIfour| supports the use of effective core potentials to describe the; innermost electrons in heavy elements.; ECPs are only available if |PSIfour| is compiled with the :ref:`LibECPInt <cmake:ecpint>` library.; If a basis set is designed to use an; effective core potential, the ECP definition should be simply placed alongside; the orbital basis set definition, *c.f.* :ref:`sec:basissets-ecps`. All; information related to the definition and number of core electrons will; automatically be detected and no further input is required to use the; ECP-containing basis set. See :srcsample:`scf-ecp` and :srcsample:`dfmp2-ecp`; for examples of computations with ECP-containing basis sets. .. warning:: Prior to May 2022, v1.6, Psi4 used a built-in ECP code. Analytic derivatives of ECPs were not available. The HF and DFT derivatives were implemented in a semi-numerical scheme, where numerical ECP gradients were added to analytic SCF gradients. For post-SCF methods, the entire gradient computation needed to be run as finite difference of energies. .. warning:: As of May 2022, v1.6, Psi4 uses the LibECPInt library, and analytic derivatives and Hessians of ECPs are available. Analytic derivatives of molecular systems including ECPs should be available whenever the method has analytic derivatives, but these have so far only been verified for HF and DFT. .. warning:: ECPs have not been tested with projected basis set guesses or with FI-SAPT calculations. If you require this functionality, please contact the developers on GitHub and/or the `forum <http://forum.psicode.org>`_. .. _`sec:scfqmmm`:. External potentials and QM/MM; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In addition to the implementation of :ref:`EFP <sec:libefp>` for accurate QM/MM; computations, |PSIfour| can perfo",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:53248,Availability,avail,available,53248,"lable if |PSIfour| is compiled with the :ref:`LibECPInt <cmake:ecpint>` library.; If a basis set is designed to use an; effective core potential, the ECP definition should be simply placed alongside; the orbital basis set definition, *c.f.* :ref:`sec:basissets-ecps`. All; information related to the definition and number of core electrons will; automatically be detected and no further input is required to use the; ECP-containing basis set. See :srcsample:`scf-ecp` and :srcsample:`dfmp2-ecp`; for examples of computations with ECP-containing basis sets. .. warning:: Prior to May 2022, v1.6, Psi4 used a built-in ECP code. Analytic derivatives of ECPs were not available. The HF and DFT derivatives were implemented in a semi-numerical scheme, where numerical ECP gradients were added to analytic SCF gradients. For post-SCF methods, the entire gradient computation needed to be run as finite difference of energies. .. warning:: As of May 2022, v1.6, Psi4 uses the LibECPInt library, and analytic derivatives and Hessians of ECPs are available. Analytic derivatives of molecular systems including ECPs should be available whenever the method has analytic derivatives, but these have so far only been verified for HF and DFT. .. warning:: ECPs have not been tested with projected basis set guesses or with FI-SAPT calculations. If you require this functionality, please contact the developers on GitHub and/or the `forum <http://forum.psicode.org>`_. .. _`sec:scfqmmm`:. External potentials and QM/MM; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In addition to the implementation of :ref:`EFP <sec:libefp>` for accurate QM/MM; computations, |PSIfour| can perform more rudimentary QM/MM procedures via the; |scf__extern| keyword. The following snippet, extracted from the; :srcsample:`extern1` test case, demonstrates its use for a TIP3P external potential::. import numpy as np; external_potentials = [; [-0.834, np.array([1.649232019048,0.0,-2.356023604706]) / psi_bohr2angstroms],; [ 0.417, np.array([0.54475",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:53326,Availability,avail,available,53326,"ential, the ECP definition should be simply placed alongside; the orbital basis set definition, *c.f.* :ref:`sec:basissets-ecps`. All; information related to the definition and number of core electrons will; automatically be detected and no further input is required to use the; ECP-containing basis set. See :srcsample:`scf-ecp` and :srcsample:`dfmp2-ecp`; for examples of computations with ECP-containing basis sets. .. warning:: Prior to May 2022, v1.6, Psi4 used a built-in ECP code. Analytic derivatives of ECPs were not available. The HF and DFT derivatives were implemented in a semi-numerical scheme, where numerical ECP gradients were added to analytic SCF gradients. For post-SCF methods, the entire gradient computation needed to be run as finite difference of energies. .. warning:: As of May 2022, v1.6, Psi4 uses the LibECPInt library, and analytic derivatives and Hessians of ECPs are available. Analytic derivatives of molecular systems including ECPs should be available whenever the method has analytic derivatives, but these have so far only been verified for HF and DFT. .. warning:: ECPs have not been tested with projected basis set guesses or with FI-SAPT calculations. If you require this functionality, please contact the developers on GitHub and/or the `forum <http://forum.psicode.org>`_. .. _`sec:scfqmmm`:. External potentials and QM/MM; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In addition to the implementation of :ref:`EFP <sec:libefp>` for accurate QM/MM; computations, |PSIfour| can perform more rudimentary QM/MM procedures via the; |scf__extern| keyword. The following snippet, extracted from the; :srcsample:`extern1` test case, demonstrates its use for a TIP3P external potential::. import numpy as np; external_potentials = [; [-0.834, np.array([1.649232019048,0.0,-2.356023604706]) / psi_bohr2angstroms],; [ 0.417, np.array([0.544757019107,0.0,-3.799961446760]) / psi_bohr2angstroms],; [ 0.417, np.array([0.544757019107,0.0,-0.912085762652]) / psi_bohr2angstroms]]. grad",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:59613,Availability,error,error,59613,"---------+--------------------+----------------------+-------------------------+. .. rubric:: Footnotes. .. [#f1] Note that this table applies only the SCF module,; not to the final convergence criteria for post-HF methods or to methods; that use an alternate starting point, like MCSCF. SAPT computations, too,; set tighter values. .. [#f2] This applies to properties computed through the :py:func:`~psi4.driver.properties` function. .. [#f3] Post-HF methods that do not rely upon the usual 4-index AO integrals use a; density-fitted SCF reference. That is, for DF-MP2 and SAPT, the default |globals__scf_type| is DF. .. [#f4] Note that this table applies to the final convergence criteria for; all the post-SCF modules that define a |ccenergy__e_convergence| keyword. .. [#f5] The E_CONVERGENCE keyword is implemented for most post-SCF modules.; See a list beginning at |ccenergy__e_convergence|. .. [#f6] The R_CONVERGENCE keyword places a convergence check on an internal; residual error measure and is implemented for several post-SCF; modules (see list beginning at |ccenergy__r_convergence|). It is defined; according to the quantum chemical method and so its default value is set; by each module individually. .. [#f7] For frequency computations by finite difference of energies,; convergence criteria are tightened further still to 10 for; |scf__e_convergence| and |scf__d_convergence| for SCF of HF or DFT, 11; for |scf__e_convergence| and |scf__d_convergence| for SCF of post-HF,; and 10 for E_CONVERGENCE for post-HF of post-HF. .. _`sec:scfrec`:. Recommendations; ~~~~~~~~~~~~~~~. The SCF code is quite flexible and powerful.; We have tried as much as possible to keep the number of options to; a minimum and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. * For |scf__guess|, the ``SAD`` guess is usually your; friend, even for open-shell systems (at the very least, it g",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:61040,Availability,avail,available,61040,"ist beginning at |ccenergy__r_convergence|). It is defined; according to the quantum chemical method and so its default value is set; by each module individually. .. [#f7] For frequency computations by finite difference of energies,; convergence criteria are tightened further still to 10 for; |scf__e_convergence| and |scf__d_convergence| for SCF of HF or DFT, 11; for |scf__e_convergence| and |scf__d_convergence| for SCF of post-HF,; and 10 for E_CONVERGENCE for post-HF of post-HF. .. _`sec:scfrec`:. Recommendations; ~~~~~~~~~~~~~~~. The SCF code is quite flexible and powerful.; We have tried as much as possible to keep the number of options to; a minimum and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. * For |scf__guess|, the ``SAD`` guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; * For wall time, ``DF`` may be a factor of ten or more faster than the exact; integral technologies available in |PSIfour|.; Use ``DF`` unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your orbital basis/atom type. Then use; ``DIRECT``.; * Don't mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; * Buy a developer a beer!. The ""best-practice"" input file for HF is::. memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvdz; scf_type df; guess sad; ints_tolerance 1.0E-10 # Even this is epically tight, 1.0E-8 is OK; }. energy('scf'); ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:20039,Deployability,update,updated,20039," (*e.g.*, in density fitting), a partial; Cholesky factorization of the density matrices is used. Often extremely; accurate, particularly for closed-shell systems. This is the default for; systems of more than one atom.; SADNO; Natural orbitals from Superposition of Atomic Densities. Similar; to the above, but it forms natural orbitals from the SAD density; matrix to get proper orbitals which are used to start the; calculation, see [Lehtola:2019:1593]_.; GWH; A generalized Wolfsberg-Helmholtz modification of the core; Hamiltonian matrix. Usually less accurate than the core guess: the; latter is exact for one-electron systems, GWH is not; see; [Lehtola:2019:1593]_).; HUCKEL; An extended H\ |u_dots|\ ckel guess based on on-the-fly atomic UHF; calculations alike SAD, see [Lehtola:2019:1593]_.; MODHUCKEL; Like HUCKEL, an extended H\ |u_dots|\ ckel guess based on; on-the-fly atomic UHF calculations alike SAD, see; [Lehtola:2019:1593]_. This variant employs an updated rule for the; generalized Wolfsberg-Helmholz formula from [Ammeter:1978:3686]_.; READ; Read the previous orbitals from a ``wfn`` file, casting from; one basis to another if needed. Useful for starting anion; computations from neutral orbitals, or after small geometry; changes. At present, casting from a different molecular point; group is not supported. This becomes the default for the second; and later iterations of geometry optimizations.; SAP; Superposition of Atomic Potentials. This is essentially a; modification of the core Hamiltonian, which includes screening; effects by using a radially screened effective atomic charge. The; screening effects have been calculated at the complete basis set; limit with finite-element calculations, see [Lehtola:2019:25945]_; and [Lehtola:2020:012516]_. The guess and its implementation have; been described in [Lehtola:2019:1593]_. The guess is evaluated on a; DFT quadrature grid, so the guess energy depends slightly on the; used DFT quadrature. The current implementation",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:27024,Deployability,update,update,27024," by orbital eigenvalue, *i.e.*, by choosing the set; of new orbitals which looks most like some previously known ""good"" set. The; ""good"" set is typically the occupied orbitals from one of the oscillating; iterations with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations :math:`N,N+2,\ldots`, invoking; |scf__mom_start| ``N`` can often rescue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent; iterations can quench oscillations. This mixing, known as; ""damping"" can be activated by setting the; |scf__damping_percentage| keyword to a nonzero percent. Damping is; turned off when the DIIS error is smaller than; |scf__damping_convergence|.; Level shifting [Off by default]; A commonly used alternative to damping is to use level shifting,; which decreases the mixing of occupied and unoccupied orbitals in; the SCF update by moving the unoccupied orbitals up in energy. It; can be shown that the SCF procedure always converges with a; suitably large level shift; however, the larger the shift is, the; slower the convergence becomes, and the calculation may end up; converging onto a higher lying SCF solution. Because of this, in; practice level shifting is most useful in the initial phase of the; calculation to reduce the orbital error enough for DIIS to work; well. The level shift is controlled by the parameter; |scf__level_shift|, and it is turned off when the DIIS error is; smaller than |scf__level_shift_cutoff|. Reasonable values for; the shift and convergence threshold are 5.0 and 1e-2,; respectively.; SOSCF [Off by Default]; See :ref:`sec:soscf`. .. _`sec:scferi`:. ERI Algorithms; ~~~~~~~~~~~~~~. The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are ava",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:32943,Deployability,configurat,configurations,32943," within a composite framework; are as follows:. COSX; An algorithm based on the semi-numerical ""chain of spheres exchange"" (COSX); approach described in [Neese:2009:98]_. The coulomb term is computed with a; direct density-fitting algorithm. The COSX algorithm uses no I/O, scales; well with system size, and requires minimal memory, making it ideal for; large systems and multi-core CPUs. See :ref:`sec:scfcosx` for more information.; LINK; An implementation of the linear-scaling ""Linear Exchange"" (LinK); algorithm described in [Ochsenfeld:1998:1663]_. The LINK algorithm provides ; many of the benefits of integral-direct SCF algorithms, including no disk I/O, ; low memory usage, and effective parallelization. Additionally, the; LINK implementation scales well with system size ; while simultaneously providing a formally-exact computation of the ; Exchange term. See :ref:`sec:scflink` for more information. In some cases the above algorithms have multiple implementations that return; the same result, but are optimal under different molecules sizes and hardware; configurations. Psi4 will automatically detect the correct algorithm to run and; only expert users should manually select the below implementations. The DF; algorithm has the following two implementations. MEM_DF; A DF algorithm optimized around memory layout and is optimal as long as; there is sufficient memory to hold the three-index DF tensors in memory. This; algorithm may be faster for builds that require disk if SSDs are used.; DISK_DF; A DF algorithm (the default DF algorithm before Psi4 1.2) optimized to; minimize Disk IO by sacrificing some performance due to memory layout. Note that these algorithms have both in-memory and on-disk options, but; performance penalties up to a factor of 2.5 can be found if the incorrect; algorithm is chosen. It is therefore highly recommended that the keyword ""DF""; be selected in all cases so that the correct implementation can be selected by; |PSIfours| internal routines. Ex",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:38895,Deployability,integrat,integration,38895,"DFDIRJ as the Coulomb construction ; algorithm when specifying |globals__scf_type| to use a composite algorithm combination (``DFDIRJ+K_alg`` in general, ; or ``DFDIRJ`` for DFT with non-hybrid functionals). . DFDIRJ supports multiple capabilities to improve performance. Specifically, DFDIRJ allows for a combination of density-matrix based ERI ; screening (set |globals__screening| to ``DENSITY``) and incremental Fock matrix construction (set |scf__incfock| to ``TRUE``). These two, when combined,; enable more aggressive screening of ERI contributions to the Coulomb matrix and thus greatly improve performance. .. _`sec:scfcosx`:. COSX Exchange; ~~~~~~~~~~~~~. The semi-numerical COSX algorithm described in [Neese:2009:98]_ evaluates; two-electron ERIs analytically over one electron coordinate and numerically; over the other electron coordinate, and belongs to the family of pseudospectral ; methods originally suggested by Friesner. In COSX, numerical integration is performed on standard; DFT quadrature grids, which are described in :ref:`sec:dft`.; Both the accuracy of the COSX algorithm and also the computational; cost are directly determined by the size of the integration grid, so selection; of the grid is important. This COSX implementation uses two separate grids.; By default, the SCF algorithm is first converged on a smaller grid, followed by a; number of SCF iterations up to a maximum value (controlled by the |scf__cosx_maxiter_final| keyword); on a larger grid. By default, |scf__cosx_maxiter_final| is set to 1, a single; SCF iteration, which results in numerical errors comparable to; performing the entire SCF on the expensive larger grid at a computational cost; much closer to the smaller grid. Setting |scf__cosx_maxiter_final| to 0 disables the; larger grid entirely. Setting |scf__cosx_maxiter_final| to -1 allows; for the SCF to fully converge on the larger grid, useful for the study of wavefunction; properties such as gradients. The size of the initial grid is ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:39111,Deployability,integrat,integration,39111,"eneral, ; or ``DFDIRJ`` for DFT with non-hybrid functionals). . DFDIRJ supports multiple capabilities to improve performance. Specifically, DFDIRJ allows for a combination of density-matrix based ERI ; screening (set |globals__screening| to ``DENSITY``) and incremental Fock matrix construction (set |scf__incfock| to ``TRUE``). These two, when combined,; enable more aggressive screening of ERI contributions to the Coulomb matrix and thus greatly improve performance. .. _`sec:scfcosx`:. COSX Exchange; ~~~~~~~~~~~~~. The semi-numerical COSX algorithm described in [Neese:2009:98]_ evaluates; two-electron ERIs analytically over one electron coordinate and numerically; over the other electron coordinate, and belongs to the family of pseudospectral ; methods originally suggested by Friesner. In COSX, numerical integration is performed on standard; DFT quadrature grids, which are described in :ref:`sec:dft`.; Both the accuracy of the COSX algorithm and also the computational; cost are directly determined by the size of the integration grid, so selection; of the grid is important. This COSX implementation uses two separate grids.; By default, the SCF algorithm is first converged on a smaller grid, followed by a; number of SCF iterations up to a maximum value (controlled by the |scf__cosx_maxiter_final| keyword); on a larger grid. By default, |scf__cosx_maxiter_final| is set to 1, a single; SCF iteration, which results in numerical errors comparable to; performing the entire SCF on the expensive larger grid at a computational cost; much closer to the smaller grid. Setting |scf__cosx_maxiter_final| to 0 disables the; larger grid entirely. Setting |scf__cosx_maxiter_final| to -1 allows; for the SCF to fully converge on the larger grid, useful for the study of wavefunction; properties such as gradients. The size of the initial grid is controlled by the keywords; |scf__cosx_radial_points_initial| and |scf__cosx_spherical_points_initial|.; The final grid is controlled by |scf__cosx",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:41453,Deployability,integrat,integration,41453,"ensity_tolerance|, and; |scf__cosx_basis_tolerance| keywords, respectively. |scf__cosx_ints_tolerance|; is the most consequential of the three thresholds in both cost and accuracy.; This keyword determines screening of negligible one-electron integrals.; |scf__cosx_density_tolerance| controls the threshold for significant; shell pairs in the density matrix. Lastly, |scf__cosx_basis_tolerance| is; a cutoff for the value of basis functions at grid points. This keyword is; used to determine the radial extent of the each basis shell, and it is the; COSX analogue to |scf__dft_basis_tolerance|. The |scf__incfock| keyword (defaults to ``false``) increases performance; by constructing the Fock matrix from differences in the density matrix, which; are more amenable to screening. This option is disabled by default because of; potential SCF convergence issues, particularly when using diffuse basis functions.; The |scf__cosx_overlap_fitting| keyword (defaults to ``true``) reduces numerical; integration errors using the method described in [Izsak:2011:144105]_ and is; always recommended. .. _`sec:scflink`:. Linear Exchange; ~~~~~~~~~~~~~~~. Large SCF calculations can benefit from specialized screening procedures that further reduce the scaling of the ERI contribution to the Fock matrix.; LinK, the linear-scaling exchange method described in [Ochsenfeld:1998:1663]_, is available in Psi4 in conjunction with composite algorithms that build J (|globals__scf_type| set to ``J_alg+LINK``).; LinK achieves linear-scaling by exploiting shell pair sparsity in the density matrix and overlap sparsity between shell pairs. Specifically, LinK exploits the fact that the Exchange term; requires only a linear-scaling number of significant elements through reformulating the; shell quartet screening process to scale linearly with system size.; LinK is most competitive when used with non-diffuse orbital basis sets, since orbital and density overlaps decay slower with diffuse functions.; LinK is especi",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:1976,Energy Efficiency,efficient,efficient,1976,"# @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index:: SCF, HF, Hartree--Fock; .. _`sec:scf`:. HF: Hartree--Fock Theory; ========================. .. codeauthor:: Justin M. Turney, Robert M. Parrish, and Andrew C. Simmonett; .. sectionauthor:: Robert M. Parrish and Jerome F. Gonthier. *Module:* :ref:`Keywords <apdx:scf>`, :ref:`PSI Variables <apdx:scf_psivar>`, :source:`LIBSCF_SOLVER <psi4/src/psi4/libscf_solver>`, :source:`LIBMINTS <psi4/src/psi4/libmints>`, :source:`LIBFOCK <psi4/src/psi4/libfock>`, :source:`LIBDIIS <psi4/src/psi4/libdiis>`. .. _`sec:scfintro`:. Introduction; ~~~~~~~~~~~~. Self-Consistent-Field (SCF) theory forms the cornerstone of *ab initio* quantum; chemistry. Here SCF refers both to conventional Hartree--Fock (HF) molecular; orbital theory and also to generalized Kohn--Sham Density Functional Theory; (KS-DFT). |PSIfour| contains a wholly rewritten SCF code, including many of the; most popular spin specializations, several efficient numerical methods for; treating Fock Matrix construction, and a brand new KS-DFT code featuring many of; the most popular DFT functional technologies. An illustrative example of using the SCF module is as follows::. molecule {; 0 3; O; O 1 1.21; }. set {; basis cc-pvdz; guess sad; reference uhf; scf_type direct; }. energy('scf'). This will run a UHF computation for triplet molecular oxygen (the ground state); using a Direct algorithm for the Electron Repulsion Integrals (ERI) and starting; from a Superposition of Atomic Densities (SAD) guess. DF integrals are; automatically used to converge the DF-SCF solution before the Direct algorithm is; activated. After printing all manner of titles, geometries, sizings, and; algorithm choices, the SCF finally reaches the iterations::. Total Energy Delta E RMS |[F,P]|. @DF-UHF iter 0: -149.80032977420572 -1.49800e+02 1.48808e-01; @DF-UHF iter 1: -149.59496320631871 2.05367e-01 2.58009e-02; @DF-UHF iter 2: -149.62349901753706 -2.85358e-02 6.68980e-03 DIIS; @DF-",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:2303,Energy Efficiency,energy,energy,2303,"e:* :ref:`Keywords <apdx:scf>`, :ref:`PSI Variables <apdx:scf_psivar>`, :source:`LIBSCF_SOLVER <psi4/src/psi4/libscf_solver>`, :source:`LIBMINTS <psi4/src/psi4/libmints>`, :source:`LIBFOCK <psi4/src/psi4/libfock>`, :source:`LIBDIIS <psi4/src/psi4/libdiis>`. .. _`sec:scfintro`:. Introduction; ~~~~~~~~~~~~. Self-Consistent-Field (SCF) theory forms the cornerstone of *ab initio* quantum; chemistry. Here SCF refers both to conventional Hartree--Fock (HF) molecular; orbital theory and also to generalized Kohn--Sham Density Functional Theory; (KS-DFT). |PSIfour| contains a wholly rewritten SCF code, including many of the; most popular spin specializations, several efficient numerical methods for; treating Fock Matrix construction, and a brand new KS-DFT code featuring many of; the most popular DFT functional technologies. An illustrative example of using the SCF module is as follows::. molecule {; 0 3; O; O 1 1.21; }. set {; basis cc-pvdz; guess sad; reference uhf; scf_type direct; }. energy('scf'). This will run a UHF computation for triplet molecular oxygen (the ground state); using a Direct algorithm for the Electron Repulsion Integrals (ERI) and starting; from a Superposition of Atomic Densities (SAD) guess. DF integrals are; automatically used to converge the DF-SCF solution before the Direct algorithm is; activated. After printing all manner of titles, geometries, sizings, and; algorithm choices, the SCF finally reaches the iterations::. Total Energy Delta E RMS |[F,P]|. @DF-UHF iter 0: -149.80032977420572 -1.49800e+02 1.48808e-01; @DF-UHF iter 1: -149.59496320631871 2.05367e-01 2.58009e-02; @DF-UHF iter 2: -149.62349901753706 -2.85358e-02 6.68980e-03 DIIS; @DF-UHF iter 3: -149.62639942687878 -2.90041e-03 2.19285e-03 DIIS; @DF-UHF iter 4: -149.62689561367233 -4.96187e-04 5.99497e-04 DIIS; @DF-UHF iter 5: -149.62694151275420 -4.58991e-05 1.27338e-04 DIIS; @DF-UHF iter 6: -149.62694337910040 -1.86635e-06 1.65616e-05 DIIS; @DF-UHF iter 7: -149.62694340915198 -3.00516e-0",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:3958,Energy Efficiency,energy,energy,3958," 2.05367e-01 2.58009e-02; @DF-UHF iter 2: -149.62349901753706 -2.85358e-02 6.68980e-03 DIIS; @DF-UHF iter 3: -149.62639942687878 -2.90041e-03 2.19285e-03 DIIS; @DF-UHF iter 4: -149.62689561367233 -4.96187e-04 5.99497e-04 DIIS; @DF-UHF iter 5: -149.62694151275420 -4.58991e-05 1.27338e-04 DIIS; @DF-UHF iter 6: -149.62694337910040 -1.86635e-06 1.65616e-05 DIIS; @DF-UHF iter 7: -149.62694340915198 -3.00516e-08 2.68990e-06 DIIS; @DF-UHF iter 8: -149.62694340999315 -8.41169e-10 2.61249e-07 DIIS. DF guess converged.; ... @UHF iter 9: -149.62730705472407 -3.63645e-04 8.63697e-05 DIIS; @UHF iter 10: -149.62730737348096 -3.18757e-07 1.50223e-05 DIIS; @UHF iter 11: -149.62730738537113 -1.18902e-08 3.80466e-06 DIIS; @UHF iter 12: -149.62730738624032 -8.69193e-10 7.06634e-07 DIIS. The first set of iterations are from the DF portion of the computation, the; second set uses the exact (but much slower) Direct algorithm. Within the DF portion; of the computation, the zeroth-iteration uses a non-idempotent density matrix; obtained from the SAD guess, so the energy is unphysically low. However, the; first true iteration is quite close to the final DF energy, highlighting the; efficiency of the SAD guess. Pulay's DIIS procedure is then used to accelerate; SCF convergence, with the DF phase reaching convergence in eight true; iterations. When used together, SAD and DIIS are usually sufficient to converge; the SCF for all but the most difficult systems. Additional convergence; techniques are available for more difficult cases, and are detailed below. At; this point, the code switches on the requested Direct integrals technology, which; requires only four full iterations to reach convergence, starting from the DF; guess. This hybrid DF/Direct procedure can significantly accelerate SCF; computations requiring exact integrals. After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. A",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:4052,Energy Efficiency,energy,energy,4052,".19285e-03 DIIS; @DF-UHF iter 4: -149.62689561367233 -4.96187e-04 5.99497e-04 DIIS; @DF-UHF iter 5: -149.62694151275420 -4.58991e-05 1.27338e-04 DIIS; @DF-UHF iter 6: -149.62694337910040 -1.86635e-06 1.65616e-05 DIIS; @DF-UHF iter 7: -149.62694340915198 -3.00516e-08 2.68990e-06 DIIS; @DF-UHF iter 8: -149.62694340999315 -8.41169e-10 2.61249e-07 DIIS. DF guess converged.; ... @UHF iter 9: -149.62730705472407 -3.63645e-04 8.63697e-05 DIIS; @UHF iter 10: -149.62730737348096 -3.18757e-07 1.50223e-05 DIIS; @UHF iter 11: -149.62730738537113 -1.18902e-08 3.80466e-06 DIIS; @UHF iter 12: -149.62730738624032 -8.69193e-10 7.06634e-07 DIIS. The first set of iterations are from the DF portion of the computation, the; second set uses the exact (but much slower) Direct algorithm. Within the DF portion; of the computation, the zeroth-iteration uses a non-idempotent density matrix; obtained from the SAD guess, so the energy is unphysically low. However, the; first true iteration is quite close to the final DF energy, highlighting the; efficiency of the SAD guess. Pulay's DIIS procedure is then used to accelerate; SCF convergence, with the DF phase reaching convergence in eight true; iterations. When used together, SAD and DIIS are usually sufficient to converge; the SCF for all but the most difficult systems. Additional convergence; techniques are available for more difficult cases, and are detailed below. At; this point, the code switches on the requested Direct integrals technology, which; requires only four full iterations to reach convergence, starting from the DF; guess. This hybrid DF/Direct procedure can significantly accelerate SCF; computations requiring exact integrals. After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; |globals__print| option. Also printed are the occupied and virtual orbital en",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:6558,Energy Efficiency,energy,energy,6558,"_{\mu i}` contains the MO coefficients, which are the; constrained variational parameters in Hartree--Fock. The molecular orbitals are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. .. math:: | \Psi_0 \rangle =; \frac{1}{\sqrt{N!}} \left | \begin{array}{cccc}; \psi_1 (\vec x_1) & \psi_2(\vec x_1) & \ldots & \psi_N (\vec x_1) \\; \psi_1 (\vec x_2) & \psi_2(\vec x_2) & \ldots & \psi_N (\vec x_2) \\; \vdots & \vdots & \ddots & \vdots \\; \psi_1 (\vec x_N) & \psi_2(\vec x_N) & \ldots & \psi_N (\vec x_N) \\; \end{array}\right |. This form for the Hartree--Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; :math:`\mathbb{R}^6` instead of a more complicated effect in; :math:`\mathbb{R}^N`\ . Considering the electronic Hamiltonian,. .. math:: \hat H = \sum_{i} -\frac{1}{2} \nabla_i^2 + \sum_{i} \sum_{A} -; \frac{Z_A}{r_{iA}} + \sum_{i>j} \frac{1}{r_{ij}},. the Hartree--Fock energy is, by Slater's rules,. .. math:: E_{\mathrm{HF}} =; \langle \Psi_0 | \hat H | \Psi_0 \rangle; = \sum_{i} \langle i | \hat h | i \rangle; + \frac 1 2 \sum_{i,j} [ii|jj] - [ij|ji]. .. math:: =; D_{\mu\nu}^\alpha \left(H_{\mu\nu} + F_{\mu\nu}^{\alpha} \right); + D_{\mu\nu}^\beta \left(H_{\mu\nu} + F_{\mu\nu}^{\beta} \right). Here :math:`H` is the AO-basis one-electron potential, encapsulating both; electron-nuclear attraction and kinetic energy,. .. math:: H_{\mu\nu} =; \left(\mu \left| -\frac{1}{2} \nabla^2 + \sum_{A} -\frac{Z_A}{r_{1A}} \right; | \nu \right),. :math:`D` is the AO-basis density matrix, build from the occupied orbital; coefficients,. .. math:: D_{\mu\nu}^{\alpha} =; C_{\mu i}^{\alpha} C_{\nu i}^{\alpha},. and :math:`F` is the Fock matrix, which is the effective one-body potential at; the current value of the density,. .. math:: F_{\mu\nu}^{\alpha} = H_{\mu\nu}; + \underbrace{\left(D_{\lambda\sigma}^{\alpha} + D_{\lambda\sigma}^{\beta}\right); (\mu\nu|\lambda\sigma)}_{J}",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:7005,Energy Efficiency,energy,energy,7005,"\vec x_2) & \psi_2(\vec x_2) & \ldots & \psi_N (\vec x_2) \\; \vdots & \vdots & \ddots & \vdots \\; \psi_1 (\vec x_N) & \psi_2(\vec x_N) & \ldots & \psi_N (\vec x_N) \\; \end{array}\right |. This form for the Hartree--Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; :math:`\mathbb{R}^6` instead of a more complicated effect in; :math:`\mathbb{R}^N`\ . Considering the electronic Hamiltonian,. .. math:: \hat H = \sum_{i} -\frac{1}{2} \nabla_i^2 + \sum_{i} \sum_{A} -; \frac{Z_A}{r_{iA}} + \sum_{i>j} \frac{1}{r_{ij}},. the Hartree--Fock energy is, by Slater's rules,. .. math:: E_{\mathrm{HF}} =; \langle \Psi_0 | \hat H | \Psi_0 \rangle; = \sum_{i} \langle i | \hat h | i \rangle; + \frac 1 2 \sum_{i,j} [ii|jj] - [ij|ji]. .. math:: =; D_{\mu\nu}^\alpha \left(H_{\mu\nu} + F_{\mu\nu}^{\alpha} \right); + D_{\mu\nu}^\beta \left(H_{\mu\nu} + F_{\mu\nu}^{\beta} \right). Here :math:`H` is the AO-basis one-electron potential, encapsulating both; electron-nuclear attraction and kinetic energy,. .. math:: H_{\mu\nu} =; \left(\mu \left| -\frac{1}{2} \nabla^2 + \sum_{A} -\frac{Z_A}{r_{1A}} \right; | \nu \right),. :math:`D` is the AO-basis density matrix, build from the occupied orbital; coefficients,. .. math:: D_{\mu\nu}^{\alpha} =; C_{\mu i}^{\alpha} C_{\nu i}^{\alpha},. and :math:`F` is the Fock matrix, which is the effective one-body potential at; the current value of the density,. .. math:: F_{\mu\nu}^{\alpha} = H_{\mu\nu}; + \underbrace{\left(D_{\lambda\sigma}^{\alpha} + D_{\lambda\sigma}^{\beta}\right); (\mu\nu|\lambda\sigma)}_{J}; + \underbrace{D_{\lambda\sigma}^{\alpha} (\mu\lambda|\sigma\nu)}_{K^{\alpha}}. Here the tensor :math:`(\mu\nu|\lambda\sigma)` is an AO Electron-Repulsion; Integral (ERI) in chemists' notation,. .. math:: (\mu\nu|\lambda\sigma) = \iint_{\mathbb{R}^6}; \phi_{\mu} (\vec r_1); \phi_{\nu} (\vec r_1); \frac{1}{r_{12}}; \phi_{\lambda} (\vec r_2); \phi_{\sigma} (\vec r_2); \ \mathrm{d}^3 r_",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:8927,Energy Efficiency,energy,energy,8927,"i_{\lambda} (\vec r_2); \phi_{\sigma} (\vec r_2); \ \mathrm{d}^3 r_1; \ \mathrm{d}^3 r_2. The MO coefficients are found as the generalized eigenvectors of the Fock Matrix,. .. math:: F^\alpha C^\alpha = S C^\alpha \epsilon^\alpha. The eigenvalues :math:`\epsilon` are the orbital energies, and the metric matrix; :math:`S` is the AO-basis overlap matrix. .. math:: S_{\mu\nu} = (\mu | \nu ). Note that the Fock Matrix depends on the density (both alpha and beta), and; therefore the orbitals. Because of this, SCF is a nonlinear procedure, which; terminates when the generating orbitals are self-consistent with the Fock matrix; they generate. The formation of the Coulomb matrix :math:`J` and the exchange matrix; :math:`K^{\alpha}` dominate the computational effort of the SCF procedure. For; very large systems, diagonalization of the Fock matrix can also present a; significant hurdle. .. _`sec:scfinput`:. Minimal Input; ~~~~~~~~~~~~~. Minimal input for a Hartree--Fock computation is a molecule block, basis set; option, and a call to ``energy('scf')``::. molecule {; He; }. set basis sto-3g. energy('scf'). This will run a Restricted Hartree--Fock (RHF) on neutral singlet Helium in; :math:`D_{2h}` spatial symmetry with a minimal ``STO-3G`` basis, 1.0E-6; energy and density convergence criteria (since single-point, see; :ref:`SCF Convergence & Algorithm <table:conv_scf>`), a DF ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess. For more; information on any of these options, see the relevant section below. .. _`sec:scfsymm`:. Spin/Symmetry Treatment; ~~~~~~~~~~~~~~~~~~~~~~~. |PSIfour| implements the most popular spin specializations of Hartree--Fock; theory, including:. Restricted Hartree--Fock (RHF) [Default]; Appropriate only for closed-shell singlet systems, but twice as efficient; as the other flavors, as the alpha and beta densities are constrained to be; identical.; Unrestricted Hartree--Fock (UHF); Appropriate for most open-shell systems and f",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:8983,Energy Efficiency,energy,energy,8983,"ents are found as the generalized eigenvectors of the Fock Matrix,. .. math:: F^\alpha C^\alpha = S C^\alpha \epsilon^\alpha. The eigenvalues :math:`\epsilon` are the orbital energies, and the metric matrix; :math:`S` is the AO-basis overlap matrix. .. math:: S_{\mu\nu} = (\mu | \nu ). Note that the Fock Matrix depends on the density (both alpha and beta), and; therefore the orbitals. Because of this, SCF is a nonlinear procedure, which; terminates when the generating orbitals are self-consistent with the Fock matrix; they generate. The formation of the Coulomb matrix :math:`J` and the exchange matrix; :math:`K^{\alpha}` dominate the computational effort of the SCF procedure. For; very large systems, diagonalization of the Fock matrix can also present a; significant hurdle. .. _`sec:scfinput`:. Minimal Input; ~~~~~~~~~~~~~. Minimal input for a Hartree--Fock computation is a molecule block, basis set; option, and a call to ``energy('scf')``::. molecule {; He; }. set basis sto-3g. energy('scf'). This will run a Restricted Hartree--Fock (RHF) on neutral singlet Helium in; :math:`D_{2h}` spatial symmetry with a minimal ``STO-3G`` basis, 1.0E-6; energy and density convergence criteria (since single-point, see; :ref:`SCF Convergence & Algorithm <table:conv_scf>`), a DF ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess. For more; information on any of these options, see the relevant section below. .. _`sec:scfsymm`:. Spin/Symmetry Treatment; ~~~~~~~~~~~~~~~~~~~~~~~. |PSIfour| implements the most popular spin specializations of Hartree--Fock; theory, including:. Restricted Hartree--Fock (RHF) [Default]; Appropriate only for closed-shell singlet systems, but twice as efficient; as the other flavors, as the alpha and beta densities are constrained to be; identical.; Unrestricted Hartree--Fock (UHF); Appropriate for most open-shell systems and fairly easy to converge.; The spatial parts of the alpha and beta orbitals are fully independent of each; ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:9148,Energy Efficiency,energy,energy,9148,": S_{\mu\nu} = (\mu | \nu ). Note that the Fock Matrix depends on the density (both alpha and beta), and; therefore the orbitals. Because of this, SCF is a nonlinear procedure, which; terminates when the generating orbitals are self-consistent with the Fock matrix; they generate. The formation of the Coulomb matrix :math:`J` and the exchange matrix; :math:`K^{\alpha}` dominate the computational effort of the SCF procedure. For; very large systems, diagonalization of the Fock matrix can also present a; significant hurdle. .. _`sec:scfinput`:. Minimal Input; ~~~~~~~~~~~~~. Minimal input for a Hartree--Fock computation is a molecule block, basis set; option, and a call to ``energy('scf')``::. molecule {; He; }. set basis sto-3g. energy('scf'). This will run a Restricted Hartree--Fock (RHF) on neutral singlet Helium in; :math:`D_{2h}` spatial symmetry with a minimal ``STO-3G`` basis, 1.0E-6; energy and density convergence criteria (since single-point, see; :ref:`SCF Convergence & Algorithm <table:conv_scf>`), a DF ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess. For more; information on any of these options, see the relevant section below. .. _`sec:scfsymm`:. Spin/Symmetry Treatment; ~~~~~~~~~~~~~~~~~~~~~~~. |PSIfour| implements the most popular spin specializations of Hartree--Fock; theory, including:. Restricted Hartree--Fock (RHF) [Default]; Appropriate only for closed-shell singlet systems, but twice as efficient; as the other flavors, as the alpha and beta densities are constrained to be; identical.; Unrestricted Hartree--Fock (UHF); Appropriate for most open-shell systems and fairly easy to converge.; The spatial parts of the alpha and beta orbitals are fully independent of each; other, which allows a considerable amount of flexibility in the wavefunction.; However, this flexibility comes at the cost of spin symmetry; UHF wavefunctions; need not be eigenfunctions of the :math:`\hat S^2` operator. The deviation of; this operator from ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:9706,Energy Efficiency,efficient,efficient,9706,"agonalization of the Fock matrix can also present a; significant hurdle. .. _`sec:scfinput`:. Minimal Input; ~~~~~~~~~~~~~. Minimal input for a Hartree--Fock computation is a molecule block, basis set; option, and a call to ``energy('scf')``::. molecule {; He; }. set basis sto-3g. energy('scf'). This will run a Restricted Hartree--Fock (RHF) on neutral singlet Helium in; :math:`D_{2h}` spatial symmetry with a minimal ``STO-3G`` basis, 1.0E-6; energy and density convergence criteria (since single-point, see; :ref:`SCF Convergence & Algorithm <table:conv_scf>`), a DF ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess. For more; information on any of these options, see the relevant section below. .. _`sec:scfsymm`:. Spin/Symmetry Treatment; ~~~~~~~~~~~~~~~~~~~~~~~. |PSIfour| implements the most popular spin specializations of Hartree--Fock; theory, including:. Restricted Hartree--Fock (RHF) [Default]; Appropriate only for closed-shell singlet systems, but twice as efficient; as the other flavors, as the alpha and beta densities are constrained to be; identical.; Unrestricted Hartree--Fock (UHF); Appropriate for most open-shell systems and fairly easy to converge.; The spatial parts of the alpha and beta orbitals are fully independent of each; other, which allows a considerable amount of flexibility in the wavefunction.; However, this flexibility comes at the cost of spin symmetry; UHF wavefunctions; need not be eigenfunctions of the :math:`\hat S^2` operator. The deviation of; this operator from its expectation value is printed on the output file. If the; deviation is greater than a few hundredths, it is advisable to switch to a; ROHF to avoid this ""spin-contamination"" problem.; Restricted Open-Shell Hartree--Fock (ROHF); Appropriate for open-shell systems where spin-contamination is problem.; Sometimes more difficult to converge, and assumes uniformly positive spin; polarization (the alpha and beta doubly-occupied orbitals are identical).; ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:10927,Energy Efficiency,charge,charge,10927," fully independent of each; other, which allows a considerable amount of flexibility in the wavefunction.; However, this flexibility comes at the cost of spin symmetry; UHF wavefunctions; need not be eigenfunctions of the :math:`\hat S^2` operator. The deviation of; this operator from its expectation value is printed on the output file. If the; deviation is greater than a few hundredths, it is advisable to switch to a; ROHF to avoid this ""spin-contamination"" problem.; Restricted Open-Shell Hartree--Fock (ROHF); Appropriate for open-shell systems where spin-contamination is problem.; Sometimes more difficult to converge, and assumes uniformly positive spin; polarization (the alpha and beta doubly-occupied orbitals are identical).; Constrained Unrestricted Hartree--Fock (CUHF); A variant of ROHF that starts from a UHF ansatz and is therefore often; easier to converge. These can be invoked by the |scf__reference| keyword, which defaults to ``RHF``.; The charge and multiplicity may either be specified in the molecule definition::. molecule h {; 0 2 # Neutral doublet; H; }. or, dynamically, by setting the relevant attributes in the Python molecule; object::. h.set_molecular_charge(0); h.set_multiplicity(2). Abelian spatial symmetry is fully supported in |PSIfour| and can be used to; obtain physical interpretation of the molecular orbitals, to assist in difficult; convergence cases, and, in some methods, to obtain significant performance; gains. The point group of the molecule is inferred when reading the molecule; section, and may be overridden by the :ref:`symmetry <sec:moleculeKeywords>` flag, as in::. molecule h {; 0 2; H; symmetry c1; }. or by the ``reset_point_group`` Python molecule attribute::. h.reset_point_group('c2v'). During the SCF procedure, the occupation of orbitals is typically determined by; the Aufbau principal across all spatial symmetries. This may result in the; occupation shifting between iterations. If the occupations are known *a priori*,; they may",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:12267,Energy Efficiency,energy,energy,12267,"cal interpretation of the molecular orbitals, to assist in difficult; convergence cases, and, in some methods, to obtain significant performance; gains. The point group of the molecule is inferred when reading the molecule; section, and may be overridden by the :ref:`symmetry <sec:moleculeKeywords>` flag, as in::. molecule h {; 0 2; H; symmetry c1; }. or by the ``reset_point_group`` Python molecule attribute::. h.reset_point_group('c2v'). During the SCF procedure, the occupation of orbitals is typically determined by; the Aufbau principal across all spatial symmetries. This may result in the; occupation shifting between iterations. If the occupations are known *a priori*,; they may be clamped throughout the procedure by using the |globals__docc| and; |globals__socc| options. For instance, all good quantum chemists know that; :math:`C_{2v}` water is; actually,::. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; docc [3, 0, 1, 1] # 1A1 2A1 1B1 3A1 1B2; basis cc-pvdz; }. energy('scf'). .. _`sec:scfbrokensymm`:. Broken Symmetry; ~~~~~~~~~~~~~~~. For certain problems, such diradicals, allowing the spin-up and spin-down; orbitals to differ in closed-shell computations can be advantageous;; this is known as symmetry breaking. The resulting unrestricted wavefunction; will often provide superior energetics, due to the increased flexibility,; but it will suffer non-physical spin contamination from higher multiplicity states.; A convenient approach to break symmetry is to perform a UHF or UKS calculation; with the guess HOMO and LUMO orbitals mixed.; Mixing of the guess orbitals can be requested by setting the |scf__guess_mix|; keyword to true::. set reference uhf; set guess_mix true; energy('scf'). .. _`sec:scflindep`:. Orthogonalization; ~~~~~~~~~~~~~~~~~. One of the first steps in the SCF procedure is the determination of an; orthogonal basis (known as the OSO basis) from the atomic orbital; basis (known as the AO basis). The Molecular Orbital basis (MO basis); is",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:12987,Energy Efficiency,energy,energy,12987," throughout the procedure by using the |globals__docc| and; |globals__socc| options. For instance, all good quantum chemists know that; :math:`C_{2v}` water is; actually,::. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; docc [3, 0, 1, 1] # 1A1 2A1 1B1 3A1 1B2; basis cc-pvdz; }. energy('scf'). .. _`sec:scfbrokensymm`:. Broken Symmetry; ~~~~~~~~~~~~~~~. For certain problems, such diradicals, allowing the spin-up and spin-down; orbitals to differ in closed-shell computations can be advantageous;; this is known as symmetry breaking. The resulting unrestricted wavefunction; will often provide superior energetics, due to the increased flexibility,; but it will suffer non-physical spin contamination from higher multiplicity states.; A convenient approach to break symmetry is to perform a UHF or UKS calculation; with the guess HOMO and LUMO orbitals mixed.; Mixing of the guess orbitals can be requested by setting the |scf__guess_mix|; keyword to true::. set reference uhf; set guess_mix true; energy('scf'). .. _`sec:scflindep`:. Orthogonalization; ~~~~~~~~~~~~~~~~~. One of the first steps in the SCF procedure is the determination of an; orthogonal basis (known as the OSO basis) from the atomic orbital; basis (known as the AO basis). The Molecular Orbital basis (MO basis); is then built as a particular unitary transformation of the OSO; basis. In |PSIfour|, the determination of the OSO basis is; accomplished via either symmetric, canonical, or partial Cholesky; orthogonalization. Symmetric orthogonalization uses the symmetric inverse square root of; the overlap matrix for the orthogonalization matrix. Use of symmetric; orthogonalization always yields the same number of OSO functions (and; thereby MOs) as AO functions. However, this may lead to numerical; problems if the overlap matrix has small eigenvalues, which may occur; for large systems or for systems where diffuse basis sets are used. This problem may be avoided by using canonical orthogonalization, in; wh",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:15830,Energy Efficiency,adapt,adapted,15830," the presence of significant linear; dependencies [Lehtola:2020:134108]_. In |PSIfour|, symmetric orthogonalization is used by default, unless; the smallest overlap eigenvalue falls below the user-supplied double; option |scf__s_tolerance|, which defaults to 1E-7. If the smallest; eigenvalue is below this cutoff, canonical orthogonalization is; forced, and all eigenvectors corresponding to eigenvalues below the; cutoff are eliminated. If the eigendecomposition is detected to be numerically unstable - the; reciprocal condition number of the overlap matrix to be smaller than; the machine epsilon - the partial Cholesky decomposition is undertaken; until |scf__s_cholesky_tolerance|, which defaults to 1E-8. Use of symmetric, canonical, and partial Cholesky orthogonalization; can be forced by setting the |scf__s_orthogonalization| option to; ``SYMMETRIC``, ``CANONICAL``, or ``PARTIALCHOLESKY``,; respectively. Note that in practice, the MOs and OSOs are built separately within; each irrep from the symmetry-adapted combinations of AOs known as; Unique Symmetry Orbitals (USOs). For canonical orthogonalization,; this implies that the number of MOs and OSOs per irrep may be slightly; smaller than the number of USOs per irrep. A contrived example demonstrating OSOs/MOs vs. AOs with symmetry is shown; below::. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c2 # Two irreps is easier to comprehend; }. set {; s_tolerance 0.0001 # Set an unreasonably tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eigenvalues for even H2O; print 3; }. energy('scf'). Output::. ==> Pre-Iterations <==. -------------------------------------------------------; Irrep Nso Nmo Nalpha Nbeta Ndocc Nsocc; -------------------------------------------------------; A 145 145 0 0 0 0; B 142 142 0 0 0 0; -------------------------------------------------------; Total 287 287 5 5 5 0; -------------------------------------------------------. ... Minimum ei",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:16424,Energy Efficiency,energy,energy,16424,"Cholesky decomposition is undertaken; until |scf__s_cholesky_tolerance|, which defaults to 1E-8. Use of symmetric, canonical, and partial Cholesky orthogonalization; can be forced by setting the |scf__s_orthogonalization| option to; ``SYMMETRIC``, ``CANONICAL``, or ``PARTIALCHOLESKY``,; respectively. Note that in practice, the MOs and OSOs are built separately within; each irrep from the symmetry-adapted combinations of AOs known as; Unique Symmetry Orbitals (USOs). For canonical orthogonalization,; this implies that the number of MOs and OSOs per irrep may be slightly; smaller than the number of USOs per irrep. A contrived example demonstrating OSOs/MOs vs. AOs with symmetry is shown; below::. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c2 # Two irreps is easier to comprehend; }. set {; s_tolerance 0.0001 # Set an unreasonably tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eigenvalues for even H2O; print 3; }. energy('scf'). Output::. ==> Pre-Iterations <==. -------------------------------------------------------; Irrep Nso Nmo Nalpha Nbeta Ndocc Nsocc; -------------------------------------------------------; A 145 145 0 0 0 0; B 142 142 0 0 0 0; -------------------------------------------------------; Total 287 287 5 5 5 0; -------------------------------------------------------. ... Minimum eigenvalue in the overlap matrix is 1.6888063568E-05.; Using Canonical Orthogonalization with cutoff of 1.0000000000E-04.; Irrep 0, 1 of 145 possible MOs eliminated.; Irrep 1, 2 of 142 possible MOs eliminated.; Overall, 3 of 287 possible MOs eliminated. In this example, there are 287 AO basis functions after spherical harmonics are; applied. These are used to produce 287 symmetry adapted USOs, 145 of which are; assigned to irrep A, and 142 of which are assigned to irrep B. Within irrep A,; 144 OSOs fall above the eigenvalue cutoff, and within irrep B 140 OSOs fall; above the eigenvalue cutoff. In total, 284 mo",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:17197,Energy Efficiency,adapt,adapted,17197,"mprehend; }. set {; s_tolerance 0.0001 # Set an unreasonably tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eigenvalues for even H2O; print 3; }. energy('scf'). Output::. ==> Pre-Iterations <==. -------------------------------------------------------; Irrep Nso Nmo Nalpha Nbeta Ndocc Nsocc; -------------------------------------------------------; A 145 145 0 0 0 0; B 142 142 0 0 0 0; -------------------------------------------------------; Total 287 287 5 5 5 0; -------------------------------------------------------. ... Minimum eigenvalue in the overlap matrix is 1.6888063568E-05.; Using Canonical Orthogonalization with cutoff of 1.0000000000E-04.; Irrep 0, 1 of 145 possible MOs eliminated.; Irrep 1, 2 of 142 possible MOs eliminated.; Overall, 3 of 287 possible MOs eliminated. In this example, there are 287 AO basis functions after spherical harmonics are; applied. These are used to produce 287 symmetry adapted USOs, 145 of which are; assigned to irrep A, and 142 of which are assigned to irrep B. Within irrep A,; 144 OSOs fall above the eigenvalue cutoff, and within irrep B 140 OSOs fall; above the eigenvalue cutoff. In total, 284 molecular orbitals are chosen from; 287 AOs/USOs. .. _`sec:scfguess`:. Initial Guess; ~~~~~~~~~~~~~. In each step of the SCF procedure, a new Fock or Kohn--Sham potential is built; according to the previous density, following which the potential is diagonalized; to produce new molecular orbitals, from which a new density is computed. This; procedure is continued until either convergence is reached or a preset maximum; number of iterations is exceeded. Convergence is determined by both change in; energy and root-mean-square change in density matrix values, which must be below; the user-specified |scf__e_convergence| and |scf__d_convergence|, respectively.; The maximum number of iterations is specified by the |scf__maxiter| option. It; should be noted that SCF is a chaotic process, and,",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:17930,Energy Efficiency,energy,energy,17930,"1, 2 of 142 possible MOs eliminated.; Overall, 3 of 287 possible MOs eliminated. In this example, there are 287 AO basis functions after spherical harmonics are; applied. These are used to produce 287 symmetry adapted USOs, 145 of which are; assigned to irrep A, and 142 of which are assigned to irrep B. Within irrep A,; 144 OSOs fall above the eigenvalue cutoff, and within irrep B 140 OSOs fall; above the eigenvalue cutoff. In total, 284 molecular orbitals are chosen from; 287 AOs/USOs. .. _`sec:scfguess`:. Initial Guess; ~~~~~~~~~~~~~. In each step of the SCF procedure, a new Fock or Kohn--Sham potential is built; according to the previous density, following which the potential is diagonalized; to produce new molecular orbitals, from which a new density is computed. This; procedure is continued until either convergence is reached or a preset maximum; number of iterations is exceeded. Convergence is determined by both change in; energy and root-mean-square change in density matrix values, which must be below; the user-specified |scf__e_convergence| and |scf__d_convergence|, respectively.; The maximum number of iterations is specified by the |scf__maxiter| option. It; should be noted that SCF is a chaotic process, and, as such, often requires; careful selection of initial orbitals and damping during iterations to ensure; convergence. This is particularly likely for large systems, metallic systems,; multireference systems, open-shell systems, anions, and systems with diffuse; basis sets. For initial orbital selection, several options are available. These include:. CORE; Diagonalization of the core Hamiltonian, removing even mean-field electron; repulsion. Simple, but often too far from the final solution for larger; systems. This is the default for single atoms.; SAD [:term:`Default <GUESS (SCF)>`]; Superposition of Atomic Densities. Builds the initial density as the; spin-averaged sum of atomic UHF computations in the current basis. If an; open-shell system, uniform s",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:20675,Energy Efficiency,charge,charge,20675,"atrix. Usually less accurate than the core guess: the; latter is exact for one-electron systems, GWH is not; see; [Lehtola:2019:1593]_).; HUCKEL; An extended H\ |u_dots|\ ckel guess based on on-the-fly atomic UHF; calculations alike SAD, see [Lehtola:2019:1593]_.; MODHUCKEL; Like HUCKEL, an extended H\ |u_dots|\ ckel guess based on; on-the-fly atomic UHF calculations alike SAD, see; [Lehtola:2019:1593]_. This variant employs an updated rule for the; generalized Wolfsberg-Helmholz formula from [Ammeter:1978:3686]_.; READ; Read the previous orbitals from a ``wfn`` file, casting from; one basis to another if needed. Useful for starting anion; computations from neutral orbitals, or after small geometry; changes. At present, casting from a different molecular point; group is not supported. This becomes the default for the second; and later iterations of geometry optimizations.; SAP; Superposition of Atomic Potentials. This is essentially a; modification of the core Hamiltonian, which includes screening; effects by using a radially screened effective atomic charge. The; screening effects have been calculated at the complete basis set; limit with finite-element calculations, see [Lehtola:2019:25945]_; and [Lehtola:2020:012516]_. The guess and its implementation have; been described in [Lehtola:2019:1593]_. The guess is evaluated on a; DFT quadrature grid, so the guess energy depends slightly on the; used DFT quadrature. The current implementation is based on; exchange-only local density calculations that are but nanohartree; away from the complete basis set limit [Lehtola:2020:012516]_.; SAPGAU; Superposition of Atomic Potentials, but using error function based; fits to the atomic radial potentials as discussed in; [Lehtola:2020:144105]_. The main difference to the SAP guess; discussed above [Lehtola:2019:25945]_ is that the SAPGAU scheme is; analytic, and can be efficiently formed in terms of three-center; two-electron integrals [Lehtola:2020:144105]_. The potential in; th",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:20991,Energy Efficiency,energy,energy,20991,"D, see; [Lehtola:2019:1593]_. This variant employs an updated rule for the; generalized Wolfsberg-Helmholz formula from [Ammeter:1978:3686]_.; READ; Read the previous orbitals from a ``wfn`` file, casting from; one basis to another if needed. Useful for starting anion; computations from neutral orbitals, or after small geometry; changes. At present, casting from a different molecular point; group is not supported. This becomes the default for the second; and later iterations of geometry optimizations.; SAP; Superposition of Atomic Potentials. This is essentially a; modification of the core Hamiltonian, which includes screening; effects by using a radially screened effective atomic charge. The; screening effects have been calculated at the complete basis set; limit with finite-element calculations, see [Lehtola:2019:25945]_; and [Lehtola:2020:012516]_. The guess and its implementation have; been described in [Lehtola:2019:1593]_. The guess is evaluated on a; DFT quadrature grid, so the guess energy depends slightly on the; used DFT quadrature. The current implementation is based on; exchange-only local density calculations that are but nanohartree; away from the complete basis set limit [Lehtola:2020:012516]_.; SAPGAU; Superposition of Atomic Potentials, but using error function based; fits to the atomic radial potentials as discussed in; [Lehtola:2020:144105]_. The main difference to the SAP guess; discussed above [Lehtola:2019:25945]_ is that the SAPGAU scheme is; analytic, and can be efficiently formed in terms of three-center; two-electron integrals [Lehtola:2020:144105]_. The potential in; the SAPGAU scheme is passed with the |scf__sapgau_basis|; keyword. The default potential is given by the large fit to the; HelFEM potential, sap_helfem_large, described in; [Lehtola:2020:144105]_. Note that this guess is known in the DIRAC; program as .SCRPOT and in the ERKALE program as SAPFIT. These are all set by the |scf__guess| keyword. Also, an automatic Python; procedur",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:21496,Energy Efficiency,efficient,efficiently,21496,"optimizations.; SAP; Superposition of Atomic Potentials. This is essentially a; modification of the core Hamiltonian, which includes screening; effects by using a radially screened effective atomic charge. The; screening effects have been calculated at the complete basis set; limit with finite-element calculations, see [Lehtola:2019:25945]_; and [Lehtola:2020:012516]_. The guess and its implementation have; been described in [Lehtola:2019:1593]_. The guess is evaluated on a; DFT quadrature grid, so the guess energy depends slightly on the; used DFT quadrature. The current implementation is based on; exchange-only local density calculations that are but nanohartree; away from the complete basis set limit [Lehtola:2020:012516]_.; SAPGAU; Superposition of Atomic Potentials, but using error function based; fits to the atomic radial potentials as discussed in; [Lehtola:2020:144105]_. The main difference to the SAP guess; discussed above [Lehtola:2019:25945]_ is that the SAPGAU scheme is; analytic, and can be efficiently formed in terms of three-center; two-electron integrals [Lehtola:2020:144105]_. The potential in; the SAPGAU scheme is passed with the |scf__sapgau_basis|; keyword. The default potential is given by the large fit to the; HelFEM potential, sap_helfem_large, described in; [Lehtola:2020:144105]_. Note that this guess is known in the DIRAC; program as .SCRPOT and in the ERKALE program as SAPFIT. These are all set by the |scf__guess| keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis. This can be done by adding; |scf__basis_guess| = SMALL_BASIS to the options list. We recommend the; 3-21G or pcseg-0 basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below::. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:22241,Energy Efficiency,efficient,efficient,22241,"rposition of Atomic Potentials, but using error function based; fits to the atomic radial potentials as discussed in; [Lehtola:2020:144105]_. The main difference to the SAP guess; discussed above [Lehtola:2019:25945]_ is that the SAPGAU scheme is; analytic, and can be efficiently formed in terms of three-center; two-electron integrals [Lehtola:2020:144105]_. The potential in; the SAPGAU scheme is passed with the |scf__sapgau_basis|; keyword. The default potential is given by the large fit to the; HelFEM potential, sap_helfem_large, described in; [Lehtola:2020:144105]_. Note that this guess is known in the DIRAC; program as .SCRPOT and in the ERKALE program as SAPFIT. These are all set by the |scf__guess| keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis. This can be done by adding; |scf__basis_guess| = SMALL_BASIS to the options list. We recommend the; 3-21G or pcseg-0 basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below::. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; basis_guess 3-21G; guess sad; }. energy('scf'). .. _`sec:scfrestart`:. Restarting the SCF; ~~~~~~~~~~~~~~~~~~. Reading orbital data from a previous calculations is done via the ``restart_file`` option,; where the actual file is a serialized ``wfn`` object (see :ref:`saving the wfn <sec:save_wfn>`); By default, the orbital data file of the converged SCF(``psi.PID.name.180.npy``) is deleted; after |PSIfour| exits or the ``clean()`` function is called. The orbital guess is automatically; set to ``READ`` when ``restart_file`` is given a ``wfn`` file.; To write the orbitals after every iteration and keep the orbitals from the last iteration, the ``write_orbitals`` options is available: ::. energy('scf', write_orbitals='my_mos')",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:22529,Energy Efficiency,energy,energy,22529,"nter; two-electron integrals [Lehtola:2020:144105]_. The potential in; the SAPGAU scheme is passed with the |scf__sapgau_basis|; keyword. The default potential is given by the large fit to the; HelFEM potential, sap_helfem_large, described in; [Lehtola:2020:144105]_. Note that this guess is known in the DIRAC; program as .SCRPOT and in the ERKALE program as SAPFIT. These are all set by the |scf__guess| keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis. This can be done by adding; |scf__basis_guess| = SMALL_BASIS to the options list. We recommend the; 3-21G or pcseg-0 basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below::. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; basis_guess 3-21G; guess sad; }. energy('scf'). .. _`sec:scfrestart`:. Restarting the SCF; ~~~~~~~~~~~~~~~~~~. Reading orbital data from a previous calculations is done via the ``restart_file`` option,; where the actual file is a serialized ``wfn`` object (see :ref:`saving the wfn <sec:save_wfn>`); By default, the orbital data file of the converged SCF(``psi.PID.name.180.npy``) is deleted; after |PSIfour| exits or the ``clean()`` function is called. The orbital guess is automatically; set to ``READ`` when ``restart_file`` is given a ``wfn`` file.; To write the orbitals after every iteration and keep the orbitals from the last iteration, the ``write_orbitals`` options is available: ::. energy('scf', write_orbitals='my_mos'),. which writes a ``Wavefunction`` object converted (serialized) to a numpy file called ``my_mos.npy``.; The restart can then be done as follows: ::. energy('scf', restart_file='my_mos'). Specifying the ``.npy`` suffix when writing and reading restart files is optional. Alternatively, the restart can also b",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:23190,Energy Efficiency,energy,energy,23190," for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below::. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; basis_guess 3-21G; guess sad; }. energy('scf'). .. _`sec:scfrestart`:. Restarting the SCF; ~~~~~~~~~~~~~~~~~~. Reading orbital data from a previous calculations is done via the ``restart_file`` option,; where the actual file is a serialized ``wfn`` object (see :ref:`saving the wfn <sec:save_wfn>`); By default, the orbital data file of the converged SCF(``psi.PID.name.180.npy``) is deleted; after |PSIfour| exits or the ``clean()`` function is called. The orbital guess is automatically; set to ``READ`` when ``restart_file`` is given a ``wfn`` file.; To write the orbitals after every iteration and keep the orbitals from the last iteration, the ``write_orbitals`` options is available: ::. energy('scf', write_orbitals='my_mos'),. which writes a ``Wavefunction`` object converted (serialized) to a numpy file called ``my_mos.npy``.; The restart can then be done as follows: ::. energy('scf', restart_file='my_mos'). Specifying the ``.npy`` suffix when writing and reading restart files is optional. Alternatively, the restart can also be done from any previously saved ``wfn`` object. ::. energy, scf_wfn = energy('scf',return_wfn=True); scf_wfn.to_file('my_wfn'); energy('scf', restart_file='my_wfn'). For advanced users manipulating or writing custom wavefunction files, note; that |PSIfour| expects the numpy file on disk to have the ``.npy`` extension, not, e.g., `.npz`. .. index:: DIIS, MOM, damping. .. _`sec:scfconv`:. Convergence Stabilization; ~~~~~~~~~~~~~~~~~~~~~~~~~. A summary of Psi's supported convergence stabilization techniques is presented below:. DIIS [On by Default]; DIIS uses previous iterates of the Fock matrix together; with an error criterion based on the orbital gradient to produc",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:23378,Energy Efficiency,energy,energy,23378,"c-pVTZ is shown below::. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; basis_guess 3-21G; guess sad; }. energy('scf'). .. _`sec:scfrestart`:. Restarting the SCF; ~~~~~~~~~~~~~~~~~~. Reading orbital data from a previous calculations is done via the ``restart_file`` option,; where the actual file is a serialized ``wfn`` object (see :ref:`saving the wfn <sec:save_wfn>`); By default, the orbital data file of the converged SCF(``psi.PID.name.180.npy``) is deleted; after |PSIfour| exits or the ``clean()`` function is called. The orbital guess is automatically; set to ``READ`` when ``restart_file`` is given a ``wfn`` file.; To write the orbitals after every iteration and keep the orbitals from the last iteration, the ``write_orbitals`` options is available: ::. energy('scf', write_orbitals='my_mos'),. which writes a ``Wavefunction`` object converted (serialized) to a numpy file called ``my_mos.npy``.; The restart can then be done as follows: ::. energy('scf', restart_file='my_mos'). Specifying the ``.npy`` suffix when writing and reading restart files is optional. Alternatively, the restart can also be done from any previously saved ``wfn`` object. ::. energy, scf_wfn = energy('scf',return_wfn=True); scf_wfn.to_file('my_wfn'); energy('scf', restart_file='my_wfn'). For advanced users manipulating or writing custom wavefunction files, note; that |PSIfour| expects the numpy file on disk to have the ``.npy`` extension, not, e.g., `.npz`. .. index:: DIIS, MOM, damping. .. _`sec:scfconv`:. Convergence Stabilization; ~~~~~~~~~~~~~~~~~~~~~~~~~. A summary of Psi's supported convergence stabilization techniques is presented below:. DIIS [On by Default]; DIIS uses previous iterates of the Fock matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:23589,Energy Efficiency,energy,energy,23589,"bital data from a previous calculations is done via the ``restart_file`` option,; where the actual file is a serialized ``wfn`` object (see :ref:`saving the wfn <sec:save_wfn>`); By default, the orbital data file of the converged SCF(``psi.PID.name.180.npy``) is deleted; after |PSIfour| exits or the ``clean()`` function is called. The orbital guess is automatically; set to ``READ`` when ``restart_file`` is given a ``wfn`` file.; To write the orbitals after every iteration and keep the orbitals from the last iteration, the ``write_orbitals`` options is available: ::. energy('scf', write_orbitals='my_mos'),. which writes a ``Wavefunction`` object converted (serialized) to a numpy file called ``my_mos.npy``.; The restart can then be done as follows: ::. energy('scf', restart_file='my_mos'). Specifying the ``.npy`` suffix when writing and reading restart files is optional. Alternatively, the restart can also be done from any previously saved ``wfn`` object. ::. energy, scf_wfn = energy('scf',return_wfn=True); scf_wfn.to_file('my_wfn'); energy('scf', restart_file='my_wfn'). For advanced users manipulating or writing custom wavefunction files, note; that |PSIfour| expects the numpy file on disk to have the ``.npy`` extension, not, e.g., `.npz`. .. index:: DIIS, MOM, damping. .. _`sec:scfconv`:. Convergence Stabilization; ~~~~~~~~~~~~~~~~~~~~~~~~~. A summary of Psi's supported convergence stabilization techniques is presented below:. DIIS [On by Default]; DIIS uses previous iterates of the Fock matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via :term:`options <DIIS (SCF)>`.; ADIIS [On by Default]; ADIIS uses previous iterates of the Fock and density matrices to produce an; informed ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:23607,Energy Efficiency,energy,energy,23607,"bital data from a previous calculations is done via the ``restart_file`` option,; where the actual file is a serialized ``wfn`` object (see :ref:`saving the wfn <sec:save_wfn>`); By default, the orbital data file of the converged SCF(``psi.PID.name.180.npy``) is deleted; after |PSIfour| exits or the ``clean()`` function is called. The orbital guess is automatically; set to ``READ`` when ``restart_file`` is given a ``wfn`` file.; To write the orbitals after every iteration and keep the orbitals from the last iteration, the ``write_orbitals`` options is available: ::. energy('scf', write_orbitals='my_mos'),. which writes a ``Wavefunction`` object converted (serialized) to a numpy file called ``my_mos.npy``.; The restart can then be done as follows: ::. energy('scf', restart_file='my_mos'). Specifying the ``.npy`` suffix when writing and reading restart files is optional. Alternatively, the restart can also be done from any previously saved ``wfn`` object. ::. energy, scf_wfn = energy('scf',return_wfn=True); scf_wfn.to_file('my_wfn'); energy('scf', restart_file='my_wfn'). For advanced users manipulating or writing custom wavefunction files, note; that |PSIfour| expects the numpy file on disk to have the ``.npy`` extension, not, e.g., `.npz`. .. index:: DIIS, MOM, damping. .. _`sec:scfconv`:. Convergence Stabilization; ~~~~~~~~~~~~~~~~~~~~~~~~~. A summary of Psi's supported convergence stabilization techniques is presented below:. DIIS [On by Default]; DIIS uses previous iterates of the Fock matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via :term:`options <DIIS (SCF)>`.; ADIIS [On by Default]; ADIIS uses previous iterates of the Fock and density matrices to produce an; informed ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:23665,Energy Efficiency,energy,energy,23665,"`restart_file`` option,; where the actual file is a serialized ``wfn`` object (see :ref:`saving the wfn <sec:save_wfn>`); By default, the orbital data file of the converged SCF(``psi.PID.name.180.npy``) is deleted; after |PSIfour| exits or the ``clean()`` function is called. The orbital guess is automatically; set to ``READ`` when ``restart_file`` is given a ``wfn`` file.; To write the orbitals after every iteration and keep the orbitals from the last iteration, the ``write_orbitals`` options is available: ::. energy('scf', write_orbitals='my_mos'),. which writes a ``Wavefunction`` object converted (serialized) to a numpy file called ``my_mos.npy``.; The restart can then be done as follows: ::. energy('scf', restart_file='my_mos'). Specifying the ``.npy`` suffix when writing and reading restart files is optional. Alternatively, the restart can also be done from any previously saved ``wfn`` object. ::. energy, scf_wfn = energy('scf',return_wfn=True); scf_wfn.to_file('my_wfn'); energy('scf', restart_file='my_wfn'). For advanced users manipulating or writing custom wavefunction files, note; that |PSIfour| expects the numpy file on disk to have the ``.npy`` extension, not, e.g., `.npz`. .. index:: DIIS, MOM, damping. .. _`sec:scfconv`:. Convergence Stabilization; ~~~~~~~~~~~~~~~~~~~~~~~~~. A summary of Psi's supported convergence stabilization techniques is presented below:. DIIS [On by Default]; DIIS uses previous iterates of the Fock matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via :term:`options <DIIS (SCF)>`.; ADIIS [On by Default]; ADIIS uses previous iterates of the Fock and density matrices to produce an; informed estimate of the next Fock matrix. ADIIS estimates are bas",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:24695,Energy Efficiency,energy,energy,24695," manipulating or writing custom wavefunction files, note; that |PSIfour| expects the numpy file on disk to have the ``.npy`` extension, not, e.g., `.npz`. .. index:: DIIS, MOM, damping. .. _`sec:scfconv`:. Convergence Stabilization; ~~~~~~~~~~~~~~~~~~~~~~~~~. A summary of Psi's supported convergence stabilization techniques is presented below:. DIIS [On by Default]; DIIS uses previous iterates of the Fock matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via :term:`options <DIIS (SCF)>`.; ADIIS [On by Default]; ADIIS uses previous iterates of the Fock and density matrices to produce an; informed estimate of the next Fock matrix. ADIIS estimates are based on minimizing; an energy estimate rather than zeroing the residual, so this performs best in the early; iterations. By default, Psi will start using ADIIS before blending the ADIIS step with; the DIIS step, eventually using the pure DIIS step. The closely-related EDIIS procedure; may be used instead by setting |scf__scf_initial_accelerator|. This is formally identical; to ADIIS for HF, but the methods will differ for more general DFT.; MOM [Off by Default]; MOM was developed to combat a particular class of convergence failure:; occupation flipping. In some cases, midway though the SCF procedure, a partially; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbital which should be; destined to be a virtual orbital. This results in the virtual orbital being; spuriously occupied for one or more iterations. Sometimes this resolves itself; without help, other times the occupation flips back and forth between two, four,; or more orbitals. This is t",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:26201,Energy Efficiency,energy,energy,26201,"developed to combat a particular class of convergence failure:; occupation flipping. In some cases, midway though the SCF procedure, a partially; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbital which should be; destined to be a virtual orbital. This results in the virtual orbital being; spuriously occupied for one or more iterations. Sometimes this resolves itself; without help, other times the occupation flips back and forth between two, four,; or more orbitals. This is typically visible in the output as a non-converging; SCF which eventually settles down to steady oscillation between two (or more); different total energies. This behavior can be ameliorated by choosing occupied; orbitals by ""shape"" instead of by orbital eigenvalue, *i.e.*, by choosing the set; of new orbitals which looks most like some previously known ""good"" set. The; ""good"" set is typically the occupied orbitals from one of the oscillating; iterations with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations :math:`N,N+2,\ldots`, invoking; |scf__mom_start| ``N`` can often rescue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent; iterations can quench oscillations. This mixing, known as; ""damping"" can be activated by setting the; |scf__damping_percentage| keyword to a nonzero percent. Damping is; turned off when the DIIS error is smaller than; |scf__damping_convergence|.; Level shifting [Off by default]; A commonly used alternative to damping is to use level shifting,; which decreases the mixing of occupied and unoccupied orbitals in; the SCF update by moving the unoccupied orbitals up in energy. It; can be shown that the SCF procedure always converges with a; suit",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:26259,Energy Efficiency,energy,energy,26259,"erged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbital which should be; destined to be a virtual orbital. This results in the virtual orbital being; spuriously occupied for one or more iterations. Sometimes this resolves itself; without help, other times the occupation flips back and forth between two, four,; or more orbitals. This is typically visible in the output as a non-converging; SCF which eventually settles down to steady oscillation between two (or more); different total energies. This behavior can be ameliorated by choosing occupied; orbitals by ""shape"" instead of by orbital eigenvalue, *i.e.*, by choosing the set; of new orbitals which looks most like some previously known ""good"" set. The; ""good"" set is typically the occupied orbitals from one of the oscillating; iterations with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations :math:`N,N+2,\ldots`, invoking; |scf__mom_start| ``N`` can often rescue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent; iterations can quench oscillations. This mixing, known as; ""damping"" can be activated by setting the; |scf__damping_percentage| keyword to a nonzero percent. Damping is; turned off when the DIIS error is smaller than; |scf__damping_convergence|.; Level shifting [Off by default]; A commonly used alternative to damping is to use level shifting,; which decreases the mixing of occupied and unoccupied orbitals in; the SCF update by moving the unoccupied orbitals up in energy. It; can be shown that the SCF procedure always converges with a; suitably large level shift; however, the larger the shift is, the; slower the convergence becomes, and the calculation may end up; converging onto a high",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:27071,Energy Efficiency,energy,energy,27071," by orbital eigenvalue, *i.e.*, by choosing the set; of new orbitals which looks most like some previously known ""good"" set. The; ""good"" set is typically the occupied orbitals from one of the oscillating; iterations with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations :math:`N,N+2,\ldots`, invoking; |scf__mom_start| ``N`` can often rescue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent; iterations can quench oscillations. This mixing, known as; ""damping"" can be activated by setting the; |scf__damping_percentage| keyword to a nonzero percent. Damping is; turned off when the DIIS error is smaller than; |scf__damping_convergence|.; Level shifting [Off by default]; A commonly used alternative to damping is to use level shifting,; which decreases the mixing of occupied and unoccupied orbitals in; the SCF update by moving the unoccupied orbitals up in energy. It; can be shown that the SCF procedure always converges with a; suitably large level shift; however, the larger the shift is, the; slower the convergence becomes, and the calculation may end up; converging onto a higher lying SCF solution. Because of this, in; practice level shifting is most useful in the initial phase of the; calculation to reduce the orbital error enough for DIIS to work; well. The level shift is controlled by the parameter; |scf__level_shift|, and it is turned off when the DIIS error is; smaller than |scf__level_shift_cutoff|. Reasonable values for; the shift and convergence threshold are 5.0 and 1e-2,; respectively.; SOSCF [Off by Default]; See :ref:`sec:soscf`. .. _`sec:scferi`:. ERI Algorithms; ~~~~~~~~~~~~~~. The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are ava",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:27424,Energy Efficiency,reduce,reduce,27424,"used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent; iterations can quench oscillations. This mixing, known as; ""damping"" can be activated by setting the; |scf__damping_percentage| keyword to a nonzero percent. Damping is; turned off when the DIIS error is smaller than; |scf__damping_convergence|.; Level shifting [Off by default]; A commonly used alternative to damping is to use level shifting,; which decreases the mixing of occupied and unoccupied orbitals in; the SCF update by moving the unoccupied orbitals up in energy. It; can be shown that the SCF procedure always converges with a; suitably large level shift; however, the larger the shift is, the; slower the convergence becomes, and the calculation may end up; converging onto a higher lying SCF solution. Because of this, in; practice level shifting is most useful in the initial phase of the; calculation to reduce the orbital error enough for DIIS to work; well. The level shift is controlled by the parameter; |scf__level_shift|, and it is turned off when the DIIS error is; smaller than |scf__level_shift_cutoff|. Reasonable values for; the shift and convergence threshold are 5.0 and 1e-2,; respectively.; SOSCF [Off by Default]; See :ref:`sec:soscf`. .. _`sec:scferi`:. ERI Algorithms; ~~~~~~~~~~~~~~. The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; |PSIfour| for these terms. The algorithm is selected by the |globals__scf_type|; keyword. Most consist of a single algorithm applied to; the construction of both the Coulomb and Exchange parts; of the Fock Matrix:. PK [:ref:`Default <table:conv_scf>`]; An out-of-core, presorted algorithm using exact ERIs. Quite fast for a; zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:28415,Energy Efficiency,reduce,reduce,28415,"hase of the; calculation to reduce the orbital error enough for DIIS to work; well. The level shift is controlled by the parameter; |scf__level_shift|, and it is turned off when the DIIS error is; smaller than |scf__level_shift_cutoff|. Reasonable values for; the shift and convergence threshold are 5.0 and 1e-2,; respectively.; SOSCF [Off by Default]; See :ref:`sec:soscf`. .. _`sec:scferi`:. ERI Algorithms; ~~~~~~~~~~~~~~. The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; |PSIfour| for these terms. The algorithm is selected by the |globals__scf_type|; keyword. Most consist of a single algorithm applied to; the construction of both the Coulomb and Exchange parts; of the Fock Matrix:. PK [:ref:`Default <table:conv_scf>`]; An out-of-core, presorted algorithm using exact ERIs. Quite fast for a; zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of; integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact ERIs. Overcomes the; memory bottleneck of the current PK algorithm. Integrals are generated; only once, and symmetry is utilized to reduce number of integrals.; DIRECT; A threaded, sieved, integral-direct algorithm, with full permutational; symmetry. This algorithm is brand new, but seems to be reasonably fast; up to 1500 basis functions, uses zero disk (if DF pre-iterations are; turned off), and can obtain significant; speedups with negligible error loss if |scf__ints_tolerance|; is set to 1.0E-8 or so.; DF [:ref:`Default <table:conv_scf>`]; A density-fitted algorithm designed for computations with thousands of; basis functions. This algorithm is highly optimized, and is threaded; with a mixture of parallel BLAS and OpenMP. Note that this algorithm; should use the -JKFIT series of auxiliary bases, *not* the -RI or; -MP2FIT bases. The default guess for auxiliary basis set should ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:28637,Energy Efficiency,reduce,reduce,28637,"shift_cutoff|. Reasonable values for; the shift and convergence threshold are 5.0 and 1e-2,; respectively.; SOSCF [Off by Default]; See :ref:`sec:soscf`. .. _`sec:scferi`:. ERI Algorithms; ~~~~~~~~~~~~~~. The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; |PSIfour| for these terms. The algorithm is selected by the |globals__scf_type|; keyword. Most consist of a single algorithm applied to; the construction of both the Coulomb and Exchange parts; of the Fock Matrix:. PK [:ref:`Default <table:conv_scf>`]; An out-of-core, presorted algorithm using exact ERIs. Quite fast for a; zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of; integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact ERIs. Overcomes the; memory bottleneck of the current PK algorithm. Integrals are generated; only once, and symmetry is utilized to reduce number of integrals.; DIRECT; A threaded, sieved, integral-direct algorithm, with full permutational; symmetry. This algorithm is brand new, but seems to be reasonably fast; up to 1500 basis functions, uses zero disk (if DF pre-iterations are; turned off), and can obtain significant; speedups with negligible error loss if |scf__ints_tolerance|; is set to 1.0E-8 or so.; DF [:ref:`Default <table:conv_scf>`]; A density-fitted algorithm designed for computations with thousands of; basis functions. This algorithm is highly optimized, and is threaded; with a mixture of parallel BLAS and OpenMP. Note that this algorithm; should use the -JKFIT series of auxiliary bases, *not* the -RI or; -MP2FIT bases. The default guess for auxiliary basis set should work; for most bases, otherwise the |scf__df_basis_scf| keyword can; be used to manually specify the auxiliary basis. This algorithm is; preferred unless either absolute accuracy is required; [:math:`\gtrsim`\ CCSD(T)] or",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:41434,Energy Efficiency,reduce,reduces,41434,"ensity_tolerance|, and; |scf__cosx_basis_tolerance| keywords, respectively. |scf__cosx_ints_tolerance|; is the most consequential of the three thresholds in both cost and accuracy.; This keyword determines screening of negligible one-electron integrals.; |scf__cosx_density_tolerance| controls the threshold for significant; shell pairs in the density matrix. Lastly, |scf__cosx_basis_tolerance| is; a cutoff for the value of basis functions at grid points. This keyword is; used to determine the radial extent of the each basis shell, and it is the; COSX analogue to |scf__dft_basis_tolerance|. The |scf__incfock| keyword (defaults to ``false``) increases performance; by constructing the Fock matrix from differences in the density matrix, which; are more amenable to screening. This option is disabled by default because of; potential SCF convergence issues, particularly when using diffuse basis functions.; The |scf__cosx_overlap_fitting| keyword (defaults to ``true``) reduces numerical; integration errors using the method described in [Izsak:2011:144105]_ and is; always recommended. .. _`sec:scflink`:. Linear Exchange; ~~~~~~~~~~~~~~~. Large SCF calculations can benefit from specialized screening procedures that further reduce the scaling of the ERI contribution to the Fock matrix.; LinK, the linear-scaling exchange method described in [Ochsenfeld:1998:1663]_, is available in Psi4 in conjunction with composite algorithms that build J (|globals__scf_type| set to ``J_alg+LINK``).; LinK achieves linear-scaling by exploiting shell pair sparsity in the density matrix and overlap sparsity between shell pairs. Specifically, LinK exploits the fact that the Exchange term; requires only a linear-scaling number of significant elements through reformulating the; shell quartet screening process to scale linearly with system size.; LinK is most competitive when used with non-diffuse orbital basis sets, since orbital and density overlaps decay slower with diffuse functions.; LinK is especi",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:41691,Energy Efficiency,reduce,reduce,41691,"negligible one-electron integrals.; |scf__cosx_density_tolerance| controls the threshold for significant; shell pairs in the density matrix. Lastly, |scf__cosx_basis_tolerance| is; a cutoff for the value of basis functions at grid points. This keyword is; used to determine the radial extent of the each basis shell, and it is the; COSX analogue to |scf__dft_basis_tolerance|. The |scf__incfock| keyword (defaults to ``false``) increases performance; by constructing the Fock matrix from differences in the density matrix, which; are more amenable to screening. This option is disabled by default because of; potential SCF convergence issues, particularly when using diffuse basis functions.; The |scf__cosx_overlap_fitting| keyword (defaults to ``true``) reduces numerical; integration errors using the method described in [Izsak:2011:144105]_ and is; always recommended. .. _`sec:scflink`:. Linear Exchange; ~~~~~~~~~~~~~~~. Large SCF calculations can benefit from specialized screening procedures that further reduce the scaling of the ERI contribution to the Fock matrix.; LinK, the linear-scaling exchange method described in [Ochsenfeld:1998:1663]_, is available in Psi4 in conjunction with composite algorithms that build J (|globals__scf_type| set to ``J_alg+LINK``).; LinK achieves linear-scaling by exploiting shell pair sparsity in the density matrix and overlap sparsity between shell pairs. Specifically, LinK exploits the fact that the Exchange term; requires only a linear-scaling number of significant elements through reformulating the; shell quartet screening process to scale linearly with system size.; LinK is most competitive when used with non-diffuse orbital basis sets, since orbital and density overlaps decay slower with diffuse functions.; LinK is especially powerful when combined with density-matrix based ERI screening (set |globals__screening| to ``DENSITY``) and incremental Fock builds (set |scf__incfock| to ``TRUE``), which decrease the number of significant two-el",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:42465,Energy Efficiency,power,powerful,42465,"r Exchange; ~~~~~~~~~~~~~~~. Large SCF calculations can benefit from specialized screening procedures that further reduce the scaling of the ERI contribution to the Fock matrix.; LinK, the linear-scaling exchange method described in [Ochsenfeld:1998:1663]_, is available in Psi4 in conjunction with composite algorithms that build J (|globals__scf_type| set to ``J_alg+LINK``).; LinK achieves linear-scaling by exploiting shell pair sparsity in the density matrix and overlap sparsity between shell pairs. Specifically, LinK exploits the fact that the Exchange term; requires only a linear-scaling number of significant elements through reformulating the; shell quartet screening process to scale linearly with system size.; LinK is most competitive when used with non-diffuse orbital basis sets, since orbital and density overlaps decay slower with diffuse functions.; LinK is especially powerful when combined with density-matrix based ERI screening (set |globals__screening| to ``DENSITY``) and incremental Fock builds (set |scf__incfock| to ``TRUE``), which decrease the number of significant two-electron integrals to calculate. To control the LinK algorithm, here are the list of options provided.; ; |scf__linK_ints_tolerance|: The integral screening tolerance used for sparsity-prep in the LinK algorithm. Defaults to the |scf__ints_tolerance| option. .. index::; single: SOSCF. .. _`sec:soscf`:. Second-order Convergence; ~~~~~~~~~~~~~~~~~~~~~~~~. Second-order convergence takes into account both the gradient and Hessian to; take a full Newton step with respect to the orbital parameters. This results in; quadratic convergence with respect to density for SCF methods. For cases where; normal acceleration methods either fail or take many iterations to converge,; second-order can reduce the total time to solution. Solving second-order (SO) methods exactly would require an inversion of the; orbital Hessian (an expensive :math:`\mathbb{N}^6` operation); however, these; equations are norma",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:43367,Energy Efficiency,reduce,reduce,43367,"hen used with non-diffuse orbital basis sets, since orbital and density overlaps decay slower with diffuse functions.; LinK is especially powerful when combined with density-matrix based ERI screening (set |globals__screening| to ``DENSITY``) and incremental Fock builds (set |scf__incfock| to ``TRUE``), which decrease the number of significant two-electron integrals to calculate. To control the LinK algorithm, here are the list of options provided.; ; |scf__linK_ints_tolerance|: The integral screening tolerance used for sparsity-prep in the LinK algorithm. Defaults to the |scf__ints_tolerance| option. .. index::; single: SOSCF. .. _`sec:soscf`:. Second-order Convergence; ~~~~~~~~~~~~~~~~~~~~~~~~. Second-order convergence takes into account both the gradient and Hessian to; take a full Newton step with respect to the orbital parameters. This results in; quadratic convergence with respect to density for SCF methods. For cases where; normal acceleration methods either fail or take many iterations to converge,; second-order can reduce the total time to solution. Solving second-order (SO) methods exactly would require an inversion of the; orbital Hessian (an expensive :math:`\mathbb{N}^6` operation); however, these; equations are normally solved iteratively where each iteration costs the same; as a normal Fock build (:math:`\mathbb{N}^4`). The overall SOSCF operation is; thus broken down into micro- and macroiterations where the microiterations; refer to solving the SOSCF equations and macroiterations are the construction; of a new Fock matrix based on the orbitals from a SOSCF step. SOSCF requires that all elements of the gradient to be less than one before the; method is valid. To this end, pre-SOSCF SCF iterations use normal; gradient-based extrapolation procedures (*e.g.*, DIIS) until the gradient; conditions are met. Note that while the total number of macroiterations will be; less for SOSCF than gradient-based convergence acceleration, the cost of solving; the micro",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:45196,Energy Efficiency,energy,energy,45196,"e total number of macroiterations will be; less for SOSCF than gradient-based convergence acceleration, the cost of solving; the microiterations typically results in the overall cost being greater for; SOSCF than for gradient-based methods. Therefore, SOSCF should only be used if; it is difficult to locate a stable minimum. SOSCF is available for all HF and DFT references with the exception of meta-; GGA functionals. To enable, set the option |scf__soscf| to ``true``.; Additional options to modify the number of microiterations taken are as; follows:. |scf__soscf_start_convergence|: when to start SOSCF based on the current density RMS. |scf__soscf_max_iter|: the maximum number of SOSCF microiterations per macroiteration. |scf__soscf_conv|: the relative convergence tolerance of the SOSCF microiterations. |scf__soscf_print|: option to print the microiterations or not. .. _`sec:scfstability_doc`:. Stability Analysis; ~~~~~~~~~~~~~~~~~~. SCF algorithms attempt to minimize the gradient of the energy with respect; to orbital variation parameters. At convergence, the gradient should be approximately zero; given a convergence criterion. Although this is enough to make sure the SCF converged to a; stationary point, this is not a sufficient condition for a minimal SCF solution. It may be; a saddle point or a maximum. To ensure that a minimum has been found, the electronic Hessian, *i.e.* the matrix of second; derivatives of the energy with respect to orbital variation parameters, must be computed.; If one or more eigenvalues of the electronic Hessian are negative, the SCF solution is not a minimum.; In that case, orbital parameters can be varied along the lowest Hessian eigenvector to lower the energy. Orbital variation parameters are usually constrained. For example, in RHF the; spatial parts of the :math:`\alpha` and :math:`\beta` orbitals are the same. In; UHF, the orbital coefficients are usually constrained to be real. A stability analysis; can check whether a lower SCF so",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:45635,Energy Efficiency,energy,energy,45635,"oscf| to ``true``.; Additional options to modify the number of microiterations taken are as; follows:. |scf__soscf_start_convergence|: when to start SOSCF based on the current density RMS. |scf__soscf_max_iter|: the maximum number of SOSCF microiterations per macroiteration. |scf__soscf_conv|: the relative convergence tolerance of the SOSCF microiterations. |scf__soscf_print|: option to print the microiterations or not. .. _`sec:scfstability_doc`:. Stability Analysis; ~~~~~~~~~~~~~~~~~~. SCF algorithms attempt to minimize the gradient of the energy with respect; to orbital variation parameters. At convergence, the gradient should be approximately zero; given a convergence criterion. Although this is enough to make sure the SCF converged to a; stationary point, this is not a sufficient condition for a minimal SCF solution. It may be; a saddle point or a maximum. To ensure that a minimum has been found, the electronic Hessian, *i.e.* the matrix of second; derivatives of the energy with respect to orbital variation parameters, must be computed.; If one or more eigenvalues of the electronic Hessian are negative, the SCF solution is not a minimum.; In that case, orbital parameters can be varied along the lowest Hessian eigenvector to lower the energy. Orbital variation parameters are usually constrained. For example, in RHF the; spatial parts of the :math:`\alpha` and :math:`\beta` orbitals are the same. In; UHF, the orbital coefficients are usually constrained to be real. A stability analysis; can check whether a lower SCF solution exists while respecting the constraints of the original; solution; this is an internal instability. If one or more constraints have to be relaxed to reach; a lower-energy solution, there is an external instability. In |PSIfour|, the only external instability; that can be checked at present is the RHF :math:`\rightarrow` UHF one. Currently, two algorithms exist in |PSIfour| for stability analysis: the original; Direct Inversion and the newly im",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:45907,Energy Efficiency,energy,energy,45907,"he maximum number of SOSCF microiterations per macroiteration. |scf__soscf_conv|: the relative convergence tolerance of the SOSCF microiterations. |scf__soscf_print|: option to print the microiterations or not. .. _`sec:scfstability_doc`:. Stability Analysis; ~~~~~~~~~~~~~~~~~~. SCF algorithms attempt to minimize the gradient of the energy with respect; to orbital variation parameters. At convergence, the gradient should be approximately zero; given a convergence criterion. Although this is enough to make sure the SCF converged to a; stationary point, this is not a sufficient condition for a minimal SCF solution. It may be; a saddle point or a maximum. To ensure that a minimum has been found, the electronic Hessian, *i.e.* the matrix of second; derivatives of the energy with respect to orbital variation parameters, must be computed.; If one or more eigenvalues of the electronic Hessian are negative, the SCF solution is not a minimum.; In that case, orbital parameters can be varied along the lowest Hessian eigenvector to lower the energy. Orbital variation parameters are usually constrained. For example, in RHF the; spatial parts of the :math:`\alpha` and :math:`\beta` orbitals are the same. In; UHF, the orbital coefficients are usually constrained to be real. A stability analysis; can check whether a lower SCF solution exists while respecting the constraints of the original; solution; this is an internal instability. If one or more constraints have to be relaxed to reach; a lower-energy solution, there is an external instability. In |PSIfour|, the only external instability; that can be checked at present is the RHF :math:`\rightarrow` UHF one. Currently, two algorithms exist in |PSIfour| for stability analysis: the original; Direct Inversion and the newly implemented Davidson algorithms. We will first describe; options common to both algorithms. To request a stability analysis at the end of the SCF,; set the keyword |scf__stability_analysis|. Value ``CHECK`` only co",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:46366,Energy Efficiency,energy,energy,46366,"nough to make sure the SCF converged to a; stationary point, this is not a sufficient condition for a minimal SCF solution. It may be; a saddle point or a maximum. To ensure that a minimum has been found, the electronic Hessian, *i.e.* the matrix of second; derivatives of the energy with respect to orbital variation parameters, must be computed.; If one or more eigenvalues of the electronic Hessian are negative, the SCF solution is not a minimum.; In that case, orbital parameters can be varied along the lowest Hessian eigenvector to lower the energy. Orbital variation parameters are usually constrained. For example, in RHF the; spatial parts of the :math:`\alpha` and :math:`\beta` orbitals are the same. In; UHF, the orbital coefficients are usually constrained to be real. A stability analysis; can check whether a lower SCF solution exists while respecting the constraints of the original; solution; this is an internal instability. If one or more constraints have to be relaxed to reach; a lower-energy solution, there is an external instability. In |PSIfour|, the only external instability; that can be checked at present is the RHF :math:`\rightarrow` UHF one. Currently, two algorithms exist in |PSIfour| for stability analysis: the original; Direct Inversion and the newly implemented Davidson algorithms. We will first describe; options common to both algorithms. To request a stability analysis at the end of the SCF,; set the keyword |scf__stability_analysis|. Value ``CHECK`` only computes the electronic; Hessian eigenvalue and checks if an actual SCF minimum has been found, while value ``FOLLOW``; rotates the converged orbitals along the lowest eigenvector, then invokes the SCF; procedure again to lower the energy. In case the minimization does not succeed; or ends up on the same unstable solution, you can tune the scale factor for the orbital; rotation through the keyword |scf__follow_step_scale|.; The rotation angle is :math:`\frac{\pi}{2}\mbox{ } \cdot` (|scf__follow_",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:47091,Energy Efficiency,energy,energy,47091,". For example, in RHF the; spatial parts of the :math:`\alpha` and :math:`\beta` orbitals are the same. In; UHF, the orbital coefficients are usually constrained to be real. A stability analysis; can check whether a lower SCF solution exists while respecting the constraints of the original; solution; this is an internal instability. If one or more constraints have to be relaxed to reach; a lower-energy solution, there is an external instability. In |PSIfour|, the only external instability; that can be checked at present is the RHF :math:`\rightarrow` UHF one. Currently, two algorithms exist in |PSIfour| for stability analysis: the original; Direct Inversion and the newly implemented Davidson algorithms. We will first describe; options common to both algorithms. To request a stability analysis at the end of the SCF,; set the keyword |scf__stability_analysis|. Value ``CHECK`` only computes the electronic; Hessian eigenvalue and checks if an actual SCF minimum has been found, while value ``FOLLOW``; rotates the converged orbitals along the lowest eigenvector, then invokes the SCF; procedure again to lower the energy. In case the minimization does not succeed; or ends up on the same unstable solution, you can tune the scale factor for the orbital; rotation through the keyword |scf__follow_step_scale|.; The rotation angle is :math:`\frac{\pi}{2}\mbox{ } \cdot` (|scf__follow_step_scale|). The default value of; 0.5 usually provides a good guess, and modification is only recommended in difficult cases.; The default behavior for the stability code is to stop after trying to reoptimize the orbitals once; if the instability still exists. For more attempts, set |scf__max_attempts|;; the default value of 1 is recommended. In case the SCF ends up in the same minimum, modification; of |scf__follow_step_scale| is recommended over increasing |scf__max_attempts|. .. note:: Setting the option |scf__stability_analysis| to ``FOLLOW`` is only avalible for UHF. When using; RHF and ROHF ins",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:48052,Energy Efficiency,energy,energy,48052,"n to lower the energy. In case the minimization does not succeed; or ends up on the same unstable solution, you can tune the scale factor for the orbital; rotation through the keyword |scf__follow_step_scale|.; The rotation angle is :math:`\frac{\pi}{2}\mbox{ } \cdot` (|scf__follow_step_scale|). The default value of; 0.5 usually provides a good guess, and modification is only recommended in difficult cases.; The default behavior for the stability code is to stop after trying to reoptimize the orbitals once; if the instability still exists. For more attempts, set |scf__max_attempts|;; the default value of 1 is recommended. In case the SCF ends up in the same minimum, modification; of |scf__follow_step_scale| is recommended over increasing |scf__max_attempts|. .. note:: Setting the option |scf__stability_analysis| to ``FOLLOW`` is only avalible for UHF. When using; RHF and ROHF instabilities can be checked, but not followed. If you want to attempt to find a lower energy solution; you should re-run the calculation with |scf__reference| set to ``UHF``. The main algorithm available in |PSIfour| is the Direct Inversion algorithm. It can *only*; work with |globals__scf_type| ``PK``, and it explicitly builds the full electronic Hessian; matrix before explicitly inverting it. As such, this algorithm is very slow and it should; be avoided whenever possible. Direct Inversion is automatically invoked if the newer algorithm; is not available. The Davidson algorithm for stability analysis was implemented recently.; Only the lowest eigenvalues of the electronic Hessian are computed, and Hessian-vector; products are computed instead of the full Hessian. This algorithm is thus; much more efficient than the Direct Inversion, but at present, it is only available for UHF :math:`\rightarrow` UHF stability; analysis. The capabilities of both algorithms are summarized below:. .. _`table:stab_methods`:. .. table:: Stability analysis methods available in |PSIfour|. +------------------+-----",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:48776,Energy Efficiency,efficient,efficient,48776,"ng |scf__max_attempts|. .. note:: Setting the option |scf__stability_analysis| to ``FOLLOW`` is only avalible for UHF. When using; RHF and ROHF instabilities can be checked, but not followed. If you want to attempt to find a lower energy solution; you should re-run the calculation with |scf__reference| set to ``UHF``. The main algorithm available in |PSIfour| is the Direct Inversion algorithm. It can *only*; work with |globals__scf_type| ``PK``, and it explicitly builds the full electronic Hessian; matrix before explicitly inverting it. As such, this algorithm is very slow and it should; be avoided whenever possible. Direct Inversion is automatically invoked if the newer algorithm; is not available. The Davidson algorithm for stability analysis was implemented recently.; Only the lowest eigenvalues of the electronic Hessian are computed, and Hessian-vector; products are computed instead of the full Hessian. This algorithm is thus; much more efficient than the Direct Inversion, but at present, it is only available for UHF :math:`\rightarrow` UHF stability; analysis. The capabilities of both algorithms are summarized below:. .. _`table:stab_methods`:. .. table:: Stability analysis methods available in |PSIfour|. +------------------+------------------+----------------------------------------------+---------------------------+---------------------+; | Algorithm | |scf__reference| | Stability checked | |scf__stability_analysis| | |globals__scf_type| |; +==================+==================+==============================================+===========================+=====================+; | | RHF | Internal, External (:math:`\rightarrow` UHF) | ``CHECK`` | PK only |; + +------------------+----------------------------------------------+---------------------------+---------------------+; | Direct Inversion | ROHF | Internal | ``CHECK`` | PK only |; +------------------+------------------+----------------------------------------------+---------------------------+--------------",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:50265,Energy Efficiency,adapt,adapt,50265,"|scf__stability_analysis| | |globals__scf_type| |; +==================+==================+==============================================+===========================+=====================+; | | RHF | Internal, External (:math:`\rightarrow` UHF) | ``CHECK`` | PK only |; + +------------------+----------------------------------------------+---------------------------+---------------------+; | Direct Inversion | ROHF | Internal | ``CHECK`` | PK only |; +------------------+------------------+----------------------------------------------+---------------------------+---------------------+; | Davidson | UHF | Internal | ``CHECK`` or ``FOLLOW`` | Anything |; +------------------+------------------+----------------------------------------------+---------------------------+---------------------+. The best algorithm is automatically selected, *i.e.* Davidson for UHF :math:`\rightarrow` UHF and Direct Inversion otherwise. In addition to the options available for Direct Inversion, the Davidson algorithm can automatically; adapt |scf__follow_step_scale| to find a new SCF minimum. If |scf__max_attempts| > 1, additional attempts; will automatically increment |scf__follow_step_scale| by 0.2 every time the SCF falls back to the previously; found unstable minimum. The increment can be adjusted by setting |scf__follow_step_increment|.; The default value is 0.2; adjust if needed to try different values of |scf__follow_step_scale| in a single computation. The Davidson solver for the eigenvalues is controlled through several keywords. |scf__solver_maxiter|: maximum number of iterations. |scf__solver_convergence|: eigenvector convergence threshold. |scf__solver_n_root|: Solve for N eigenvectors in each irreducible representation. |scf__solver_roots_per_irrep|: The number of eigenvectors to solve in each irreducible representation. An array of as many integers as there are irreducible representations. |scf__solver_n_guess|: Use N guess vectors, this needs to be larger than the number of roots ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:54570,Energy Efficiency,charge,charge,54570,"ntact the developers on GitHub and/or the `forum <http://forum.psicode.org>`_. .. _`sec:scfqmmm`:. External potentials and QM/MM; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In addition to the implementation of :ref:`EFP <sec:libefp>` for accurate QM/MM; computations, |PSIfour| can perform more rudimentary QM/MM procedures via the; |scf__extern| keyword. The following snippet, extracted from the; :srcsample:`extern1` test case, demonstrates its use for a TIP3P external potential::. import numpy as np; external_potentials = [; [-0.834, np.array([1.649232019048,0.0,-2.356023604706]) / psi_bohr2angstroms],; [ 0.417, np.array([0.544757019107,0.0,-3.799961446760]) / psi_bohr2angstroms],; [ 0.417, np.array([0.544757019107,0.0,-0.912085762652]) / psi_bohr2angstroms]]. gradient('scf', external_potentials=external_potentials). The ``external_potentials`` array has three rows for three separate; particles, and it is passed to the SCF code on the last line. The; rows are composed of the atomic charge, x coordinate, y coordinate,; and z coordinate in that order. The atomic charge and coordinates are; specified in atomic units, [e] and [a0]. Add as many particle rows as; needed to describe the full MM region. .. caution:: In |PSIfour| previous to Spring 2022 and v1.6, setting an; external potential like the above looked like ::. Chrgfield = QMMM(); Chrgfield.extern.addCharge(-0.834, 1.649232019048, 0.0, -2.356023604706); Chrgfield.extern.addCharge( 0.417, 0.544757019107, 0.0, -3.799961446760); Chrgfield.extern.addCharge( 0.417, 0.544757019107, 0.0, -0.912085762652); psi4.set_global_option_python('EXTERN', Chrgfield.extern). gradient('scf'). The main differences are that (1) the specification of; charge locations in the old way used the units of the active; molecule, whereas the new way always uses Bohr and (2) the; specification of the charge and locations in the old way used the; :py:class:`psi4.driver.QMMM` class directly and added one charge; per command, whereas the new way consolidates ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:54650,Energy Efficiency,charge,charge,54650,"mm`:. External potentials and QM/MM; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In addition to the implementation of :ref:`EFP <sec:libefp>` for accurate QM/MM; computations, |PSIfour| can perform more rudimentary QM/MM procedures via the; |scf__extern| keyword. The following snippet, extracted from the; :srcsample:`extern1` test case, demonstrates its use for a TIP3P external potential::. import numpy as np; external_potentials = [; [-0.834, np.array([1.649232019048,0.0,-2.356023604706]) / psi_bohr2angstroms],; [ 0.417, np.array([0.544757019107,0.0,-3.799961446760]) / psi_bohr2angstroms],; [ 0.417, np.array([0.544757019107,0.0,-0.912085762652]) / psi_bohr2angstroms]]. gradient('scf', external_potentials=external_potentials). The ``external_potentials`` array has three rows for three separate; particles, and it is passed to the SCF code on the last line. The; rows are composed of the atomic charge, x coordinate, y coordinate,; and z coordinate in that order. The atomic charge and coordinates are; specified in atomic units, [e] and [a0]. Add as many particle rows as; needed to describe the full MM region. .. caution:: In |PSIfour| previous to Spring 2022 and v1.6, setting an; external potential like the above looked like ::. Chrgfield = QMMM(); Chrgfield.extern.addCharge(-0.834, 1.649232019048, 0.0, -2.356023604706); Chrgfield.extern.addCharge( 0.417, 0.544757019107, 0.0, -3.799961446760); Chrgfield.extern.addCharge( 0.417, 0.544757019107, 0.0, -0.912085762652); psi4.set_global_option_python('EXTERN', Chrgfield.extern). gradient('scf'). The main differences are that (1) the specification of; charge locations in the old way used the units of the active; molecule, whereas the new way always uses Bohr and (2) the; specification of the charge and locations in the old way used the; :py:class:`psi4.driver.QMMM` class directly and added one charge; per command, whereas the new way consolidates all into an array and; passes it by keyword argument to the calculation. The successor to the",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:55284,Energy Efficiency,charge,charge,55284,", external_potentials=external_potentials). The ``external_potentials`` array has three rows for three separate; particles, and it is passed to the SCF code on the last line. The; rows are composed of the atomic charge, x coordinate, y coordinate,; and z coordinate in that order. The atomic charge and coordinates are; specified in atomic units, [e] and [a0]. Add as many particle rows as; needed to describe the full MM region. .. caution:: In |PSIfour| previous to Spring 2022 and v1.6, setting an; external potential like the above looked like ::. Chrgfield = QMMM(); Chrgfield.extern.addCharge(-0.834, 1.649232019048, 0.0, -2.356023604706); Chrgfield.extern.addCharge( 0.417, 0.544757019107, 0.0, -3.799961446760); Chrgfield.extern.addCharge( 0.417, 0.544757019107, 0.0, -0.912085762652); psi4.set_global_option_python('EXTERN', Chrgfield.extern). gradient('scf'). The main differences are that (1) the specification of; charge locations in the old way used the units of the active; molecule, whereas the new way always uses Bohr and (2) the; specification of the charge and locations in the old way used the; :py:class:`psi4.driver.QMMM` class directly and added one charge; per command, whereas the new way consolidates all into an array and; passes it by keyword argument to the calculation. The successor to the :py:class:`psi4.driver.QMMM` class,; :py:class:`psi4.driver.QMMMbohr`, is operable, but it is discouraged; from being used directly. To run a computation in a constant dipole field, the |scf__perturb_h|,; |scf__perturb_with| and |scf__perturb_dipole| keywords can be used. As an; example, to add a dipole field of magnitude 0.05 a.u. in the y direction and; 0.1 a.u. in the z direction, we can use the following keywords::. set perturb_h true; set perturb_with dipole; set perturb_dipole [ 0, 0.05, 0.1 ]. Note that if any specified fields do not fall along a symmetry axis, the; symmetry of the calculation should be reduced accordingly; if in doubt run the; calculation in C1 s",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:55427,Energy Efficiency,charge,charge,55427,", external_potentials=external_potentials). The ``external_potentials`` array has three rows for three separate; particles, and it is passed to the SCF code on the last line. The; rows are composed of the atomic charge, x coordinate, y coordinate,; and z coordinate in that order. The atomic charge and coordinates are; specified in atomic units, [e] and [a0]. Add as many particle rows as; needed to describe the full MM region. .. caution:: In |PSIfour| previous to Spring 2022 and v1.6, setting an; external potential like the above looked like ::. Chrgfield = QMMM(); Chrgfield.extern.addCharge(-0.834, 1.649232019048, 0.0, -2.356023604706); Chrgfield.extern.addCharge( 0.417, 0.544757019107, 0.0, -3.799961446760); Chrgfield.extern.addCharge( 0.417, 0.544757019107, 0.0, -0.912085762652); psi4.set_global_option_python('EXTERN', Chrgfield.extern). gradient('scf'). The main differences are that (1) the specification of; charge locations in the old way used the units of the active; molecule, whereas the new way always uses Bohr and (2) the; specification of the charge and locations in the old way used the; :py:class:`psi4.driver.QMMM` class directly and added one charge; per command, whereas the new way consolidates all into an array and; passes it by keyword argument to the calculation. The successor to the :py:class:`psi4.driver.QMMM` class,; :py:class:`psi4.driver.QMMMbohr`, is operable, but it is discouraged; from being used directly. To run a computation in a constant dipole field, the |scf__perturb_h|,; |scf__perturb_with| and |scf__perturb_dipole| keywords can be used. As an; example, to add a dipole field of magnitude 0.05 a.u. in the y direction and; 0.1 a.u. in the z direction, we can use the following keywords::. set perturb_h true; set perturb_with dipole; set perturb_dipole [ 0, 0.05, 0.1 ]. Note that if any specified fields do not fall along a symmetry axis, the; symmetry of the calculation should be reduced accordingly; if in doubt run the; calculation in C1 s",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:55531,Energy Efficiency,charge,charge,55531,", x coordinate, y coordinate,; and z coordinate in that order. The atomic charge and coordinates are; specified in atomic units, [e] and [a0]. Add as many particle rows as; needed to describe the full MM region. .. caution:: In |PSIfour| previous to Spring 2022 and v1.6, setting an; external potential like the above looked like ::. Chrgfield = QMMM(); Chrgfield.extern.addCharge(-0.834, 1.649232019048, 0.0, -2.356023604706); Chrgfield.extern.addCharge( 0.417, 0.544757019107, 0.0, -3.799961446760); Chrgfield.extern.addCharge( 0.417, 0.544757019107, 0.0, -0.912085762652); psi4.set_global_option_python('EXTERN', Chrgfield.extern). gradient('scf'). The main differences are that (1) the specification of; charge locations in the old way used the units of the active; molecule, whereas the new way always uses Bohr and (2) the; specification of the charge and locations in the old way used the; :py:class:`psi4.driver.QMMM` class directly and added one charge; per command, whereas the new way consolidates all into an array and; passes it by keyword argument to the calculation. The successor to the :py:class:`psi4.driver.QMMM` class,; :py:class:`psi4.driver.QMMMbohr`, is operable, but it is discouraged; from being used directly. To run a computation in a constant dipole field, the |scf__perturb_h|,; |scf__perturb_with| and |scf__perturb_dipole| keywords can be used. As an; example, to add a dipole field of magnitude 0.05 a.u. in the y direction and; 0.1 a.u. in the z direction, we can use the following keywords::. set perturb_h true; set perturb_with dipole; set perturb_dipole [ 0, 0.05, 0.1 ]. Note that if any specified fields do not fall along a symmetry axis, the; symmetry of the calculation should be reduced accordingly; if in doubt run the; calculation in C1 symmetry. For examples of SCF and MP2 calculations in an; external field, see :srcsample:`scf7` and :srcsample:`dfmp2-grad5`. .. _`sec:scfdefault`:. Convergence and Algorithm Defaults; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~.",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:56297,Energy Efficiency,reduce,reduced,56297,"tion of; charge locations in the old way used the units of the active; molecule, whereas the new way always uses Bohr and (2) the; specification of the charge and locations in the old way used the; :py:class:`psi4.driver.QMMM` class directly and added one charge; per command, whereas the new way consolidates all into an array and; passes it by keyword argument to the calculation. The successor to the :py:class:`psi4.driver.QMMM` class,; :py:class:`psi4.driver.QMMMbohr`, is operable, but it is discouraged; from being used directly. To run a computation in a constant dipole field, the |scf__perturb_h|,; |scf__perturb_with| and |scf__perturb_dipole| keywords can be used. As an; example, to add a dipole field of magnitude 0.05 a.u. in the y direction and; 0.1 a.u. in the z direction, we can use the following keywords::. set perturb_h true; set perturb_with dipole; set perturb_dipole [ 0, 0.05, 0.1 ]. Note that if any specified fields do not fall along a symmetry axis, the; symmetry of the calculation should be reduced accordingly; if in doubt run the; calculation in C1 symmetry. For examples of SCF and MP2 calculations in an; external field, see :srcsample:`scf7` and :srcsample:`dfmp2-grad5`. .. _`sec:scfdefault`:. Convergence and Algorithm Defaults; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. _`table:conv_scf`:. .. table:: SCF algorithm and convergence criteria defaults by calculation type [#f1]_. +--------------------+--------------------+----------------------+----------------------+---------------------+; | *Ab Initio* Method | Calculation Type | |scf__e_convergence| | |scf__d_convergence| | |globals__scf_type| |; +====================+====================+======================+======================+=====================+; | SCF of HF or DFT | energy | 6 | 6 | DF |; + +--------------------+----------------------+----------------------+ +; | | optimization | 8 | 8 | |; + +--------------------+----------------------+----------------------+ +; | | frequency [#f7]_ | 8 | 8",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:57046,Energy Efficiency,energy,energy,57046,"n should be reduced accordingly; if in doubt run the; calculation in C1 symmetry. For examples of SCF and MP2 calculations in an; external field, see :srcsample:`scf7` and :srcsample:`dfmp2-grad5`. .. _`sec:scfdefault`:. Convergence and Algorithm Defaults; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. _`table:conv_scf`:. .. table:: SCF algorithm and convergence criteria defaults by calculation type [#f1]_. +--------------------+--------------------+----------------------+----------------------+---------------------+; | *Ab Initio* Method | Calculation Type | |scf__e_convergence| | |scf__d_convergence| | |globals__scf_type| |; +====================+====================+======================+======================+=====================+; | SCF of HF or DFT | energy | 6 | 6 | DF |; + +--------------------+----------------------+----------------------+ +; | | optimization | 8 | 8 | |; + +--------------------+----------------------+----------------------+ +; | | frequency [#f7]_ | 8 | 8 | |; +--------------------+--------------------+----------------------+----------------------+---------------------+; | SCF of post-HF | energy | 8 | 8 | PK [#f3]_ |; + +--------------------+----------------------+----------------------+ +; | | optimization | 10 | 10 | |; + +--------------------+----------------------+----------------------+ +; | | frequency [#f7]_ | 10 | 10 | |; + +--------------------+----------------------+----------------------+ +; | | CC property [#f2]_ | 10 | 10 | |; +--------------------+--------------------+----------------------+----------------------+---------------------+. .. _`table:conv_corl`:. .. table:: Post-SCF convergence criteria defaults by calculation type [#f4]_. +--------------------+--------------------+----------------------+-------------------------+; | *Ab Initio* Method | Calculation Type | E_CONVERGENCE [#f5]_ | R_CONVERGENCE [#f6]_ |; +====================+====================+======================+=========================+; | post-HF of post-HF |",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:57413,Energy Efficiency,energy,energy,57413,"n should be reduced accordingly; if in doubt run the; calculation in C1 symmetry. For examples of SCF and MP2 calculations in an; external field, see :srcsample:`scf7` and :srcsample:`dfmp2-grad5`. .. _`sec:scfdefault`:. Convergence and Algorithm Defaults; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. _`table:conv_scf`:. .. table:: SCF algorithm and convergence criteria defaults by calculation type [#f1]_. +--------------------+--------------------+----------------------+----------------------+---------------------+; | *Ab Initio* Method | Calculation Type | |scf__e_convergence| | |scf__d_convergence| | |globals__scf_type| |; +====================+====================+======================+======================+=====================+; | SCF of HF or DFT | energy | 6 | 6 | DF |; + +--------------------+----------------------+----------------------+ +; | | optimization | 8 | 8 | |; + +--------------------+----------------------+----------------------+ +; | | frequency [#f7]_ | 8 | 8 | |; +--------------------+--------------------+----------------------+----------------------+---------------------+; | SCF of post-HF | energy | 8 | 8 | PK [#f3]_ |; + +--------------------+----------------------+----------------------+ +; | | optimization | 10 | 10 | |; + +--------------------+----------------------+----------------------+ +; | | frequency [#f7]_ | 10 | 10 | |; + +--------------------+----------------------+----------------------+ +; | | CC property [#f2]_ | 10 | 10 | |; +--------------------+--------------------+----------------------+----------------------+---------------------+. .. _`table:conv_corl`:. .. table:: Post-SCF convergence criteria defaults by calculation type [#f4]_. +--------------------+--------------------+----------------------+-------------------------+; | *Ab Initio* Method | Calculation Type | E_CONVERGENCE [#f5]_ | R_CONVERGENCE [#f6]_ |; +====================+====================+======================+=========================+; | post-HF of post-HF |",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:58286,Energy Efficiency,energy,energy,58286,"+----------------------+---------------------+; | SCF of post-HF | energy | 8 | 8 | PK [#f3]_ |; + +--------------------+----------------------+----------------------+ +; | | optimization | 10 | 10 | |; + +--------------------+----------------------+----------------------+ +; | | frequency [#f7]_ | 10 | 10 | |; + +--------------------+----------------------+----------------------+ +; | | CC property [#f2]_ | 10 | 10 | |; +--------------------+--------------------+----------------------+----------------------+---------------------+. .. _`table:conv_corl`:. .. table:: Post-SCF convergence criteria defaults by calculation type [#f4]_. +--------------------+--------------------+----------------------+-------------------------+; | *Ab Initio* Method | Calculation Type | E_CONVERGENCE [#f5]_ | R_CONVERGENCE [#f6]_ |; +====================+====================+======================+=========================+; | post-HF of post-HF | energy | 6 | |; + +--------------------+----------------------+-------------------------+; | | optimization | 8 | |; + +--------------------+----------------------+-------------------------+; | | frequency [#f7]_ | 8 | |; + +--------------------+----------------------+-------------------------+; | | CC property [#f2]_ | 8 | |; +--------------------+--------------------+----------------------+-------------------------+. .. rubric:: Footnotes. .. [#f1] Note that this table applies only the SCF module,; not to the final convergence criteria for post-HF methods or to methods; that use an alternate starting point, like MCSCF. SAPT computations, too,; set tighter values. .. [#f2] This applies to properties computed through the :py:func:`~psi4.driver.properties` function. .. [#f3] Post-HF methods that do not rely upon the usual 4-index AO integrals use a; density-fitted SCF reference. That is, for DF-MP2 and SAPT, the default |globals__scf_type| is DF. .. [#f4] Note that this table applies to the final convergence criteria for; all the post-SCF modules",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:60256,Energy Efficiency,power,powerful,60256,"DF. .. [#f4] Note that this table applies to the final convergence criteria for; all the post-SCF modules that define a |ccenergy__e_convergence| keyword. .. [#f5] The E_CONVERGENCE keyword is implemented for most post-SCF modules.; See a list beginning at |ccenergy__e_convergence|. .. [#f6] The R_CONVERGENCE keyword places a convergence check on an internal; residual error measure and is implemented for several post-SCF; modules (see list beginning at |ccenergy__r_convergence|). It is defined; according to the quantum chemical method and so its default value is set; by each module individually. .. [#f7] For frequency computations by finite difference of energies,; convergence criteria are tightened further still to 10 for; |scf__e_convergence| and |scf__d_convergence| for SCF of HF or DFT, 11; for |scf__e_convergence| and |scf__d_convergence| for SCF of post-HF,; and 10 for E_CONVERGENCE for post-HF of post-HF. .. _`sec:scfrec`:. Recommendations; ~~~~~~~~~~~~~~~. The SCF code is quite flexible and powerful.; We have tried as much as possible to keep the number of options to; a minimum and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. * For |scf__guess|, the ``SAD`` guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; * For wall time, ``DF`` may be a factor of ten or more faster than the exact; integral technologies available in |PSIfour|.; Use ``DF`` unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your orbital basis/atom type. Then use; ``DIRECT``.; * Don't mess with the DIIS convergenc",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:61667,Energy Efficiency,energy,energy,61667,"ist beginning at |ccenergy__r_convergence|). It is defined; according to the quantum chemical method and so its default value is set; by each module individually. .. [#f7] For frequency computations by finite difference of energies,; convergence criteria are tightened further still to 10 for; |scf__e_convergence| and |scf__d_convergence| for SCF of HF or DFT, 11; for |scf__e_convergence| and |scf__d_convergence| for SCF of post-HF,; and 10 for E_CONVERGENCE for post-HF of post-HF. .. _`sec:scfrec`:. Recommendations; ~~~~~~~~~~~~~~~. The SCF code is quite flexible and powerful.; We have tried as much as possible to keep the number of options to; a minimum and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. * For |scf__guess|, the ``SAD`` guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; * For wall time, ``DF`` may be a factor of ten or more faster than the exact; integral technologies available in |PSIfour|.; Use ``DF`` unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your orbital basis/atom type. Then use; ``DIRECT``.; * Don't mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; * Buy a developer a beer!. The ""best-practice"" input file for HF is::. memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvdz; scf_type df; guess sad; ints_tolerance 1.0E-10 # Even this is epically tight, 1.0E-8 is OK; }. energy('scf'); ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:5459,Integrability,contract,contracted,5459,"this point, the code switches on the requested Direct integrals technology, which; requires only four full iterations to reach convergence, starting from the DF; guess. This hybrid DF/Direct procedure can significantly accelerate SCF; computations requiring exact integrals. After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; |globals__print| option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. .. index::; pair: SCF; theory. .. _`sec:scftheory`:. Theory; ~~~~~~. The objective of Hartree--Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) :math:`\{\psi_i\}`,. .. math:: \psi_i(\vec x_1) = C_{\mu i} \phi_{\mu} (\vec x_1). Here, :math:`\{\phi_{\mu}\}` are the basis functions, which, in |PSIfour| are; contracted Cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix :math:`C_{\mu i}` contains the MO coefficients, which are the; constrained variational parameters in Hartree--Fock. The molecular orbitals are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. .. math:: | \Psi_0 \rangle =; \frac{1}{\sqrt{N!}} \left | \begin{array}{cccc}; \psi_1 (\vec x_1) & \psi_2(\vec x_1) & \ldots & \psi_N (\vec x_1) \\; \psi_1 (\vec x_2) & \psi_2(\vec x_2) & \ldots & \psi_N (\vec x_2) \\; \vdots & \vdots & \ddots & \vdots \\; \psi_1 (\vec x_N) & \psi_2(\vec x_N) & \ldots & \psi_N (\vec x_N) \\; \end{array}\right |. This form for the Hartree--Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; :math:`\mathbb{R}^6` instead of a more complicated effect in; :math:`\mathbb{R}^N`\ . Considering the electronic Hamiltonian,. .. math:: \hat H = \sum_{i} -\frac{1}{2} \nabla",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:8302,Integrability,depend,depends,8302,"ix, which is the effective one-body potential at; the current value of the density,. .. math:: F_{\mu\nu}^{\alpha} = H_{\mu\nu}; + \underbrace{\left(D_{\lambda\sigma}^{\alpha} + D_{\lambda\sigma}^{\beta}\right); (\mu\nu|\lambda\sigma)}_{J}; + \underbrace{D_{\lambda\sigma}^{\alpha} (\mu\lambda|\sigma\nu)}_{K^{\alpha}}. Here the tensor :math:`(\mu\nu|\lambda\sigma)` is an AO Electron-Repulsion; Integral (ERI) in chemists' notation,. .. math:: (\mu\nu|\lambda\sigma) = \iint_{\mathbb{R}^6}; \phi_{\mu} (\vec r_1); \phi_{\nu} (\vec r_1); \frac{1}{r_{12}}; \phi_{\lambda} (\vec r_2); \phi_{\sigma} (\vec r_2); \ \mathrm{d}^3 r_1; \ \mathrm{d}^3 r_2. The MO coefficients are found as the generalized eigenvectors of the Fock Matrix,. .. math:: F^\alpha C^\alpha = S C^\alpha \epsilon^\alpha. The eigenvalues :math:`\epsilon` are the orbital energies, and the metric matrix; :math:`S` is the AO-basis overlap matrix. .. math:: S_{\mu\nu} = (\mu | \nu ). Note that the Fock Matrix depends on the density (both alpha and beta), and; therefore the orbitals. Because of this, SCF is a nonlinear procedure, which; terminates when the generating orbitals are self-consistent with the Fock matrix; they generate. The formation of the Coulomb matrix :math:`J` and the exchange matrix; :math:`K^{\alpha}` dominate the computational effort of the SCF procedure. For; very large systems, diagonalization of the Fock matrix can also present a; significant hurdle. .. _`sec:scfinput`:. Minimal Input; ~~~~~~~~~~~~~. Minimal input for a Hartree--Fock computation is a molecule block, basis set; option, and a call to ``energy('scf')``::. molecule {; He; }. set basis sto-3g. energy('scf'). This will run a Restricted Hartree--Fock (RHF) on neutral singlet Helium in; :math:`D_{2h}` spatial symmetry with a minimal ``STO-3G`` basis, 1.0E-6; energy and density convergence criteria (since single-point, see; :ref:`SCF Convergence & Algorithm <table:conv_scf>`), a DF ERI algorithm, symmetric; orthogonalization, DIIS, an",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:14852,Integrability,depend,dependencies,14852,"ich may occur; for large systems or for systems where diffuse basis sets are used. This problem may be avoided by using canonical orthogonalization, in; which an asymmetric inverse square root of the overlap matrix is; formed, with numerical stability enhanced by the elimination of; eigenvectors corresponding to very small eigenvalues. As a few; combinations of AO basis functions may be discarded, the number of; canonical-orthogonalized OSOs and MOs may be slightly smaller than the; number of AOs. When the basis set is too overcomplete, the eigendecomposition of the; overlap matrix is no longer numerically stable. In this case the; partial Cholesky decomposition can be used to pick a subset of basis; functions that span a sufficiently complete set, see; [Lehtola:2019:241102]_ and [Lehtola:2020:032504]_. This subset can then; be orthonormalized as usual; the rest of the basis functions are; hidden from the calculation. The Cholesky approach allows reaching; accurate energies even in the presence of significant linear; dependencies [Lehtola:2020:134108]_. In |PSIfour|, symmetric orthogonalization is used by default, unless; the smallest overlap eigenvalue falls below the user-supplied double; option |scf__s_tolerance|, which defaults to 1E-7. If the smallest; eigenvalue is below this cutoff, canonical orthogonalization is; forced, and all eigenvectors corresponding to eigenvalues below the; cutoff are eliminated. If the eigendecomposition is detected to be numerically unstable - the; reciprocal condition number of the overlap matrix to be smaller than; the machine epsilon - the partial Cholesky decomposition is undertaken; until |scf__s_cholesky_tolerance|, which defaults to 1E-8. Use of symmetric, canonical, and partial Cholesky orthogonalization; can be forced by setting the |scf__s_orthogonalization| option to; ``SYMMETRIC``, ``CANONICAL``, or ``PARTIALCHOLESKY``,; respectively. Note that in practice, the MOs and OSOs are built separately within; each irrep from th",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:20998,Integrability,depend,depends,20998,"D, see; [Lehtola:2019:1593]_. This variant employs an updated rule for the; generalized Wolfsberg-Helmholz formula from [Ammeter:1978:3686]_.; READ; Read the previous orbitals from a ``wfn`` file, casting from; one basis to another if needed. Useful for starting anion; computations from neutral orbitals, or after small geometry; changes. At present, casting from a different molecular point; group is not supported. This becomes the default for the second; and later iterations of geometry optimizations.; SAP; Superposition of Atomic Potentials. This is essentially a; modification of the core Hamiltonian, which includes screening; effects by using a radially screened effective atomic charge. The; screening effects have been calculated at the complete basis set; limit with finite-element calculations, see [Lehtola:2019:25945]_; and [Lehtola:2020:012516]_. The guess and its implementation have; been described in [Lehtola:2019:1593]_. The guess is evaluated on a; DFT quadrature grid, so the guess energy depends slightly on the; used DFT quadrature. The current implementation is based on; exchange-only local density calculations that are but nanohartree; away from the complete basis set limit [Lehtola:2020:012516]_.; SAPGAU; Superposition of Atomic Potentials, but using error function based; fits to the atomic radial potentials as discussed in; [Lehtola:2020:144105]_. The main difference to the SAP guess; discussed above [Lehtola:2019:25945]_ is that the SAPGAU scheme is; analytic, and can be efficiently formed in terms of three-center; two-electron integrals [Lehtola:2020:144105]_. The potential in; the SAPGAU scheme is passed with the |scf__sapgau_basis|; keyword. The default potential is given by the large fit to the; HelFEM potential, sap_helfem_large, described in; [Lehtola:2020:144105]_. Note that this guess is known in the DIRAC; program as .SCRPOT and in the ERKALE program as SAPFIT. These are all set by the |scf__guess| keyword. Also, an automatic Python; procedur",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:33860,Integrability,rout,routines,33860," In some cases the above algorithms have multiple implementations that return; the same result, but are optimal under different molecules sizes and hardware; configurations. Psi4 will automatically detect the correct algorithm to run and; only expert users should manually select the below implementations. The DF; algorithm has the following two implementations. MEM_DF; A DF algorithm optimized around memory layout and is optimal as long as; there is sufficient memory to hold the three-index DF tensors in memory. This; algorithm may be faster for builds that require disk if SSDs are used.; DISK_DF; A DF algorithm (the default DF algorithm before Psi4 1.2) optimized to; minimize Disk IO by sacrificing some performance due to memory layout. Note that these algorithms have both in-memory and on-disk options, but; performance penalties up to a factor of 2.5 can be found if the incorrect; algorithm is chosen. It is therefore highly recommended that the keyword ""DF""; be selected in all cases so that the correct implementation can be selected by; |PSIfours| internal routines. Expert users can manually switch between MEM_DF and; DISK_DF; however, they may find documented exceptions during use as several; post SCF algorithms require a specific implementation. Additionally, expert users ; can manually switch between the in-memory and on-disk options *within* MEM_DF or DISK_DF using ; the |scf__scf_subtype| option. Using ``SCF_SUBTYPE = AUTO``, where |PSIfour| ; automatically selects the in-memory or on-disk option for MEM_DF/DISK_DF based on memory and molecule, is the default ; and recommended option. However, the in-memory or on-disk algorithms for MEM_DF and DISK_DF can be forced by using; ``SCF_SUBTYPE = INCORE`` or ``SCF_SUBTYPE = OUT_OF_CORE``, respectively.; Note that an exception will be thrown if ; ``SCF_SUBTYPE = INCORE`` is used without allocating sufficient memory to ; |PSIfour|. For some of these algorithms, Schwarz and/or density sieving can be used to; identify ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:38895,Integrability,integrat,integration,38895,"DFDIRJ as the Coulomb construction ; algorithm when specifying |globals__scf_type| to use a composite algorithm combination (``DFDIRJ+K_alg`` in general, ; or ``DFDIRJ`` for DFT with non-hybrid functionals). . DFDIRJ supports multiple capabilities to improve performance. Specifically, DFDIRJ allows for a combination of density-matrix based ERI ; screening (set |globals__screening| to ``DENSITY``) and incremental Fock matrix construction (set |scf__incfock| to ``TRUE``). These two, when combined,; enable more aggressive screening of ERI contributions to the Coulomb matrix and thus greatly improve performance. .. _`sec:scfcosx`:. COSX Exchange; ~~~~~~~~~~~~~. The semi-numerical COSX algorithm described in [Neese:2009:98]_ evaluates; two-electron ERIs analytically over one electron coordinate and numerically; over the other electron coordinate, and belongs to the family of pseudospectral ; methods originally suggested by Friesner. In COSX, numerical integration is performed on standard; DFT quadrature grids, which are described in :ref:`sec:dft`.; Both the accuracy of the COSX algorithm and also the computational; cost are directly determined by the size of the integration grid, so selection; of the grid is important. This COSX implementation uses two separate grids.; By default, the SCF algorithm is first converged on a smaller grid, followed by a; number of SCF iterations up to a maximum value (controlled by the |scf__cosx_maxiter_final| keyword); on a larger grid. By default, |scf__cosx_maxiter_final| is set to 1, a single; SCF iteration, which results in numerical errors comparable to; performing the entire SCF on the expensive larger grid at a computational cost; much closer to the smaller grid. Setting |scf__cosx_maxiter_final| to 0 disables the; larger grid entirely. Setting |scf__cosx_maxiter_final| to -1 allows; for the SCF to fully converge on the larger grid, useful for the study of wavefunction; properties such as gradients. The size of the initial grid is ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:39111,Integrability,integrat,integration,39111,"eneral, ; or ``DFDIRJ`` for DFT with non-hybrid functionals). . DFDIRJ supports multiple capabilities to improve performance. Specifically, DFDIRJ allows for a combination of density-matrix based ERI ; screening (set |globals__screening| to ``DENSITY``) and incremental Fock matrix construction (set |scf__incfock| to ``TRUE``). These two, when combined,; enable more aggressive screening of ERI contributions to the Coulomb matrix and thus greatly improve performance. .. _`sec:scfcosx`:. COSX Exchange; ~~~~~~~~~~~~~. The semi-numerical COSX algorithm described in [Neese:2009:98]_ evaluates; two-electron ERIs analytically over one electron coordinate and numerically; over the other electron coordinate, and belongs to the family of pseudospectral ; methods originally suggested by Friesner. In COSX, numerical integration is performed on standard; DFT quadrature grids, which are described in :ref:`sec:dft`.; Both the accuracy of the COSX algorithm and also the computational; cost are directly determined by the size of the integration grid, so selection; of the grid is important. This COSX implementation uses two separate grids.; By default, the SCF algorithm is first converged on a smaller grid, followed by a; number of SCF iterations up to a maximum value (controlled by the |scf__cosx_maxiter_final| keyword); on a larger grid. By default, |scf__cosx_maxiter_final| is set to 1, a single; SCF iteration, which results in numerical errors comparable to; performing the entire SCF on the expensive larger grid at a computational cost; much closer to the smaller grid. Setting |scf__cosx_maxiter_final| to 0 disables the; larger grid entirely. Setting |scf__cosx_maxiter_final| to -1 allows; for the SCF to fully converge on the larger grid, useful for the study of wavefunction; properties such as gradients. The size of the initial grid is controlled by the keywords; |scf__cosx_radial_points_initial| and |scf__cosx_spherical_points_initial|.; The final grid is controlled by |scf__cosx",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:41453,Integrability,integrat,integration,41453,"ensity_tolerance|, and; |scf__cosx_basis_tolerance| keywords, respectively. |scf__cosx_ints_tolerance|; is the most consequential of the three thresholds in both cost and accuracy.; This keyword determines screening of negligible one-electron integrals.; |scf__cosx_density_tolerance| controls the threshold for significant; shell pairs in the density matrix. Lastly, |scf__cosx_basis_tolerance| is; a cutoff for the value of basis functions at grid points. This keyword is; used to determine the radial extent of the each basis shell, and it is the; COSX analogue to |scf__dft_basis_tolerance|. The |scf__incfock| keyword (defaults to ``false``) increases performance; by constructing the Fock matrix from differences in the density matrix, which; are more amenable to screening. This option is disabled by default because of; potential SCF convergence issues, particularly when using diffuse basis functions.; The |scf__cosx_overlap_fitting| keyword (defaults to ``true``) reduces numerical; integration errors using the method described in [Izsak:2011:144105]_ and is; always recommended. .. _`sec:scflink`:. Linear Exchange; ~~~~~~~~~~~~~~~. Large SCF calculations can benefit from specialized screening procedures that further reduce the scaling of the ERI contribution to the Fock matrix.; LinK, the linear-scaling exchange method described in [Ochsenfeld:1998:1663]_, is available in Psi4 in conjunction with composite algorithms that build J (|globals__scf_type| set to ``J_alg+LINK``).; LinK achieves linear-scaling by exploiting shell pair sparsity in the density matrix and overlap sparsity between shell pairs. Specifically, LinK exploits the fact that the Exchange term; requires only a linear-scaling number of significant elements through reformulating the; shell quartet screening process to scale linearly with system size.; LinK is most competitive when used with non-diffuse orbital basis sets, since orbital and density overlaps decay slower with diffuse functions.; LinK is especi",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:14071,Modifiability,enhance,enhanced,14071,"ogonalization; ~~~~~~~~~~~~~~~~~. One of the first steps in the SCF procedure is the determination of an; orthogonal basis (known as the OSO basis) from the atomic orbital; basis (known as the AO basis). The Molecular Orbital basis (MO basis); is then built as a particular unitary transformation of the OSO; basis. In |PSIfour|, the determination of the OSO basis is; accomplished via either symmetric, canonical, or partial Cholesky; orthogonalization. Symmetric orthogonalization uses the symmetric inverse square root of; the overlap matrix for the orthogonalization matrix. Use of symmetric; orthogonalization always yields the same number of OSO functions (and; thereby MOs) as AO functions. However, this may lead to numerical; problems if the overlap matrix has small eigenvalues, which may occur; for large systems or for systems where diffuse basis sets are used. This problem may be avoided by using canonical orthogonalization, in; which an asymmetric inverse square root of the overlap matrix is; formed, with numerical stability enhanced by the elimination of; eigenvectors corresponding to very small eigenvalues. As a few; combinations of AO basis functions may be discarded, the number of; canonical-orthogonalized OSOs and MOs may be slightly smaller than the; number of AOs. When the basis set is too overcomplete, the eigendecomposition of the; overlap matrix is no longer numerically stable. In this case the; partial Cholesky decomposition can be used to pick a subset of basis; functions that span a sufficiently complete set, see; [Lehtola:2019:241102]_ and [Lehtola:2020:032504]_. This subset can then; be orthonormalized as usual; the rest of the basis functions are; hidden from the calculation. The Cholesky approach allows reaching; accurate energies even in the presence of significant linear; dependencies [Lehtola:2020:134108]_. In |PSIfour|, symmetric orthogonalization is used by default, unless; the smallest overlap eigenvalue falls below the user-supplied double; ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:15830,Modifiability,adapt,adapted,15830," the presence of significant linear; dependencies [Lehtola:2020:134108]_. In |PSIfour|, symmetric orthogonalization is used by default, unless; the smallest overlap eigenvalue falls below the user-supplied double; option |scf__s_tolerance|, which defaults to 1E-7. If the smallest; eigenvalue is below this cutoff, canonical orthogonalization is; forced, and all eigenvectors corresponding to eigenvalues below the; cutoff are eliminated. If the eigendecomposition is detected to be numerically unstable - the; reciprocal condition number of the overlap matrix to be smaller than; the machine epsilon - the partial Cholesky decomposition is undertaken; until |scf__s_cholesky_tolerance|, which defaults to 1E-8. Use of symmetric, canonical, and partial Cholesky orthogonalization; can be forced by setting the |scf__s_orthogonalization| option to; ``SYMMETRIC``, ``CANONICAL``, or ``PARTIALCHOLESKY``,; respectively. Note that in practice, the MOs and OSOs are built separately within; each irrep from the symmetry-adapted combinations of AOs known as; Unique Symmetry Orbitals (USOs). For canonical orthogonalization,; this implies that the number of MOs and OSOs per irrep may be slightly; smaller than the number of USOs per irrep. A contrived example demonstrating OSOs/MOs vs. AOs with symmetry is shown; below::. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c2 # Two irreps is easier to comprehend; }. set {; s_tolerance 0.0001 # Set an unreasonably tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eigenvalues for even H2O; print 3; }. energy('scf'). Output::. ==> Pre-Iterations <==. -------------------------------------------------------; Irrep Nso Nmo Nalpha Nbeta Ndocc Nsocc; -------------------------------------------------------; A 145 145 0 0 0 0; B 142 142 0 0 0 0; -------------------------------------------------------; Total 287 287 5 5 5 0; -------------------------------------------------------. ... Minimum ei",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:17197,Modifiability,adapt,adapted,17197,"mprehend; }. set {; s_tolerance 0.0001 # Set an unreasonably tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eigenvalues for even H2O; print 3; }. energy('scf'). Output::. ==> Pre-Iterations <==. -------------------------------------------------------; Irrep Nso Nmo Nalpha Nbeta Ndocc Nsocc; -------------------------------------------------------; A 145 145 0 0 0 0; B 142 142 0 0 0 0; -------------------------------------------------------; Total 287 287 5 5 5 0; -------------------------------------------------------. ... Minimum eigenvalue in the overlap matrix is 1.6888063568E-05.; Using Canonical Orthogonalization with cutoff of 1.0000000000E-04.; Irrep 0, 1 of 145 possible MOs eliminated.; Irrep 1, 2 of 142 possible MOs eliminated.; Overall, 3 of 287 possible MOs eliminated. In this example, there are 287 AO basis functions after spherical harmonics are; applied. These are used to produce 287 symmetry adapted USOs, 145 of which are; assigned to irrep A, and 142 of which are assigned to irrep B. Within irrep A,; 144 OSOs fall above the eigenvalue cutoff, and within irrep B 140 OSOs fall; above the eigenvalue cutoff. In total, 284 molecular orbitals are chosen from; 287 AOs/USOs. .. _`sec:scfguess`:. Initial Guess; ~~~~~~~~~~~~~. In each step of the SCF procedure, a new Fock or Kohn--Sham potential is built; according to the previous density, following which the potential is diagonalized; to produce new molecular orbitals, from which a new density is computed. This; procedure is continued until either convergence is reached or a preset maximum; number of iterations is exceeded. Convergence is determined by both change in; energy and root-mean-square change in density matrix values, which must be below; the user-specified |scf__e_convergence| and |scf__d_convergence|, respectively.; The maximum number of iterations is specified by the |scf__maxiter| option. It; should be noted that SCF is a chaotic process, and,",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:19756,Modifiability,extend,extended,19756,"(SCF)>`]; Superposition of Atomic Densities. Builds the initial density as the; spin-averaged sum of atomic UHF computations in the current basis. If an; open-shell system, uniform scaling of the spin-averaged density matrices is; performed. If orbitals are needed (*e.g.*, in density fitting), a partial; Cholesky factorization of the density matrices is used. Often extremely; accurate, particularly for closed-shell systems. This is the default for; systems of more than one atom.; SADNO; Natural orbitals from Superposition of Atomic Densities. Similar; to the above, but it forms natural orbitals from the SAD density; matrix to get proper orbitals which are used to start the; calculation, see [Lehtola:2019:1593]_.; GWH; A generalized Wolfsberg-Helmholtz modification of the core; Hamiltonian matrix. Usually less accurate than the core guess: the; latter is exact for one-electron systems, GWH is not; see; [Lehtola:2019:1593]_).; HUCKEL; An extended H\ |u_dots|\ ckel guess based on on-the-fly atomic UHF; calculations alike SAD, see [Lehtola:2019:1593]_.; MODHUCKEL; Like HUCKEL, an extended H\ |u_dots|\ ckel guess based on; on-the-fly atomic UHF calculations alike SAD, see; [Lehtola:2019:1593]_. This variant employs an updated rule for the; generalized Wolfsberg-Helmholz formula from [Ammeter:1978:3686]_.; READ; Read the previous orbitals from a ``wfn`` file, casting from; one basis to another if needed. Useful for starting anion; computations from neutral orbitals, or after small geometry; changes. At present, casting from a different molecular point; group is not supported. This becomes the default for the second; and later iterations of geometry optimizations.; SAP; Superposition of Atomic Potentials. This is essentially a; modification of the core Hamiltonian, which includes screening; effects by using a radially screened effective atomic charge. The; screening effects have been calculated at the complete basis set; limit with finite-element calculations, see [Lehtola:",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:19899,Modifiability,extend,extended,19899,"ent basis. If an; open-shell system, uniform scaling of the spin-averaged density matrices is; performed. If orbitals are needed (*e.g.*, in density fitting), a partial; Cholesky factorization of the density matrices is used. Often extremely; accurate, particularly for closed-shell systems. This is the default for; systems of more than one atom.; SADNO; Natural orbitals from Superposition of Atomic Densities. Similar; to the above, but it forms natural orbitals from the SAD density; matrix to get proper orbitals which are used to start the; calculation, see [Lehtola:2019:1593]_.; GWH; A generalized Wolfsberg-Helmholtz modification of the core; Hamiltonian matrix. Usually less accurate than the core guess: the; latter is exact for one-electron systems, GWH is not; see; [Lehtola:2019:1593]_).; HUCKEL; An extended H\ |u_dots|\ ckel guess based on on-the-fly atomic UHF; calculations alike SAD, see [Lehtola:2019:1593]_.; MODHUCKEL; Like HUCKEL, an extended H\ |u_dots|\ ckel guess based on; on-the-fly atomic UHF calculations alike SAD, see; [Lehtola:2019:1593]_. This variant employs an updated rule for the; generalized Wolfsberg-Helmholz formula from [Ammeter:1978:3686]_.; READ; Read the previous orbitals from a ``wfn`` file, casting from; one basis to another if needed. Useful for starting anion; computations from neutral orbitals, or after small geometry; changes. At present, casting from a different molecular point; group is not supported. This becomes the default for the second; and later iterations of geometry optimizations.; SAP; Superposition of Atomic Potentials. This is essentially a; modification of the core Hamiltonian, which includes screening; effects by using a radially screened effective atomic charge. The; screening effects have been calculated at the complete basis set; limit with finite-element calculations, see [Lehtola:2019:25945]_; and [Lehtola:2020:012516]_. The guess and its implementation have; been described in [Lehtola:2019:1593]_. The guess is e",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:32943,Modifiability,config,configurations,32943," within a composite framework; are as follows:. COSX; An algorithm based on the semi-numerical ""chain of spheres exchange"" (COSX); approach described in [Neese:2009:98]_. The coulomb term is computed with a; direct density-fitting algorithm. The COSX algorithm uses no I/O, scales; well with system size, and requires minimal memory, making it ideal for; large systems and multi-core CPUs. See :ref:`sec:scfcosx` for more information.; LINK; An implementation of the linear-scaling ""Linear Exchange"" (LinK); algorithm described in [Ochsenfeld:1998:1663]_. The LINK algorithm provides ; many of the benefits of integral-direct SCF algorithms, including no disk I/O, ; low memory usage, and effective parallelization. Additionally, the; LINK implementation scales well with system size ; while simultaneously providing a formally-exact computation of the ; Exchange term. See :ref:`sec:scflink` for more information. In some cases the above algorithms have multiple implementations that return; the same result, but are optimal under different molecules sizes and hardware; configurations. Psi4 will automatically detect the correct algorithm to run and; only expert users should manually select the below implementations. The DF; algorithm has the following two implementations. MEM_DF; A DF algorithm optimized around memory layout and is optimal as long as; there is sufficient memory to hold the three-index DF tensors in memory. This; algorithm may be faster for builds that require disk if SSDs are used.; DISK_DF; A DF algorithm (the default DF algorithm before Psi4 1.2) optimized to; minimize Disk IO by sacrificing some performance due to memory layout. Note that these algorithms have both in-memory and on-disk options, but; performance penalties up to a factor of 2.5 can be found if the incorrect; algorithm is chosen. It is therefore highly recommended that the keyword ""DF""; be selected in all cases so that the correct implementation can be selected by; |PSIfours| internal routines. Ex",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:34822,Modifiability,extend,extended,34822,"ted in all cases so that the correct implementation can be selected by; |PSIfours| internal routines. Expert users can manually switch between MEM_DF and; DISK_DF; however, they may find documented exceptions during use as several; post SCF algorithms require a specific implementation. Additionally, expert users ; can manually switch between the in-memory and on-disk options *within* MEM_DF or DISK_DF using ; the |scf__scf_subtype| option. Using ``SCF_SUBTYPE = AUTO``, where |PSIfour| ; automatically selects the in-memory or on-disk option for MEM_DF/DISK_DF based on memory and molecule, is the default ; and recommended option. However, the in-memory or on-disk algorithms for MEM_DF and DISK_DF can be forced by using; ``SCF_SUBTYPE = INCORE`` or ``SCF_SUBTYPE = OUT_OF_CORE``, respectively.; Note that an exception will be thrown if ; ``SCF_SUBTYPE = INCORE`` is used without allocating sufficient memory to ; |PSIfour|. For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set the |scf__ints_tolerance| keyword to your desired cutoff; (1.0E-12 is recommended for most applications). To choose the type of sieving, set ; the |globals__screening| keyword to your desired option. For Schwarz screening, set it; to ``SCHWARZ``, for CSAM, ``CSAM``, and for density matrix-based screening, ``DENSITY``. SCHWARZ; Uses the Cauchy-Schwarz inequality to calculate an upper bounded value of a shell quartet,. .. math:: (PQ|RS) <= \sqrt{(PQ|PQ)(RS|RS)}. CSAM; An extension of the Schwarz estimate that also screens over the long range 1/r operator, described in [Thompson:2017:144101]_. DENSITY; An extension of the Schwarz estimate that also screens over elements of the density matrix.; For the RHF case, described in [Haser:1989:104]_. .. math:: CON(PQ|RS) <= \sqrt{(PQ|PQ)(RS|RS)} \cdot DCON(PQ, RS). .. math:: DCON(PQ, RS) = max(4D_{PQ}, 4D_{RS}, D_{PR}, D_{PS}, D_{QR}, D_{QS}). When us",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:50265,Modifiability,adapt,adapt,50265,"|scf__stability_analysis| | |globals__scf_type| |; +==================+==================+==============================================+===========================+=====================+; | | RHF | Internal, External (:math:`\rightarrow` UHF) | ``CHECK`` | PK only |; + +------------------+----------------------------------------------+---------------------------+---------------------+; | Direct Inversion | ROHF | Internal | ``CHECK`` | PK only |; +------------------+------------------+----------------------------------------------+---------------------------+---------------------+; | Davidson | UHF | Internal | ``CHECK`` or ``FOLLOW`` | Anything |; +------------------+------------------+----------------------------------------------+---------------------------+---------------------+. The best algorithm is automatically selected, *i.e.* Davidson for UHF :math:`\rightarrow` UHF and Direct Inversion otherwise. In addition to the options available for Direct Inversion, the Davidson algorithm can automatically; adapt |scf__follow_step_scale| to find a new SCF minimum. If |scf__max_attempts| > 1, additional attempts; will automatically increment |scf__follow_step_scale| by 0.2 every time the SCF falls back to the previously; found unstable minimum. The increment can be adjusted by setting |scf__follow_step_increment|.; The default value is 0.2; adjust if needed to try different values of |scf__follow_step_scale| in a single computation. The Davidson solver for the eigenvalues is controlled through several keywords. |scf__solver_maxiter|: maximum number of iterations. |scf__solver_convergence|: eigenvector convergence threshold. |scf__solver_n_root|: Solve for N eigenvectors in each irreducible representation. |scf__solver_roots_per_irrep|: The number of eigenvectors to solve in each irreducible representation. An array of as many integers as there are irreducible representations. |scf__solver_n_guess|: Use N guess vectors, this needs to be larger than the number of roots ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:60243,Modifiability,flexible,flexible,60243,"DF. .. [#f4] Note that this table applies to the final convergence criteria for; all the post-SCF modules that define a |ccenergy__e_convergence| keyword. .. [#f5] The E_CONVERGENCE keyword is implemented for most post-SCF modules.; See a list beginning at |ccenergy__e_convergence|. .. [#f6] The R_CONVERGENCE keyword places a convergence check on an internal; residual error measure and is implemented for several post-SCF; modules (see list beginning at |ccenergy__r_convergence|). It is defined; according to the quantum chemical method and so its default value is set; by each module individually. .. [#f7] For frequency computations by finite difference of energies,; convergence criteria are tightened further still to 10 for; |scf__e_convergence| and |scf__d_convergence| for SCF of HF or DFT, 11; for |scf__e_convergence| and |scf__d_convergence| for SCF of post-HF,; and 10 for E_CONVERGENCE for post-HF of post-HF. .. _`sec:scfrec`:. Recommendations; ~~~~~~~~~~~~~~~. The SCF code is quite flexible and powerful.; We have tried as much as possible to keep the number of options to; a minimum and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. * For |scf__guess|, the ``SAD`` guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; * For wall time, ``DF`` may be a factor of ten or more faster than the exact; integral technologies available in |PSIfour|.; Use ``DF`` unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your orbital basis/atom type. Then use; ``DIRECT``.; * Don't mess with the DIIS convergenc",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:4846,Performance,perform,performed,4846,"m. Within the DF portion; of the computation, the zeroth-iteration uses a non-idempotent density matrix; obtained from the SAD guess, so the energy is unphysically low. However, the; first true iteration is quite close to the final DF energy, highlighting the; efficiency of the SAD guess. Pulay's DIIS procedure is then used to accelerate; SCF convergence, with the DF phase reaching convergence in eight true; iterations. When used together, SAD and DIIS are usually sufficient to converge; the SCF for all but the most difficult systems. Additional convergence; techniques are available for more difficult cases, and are detailed below. At; this point, the code switches on the requested Direct integrals technology, which; requires only four full iterations to reach convergence, starting from the DF; guess. This hybrid DF/Direct procedure can significantly accelerate SCF; computations requiring exact integrals. After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; |globals__print| option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. .. index::; pair: SCF; theory. .. _`sec:scftheory`:. Theory; ~~~~~~. The objective of Hartree--Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) :math:`\{\psi_i\}`,. .. math:: \psi_i(\vec x_1) = C_{\mu i} \phi_{\mu} (\vec x_1). Here, :math:`\{\phi_{\mu}\}` are the basis functions, which, in |PSIfour| are; contracted Cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix :math:`C_{\mu i}` contains the MO coefficients, which are the; constrained variational parameters in Hartree--Fock. The molecular orbitals are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. .. math:: | \Psi_0 \rang",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:5261,Performance,optimiz,optimized,5261,"r, SAD and DIIS are usually sufficient to converge; the SCF for all but the most difficult systems. Additional convergence; techniques are available for more difficult cases, and are detailed below. At; this point, the code switches on the requested Direct integrals technology, which; requires only four full iterations to reach convergence, starting from the DF; guess. This hybrid DF/Direct procedure can significantly accelerate SCF; computations requiring exact integrals. After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; |globals__print| option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. .. index::; pair: SCF; theory. .. _`sec:scftheory`:. Theory; ~~~~~~. The objective of Hartree--Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) :math:`\{\psi_i\}`,. .. math:: \psi_i(\vec x_1) = C_{\mu i} \phi_{\mu} (\vec x_1). Here, :math:`\{\phi_{\mu}\}` are the basis functions, which, in |PSIfour| are; contracted Cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix :math:`C_{\mu i}` contains the MO coefficients, which are the; constrained variational parameters in Hartree--Fock. The molecular orbitals are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. .. math:: | \Psi_0 \rangle =; \frac{1}{\sqrt{N!}} \left | \begin{array}{cccc}; \psi_1 (\vec x_1) & \psi_2(\vec x_1) & \ldots & \psi_N (\vec x_1) \\; \psi_1 (\vec x_2) & \psi_2(\vec x_2) & \ldots & \psi_N (\vec x_2) \\; \vdots & \vdots & \ddots & \vdots \\; \psi_1 (\vec x_N) & \psi_2(\vec x_N) & \ldots & \psi_N (\vec x_N) \\; \end{array}\right |. This form for the Hartree--Fock wavefunction is actually entirely equivalent to; treating the electron correlation a",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:11406,Performance,perform,performance,11406,"the; deviation is greater than a few hundredths, it is advisable to switch to a; ROHF to avoid this ""spin-contamination"" problem.; Restricted Open-Shell Hartree--Fock (ROHF); Appropriate for open-shell systems where spin-contamination is problem.; Sometimes more difficult to converge, and assumes uniformly positive spin; polarization (the alpha and beta doubly-occupied orbitals are identical).; Constrained Unrestricted Hartree--Fock (CUHF); A variant of ROHF that starts from a UHF ansatz and is therefore often; easier to converge. These can be invoked by the |scf__reference| keyword, which defaults to ``RHF``.; The charge and multiplicity may either be specified in the molecule definition::. molecule h {; 0 2 # Neutral doublet; H; }. or, dynamically, by setting the relevant attributes in the Python molecule; object::. h.set_molecular_charge(0); h.set_multiplicity(2). Abelian spatial symmetry is fully supported in |PSIfour| and can be used to; obtain physical interpretation of the molecular orbitals, to assist in difficult; convergence cases, and, in some methods, to obtain significant performance; gains. The point group of the molecule is inferred when reading the molecule; section, and may be overridden by the :ref:`symmetry <sec:moleculeKeywords>` flag, as in::. molecule h {; 0 2; H; symmetry c1; }. or by the ``reset_point_group`` Python molecule attribute::. h.reset_point_group('c2v'). During the SCF procedure, the occupation of orbitals is typically determined by; the Aufbau principal across all spatial symmetries. This may result in the; occupation shifting between iterations. If the occupations are known *a priori*,; they may be clamped throughout the procedure by using the |globals__docc| and; |globals__socc| options. For instance, all good quantum chemists know that; :math:`C_{2v}` water is; actually,::. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; docc [3, 0, 1, 1] # 1A1 2A1 1B1 3A1 1B2; basis cc-pvdz; }. energy('scf'). .. _`sec:scfbrokensymm",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:12770,Performance,perform,perform,12770,"ermined by; the Aufbau principal across all spatial symmetries. This may result in the; occupation shifting between iterations. If the occupations are known *a priori*,; they may be clamped throughout the procedure by using the |globals__docc| and; |globals__socc| options. For instance, all good quantum chemists know that; :math:`C_{2v}` water is; actually,::. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; docc [3, 0, 1, 1] # 1A1 2A1 1B1 3A1 1B2; basis cc-pvdz; }. energy('scf'). .. _`sec:scfbrokensymm`:. Broken Symmetry; ~~~~~~~~~~~~~~~. For certain problems, such diradicals, allowing the spin-up and spin-down; orbitals to differ in closed-shell computations can be advantageous;; this is known as symmetry breaking. The resulting unrestricted wavefunction; will often provide superior energetics, due to the increased flexibility,; but it will suffer non-physical spin contamination from higher multiplicity states.; A convenient approach to break symmetry is to perform a UHF or UKS calculation; with the guess HOMO and LUMO orbitals mixed.; Mixing of the guess orbitals can be requested by setting the |scf__guess_mix|; keyword to true::. set reference uhf; set guess_mix true; energy('scf'). .. _`sec:scflindep`:. Orthogonalization; ~~~~~~~~~~~~~~~~~. One of the first steps in the SCF procedure is the determination of an; orthogonal basis (known as the OSO basis) from the atomic orbital; basis (known as the AO basis). The Molecular Orbital basis (MO basis); is then built as a particular unitary transformation of the OSO; basis. In |PSIfour|, the determination of the OSO basis is; accomplished via either symmetric, canonical, or partial Cholesky; orthogonalization. Symmetric orthogonalization uses the symmetric inverse square root of; the overlap matrix for the orthogonalization matrix. Use of symmetric; orthogonalization always yields the same number of OSO functions (and; thereby MOs) as AO functions. However, this may lead to numerical; problems if the overla",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:19037,Performance,perform,performed,19037,"st be below; the user-specified |scf__e_convergence| and |scf__d_convergence|, respectively.; The maximum number of iterations is specified by the |scf__maxiter| option. It; should be noted that SCF is a chaotic process, and, as such, often requires; careful selection of initial orbitals and damping during iterations to ensure; convergence. This is particularly likely for large systems, metallic systems,; multireference systems, open-shell systems, anions, and systems with diffuse; basis sets. For initial orbital selection, several options are available. These include:. CORE; Diagonalization of the core Hamiltonian, removing even mean-field electron; repulsion. Simple, but often too far from the final solution for larger; systems. This is the default for single atoms.; SAD [:term:`Default <GUESS (SCF)>`]; Superposition of Atomic Densities. Builds the initial density as the; spin-averaged sum of atomic UHF computations in the current basis. If an; open-shell system, uniform scaling of the spin-averaged density matrices is; performed. If orbitals are needed (*e.g.*, in density fitting), a partial; Cholesky factorization of the density matrices is used. Often extremely; accurate, particularly for closed-shell systems. This is the default for; systems of more than one atom.; SADNO; Natural orbitals from Superposition of Atomic Densities. Similar; to the above, but it forms natural orbitals from the SAD density; matrix to get proper orbitals which are used to start the; calculation, see [Lehtola:2019:1593]_.; GWH; A generalized Wolfsberg-Helmholtz modification of the core; Hamiltonian matrix. Usually less accurate than the core guess: the; latter is exact for one-electron systems, GWH is not; see; [Lehtola:2019:1593]_).; HUCKEL; An extended H\ |u_dots|\ ckel guess based on on-the-fly atomic UHF; calculations alike SAD, see [Lehtola:2019:1593]_.; MODHUCKEL; Like HUCKEL, an extended H\ |u_dots|\ ckel guess based on; on-the-fly atomic UHF calculations alike SAD, see; [Lehtol",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:20477,Performance,optimiz,optimizations,20477,"oper orbitals which are used to start the; calculation, see [Lehtola:2019:1593]_.; GWH; A generalized Wolfsberg-Helmholtz modification of the core; Hamiltonian matrix. Usually less accurate than the core guess: the; latter is exact for one-electron systems, GWH is not; see; [Lehtola:2019:1593]_).; HUCKEL; An extended H\ |u_dots|\ ckel guess based on on-the-fly atomic UHF; calculations alike SAD, see [Lehtola:2019:1593]_.; MODHUCKEL; Like HUCKEL, an extended H\ |u_dots|\ ckel guess based on; on-the-fly atomic UHF calculations alike SAD, see; [Lehtola:2019:1593]_. This variant employs an updated rule for the; generalized Wolfsberg-Helmholz formula from [Ammeter:1978:3686]_.; READ; Read the previous orbitals from a ``wfn`` file, casting from; one basis to another if needed. Useful for starting anion; computations from neutral orbitals, or after small geometry; changes. At present, casting from a different molecular point; group is not supported. This becomes the default for the second; and later iterations of geometry optimizations.; SAP; Superposition of Atomic Potentials. This is essentially a; modification of the core Hamiltonian, which includes screening; effects by using a radially screened effective atomic charge. The; screening effects have been calculated at the complete basis set; limit with finite-element calculations, see [Lehtola:2019:25945]_; and [Lehtola:2020:012516]_. The guess and its implementation have; been described in [Lehtola:2019:1593]_. The guess is evaluated on a; DFT quadrature grid, so the guess energy depends slightly on the; used DFT quadrature. The current implementation is based on; exchange-only local density calculations that are but nanohartree; away from the complete basis set limit [Lehtola:2020:012516]_.; SAPGAU; Superposition of Atomic Potentials, but using error function based; fits to the atomic radial potentials as discussed in; [Lehtola:2020:144105]_. The main difference to the SAP guess; discussed above [Lehtola:2019:25945]_ is",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:22302,Performance,perform,performing,22302,":2020:144105]_. The main difference to the SAP guess; discussed above [Lehtola:2019:25945]_ is that the SAPGAU scheme is; analytic, and can be efficiently formed in terms of three-center; two-electron integrals [Lehtola:2020:144105]_. The potential in; the SAPGAU scheme is passed with the |scf__sapgau_basis|; keyword. The default potential is given by the large fit to the; HelFEM potential, sap_helfem_large, described in; [Lehtola:2020:144105]_. Note that this guess is known in the DIRAC; program as .SCRPOT and in the ERKALE program as SAPFIT. These are all set by the |scf__guess| keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis. This can be done by adding; |scf__basis_guess| = SMALL_BASIS to the options list. We recommend the; 3-21G or pcseg-0 basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below::. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; basis_guess 3-21G; guess sad; }. energy('scf'). .. _`sec:scfrestart`:. Restarting the SCF; ~~~~~~~~~~~~~~~~~~. Reading orbital data from a previous calculations is done via the ``restart_file`` option,; where the actual file is a serialized ``wfn`` object (see :ref:`saving the wfn <sec:save_wfn>`); By default, the orbital data file of the converged SCF(``psi.PID.name.180.npy``) is deleted; after |PSIfour| exits or the ``clean()`` function is called. The orbital guess is automatically; set to ``READ`` when ``restart_file`` is given a ``wfn`` file.; To write the orbitals after every iteration and keep the orbitals from the last iteration, the ``write_orbitals`` options is available: ::. energy('scf', write_orbitals='my_mos'),. which writes a ``Wavefunction`` object converted (serialized) to a numpy file called ``my_mos.npy``.; The restart can then ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:24753,Performance,perform,performs,24753," manipulating or writing custom wavefunction files, note; that |PSIfour| expects the numpy file on disk to have the ``.npy`` extension, not, e.g., `.npz`. .. index:: DIIS, MOM, damping. .. _`sec:scfconv`:. Convergence Stabilization; ~~~~~~~~~~~~~~~~~~~~~~~~~. A summary of Psi's supported convergence stabilization techniques is presented below:. DIIS [On by Default]; DIIS uses previous iterates of the Fock matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via :term:`options <DIIS (SCF)>`.; ADIIS [On by Default]; ADIIS uses previous iterates of the Fock and density matrices to produce an; informed estimate of the next Fock matrix. ADIIS estimates are based on minimizing; an energy estimate rather than zeroing the residual, so this performs best in the early; iterations. By default, Psi will start using ADIIS before blending the ADIIS step with; the DIIS step, eventually using the pure DIIS step. The closely-related EDIIS procedure; may be used instead by setting |scf__scf_initial_accelerator|. This is formally identical; to ADIIS for HF, but the methods will differ for more general DFT.; MOM [Off by Default]; MOM was developed to combat a particular class of convergence failure:; occupation flipping. In some cases, midway though the SCF procedure, a partially; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbital which should be; destined to be a virtual orbital. This results in the virtual orbital being; spuriously occupied for one or more iterations. Sometimes this resolves itself; without help, other times the occupation flips back and forth between two, four,; or more orbitals. This is t",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:25349,Performance,optimiz,optimized,25349,". In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via :term:`options <DIIS (SCF)>`.; ADIIS [On by Default]; ADIIS uses previous iterates of the Fock and density matrices to produce an; informed estimate of the next Fock matrix. ADIIS estimates are based on minimizing; an energy estimate rather than zeroing the residual, so this performs best in the early; iterations. By default, Psi will start using ADIIS before blending the ADIIS step with; the DIIS step, eventually using the pure DIIS step. The closely-related EDIIS procedure; may be used instead by setting |scf__scf_initial_accelerator|. This is formally identical; to ADIIS for HF, but the methods will differ for more general DFT.; MOM [Off by Default]; MOM was developed to combat a particular class of convergence failure:; occupation flipping. In some cases, midway though the SCF procedure, a partially; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbital which should be; destined to be a virtual orbital. This results in the virtual orbital being; spuriously occupied for one or more iterations. Sometimes this resolves itself; without help, other times the occupation flips back and forth between two, four,; or more orbitals. This is typically visible in the output as a non-converging; SCF which eventually settles down to steady oscillation between two (or more); different total energies. This behavior can be ameliorated by choosing occupied; orbitals by ""shape"" instead of by orbital eigenvalue, *i.e.*, by choosing the set; of new orbitals which looks most like some previously known ""good"" set. The; ""good"" set is typically the occupied orbitals from one of the oscillating; iterations with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations :math:`N,N+2,\ldots`, invoking; |scf__mom_start| ``N`` can often rescue t",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:28533,Performance,bottleneck,bottleneck,28533,"hift|, and it is turned off when the DIIS error is; smaller than |scf__level_shift_cutoff|. Reasonable values for; the shift and convergence threshold are 5.0 and 1e-2,; respectively.; SOSCF [Off by Default]; See :ref:`sec:soscf`. .. _`sec:scferi`:. ERI Algorithms; ~~~~~~~~~~~~~~. The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; |PSIfour| for these terms. The algorithm is selected by the |globals__scf_type|; keyword. Most consist of a single algorithm applied to; the construction of both the Coulomb and Exchange parts; of the Fock Matrix:. PK [:ref:`Default <table:conv_scf>`]; An out-of-core, presorted algorithm using exact ERIs. Quite fast for a; zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of; integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact ERIs. Overcomes the; memory bottleneck of the current PK algorithm. Integrals are generated; only once, and symmetry is utilized to reduce number of integrals.; DIRECT; A threaded, sieved, integral-direct algorithm, with full permutational; symmetry. This algorithm is brand new, but seems to be reasonably fast; up to 1500 basis functions, uses zero disk (if DF pre-iterations are; turned off), and can obtain significant; speedups with negligible error loss if |scf__ints_tolerance|; is set to 1.0E-8 or so.; DF [:ref:`Default <table:conv_scf>`]; A density-fitted algorithm designed for computations with thousands of; basis functions. This algorithm is highly optimized, and is threaded; with a mixture of parallel BLAS and OpenMP. Note that this algorithm; should use the -JKFIT series of auxiliary bases, *not* the -RI or; -MP2FIT bases. The default guess for auxiliary basis set should work; for most bases, otherwise the |scf__df_basis_scf| keyword can; be used to manually specify the auxiliary basis. This algorithm is; preferr",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:29168,Performance,optimiz,optimized,29168,"K [:ref:`Default <table:conv_scf>`]; An out-of-core, presorted algorithm using exact ERIs. Quite fast for a; zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of; integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact ERIs. Overcomes the; memory bottleneck of the current PK algorithm. Integrals are generated; only once, and symmetry is utilized to reduce number of integrals.; DIRECT; A threaded, sieved, integral-direct algorithm, with full permutational; symmetry. This algorithm is brand new, but seems to be reasonably fast; up to 1500 basis functions, uses zero disk (if DF pre-iterations are; turned off), and can obtain significant; speedups with negligible error loss if |scf__ints_tolerance|; is set to 1.0E-8 or so.; DF [:ref:`Default <table:conv_scf>`]; A density-fitted algorithm designed for computations with thousands of; basis functions. This algorithm is highly optimized, and is threaded; with a mixture of parallel BLAS and OpenMP. Note that this algorithm; should use the -JKFIT series of auxiliary bases, *not* the -RI or; -MP2FIT bases. The default guess for auxiliary basis set should work; for most bases, otherwise the |scf__df_basis_scf| keyword can; be used to manually specify the auxiliary basis. This algorithm is; preferred unless either absolute accuracy is required; [:math:`\gtrsim`\ CCSD(T)] or a -JKFIT auxiliary basis is unavailable; for the orbital basis/atoms involved.; CD; A threaded algorithm using approximate ERIs obtained by Cholesky; decomposition of the ERI tensor. The accuracy of the Cholesky; decomposition is controlled by the keyword |scf__cholesky_tolerance|.; This algorithm is similar to the DF algorithm, but it is not suitable; for gradient computations. The algorithm to obtain the Cholesky; vectors is not designed for computations with thousands of basis; functions. |PSIfour| also features the capability to use ""composite"" Fock matrix build",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:30699,Performance,perform,perform,30699,"threaded algorithm using approximate ERIs obtained by Cholesky; decomposition of the ERI tensor. The accuracy of the Cholesky; decomposition is controlled by the keyword |scf__cholesky_tolerance|.; This algorithm is similar to the DF algorithm, but it is not suitable; for gradient computations. The algorithm to obtain the Cholesky; vectors is not designed for computations with thousands of basis; functions. |PSIfour| also features the capability to use ""composite"" Fock matrix build; algorithms - arbitrary combinations of specialized algorithms that construct; either the Coulomb or the Exchange matrix separately. In general, since; separate Coulomb and Exchange matrix build algorithms exploit properties specific to; their respective matrix, composite algorithms display lower; scaling factors than their combined Fock build counterparts. However, composite algorithms also; introduce redundant ERI computations into the calculation. Therefore, composite Fock build; algorithms tend to perform better for larger systems, but worse for smaller systems. Arbitrary; composite algorithms can be accessed by setting |globals__scf_type| to ``J_alg+K_alg``,; where *J_alg* and *K_alg* are the names of the separate Coulomb; and Exchange construction algorithms to use, respectively. Alternatively, if one is using; DFT with non-hybrid functionals, a composite Coulomb construction algorithm can be; specified solo by setting |globals__scf_type| to ``J_alg``, without the need to set ; an associated ``K_alg``. Specialized algorithms available to construct the Coulomb term within a composite framework ; are as follows:. DFDIRJ; An integral-direct algorithm constructing the Coulomb term based on [Weigend:2002:4285]_; The DFDIRJ algorithm combines the benefits of integral-direct SCF approaches ; with that of density-fitting. Specifically, DFJ utilizes no I/O and displays ; strong performance with large system size through a combination of ; effective parallelization and utilization of density-",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:31590,Performance,perform,performance,31590,"tion. Therefore, composite Fock build; algorithms tend to perform better for larger systems, but worse for smaller systems. Arbitrary; composite algorithms can be accessed by setting |globals__scf_type| to ``J_alg+K_alg``,; where *J_alg* and *K_alg* are the names of the separate Coulomb; and Exchange construction algorithms to use, respectively. Alternatively, if one is using; DFT with non-hybrid functionals, a composite Coulomb construction algorithm can be; specified solo by setting |globals__scf_type| to ``J_alg``, without the need to set ; an associated ``K_alg``. Specialized algorithms available to construct the Coulomb term within a composite framework ; are as follows:. DFDIRJ; An integral-direct algorithm constructing the Coulomb term based on [Weigend:2002:4285]_; The DFDIRJ algorithm combines the benefits of integral-direct SCF approaches ; with that of density-fitting. Specifically, DFJ utilizes no I/O and displays ; strong performance with large system size through a combination of ; effective parallelization and utilization of density-fitting to minimize ; ERI computational cost. See the :ref:`sec:scfddfj` section for more information. Specialized algorithms available to construct the Exchange term within a composite framework; are as follows:. COSX; An algorithm based on the semi-numerical ""chain of spheres exchange"" (COSX); approach described in [Neese:2009:98]_. The coulomb term is computed with a; direct density-fitting algorithm. The COSX algorithm uses no I/O, scales; well with system size, and requires minimal memory, making it ideal for; large systems and multi-core CPUs. See :ref:`sec:scfcosx` for more information.; LINK; An implementation of the linear-scaling ""Linear Exchange"" (LinK); algorithm described in [Ochsenfeld:1998:1663]_. The LINK algorithm provides ; many of the benefits of integral-direct SCF algorithms, including no disk I/O, ; low memory usage, and effective parallelization. Additionally, the; LINK implementation scales well with",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:33172,Performance,optimiz,optimized,33172," large systems and multi-core CPUs. See :ref:`sec:scfcosx` for more information.; LINK; An implementation of the linear-scaling ""Linear Exchange"" (LinK); algorithm described in [Ochsenfeld:1998:1663]_. The LINK algorithm provides ; many of the benefits of integral-direct SCF algorithms, including no disk I/O, ; low memory usage, and effective parallelization. Additionally, the; LINK implementation scales well with system size ; while simultaneously providing a formally-exact computation of the ; Exchange term. See :ref:`sec:scflink` for more information. In some cases the above algorithms have multiple implementations that return; the same result, but are optimal under different molecules sizes and hardware; configurations. Psi4 will automatically detect the correct algorithm to run and; only expert users should manually select the below implementations. The DF; algorithm has the following two implementations. MEM_DF; A DF algorithm optimized around memory layout and is optimal as long as; there is sufficient memory to hold the three-index DF tensors in memory. This; algorithm may be faster for builds that require disk if SSDs are used.; DISK_DF; A DF algorithm (the default DF algorithm before Psi4 1.2) optimized to; minimize Disk IO by sacrificing some performance due to memory layout. Note that these algorithms have both in-memory and on-disk options, but; performance penalties up to a factor of 2.5 can be found if the incorrect; algorithm is chosen. It is therefore highly recommended that the keyword ""DF""; be selected in all cases so that the correct implementation can be selected by; |PSIfours| internal routines. Expert users can manually switch between MEM_DF and; DISK_DF; however, they may find documented exceptions during use as several; post SCF algorithms require a specific implementation. Additionally, expert users ; can manually switch between the in-memory and on-disk options *within* MEM_DF or DISK_DF using ; the |scf__scf_subtype| option. Using ``SCF_S",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:33448,Performance,optimiz,optimized,33448,"l-direct SCF algorithms, including no disk I/O, ; low memory usage, and effective parallelization. Additionally, the; LINK implementation scales well with system size ; while simultaneously providing a formally-exact computation of the ; Exchange term. See :ref:`sec:scflink` for more information. In some cases the above algorithms have multiple implementations that return; the same result, but are optimal under different molecules sizes and hardware; configurations. Psi4 will automatically detect the correct algorithm to run and; only expert users should manually select the below implementations. The DF; algorithm has the following two implementations. MEM_DF; A DF algorithm optimized around memory layout and is optimal as long as; there is sufficient memory to hold the three-index DF tensors in memory. This; algorithm may be faster for builds that require disk if SSDs are used.; DISK_DF; A DF algorithm (the default DF algorithm before Psi4 1.2) optimized to; minimize Disk IO by sacrificing some performance due to memory layout. Note that these algorithms have both in-memory and on-disk options, but; performance penalties up to a factor of 2.5 can be found if the incorrect; algorithm is chosen. It is therefore highly recommended that the keyword ""DF""; be selected in all cases so that the correct implementation can be selected by; |PSIfours| internal routines. Expert users can manually switch between MEM_DF and; DISK_DF; however, they may find documented exceptions during use as several; post SCF algorithms require a specific implementation. Additionally, expert users ; can manually switch between the in-memory and on-disk options *within* MEM_DF or DISK_DF using ; the |scf__scf_subtype| option. Using ``SCF_SUBTYPE = AUTO``, where |PSIfour| ; automatically selects the in-memory or on-disk option for MEM_DF/DISK_DF based on memory and molecule, is the default ; and recommended option. However, the in-memory or on-disk algorithms for MEM_DF and DISK_DF can be forced by ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:33499,Performance,perform,performance,33499,"l-direct SCF algorithms, including no disk I/O, ; low memory usage, and effective parallelization. Additionally, the; LINK implementation scales well with system size ; while simultaneously providing a formally-exact computation of the ; Exchange term. See :ref:`sec:scflink` for more information. In some cases the above algorithms have multiple implementations that return; the same result, but are optimal under different molecules sizes and hardware; configurations. Psi4 will automatically detect the correct algorithm to run and; only expert users should manually select the below implementations. The DF; algorithm has the following two implementations. MEM_DF; A DF algorithm optimized around memory layout and is optimal as long as; there is sufficient memory to hold the three-index DF tensors in memory. This; algorithm may be faster for builds that require disk if SSDs are used.; DISK_DF; A DF algorithm (the default DF algorithm before Psi4 1.2) optimized to; minimize Disk IO by sacrificing some performance due to memory layout. Note that these algorithms have both in-memory and on-disk options, but; performance penalties up to a factor of 2.5 can be found if the incorrect; algorithm is chosen. It is therefore highly recommended that the keyword ""DF""; be selected in all cases so that the correct implementation can be selected by; |PSIfours| internal routines. Expert users can manually switch between MEM_DF and; DISK_DF; however, they may find documented exceptions during use as several; post SCF algorithms require a specific implementation. Additionally, expert users ; can manually switch between the in-memory and on-disk options *within* MEM_DF or DISK_DF using ; the |scf__scf_subtype| option. Using ``SCF_SUBTYPE = AUTO``, where |PSIfour| ; automatically selects the in-memory or on-disk option for MEM_DF/DISK_DF based on memory and molecule, is the default ; and recommended option. However, the in-memory or on-disk algorithms for MEM_DF and DISK_DF can be forced by ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:33606,Performance,perform,performance,33606,"itionally, the; LINK implementation scales well with system size ; while simultaneously providing a formally-exact computation of the ; Exchange term. See :ref:`sec:scflink` for more information. In some cases the above algorithms have multiple implementations that return; the same result, but are optimal under different molecules sizes and hardware; configurations. Psi4 will automatically detect the correct algorithm to run and; only expert users should manually select the below implementations. The DF; algorithm has the following two implementations. MEM_DF; A DF algorithm optimized around memory layout and is optimal as long as; there is sufficient memory to hold the three-index DF tensors in memory. This; algorithm may be faster for builds that require disk if SSDs are used.; DISK_DF; A DF algorithm (the default DF algorithm before Psi4 1.2) optimized to; minimize Disk IO by sacrificing some performance due to memory layout. Note that these algorithms have both in-memory and on-disk options, but; performance penalties up to a factor of 2.5 can be found if the incorrect; algorithm is chosen. It is therefore highly recommended that the keyword ""DF""; be selected in all cases so that the correct implementation can be selected by; |PSIfours| internal routines. Expert users can manually switch between MEM_DF and; DISK_DF; however, they may find documented exceptions during use as several; post SCF algorithms require a specific implementation. Additionally, expert users ; can manually switch between the in-memory and on-disk options *within* MEM_DF or DISK_DF using ; the |scf__scf_subtype| option. Using ``SCF_SUBTYPE = AUTO``, where |PSIfour| ; automatically selects the in-memory or on-disk option for MEM_DF/DISK_DF based on memory and molecule, is the default ; and recommended option. However, the in-memory or on-disk algorithms for MEM_DF and DISK_DF can be forced by using; ``SCF_SUBTYPE = INCORE`` or ``SCF_SUBTYPE = OUT_OF_CORE``, respectively.; Note that an excepti",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:37305,Performance,bottleneck,bottleneck,37305,"es |scf__df_basis_scf| manually. For; some atoms, cc-pVDZ-JKFIT is not defined, so a very large fitting basis of last; resort will be used.; To avoid this, either set |scf__df_basis_scf| to an auxiliary; basis set defined for all atoms in the system, or set |scf__df_scf_guess|; to false, which disables this acceleration entirely. .. _`sec:scfddfj`:. Integral-Direct Density-Fitted Coulomb Construction; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. The Resolution of the Identity (RI) can be used to decompose the normally 4-center ERI tensor into a combination of 3-center and 2-center components.; By reducing the dimensionality of the ERI tensor, application of the RI (often referred to as density-fitting, or DF) can be used to greatly speed up; SCF calculations. The reduction in ERI tensor rank also makes DF an appealing option for conventional SCF calculations, where the ERIs are stored ; in core or on disk. However, even when using DF, I/O becomes a significant bottleneck for systems of a sufficient size when performing conventional SCF; calculations. In principle, though, DF approaches can be utilized in an integral-direct context, gaining the benefits of DF methods without suffering the; I/O bottlenecks that conventional DF methods will eventually run into. One such approach, outlined by Weigend in [Weigend:2002:4285]_,; is available for use in Psi4 for the separate construction of the Coulomb contribution to the Fock matrix. This implementation can be used alongside ; Psi4's separate Exchange construction algorithms for composite Fock matrix construction by using the keyword DFDIRJ as the Coulomb construction ; algorithm when specifying |globals__scf_type| to use a composite algorithm combination (``DFDIRJ+K_alg`` in general, ; or ``DFDIRJ`` for DFT with non-hybrid functionals). . DFDIRJ supports multiple capabilities to improve performance. Specifically, DFDIRJ allows for a combination of density-matrix based ERI ; screening (set |globals__screening| to ``",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:37354,Performance,perform,performing,37354,"es |scf__df_basis_scf| manually. For; some atoms, cc-pVDZ-JKFIT is not defined, so a very large fitting basis of last; resort will be used.; To avoid this, either set |scf__df_basis_scf| to an auxiliary; basis set defined for all atoms in the system, or set |scf__df_scf_guess|; to false, which disables this acceleration entirely. .. _`sec:scfddfj`:. Integral-Direct Density-Fitted Coulomb Construction; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. The Resolution of the Identity (RI) can be used to decompose the normally 4-center ERI tensor into a combination of 3-center and 2-center components.; By reducing the dimensionality of the ERI tensor, application of the RI (often referred to as density-fitting, or DF) can be used to greatly speed up; SCF calculations. The reduction in ERI tensor rank also makes DF an appealing option for conventional SCF calculations, where the ERIs are stored ; in core or on disk. However, even when using DF, I/O becomes a significant bottleneck for systems of a sufficient size when performing conventional SCF; calculations. In principle, though, DF approaches can be utilized in an integral-direct context, gaining the benefits of DF methods without suffering the; I/O bottlenecks that conventional DF methods will eventually run into. One such approach, outlined by Weigend in [Weigend:2002:4285]_,; is available for use in Psi4 for the separate construction of the Coulomb contribution to the Fock matrix. This implementation can be used alongside ; Psi4's separate Exchange construction algorithms for composite Fock matrix construction by using the keyword DFDIRJ as the Coulomb construction ; algorithm when specifying |globals__scf_type| to use a composite algorithm combination (``DFDIRJ+K_alg`` in general, ; or ``DFDIRJ`` for DFT with non-hybrid functionals). . DFDIRJ supports multiple capabilities to improve performance. Specifically, DFDIRJ allows for a combination of density-matrix based ERI ; screening (set |globals__screening| to ``",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:37542,Performance,bottleneck,bottlenecks,37542,"s_scf| to an auxiliary; basis set defined for all atoms in the system, or set |scf__df_scf_guess|; to false, which disables this acceleration entirely. .. _`sec:scfddfj`:. Integral-Direct Density-Fitted Coulomb Construction; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. The Resolution of the Identity (RI) can be used to decompose the normally 4-center ERI tensor into a combination of 3-center and 2-center components.; By reducing the dimensionality of the ERI tensor, application of the RI (often referred to as density-fitting, or DF) can be used to greatly speed up; SCF calculations. The reduction in ERI tensor rank also makes DF an appealing option for conventional SCF calculations, where the ERIs are stored ; in core or on disk. However, even when using DF, I/O becomes a significant bottleneck for systems of a sufficient size when performing conventional SCF; calculations. In principle, though, DF approaches can be utilized in an integral-direct context, gaining the benefits of DF methods without suffering the; I/O bottlenecks that conventional DF methods will eventually run into. One such approach, outlined by Weigend in [Weigend:2002:4285]_,; is available for use in Psi4 for the separate construction of the Coulomb contribution to the Fock matrix. This implementation can be used alongside ; Psi4's separate Exchange construction algorithms for composite Fock matrix construction by using the keyword DFDIRJ as the Coulomb construction ; algorithm when specifying |globals__scf_type| to use a composite algorithm combination (``DFDIRJ+K_alg`` in general, ; or ``DFDIRJ`` for DFT with non-hybrid functionals). . DFDIRJ supports multiple capabilities to improve performance. Specifically, DFDIRJ allows for a combination of density-matrix based ERI ; screening (set |globals__screening| to ``DENSITY``) and incremental Fock matrix construction (set |scf__incfock| to ``TRUE``). These two, when combined,; enable more aggressive screening of ERI contributions to the Coulo",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:38193,Performance,perform,performance,38193,"ventional SCF calculations, where the ERIs are stored ; in core or on disk. However, even when using DF, I/O becomes a significant bottleneck for systems of a sufficient size when performing conventional SCF; calculations. In principle, though, DF approaches can be utilized in an integral-direct context, gaining the benefits of DF methods without suffering the; I/O bottlenecks that conventional DF methods will eventually run into. One such approach, outlined by Weigend in [Weigend:2002:4285]_,; is available for use in Psi4 for the separate construction of the Coulomb contribution to the Fock matrix. This implementation can be used alongside ; Psi4's separate Exchange construction algorithms for composite Fock matrix construction by using the keyword DFDIRJ as the Coulomb construction ; algorithm when specifying |globals__scf_type| to use a composite algorithm combination (``DFDIRJ+K_alg`` in general, ; or ``DFDIRJ`` for DFT with non-hybrid functionals). . DFDIRJ supports multiple capabilities to improve performance. Specifically, DFDIRJ allows for a combination of density-matrix based ERI ; screening (set |globals__screening| to ``DENSITY``) and incremental Fock matrix construction (set |scf__incfock| to ``TRUE``). These two, when combined,; enable more aggressive screening of ERI contributions to the Coulomb matrix and thus greatly improve performance. .. _`sec:scfcosx`:. COSX Exchange; ~~~~~~~~~~~~~. The semi-numerical COSX algorithm described in [Neese:2009:98]_ evaluates; two-electron ERIs analytically over one electron coordinate and numerically; over the other electron coordinate, and belongs to the family of pseudospectral ; methods originally suggested by Friesner. In COSX, numerical integration is performed on standard; DFT quadrature grids, which are described in :ref:`sec:dft`.; Both the accuracy of the COSX algorithm and also the computational; cost are directly determined by the size of the integration grid, so selection; of the grid is important. This ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:38537,Performance,perform,performance,38537,", gaining the benefits of DF methods without suffering the; I/O bottlenecks that conventional DF methods will eventually run into. One such approach, outlined by Weigend in [Weigend:2002:4285]_,; is available for use in Psi4 for the separate construction of the Coulomb contribution to the Fock matrix. This implementation can be used alongside ; Psi4's separate Exchange construction algorithms for composite Fock matrix construction by using the keyword DFDIRJ as the Coulomb construction ; algorithm when specifying |globals__scf_type| to use a composite algorithm combination (``DFDIRJ+K_alg`` in general, ; or ``DFDIRJ`` for DFT with non-hybrid functionals). . DFDIRJ supports multiple capabilities to improve performance. Specifically, DFDIRJ allows for a combination of density-matrix based ERI ; screening (set |globals__screening| to ``DENSITY``) and incremental Fock matrix construction (set |scf__incfock| to ``TRUE``). These two, when combined,; enable more aggressive screening of ERI contributions to the Coulomb matrix and thus greatly improve performance. .. _`sec:scfcosx`:. COSX Exchange; ~~~~~~~~~~~~~. The semi-numerical COSX algorithm described in [Neese:2009:98]_ evaluates; two-electron ERIs analytically over one electron coordinate and numerically; over the other electron coordinate, and belongs to the family of pseudospectral ; methods originally suggested by Friesner. In COSX, numerical integration is performed on standard; DFT quadrature grids, which are described in :ref:`sec:dft`.; Both the accuracy of the COSX algorithm and also the computational; cost are directly determined by the size of the integration grid, so selection; of the grid is important. This COSX implementation uses two separate grids.; By default, the SCF algorithm is first converged on a smaller grid, followed by a; number of SCF iterations up to a maximum value (controlled by the |scf__cosx_maxiter_final| keyword); on a larger grid. By default, |scf__cosx_maxiter_final| is set to 1, a sin",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:38910,Performance,perform,performed,38910,"DFDIRJ as the Coulomb construction ; algorithm when specifying |globals__scf_type| to use a composite algorithm combination (``DFDIRJ+K_alg`` in general, ; or ``DFDIRJ`` for DFT with non-hybrid functionals). . DFDIRJ supports multiple capabilities to improve performance. Specifically, DFDIRJ allows for a combination of density-matrix based ERI ; screening (set |globals__screening| to ``DENSITY``) and incremental Fock matrix construction (set |scf__incfock| to ``TRUE``). These two, when combined,; enable more aggressive screening of ERI contributions to the Coulomb matrix and thus greatly improve performance. .. _`sec:scfcosx`:. COSX Exchange; ~~~~~~~~~~~~~. The semi-numerical COSX algorithm described in [Neese:2009:98]_ evaluates; two-electron ERIs analytically over one electron coordinate and numerically; over the other electron coordinate, and belongs to the family of pseudospectral ; methods originally suggested by Friesner. In COSX, numerical integration is performed on standard; DFT quadrature grids, which are described in :ref:`sec:dft`.; Both the accuracy of the COSX algorithm and also the computational; cost are directly determined by the size of the integration grid, so selection; of the grid is important. This COSX implementation uses two separate grids.; By default, the SCF algorithm is first converged on a smaller grid, followed by a; number of SCF iterations up to a maximum value (controlled by the |scf__cosx_maxiter_final| keyword); on a larger grid. By default, |scf__cosx_maxiter_final| is set to 1, a single; SCF iteration, which results in numerical errors comparable to; performing the entire SCF on the expensive larger grid at a computational cost; much closer to the smaller grid. Setting |scf__cosx_maxiter_final| to 0 disables the; larger grid entirely. Setting |scf__cosx_maxiter_final| to -1 allows; for the SCF to fully converge on the larger grid, useful for the study of wavefunction; properties such as gradients. The size of the initial grid is ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:39548,Performance,perform,performing,39548,"ormance. .. _`sec:scfcosx`:. COSX Exchange; ~~~~~~~~~~~~~. The semi-numerical COSX algorithm described in [Neese:2009:98]_ evaluates; two-electron ERIs analytically over one electron coordinate and numerically; over the other electron coordinate, and belongs to the family of pseudospectral ; methods originally suggested by Friesner. In COSX, numerical integration is performed on standard; DFT quadrature grids, which are described in :ref:`sec:dft`.; Both the accuracy of the COSX algorithm and also the computational; cost are directly determined by the size of the integration grid, so selection; of the grid is important. This COSX implementation uses two separate grids.; By default, the SCF algorithm is first converged on a smaller grid, followed by a; number of SCF iterations up to a maximum value (controlled by the |scf__cosx_maxiter_final| keyword); on a larger grid. By default, |scf__cosx_maxiter_final| is set to 1, a single; SCF iteration, which results in numerical errors comparable to; performing the entire SCF on the expensive larger grid at a computational cost; much closer to the smaller grid. Setting |scf__cosx_maxiter_final| to 0 disables the; larger grid entirely. Setting |scf__cosx_maxiter_final| to -1 allows; for the SCF to fully converge on the larger grid, useful for the study of wavefunction; properties such as gradients. The size of the initial grid is controlled by the keywords; |scf__cosx_radial_points_initial| and |scf__cosx_spherical_points_initial|.; The final grid is controlled by |scf__cosx_radial_points_final| and; |scf__cosx_spherical_points_final|. Currently, the default grids are very crude,; allowing for high performance at the cost of accuracy. If high-accuracy calculations; are desired with COSX, the grid sizes should be increased. Screening thresholds over integrals, densities, and basis extents are set; with the |scf__cosx_ints_tolerance|, |scf__cosx_density_tolerance|, and; |scf__cosx_basis_tolerance| keywords, respectively. |scf__",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:40208,Performance,perform,performance,40208," uses two separate grids.; By default, the SCF algorithm is first converged on a smaller grid, followed by a; number of SCF iterations up to a maximum value (controlled by the |scf__cosx_maxiter_final| keyword); on a larger grid. By default, |scf__cosx_maxiter_final| is set to 1, a single; SCF iteration, which results in numerical errors comparable to; performing the entire SCF on the expensive larger grid at a computational cost; much closer to the smaller grid. Setting |scf__cosx_maxiter_final| to 0 disables the; larger grid entirely. Setting |scf__cosx_maxiter_final| to -1 allows; for the SCF to fully converge on the larger grid, useful for the study of wavefunction; properties such as gradients. The size of the initial grid is controlled by the keywords; |scf__cosx_radial_points_initial| and |scf__cosx_spherical_points_initial|.; The final grid is controlled by |scf__cosx_radial_points_final| and; |scf__cosx_spherical_points_final|. Currently, the default grids are very crude,; allowing for high performance at the cost of accuracy. If high-accuracy calculations; are desired with COSX, the grid sizes should be increased. Screening thresholds over integrals, densities, and basis extents are set; with the |scf__cosx_ints_tolerance|, |scf__cosx_density_tolerance|, and; |scf__cosx_basis_tolerance| keywords, respectively. |scf__cosx_ints_tolerance|; is the most consequential of the three thresholds in both cost and accuracy.; This keyword determines screening of negligible one-electron integrals.; |scf__cosx_density_tolerance| controls the threshold for significant; shell pairs in the density matrix. Lastly, |scf__cosx_basis_tolerance| is; a cutoff for the value of basis functions at grid points. This keyword is; used to determine the radial extent of the each basis shell, and it is the; COSX analogue to |scf__dft_basis_tolerance|. The |scf__incfock| keyword (defaults to ``false``) increases performance; by constructing the Fock matrix from differences in the density m",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:41116,Performance,perform,performance,41116,"rrently, the default grids are very crude,; allowing for high performance at the cost of accuracy. If high-accuracy calculations; are desired with COSX, the grid sizes should be increased. Screening thresholds over integrals, densities, and basis extents are set; with the |scf__cosx_ints_tolerance|, |scf__cosx_density_tolerance|, and; |scf__cosx_basis_tolerance| keywords, respectively. |scf__cosx_ints_tolerance|; is the most consequential of the three thresholds in both cost and accuracy.; This keyword determines screening of negligible one-electron integrals.; |scf__cosx_density_tolerance| controls the threshold for significant; shell pairs in the density matrix. Lastly, |scf__cosx_basis_tolerance| is; a cutoff for the value of basis functions at grid points. This keyword is; used to determine the radial extent of the each basis shell, and it is the; COSX analogue to |scf__dft_basis_tolerance|. The |scf__incfock| keyword (defaults to ``false``) increases performance; by constructing the Fock matrix from differences in the density matrix, which; are more amenable to screening. This option is disabled by default because of; potential SCF convergence issues, particularly when using diffuse basis functions.; The |scf__cosx_overlap_fitting| keyword (defaults to ``true``) reduces numerical; integration errors using the method described in [Izsak:2011:144105]_ and is; always recommended. .. _`sec:scflink`:. Linear Exchange; ~~~~~~~~~~~~~~~. Large SCF calculations can benefit from specialized screening procedures that further reduce the scaling of the ERI contribution to the Fock matrix.; LinK, the linear-scaling exchange method described in [Ochsenfeld:1998:1663]_, is available in Psi4 in conjunction with composite algorithms that build J (|globals__scf_type| set to ``J_alg+LINK``).; LinK achieves linear-scaling by exploiting shell pair sparsity in the density matrix and overlap sparsity between shell pairs. Specifically, LinK exploits the fact that the Exchange term; requ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:47192,Performance,tune,tune,47192,"F solution exists while respecting the constraints of the original; solution; this is an internal instability. If one or more constraints have to be relaxed to reach; a lower-energy solution, there is an external instability. In |PSIfour|, the only external instability; that can be checked at present is the RHF :math:`\rightarrow` UHF one. Currently, two algorithms exist in |PSIfour| for stability analysis: the original; Direct Inversion and the newly implemented Davidson algorithms. We will first describe; options common to both algorithms. To request a stability analysis at the end of the SCF,; set the keyword |scf__stability_analysis|. Value ``CHECK`` only computes the electronic; Hessian eigenvalue and checks if an actual SCF minimum has been found, while value ``FOLLOW``; rotates the converged orbitals along the lowest eigenvector, then invokes the SCF; procedure again to lower the energy. In case the minimization does not succeed; or ends up on the same unstable solution, you can tune the scale factor for the orbital; rotation through the keyword |scf__follow_step_scale|.; The rotation angle is :math:`\frac{\pi}{2}\mbox{ } \cdot` (|scf__follow_step_scale|). The default value of; 0.5 usually provides a good guess, and modification is only recommended in difficult cases.; The default behavior for the stability code is to stop after trying to reoptimize the orbitals once; if the instability still exists. For more attempts, set |scf__max_attempts|;; the default value of 1 is recommended. In case the SCF ends up in the same minimum, modification; of |scf__follow_step_scale| is recommended over increasing |scf__max_attempts|. .. note:: Setting the option |scf__stability_analysis| to ``FOLLOW`` is only avalible for UHF. When using; RHF and ROHF instabilities can be checked, but not followed. If you want to attempt to find a lower energy solution; you should re-run the calculation with |scf__reference| set to ``UHF``. The main algorithm available in |PSIfour| is the Di",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:53855,Performance,perform,perform,53855,"Analytic derivatives of ECPs were not available. The HF and DFT derivatives were implemented in a semi-numerical scheme, where numerical ECP gradients were added to analytic SCF gradients. For post-SCF methods, the entire gradient computation needed to be run as finite difference of energies. .. warning:: As of May 2022, v1.6, Psi4 uses the LibECPInt library, and analytic derivatives and Hessians of ECPs are available. Analytic derivatives of molecular systems including ECPs should be available whenever the method has analytic derivatives, but these have so far only been verified for HF and DFT. .. warning:: ECPs have not been tested with projected basis set guesses or with FI-SAPT calculations. If you require this functionality, please contact the developers on GitHub and/or the `forum <http://forum.psicode.org>`_. .. _`sec:scfqmmm`:. External potentials and QM/MM; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In addition to the implementation of :ref:`EFP <sec:libefp>` for accurate QM/MM; computations, |PSIfour| can perform more rudimentary QM/MM procedures via the; |scf__extern| keyword. The following snippet, extracted from the; :srcsample:`extern1` test case, demonstrates its use for a TIP3P external potential::. import numpy as np; external_potentials = [; [-0.834, np.array([1.649232019048,0.0,-2.356023604706]) / psi_bohr2angstroms],; [ 0.417, np.array([0.544757019107,0.0,-3.799961446760]) / psi_bohr2angstroms],; [ 0.417, np.array([0.544757019107,0.0,-0.912085762652]) / psi_bohr2angstroms]]. gradient('scf', external_potentials=external_potentials). The ``external_potentials`` array has three rows for three separate; particles, and it is passed to the SCF code on the last line. The; rows are composed of the atomic charge, x coordinate, y coordinate,; and z coordinate in that order. The atomic charge and coordinates are; specified in atomic units, [e] and [a0]. Add as many particle rows as; needed to describe the full MM region. .. caution:: In |PSIfour| previous to Spring 2022",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:57147,Performance,optimiz,optimization,57147,"n should be reduced accordingly; if in doubt run the; calculation in C1 symmetry. For examples of SCF and MP2 calculations in an; external field, see :srcsample:`scf7` and :srcsample:`dfmp2-grad5`. .. _`sec:scfdefault`:. Convergence and Algorithm Defaults; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. _`table:conv_scf`:. .. table:: SCF algorithm and convergence criteria defaults by calculation type [#f1]_. +--------------------+--------------------+----------------------+----------------------+---------------------+; | *Ab Initio* Method | Calculation Type | |scf__e_convergence| | |scf__d_convergence| | |globals__scf_type| |; +====================+====================+======================+======================+=====================+; | SCF of HF or DFT | energy | 6 | 6 | DF |; + +--------------------+----------------------+----------------------+ +; | | optimization | 8 | 8 | |; + +--------------------+----------------------+----------------------+ +; | | frequency [#f7]_ | 8 | 8 | |; +--------------------+--------------------+----------------------+----------------------+---------------------+; | SCF of post-HF | energy | 8 | 8 | PK [#f3]_ |; + +--------------------+----------------------+----------------------+ +; | | optimization | 10 | 10 | |; + +--------------------+----------------------+----------------------+ +; | | frequency [#f7]_ | 10 | 10 | |; + +--------------------+----------------------+----------------------+ +; | | CC property [#f2]_ | 10 | 10 | |; +--------------------+--------------------+----------------------+----------------------+---------------------+. .. _`table:conv_corl`:. .. table:: Post-SCF convergence criteria defaults by calculation type [#f4]_. +--------------------+--------------------+----------------------+-------------------------+; | *Ab Initio* Method | Calculation Type | E_CONVERGENCE [#f5]_ | R_CONVERGENCE [#f6]_ |; +====================+====================+======================+=========================+; | post-HF of post-HF |",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:57521,Performance,optimiz,optimization,57521,"n should be reduced accordingly; if in doubt run the; calculation in C1 symmetry. For examples of SCF and MP2 calculations in an; external field, see :srcsample:`scf7` and :srcsample:`dfmp2-grad5`. .. _`sec:scfdefault`:. Convergence and Algorithm Defaults; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. _`table:conv_scf`:. .. table:: SCF algorithm and convergence criteria defaults by calculation type [#f1]_. +--------------------+--------------------+----------------------+----------------------+---------------------+; | *Ab Initio* Method | Calculation Type | |scf__e_convergence| | |scf__d_convergence| | |globals__scf_type| |; +====================+====================+======================+======================+=====================+; | SCF of HF or DFT | energy | 6 | 6 | DF |; + +--------------------+----------------------+----------------------+ +; | | optimization | 8 | 8 | |; + +--------------------+----------------------+----------------------+ +; | | frequency [#f7]_ | 8 | 8 | |; +--------------------+--------------------+----------------------+----------------------+---------------------+; | SCF of post-HF | energy | 8 | 8 | PK [#f3]_ |; + +--------------------+----------------------+----------------------+ +; | | optimization | 10 | 10 | |; + +--------------------+----------------------+----------------------+ +; | | frequency [#f7]_ | 10 | 10 | |; + +--------------------+----------------------+----------------------+ +; | | CC property [#f2]_ | 10 | 10 | |; +--------------------+--------------------+----------------------+----------------------+---------------------+. .. _`table:conv_corl`:. .. table:: Post-SCF convergence criteria defaults by calculation type [#f4]_. +--------------------+--------------------+----------------------+-------------------------+; | *Ab Initio* Method | Calculation Type | E_CONVERGENCE [#f5]_ | R_CONVERGENCE [#f6]_ |; +====================+====================+======================+=========================+; | post-HF of post-HF |",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:58381,Performance,optimiz,optimization,58381,"+----------------------+---------------------+; | SCF of post-HF | energy | 8 | 8 | PK [#f3]_ |; + +--------------------+----------------------+----------------------+ +; | | optimization | 10 | 10 | |; + +--------------------+----------------------+----------------------+ +; | | frequency [#f7]_ | 10 | 10 | |; + +--------------------+----------------------+----------------------+ +; | | CC property [#f2]_ | 10 | 10 | |; +--------------------+--------------------+----------------------+----------------------+---------------------+. .. _`table:conv_corl`:. .. table:: Post-SCF convergence criteria defaults by calculation type [#f4]_. +--------------------+--------------------+----------------------+-------------------------+; | *Ab Initio* Method | Calculation Type | E_CONVERGENCE [#f5]_ | R_CONVERGENCE [#f6]_ |; +====================+====================+======================+=========================+; | post-HF of post-HF | energy | 6 | |; + +--------------------+----------------------+-------------------------+; | | optimization | 8 | |; + +--------------------+----------------------+-------------------------+; | | frequency [#f7]_ | 8 | |; + +--------------------+----------------------+-------------------------+; | | CC property [#f2]_ | 8 | |; +--------------------+--------------------+----------------------+-------------------------+. .. rubric:: Footnotes. .. [#f1] Note that this table applies only the SCF module,; not to the final convergence criteria for post-HF methods or to methods; that use an alternate starting point, like MCSCF. SAPT computations, too,; set tighter values. .. [#f2] This applies to properties computed through the :py:func:`~psi4.driver.properties` function. .. [#f3] Post-HF methods that do not rely upon the usual 4-index AO integrals use a; density-fitted SCF reference. That is, for DF-MP2 and SAPT, the default |globals__scf_type| is DF. .. [#f4] Note that this table applies to the final convergence criteria for; all the post-SCF modules",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:60809,Performance,perform,performing,60809,"ist beginning at |ccenergy__r_convergence|). It is defined; according to the quantum chemical method and so its default value is set; by each module individually. .. [#f7] For frequency computations by finite difference of energies,; convergence criteria are tightened further still to 10 for; |scf__e_convergence| and |scf__d_convergence| for SCF of HF or DFT, 11; for |scf__e_convergence| and |scf__d_convergence| for SCF of post-HF,; and 10 for E_CONVERGENCE for post-HF of post-HF. .. _`sec:scfrec`:. Recommendations; ~~~~~~~~~~~~~~~. The SCF code is quite flexible and powerful.; We have tried as much as possible to keep the number of options to; a minimum and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. * For |scf__guess|, the ``SAD`` guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; * For wall time, ``DF`` may be a factor of ten or more faster than the exact; integral technologies available in |PSIfour|.; Use ``DF`` unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your orbital basis/atom type. Then use; ``DIRECT``.; * Don't mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; * Buy a developer a beer!. The ""best-practice"" input file for HF is::. memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvdz; scf_type df; guess sad; ints_tolerance 1.0E-10 # Even this is epically tight, 1.0E-8 is OK; }. energy('scf'); ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:61295,Performance,optimiz,optimized,61295,"ist beginning at |ccenergy__r_convergence|). It is defined; according to the quantum chemical method and so its default value is set; by each module individually. .. [#f7] For frequency computations by finite difference of energies,; convergence criteria are tightened further still to 10 for; |scf__e_convergence| and |scf__d_convergence| for SCF of HF or DFT, 11; for |scf__e_convergence| and |scf__d_convergence| for SCF of post-HF,; and 10 for E_CONVERGENCE for post-HF of post-HF. .. _`sec:scfrec`:. Recommendations; ~~~~~~~~~~~~~~~. The SCF code is quite flexible and powerful.; We have tried as much as possible to keep the number of options to; a minimum and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. * For |scf__guess|, the ``SAD`` guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; * For wall time, ``DF`` may be a factor of ten or more faster than the exact; integral technologies available in |PSIfour|.; Use ``DF`` unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your orbital basis/atom type. Then use; ``DIRECT``.; * Don't mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; * Buy a developer a beer!. The ""best-practice"" input file for HF is::. memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvdz; scf_type df; guess sad; ints_tolerance 1.0E-10 # Even this is epically tight, 1.0E-8 is OK; }. energy('scf'); ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:10393,Safety,avoid,avoid,10393,"formation on any of these options, see the relevant section below. .. _`sec:scfsymm`:. Spin/Symmetry Treatment; ~~~~~~~~~~~~~~~~~~~~~~~. |PSIfour| implements the most popular spin specializations of Hartree--Fock; theory, including:. Restricted Hartree--Fock (RHF) [Default]; Appropriate only for closed-shell singlet systems, but twice as efficient; as the other flavors, as the alpha and beta densities are constrained to be; identical.; Unrestricted Hartree--Fock (UHF); Appropriate for most open-shell systems and fairly easy to converge.; The spatial parts of the alpha and beta orbitals are fully independent of each; other, which allows a considerable amount of flexibility in the wavefunction.; However, this flexibility comes at the cost of spin symmetry; UHF wavefunctions; need not be eigenfunctions of the :math:`\hat S^2` operator. The deviation of; this operator from its expectation value is printed on the output file. If the; deviation is greater than a few hundredths, it is advisable to switch to a; ROHF to avoid this ""spin-contamination"" problem.; Restricted Open-Shell Hartree--Fock (ROHF); Appropriate for open-shell systems where spin-contamination is problem.; Sometimes more difficult to converge, and assumes uniformly positive spin; polarization (the alpha and beta doubly-occupied orbitals are identical).; Constrained Unrestricted Hartree--Fock (CUHF); A variant of ROHF that starts from a UHF ansatz and is therefore often; easier to converge. These can be invoked by the |scf__reference| keyword, which defaults to ``RHF``.; The charge and multiplicity may either be specified in the molecule definition::. molecule h {; 0 2 # Neutral doublet; H; }. or, dynamically, by setting the relevant attributes in the Python molecule; object::. h.set_molecular_charge(0); h.set_multiplicity(2). Abelian spatial symmetry is fully supported in |PSIfour| and can be used to; obtain physical interpretation of the molecular orbitals, to assist in difficult; convergence cases, and, ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:13922,Safety,avoid,avoided,13922,"ogonalization; ~~~~~~~~~~~~~~~~~. One of the first steps in the SCF procedure is the determination of an; orthogonal basis (known as the OSO basis) from the atomic orbital; basis (known as the AO basis). The Molecular Orbital basis (MO basis); is then built as a particular unitary transformation of the OSO; basis. In |PSIfour|, the determination of the OSO basis is; accomplished via either symmetric, canonical, or partial Cholesky; orthogonalization. Symmetric orthogonalization uses the symmetric inverse square root of; the overlap matrix for the orthogonalization matrix. Use of symmetric; orthogonalization always yields the same number of OSO functions (and; thereby MOs) as AO functions. However, this may lead to numerical; problems if the overlap matrix has small eigenvalues, which may occur; for large systems or for systems where diffuse basis sets are used. This problem may be avoided by using canonical orthogonalization, in; which an asymmetric inverse square root of the overlap matrix is; formed, with numerical stability enhanced by the elimination of; eigenvectors corresponding to very small eigenvalues. As a few; combinations of AO basis functions may be discarded, the number of; canonical-orthogonalized OSOs and MOs may be slightly smaller than the; number of AOs. When the basis set is too overcomplete, the eigendecomposition of the; overlap matrix is no longer numerically stable. In this case the; partial Cholesky decomposition can be used to pick a subset of basis; functions that span a sufficiently complete set, see; [Lehtola:2019:241102]_ and [Lehtola:2020:032504]_. This subset can then; be orthonormalized as usual; the rest of the basis functions are; hidden from the calculation. The Cholesky approach allows reaching; accurate energies even in the presence of significant linear; dependencies [Lehtola:2020:134108]_. In |PSIfour|, symmetric orthogonalization is used by default, unless; the smallest overlap eigenvalue falls below the user-supplied double; ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:15283,Safety,detect,detected,15283,"he; overlap matrix is no longer numerically stable. In this case the; partial Cholesky decomposition can be used to pick a subset of basis; functions that span a sufficiently complete set, see; [Lehtola:2019:241102]_ and [Lehtola:2020:032504]_. This subset can then; be orthonormalized as usual; the rest of the basis functions are; hidden from the calculation. The Cholesky approach allows reaching; accurate energies even in the presence of significant linear; dependencies [Lehtola:2020:134108]_. In |PSIfour|, symmetric orthogonalization is used by default, unless; the smallest overlap eigenvalue falls below the user-supplied double; option |scf__s_tolerance|, which defaults to 1E-7. If the smallest; eigenvalue is below this cutoff, canonical orthogonalization is; forced, and all eigenvectors corresponding to eigenvalues below the; cutoff are eliminated. If the eigendecomposition is detected to be numerically unstable - the; reciprocal condition number of the overlap matrix to be smaller than; the machine epsilon - the partial Cholesky decomposition is undertaken; until |scf__s_cholesky_tolerance|, which defaults to 1E-8. Use of symmetric, canonical, and partial Cholesky orthogonalization; can be forced by setting the |scf__s_orthogonalization| option to; ``SYMMETRIC``, ``CANONICAL``, or ``PARTIALCHOLESKY``,; respectively. Note that in practice, the MOs and OSOs are built separately within; each irrep from the symmetry-adapted combinations of AOs known as; Unique Symmetry Orbitals (USOs). For canonical orthogonalization,; this implies that the number of MOs and OSOs per irrep may be slightly; smaller than the number of USOs per irrep. A contrived example demonstrating OSOs/MOs vs. AOs with symmetry is shown; below::. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c2 # Two irreps is easier to comprehend; }. set {; s_tolerance 0.0001 # Set an unreasonably tight; # tolerance to force canonical; basis aug-cc-pv5z # This diffuse basis will have; # small-ish eige",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:30598,Safety,redund,redundant,30598,"gtrsim`\ CCSD(T)] or a -JKFIT auxiliary basis is unavailable; for the orbital basis/atoms involved.; CD; A threaded algorithm using approximate ERIs obtained by Cholesky; decomposition of the ERI tensor. The accuracy of the Cholesky; decomposition is controlled by the keyword |scf__cholesky_tolerance|.; This algorithm is similar to the DF algorithm, but it is not suitable; for gradient computations. The algorithm to obtain the Cholesky; vectors is not designed for computations with thousands of basis; functions. |PSIfour| also features the capability to use ""composite"" Fock matrix build; algorithms - arbitrary combinations of specialized algorithms that construct; either the Coulomb or the Exchange matrix separately. In general, since; separate Coulomb and Exchange matrix build algorithms exploit properties specific to; their respective matrix, composite algorithms display lower; scaling factors than their combined Fock build counterparts. However, composite algorithms also; introduce redundant ERI computations into the calculation. Therefore, composite Fock build; algorithms tend to perform better for larger systems, but worse for smaller systems. Arbitrary; composite algorithms can be accessed by setting |globals__scf_type| to ``J_alg+K_alg``,; where *J_alg* and *K_alg* are the names of the separate Coulomb; and Exchange construction algorithms to use, respectively. Alternatively, if one is using; DFT with non-hybrid functionals, a composite Coulomb construction algorithm can be; specified solo by setting |globals__scf_type| to ``J_alg``, without the need to set ; an associated ``K_alg``. Specialized algorithms available to construct the Coulomb term within a composite framework ; are as follows:. DFDIRJ; An integral-direct algorithm constructing the Coulomb term based on [Weigend:2002:4285]_; The DFDIRJ algorithm combines the benefits of integral-direct SCF approaches ; with that of density-fitting. Specifically, DFJ utilizes no I/O and displays ; strong performan",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:32983,Safety,detect,detect,32983,"[Neese:2009:98]_. The coulomb term is computed with a; direct density-fitting algorithm. The COSX algorithm uses no I/O, scales; well with system size, and requires minimal memory, making it ideal for; large systems and multi-core CPUs. See :ref:`sec:scfcosx` for more information.; LINK; An implementation of the linear-scaling ""Linear Exchange"" (LinK); algorithm described in [Ochsenfeld:1998:1663]_. The LINK algorithm provides ; many of the benefits of integral-direct SCF algorithms, including no disk I/O, ; low memory usage, and effective parallelization. Additionally, the; LINK implementation scales well with system size ; while simultaneously providing a formally-exact computation of the ; Exchange term. See :ref:`sec:scflink` for more information. In some cases the above algorithms have multiple implementations that return; the same result, but are optimal under different molecules sizes and hardware; configurations. Psi4 will automatically detect the correct algorithm to run and; only expert users should manually select the below implementations. The DF; algorithm has the following two implementations. MEM_DF; A DF algorithm optimized around memory layout and is optimal as long as; there is sufficient memory to hold the three-index DF tensors in memory. This; algorithm may be faster for builds that require disk if SSDs are used.; DISK_DF; A DF algorithm (the default DF algorithm before Psi4 1.2) optimized to; minimize Disk IO by sacrificing some performance due to memory layout. Note that these algorithms have both in-memory and on-disk options, but; performance penalties up to a factor of 2.5 can be found if the incorrect; algorithm is chosen. It is therefore highly recommended that the keyword ""DF""; be selected in all cases so that the correct implementation can be selected by; |PSIfours| internal routines. Expert users can manually switch between MEM_DF and; DISK_DF; however, they may find documented exceptions during use as several; post SCF algorithms requi",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:36466,Safety,avoid,avoid,36466,"matrix.; For the RHF case, described in [Haser:1989:104]_. .. math:: CON(PQ|RS) <= \sqrt{(PQ|PQ)(RS|RS)} \cdot DCON(PQ, RS). .. math:: DCON(PQ, RS) = max(4D_{PQ}, 4D_{RS}, D_{PR}, D_{PS}, D_{QR}, D_{QS}). When using density-matrix based integral screening, it is useful to build the J and K matrices; incrementally, also described in [Haser:1989:104]_, using the difference in the density matrix between iterations, rather than the; full density matrix. To turn on this option, set |scf__incfock| to ``true``. We have added the automatic capability to use the extremely fast DF; code for intermediate convergence of the orbitals, for |globals__scf_type|; ``DIRECT``. At the moment, the code defaults to cc-pVDZ-JKFIT as the; auxiliary basis, unless the user specifies |scf__df_basis_scf| manually. For; some atoms, cc-pVDZ-JKFIT is not defined, so a very large fitting basis of last; resort will be used.; To avoid this, either set |scf__df_basis_scf| to an auxiliary; basis set defined for all atoms in the system, or set |scf__df_scf_guess|; to false, which disables this acceleration entirely. .. _`sec:scfddfj`:. Integral-Direct Density-Fitted Coulomb Construction; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. The Resolution of the Identity (RI) can be used to decompose the normally 4-center ERI tensor into a combination of 3-center and 2-center components.; By reducing the dimensionality of the ERI tensor, application of the RI (often referred to as density-fitting, or DF) can be used to greatly speed up; SCF calculations. The reduction in ERI tensor rank also makes DF an appealing option for conventional SCF calculations, where the ERIs are stored ; in core or on disk. However, even when using DF, I/O becomes a significant bottleneck for systems of a sufficient size when performing conventional SCF; calculations. In principle, though, DF approaches can be utilized in an integral-direct context, gaining the benefits of DF methods without suffering the; I/O bottlenecks tha",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:48419,Safety,avoid,avoided,48419,"ly provides a good guess, and modification is only recommended in difficult cases.; The default behavior for the stability code is to stop after trying to reoptimize the orbitals once; if the instability still exists. For more attempts, set |scf__max_attempts|;; the default value of 1 is recommended. In case the SCF ends up in the same minimum, modification; of |scf__follow_step_scale| is recommended over increasing |scf__max_attempts|. .. note:: Setting the option |scf__stability_analysis| to ``FOLLOW`` is only avalible for UHF. When using; RHF and ROHF instabilities can be checked, but not followed. If you want to attempt to find a lower energy solution; you should re-run the calculation with |scf__reference| set to ``UHF``. The main algorithm available in |PSIfour| is the Direct Inversion algorithm. It can *only*; work with |globals__scf_type| ``PK``, and it explicitly builds the full electronic Hessian; matrix before explicitly inverting it. As such, this algorithm is very slow and it should; be avoided whenever possible. Direct Inversion is automatically invoked if the newer algorithm; is not available. The Davidson algorithm for stability analysis was implemented recently.; Only the lowest eigenvalues of the electronic Hessian are computed, and Hessian-vector; products are computed instead of the full Hessian. This algorithm is thus; much more efficient than the Direct Inversion, but at present, it is only available for UHF :math:`\rightarrow` UHF stability; analysis. The capabilities of both algorithms are summarized below:. .. _`table:stab_methods`:. .. table:: Stability analysis methods available in |PSIfour|. +------------------+------------------+----------------------------------------------+---------------------------+---------------------+; | Algorithm | |scf__reference| | Stability checked | |scf__stability_analysis| | |globals__scf_type| |; +==================+==================+==============================================+=========================",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:52573,Safety,detect,detected,52573," to Kohn-Sham references is under development. As of 1.7, only LDA functionals are currently supported. In case convergence problems are encountered during the Davidson procedure, file a bug report.; If the solver seems to converge on the wrong eigenvalue, try increasing |scf__solver_n_guess|.; Otherwise, if the solver is almost converged but reaches the maximum number of iterations, try increasing; |scf__solver_maxiter|. .. _`sec:scf-ecps`:. Effective core potentials (ECPs); ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. |PSIfour| supports the use of effective core potentials to describe the; innermost electrons in heavy elements.; ECPs are only available if |PSIfour| is compiled with the :ref:`LibECPInt <cmake:ecpint>` library.; If a basis set is designed to use an; effective core potential, the ECP definition should be simply placed alongside; the orbital basis set definition, *c.f.* :ref:`sec:basissets-ecps`. All; information related to the definition and number of core electrons will; automatically be detected and no further input is required to use the; ECP-containing basis set. See :srcsample:`scf-ecp` and :srcsample:`dfmp2-ecp`; for examples of computations with ECP-containing basis sets. .. warning:: Prior to May 2022, v1.6, Psi4 used a built-in ECP code. Analytic derivatives of ECPs were not available. The HF and DFT derivatives were implemented in a semi-numerical scheme, where numerical ECP gradients were added to analytic SCF gradients. For post-SCF methods, the entire gradient computation needed to be run as finite difference of energies. .. warning:: As of May 2022, v1.6, Psi4 uses the LibECPInt library, and analytic derivatives and Hessians of ECPs are available. Analytic derivatives of molecular systems including ECPs should be available whenever the method has analytic derivatives, but these have so far only been verified for HF and DFT. .. warning:: ECPs have not been tested with projected basis set guesses or with FI-SAPT calculations. If you require this func",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:30804,Security,access,accessed,30804,"scf__cholesky_tolerance|.; This algorithm is similar to the DF algorithm, but it is not suitable; for gradient computations. The algorithm to obtain the Cholesky; vectors is not designed for computations with thousands of basis; functions. |PSIfour| also features the capability to use ""composite"" Fock matrix build; algorithms - arbitrary combinations of specialized algorithms that construct; either the Coulomb or the Exchange matrix separately. In general, since; separate Coulomb and Exchange matrix build algorithms exploit properties specific to; their respective matrix, composite algorithms display lower; scaling factors than their combined Fock build counterparts. However, composite algorithms also; introduce redundant ERI computations into the calculation. Therefore, composite Fock build; algorithms tend to perform better for larger systems, but worse for smaller systems. Arbitrary; composite algorithms can be accessed by setting |globals__scf_type| to ``J_alg+K_alg``,; where *J_alg* and *K_alg* are the names of the separate Coulomb; and Exchange construction algorithms to use, respectively. Alternatively, if one is using; DFT with non-hybrid functionals, a composite Coulomb construction algorithm can be; specified solo by setting |globals__scf_type| to ``J_alg``, without the need to set ; an associated ``K_alg``. Specialized algorithms available to construct the Coulomb term within a composite framework ; are as follows:. DFDIRJ; An integral-direct algorithm constructing the Coulomb term based on [Weigend:2002:4285]_; The DFDIRJ algorithm combines the benefits of integral-direct SCF approaches ; with that of density-fitting. Specifically, DFJ utilizes no I/O and displays ; strong performance with large system size through a combination of ; effective parallelization and utilization of density-fitting to minimize ; ERI computational cost. See the :ref:`sec:scfddfj` section for more information. Specialized algorithms available to construct the Exchange term with",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:53471,Testability,test,tested,53471,"tion related to the definition and number of core electrons will; automatically be detected and no further input is required to use the; ECP-containing basis set. See :srcsample:`scf-ecp` and :srcsample:`dfmp2-ecp`; for examples of computations with ECP-containing basis sets. .. warning:: Prior to May 2022, v1.6, Psi4 used a built-in ECP code. Analytic derivatives of ECPs were not available. The HF and DFT derivatives were implemented in a semi-numerical scheme, where numerical ECP gradients were added to analytic SCF gradients. For post-SCF methods, the entire gradient computation needed to be run as finite difference of energies. .. warning:: As of May 2022, v1.6, Psi4 uses the LibECPInt library, and analytic derivatives and Hessians of ECPs are available. Analytic derivatives of molecular systems including ECPs should be available whenever the method has analytic derivatives, but these have so far only been verified for HF and DFT. .. warning:: ECPs have not been tested with projected basis set guesses or with FI-SAPT calculations. If you require this functionality, please contact the developers on GitHub and/or the `forum <http://forum.psicode.org>`_. .. _`sec:scfqmmm`:. External potentials and QM/MM; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In addition to the implementation of :ref:`EFP <sec:libefp>` for accurate QM/MM; computations, |PSIfour| can perform more rudimentary QM/MM procedures via the; |scf__extern| keyword. The following snippet, extracted from the; :srcsample:`extern1` test case, demonstrates its use for a TIP3P external potential::. import numpy as np; external_potentials = [; [-0.834, np.array([1.649232019048,0.0,-2.356023604706]) / psi_bohr2angstroms],; [ 0.417, np.array([0.544757019107,0.0,-3.799961446760]) / psi_bohr2angstroms],; [ 0.417, np.array([0.544757019107,0.0,-0.912085762652]) / psi_bohr2angstroms]]. gradient('scf', external_potentials=external_potentials). The ``external_potentials`` array has three rows for three separate; particles, and it is",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:53993,Testability,test,test,53993,"dded to analytic SCF gradients. For post-SCF methods, the entire gradient computation needed to be run as finite difference of energies. .. warning:: As of May 2022, v1.6, Psi4 uses the LibECPInt library, and analytic derivatives and Hessians of ECPs are available. Analytic derivatives of molecular systems including ECPs should be available whenever the method has analytic derivatives, but these have so far only been verified for HF and DFT. .. warning:: ECPs have not been tested with projected basis set guesses or with FI-SAPT calculations. If you require this functionality, please contact the developers on GitHub and/or the `forum <http://forum.psicode.org>`_. .. _`sec:scfqmmm`:. External potentials and QM/MM; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In addition to the implementation of :ref:`EFP <sec:libefp>` for accurate QM/MM; computations, |PSIfour| can perform more rudimentary QM/MM procedures via the; |scf__extern| keyword. The following snippet, extracted from the; :srcsample:`extern1` test case, demonstrates its use for a TIP3P external potential::. import numpy as np; external_potentials = [; [-0.834, np.array([1.649232019048,0.0,-2.356023604706]) / psi_bohr2angstroms],; [ 0.417, np.array([0.544757019107,0.0,-3.799961446760]) / psi_bohr2angstroms],; [ 0.417, np.array([0.544757019107,0.0,-0.912085762652]) / psi_bohr2angstroms]]. gradient('scf', external_potentials=external_potentials). The ``external_potentials`` array has three rows for three separate; particles, and it is passed to the SCF code on the last line. The; rows are composed of the atomic charge, x coordinate, y coordinate,; and z coordinate in that order. The atomic charge and coordinates are; specified in atomic units, [e] and [a0]. Add as many particle rows as; needed to describe the full MM region. .. caution:: In |PSIfour| previous to Spring 2022 and v1.6, setting an; external potential like the above looked like ::. Chrgfield = QMMM(); Chrgfield.extern.addCharge(-0.834, 1.649232019048, 0.0, -2.3560",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:5717,Usability,simpl,simplest,5717,"als. After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; |globals__print| option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. .. index::; pair: SCF; theory. .. _`sec:scftheory`:. Theory; ~~~~~~. The objective of Hartree--Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) :math:`\{\psi_i\}`,. .. math:: \psi_i(\vec x_1) = C_{\mu i} \phi_{\mu} (\vec x_1). Here, :math:`\{\phi_{\mu}\}` are the basis functions, which, in |PSIfour| are; contracted Cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix :math:`C_{\mu i}` contains the MO coefficients, which are the; constrained variational parameters in Hartree--Fock. The molecular orbitals are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. .. math:: | \Psi_0 \rangle =; \frac{1}{\sqrt{N!}} \left | \begin{array}{cccc}; \psi_1 (\vec x_1) & \psi_2(\vec x_1) & \ldots & \psi_N (\vec x_1) \\; \psi_1 (\vec x_2) & \psi_2(\vec x_2) & \ldots & \psi_N (\vec x_2) \\; \vdots & \vdots & \ddots & \vdots \\; \psi_1 (\vec x_N) & \psi_2(\vec x_N) & \ldots & \psi_N (\vec x_N) \\; \end{array}\right |. This form for the Hartree--Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; :math:`\mathbb{R}^6` instead of a more complicated effect in; :math:`\mathbb{R}^N`\ . Considering the electronic Hamiltonian,. .. math:: \hat H = \sum_{i} -\frac{1}{2} \nabla_i^2 + \sum_{i} \sum_{A} -; \frac{Z_A}{r_{iA}} + \sum_{i>j} \frac{1}{r_{ij}},. the Hartree--Fock energy is, by Slater's rules,. .. math:: E_{\mathrm{HF}} =; \langle \Psi_0 | \hat H | \Psi_0 \rangle; = \sum_{i} \langle i | \hat h | i \rangle; + \frac 1 2 \sum_{i,j} [ii|jj",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:52385,Usability,simpl,simply,52385," Psi4 had a different set of keywords controlling instability analysis, and those were included in the CPHF module rather than the SCF module.; .. warning:: Extending Davidson instability analysis to Kohn-Sham references is under development. As of 1.7, only LDA functionals are currently supported. In case convergence problems are encountered during the Davidson procedure, file a bug report.; If the solver seems to converge on the wrong eigenvalue, try increasing |scf__solver_n_guess|.; Otherwise, if the solver is almost converged but reaches the maximum number of iterations, try increasing; |scf__solver_maxiter|. .. _`sec:scf-ecps`:. Effective core potentials (ECPs); ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. |PSIfour| supports the use of effective core potentials to describe the; innermost electrons in heavy elements.; ECPs are only available if |PSIfour| is compiled with the :ref:`LibECPInt <cmake:ecpint>` library.; If a basis set is designed to use an; effective core potential, the ECP definition should be simply placed alongside; the orbital basis set definition, *c.f.* :ref:`sec:basissets-ecps`. All; information related to the definition and number of core electrons will; automatically be detected and no further input is required to use the; ECP-containing basis set. See :srcsample:`scf-ecp` and :srcsample:`dfmp2-ecp`; for examples of computations with ECP-containing basis sets. .. warning:: Prior to May 2022, v1.6, Psi4 used a built-in ECP code. Analytic derivatives of ECPs were not available. The HF and DFT derivatives were implemented in a semi-numerical scheme, where numerical ECP gradients were added to analytic SCF gradients. For post-SCF methods, the entire gradient computation needed to be run as finite difference of energies. .. warning:: As of May 2022, v1.6, Psi4 uses the LibECPInt library, and analytic derivatives and Hessians of ECPs are available. Analytic derivatives of molecular systems including ECPs should be available whenever the method has analytic ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst:60728,Usability,simpl,simple,60728,"ist beginning at |ccenergy__r_convergence|). It is defined; according to the quantum chemical method and so its default value is set; by each module individually. .. [#f7] For frequency computations by finite difference of energies,; convergence criteria are tightened further still to 10 for; |scf__e_convergence| and |scf__d_convergence| for SCF of HF or DFT, 11; for |scf__e_convergence| and |scf__d_convergence| for SCF of post-HF,; and 10 for E_CONVERGENCE for post-HF of post-HF. .. _`sec:scfrec`:. Recommendations; ~~~~~~~~~~~~~~~. The SCF code is quite flexible and powerful.; We have tried as much as possible to keep the number of options to; a minimum and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. * For |scf__guess|, the ``SAD`` guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; * For wall time, ``DF`` may be a factor of ten or more faster than the exact; integral technologies available in |PSIfour|.; Use ``DF`` unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your orbital basis/atom type. Then use; ``DIRECT``.; * Don't mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; * Buy a developer a beer!. The ""best-practice"" input file for HF is::. memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvdz; scf_type df; guess sad; ints_tolerance 1.0E-10 # Even this is epically tight, 1.0E-8 is OK; }. energy('scf'); ",MatchSource.DOCS,doc/sphinxman/source/scf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/scf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst:2329,Availability,avail,available,2329,"fp_solver>`. .. image:: https://img.shields.io/badge/home-simint-5077AB.svg; :target: http://www.bennyp.org/research/simint/. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: http://www.bennyp.org/research/simint/. These are the vectorized implementation of the Obara-Saika (OS) method of; calculating electron repulsion integrals developed by B. Pritchard and; interfaced into libmints. Enabling simint and adding ``set; integral_package simint`` (do this in ``~/.psi4rc`` for universal effect); runs libderiv from Libint for derivative integrals and simint for; non-derivative integrals. Note that present AM maximum is ``$$(gg|gg)$$``. .. warning:: simint seems to be having some problems with Intel 2018 compilers. presently disabled in conda package. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/simint/badges/version.svg; :target: https://anaconda.org/psi4/simint. * SIMINT is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * The conda package is compiled to least-common-denominator, namely SSE instruction set. * If using the |PSIfour| binary, simint has already been installed alongside. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; simint can be obtained through ``conda install simint -c psi4``.; Then enable it as a feature with :makevar:`ENABLE_simint`,; hint its location with :makevar:`CMAKE_PREFIX_PATH`,; and rebuild |PSIfour| to detect simint and activate dependent code. .. * Previous bullet had details. To build |PSIfour| from source and use ; .. simint from conda without thinking, consult. * To remove a conda installation, ``conda remove simint``. **Source**. * .. image:: https://img.shields.io/github/tag/psi4/simint.svg?maxAge=2592000. .. :target: https://github.com/psi4/simint TODO BPP. * If using |PSIfour| built from source and you want simint built from; ",MatchSource.DOCS,doc/sphinxman/source/simint.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst:2565,Deployability,install,installed,2565,"o/badge/docs-latest-5077AB.svg; :target: http://www.bennyp.org/research/simint/. These are the vectorized implementation of the Obara-Saika (OS) method of; calculating electron repulsion integrals developed by B. Pritchard and; interfaced into libmints. Enabling simint and adding ``set; integral_package simint`` (do this in ``~/.psi4rc`` for universal effect); runs libderiv from Libint for derivative integrals and simint for; non-derivative integrals. Note that present AM maximum is ``$$(gg|gg)$$``. .. warning:: simint seems to be having some problems with Intel 2018 compilers. presently disabled in conda package. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/simint/badges/version.svg; :target: https://anaconda.org/psi4/simint. * SIMINT is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * The conda package is compiled to least-common-denominator, namely SSE instruction set. * If using the |PSIfour| binary, simint has already been installed alongside. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; simint can be obtained through ``conda install simint -c psi4``.; Then enable it as a feature with :makevar:`ENABLE_simint`,; hint its location with :makevar:`CMAKE_PREFIX_PATH`,; and rebuild |PSIfour| to detect simint and activate dependent code. .. * Previous bullet had details. To build |PSIfour| from source and use ; .. simint from conda without thinking, consult. * To remove a conda installation, ``conda remove simint``. **Source**. * .. image:: https://img.shields.io/github/tag/psi4/simint.svg?maxAge=2592000. .. :target: https://github.com/psi4/simint TODO BPP. * If using |PSIfour| built from source and you want simint built from; from source also,; enable it as a feature with :makevar:`ENABLE_simint`,; and let the build system fetch and build it and activate dependent code. .. _`cmake:simint`:. How to conf",MatchSource.DOCS,doc/sphinxman/source/simint.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst:2670,Deployability,install,installed,2670," (OS) method of; calculating electron repulsion integrals developed by B. Pritchard and; interfaced into libmints. Enabling simint and adding ``set; integral_package simint`` (do this in ``~/.psi4rc`` for universal effect); runs libderiv from Libint for derivative integrals and simint for; non-derivative integrals. Note that present AM maximum is ``$$(gg|gg)$$``. .. warning:: simint seems to be having some problems with Intel 2018 compilers. presently disabled in conda package. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/simint/badges/version.svg; :target: https://anaconda.org/psi4/simint. * SIMINT is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * The conda package is compiled to least-common-denominator, namely SSE instruction set. * If using the |PSIfour| binary, simint has already been installed alongside. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; simint can be obtained through ``conda install simint -c psi4``.; Then enable it as a feature with :makevar:`ENABLE_simint`,; hint its location with :makevar:`CMAKE_PREFIX_PATH`,; and rebuild |PSIfour| to detect simint and activate dependent code. .. * Previous bullet had details. To build |PSIfour| from source and use ; .. simint from conda without thinking, consult. * To remove a conda installation, ``conda remove simint``. **Source**. * .. image:: https://img.shields.io/github/tag/psi4/simint.svg?maxAge=2592000. .. :target: https://github.com/psi4/simint TODO BPP. * If using |PSIfour| built from source and you want simint built from; from source also,; enable it as a feature with :makevar:`ENABLE_simint`,; and let the build system fetch and build it and activate dependent code. .. _`cmake:simint`:. How to configure simint for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, simint is",MatchSource.DOCS,doc/sphinxman/source/simint.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst:2761,Deployability,install,install,2761," (OS) method of; calculating electron repulsion integrals developed by B. Pritchard and; interfaced into libmints. Enabling simint and adding ``set; integral_package simint`` (do this in ``~/.psi4rc`` for universal effect); runs libderiv from Libint for derivative integrals and simint for; non-derivative integrals. Note that present AM maximum is ``$$(gg|gg)$$``. .. warning:: simint seems to be having some problems with Intel 2018 compilers. presently disabled in conda package. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/simint/badges/version.svg; :target: https://anaconda.org/psi4/simint. * SIMINT is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * The conda package is compiled to least-common-denominator, namely SSE instruction set. * If using the |PSIfour| binary, simint has already been installed alongside. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; simint can be obtained through ``conda install simint -c psi4``.; Then enable it as a feature with :makevar:`ENABLE_simint`,; hint its location with :makevar:`CMAKE_PREFIX_PATH`,; and rebuild |PSIfour| to detect simint and activate dependent code. .. * Previous bullet had details. To build |PSIfour| from source and use ; .. simint from conda without thinking, consult. * To remove a conda installation, ``conda remove simint``. **Source**. * .. image:: https://img.shields.io/github/tag/psi4/simint.svg?maxAge=2592000. .. :target: https://github.com/psi4/simint TODO BPP. * If using |PSIfour| built from source and you want simint built from; from source also,; enable it as a feature with :makevar:`ENABLE_simint`,; and let the build system fetch and build it and activate dependent code. .. _`cmake:simint`:. How to configure simint for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, simint is",MatchSource.DOCS,doc/sphinxman/source/simint.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst:3113,Deployability,install,installation,3113,"ompilers. presently disabled in conda package. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/simint/badges/version.svg; :target: https://anaconda.org/psi4/simint. * SIMINT is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * The conda package is compiled to least-common-denominator, namely SSE instruction set. * If using the |PSIfour| binary, simint has already been installed alongside. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; simint can be obtained through ``conda install simint -c psi4``.; Then enable it as a feature with :makevar:`ENABLE_simint`,; hint its location with :makevar:`CMAKE_PREFIX_PATH`,; and rebuild |PSIfour| to detect simint and activate dependent code. .. * Previous bullet had details. To build |PSIfour| from source and use ; .. simint from conda without thinking, consult. * To remove a conda installation, ``conda remove simint``. **Source**. * .. image:: https://img.shields.io/github/tag/psi4/simint.svg?maxAge=2592000. .. :target: https://github.com/psi4/simint TODO BPP. * If using |PSIfour| built from source and you want simint built from; from source also,; enable it as a feature with :makevar:`ENABLE_simint`,; and let the build system fetch and build it and activate dependent code. .. _`cmake:simint`:. How to configure simint for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, simint is a library that provides alternate; integrals. * Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) simint. * Upstream Dependencies |w---w| simint |dr| None. **CMake Variables**. * :makevar:`ENABLE_simint` |w---w| CMake variable toggling whether |PSIfour| builds with simint; * :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation dir",MatchSource.DOCS,doc/sphinxman/source/simint.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst:4106,Deployability,install,installation,4106,"on, ``conda remove simint``. **Source**. * .. image:: https://img.shields.io/github/tag/psi4/simint.svg?maxAge=2592000. .. :target: https://github.com/psi4/simint TODO BPP. * If using |PSIfour| built from source and you want simint built from; from source also,; enable it as a feature with :makevar:`ENABLE_simint`,; and let the build system fetch and build it and activate dependent code. .. _`cmake:simint`:. How to configure simint for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, simint is a library that provides alternate; integrals. * Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) simint. * Upstream Dependencies |w---w| simint |dr| None. **CMake Variables**. * :makevar:`ENABLE_simint` |w---w| CMake variable toggling whether |PSIfour| builds with simint; * :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing ``include/simint/simint.h``; * :makevar:`simint_DIR` |w---w| CMake variable to specify where pre-built simint can be found. Set to installation directory containing ``share/cmake/simint/simintConfig.cmake``; * :makevar:`CMAKE_DISABLE_FIND_PACKAGE_simint` |w---w| CMake variable to force internal build of simint instead of detecting pre-built; * :makevar:`CMAKE_INSIST_FIND_PACKAGE_simint` |w---w| CMake variable to force detecting pre-built simint and not falling back on internal build; * :makevar:`SIMINT_VECTOR` |w---w| CMake variable for simint vectorization (i.e., scalar sse avx avxfma micavx512). Default is ``avx``, *not* detected, so ``sse`` may be required for older chipsets. See http://www.bennyp.org/research/simint/README.txt for details. **Examples**. A. Build bundled. .. code-block:: bash. >>> cmake -DENABLE_simint=ON. B. Build *without* simint. .. code-block:: bash. >>> cmake. C. Link against pre-built. .. code-block:: bash. >>> cmake -DENABLE_simint=ON -DCMAKE_",MatchSource.DOCS,doc/sphinxman/source/simint.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst:4271,Deployability,install,installation,4271,"using |PSIfour| built from source and you want simint built from; from source also,; enable it as a feature with :makevar:`ENABLE_simint`,; and let the build system fetch and build it and activate dependent code. .. _`cmake:simint`:. How to configure simint for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, simint is a library that provides alternate; integrals. * Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) simint. * Upstream Dependencies |w---w| simint |dr| None. **CMake Variables**. * :makevar:`ENABLE_simint` |w---w| CMake variable toggling whether |PSIfour| builds with simint; * :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing ``include/simint/simint.h``; * :makevar:`simint_DIR` |w---w| CMake variable to specify where pre-built simint can be found. Set to installation directory containing ``share/cmake/simint/simintConfig.cmake``; * :makevar:`CMAKE_DISABLE_FIND_PACKAGE_simint` |w---w| CMake variable to force internal build of simint instead of detecting pre-built; * :makevar:`CMAKE_INSIST_FIND_PACKAGE_simint` |w---w| CMake variable to force detecting pre-built simint and not falling back on internal build; * :makevar:`SIMINT_VECTOR` |w---w| CMake variable for simint vectorization (i.e., scalar sse avx avxfma micavx512). Default is ``avx``, *not* detected, so ``sse`` may be required for older chipsets. See http://www.bennyp.org/research/simint/README.txt for details. **Examples**. A. Build bundled. .. code-block:: bash. >>> cmake -DENABLE_simint=ON. B. Build *without* simint. .. code-block:: bash. >>> cmake. C. Link against pre-built. .. code-block:: bash. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/simint/root. .. code-block:: bash. >>> cmake -DENABLE_simint=ON -Dsimint_DIR=/path/to/simint/configdir. D. Build bundled despite pre-built being detectable.",MatchSource.DOCS,doc/sphinxman/source/simint.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst:1774,Integrability,interface,interfaced,1774,"hould have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index:: SIMINT, integrals. .. _`sec:simint`:. Interface to SIMINT by B. Pritchard; ===================================. .. codeauthor:: Benjamin P. Pritchard; .. sectionauthor:: Lori A. Burns. .. *Module:* :ref:`Keywords <apdx:efp>`, :ref:`PSI Variables <apdx:efp_psivar>`, :source:`LIBEFP <src/lib/libefp_solver>`. .. image:: https://img.shields.io/badge/home-simint-5077AB.svg; :target: http://www.bennyp.org/research/simint/. .. raw:: html. <br>. .. image:: https://img.shields.io/badge/docs-latest-5077AB.svg; :target: http://www.bennyp.org/research/simint/. These are the vectorized implementation of the Obara-Saika (OS) method of; calculating electron repulsion integrals developed by B. Pritchard and; interfaced into libmints. Enabling simint and adding ``set; integral_package simint`` (do this in ``~/.psi4rc`` for universal effect); runs libderiv from Libint for derivative integrals and simint for; non-derivative integrals. Note that present AM maximum is ``$$(gg|gg)$$``. .. warning:: simint seems to be having some problems with Intel 2018 compilers. presently disabled in conda package. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/simint/badges/version.svg; :target: https://anaconda.org/psi4/simint. * SIMINT is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * The conda package is compiled to least-common-denominator, namely SSE instruction set. * If using the |PSIfour| binary, simint has already been installed alongside. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; simint can be obtained through ``conda install simint -c ",MatchSource.DOCS,doc/sphinxman/source/simint.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst:2954,Integrability,depend,dependent,2954,"psi4rc`` for universal effect); runs libderiv from Libint for derivative integrals and simint for; non-derivative integrals. Note that present AM maximum is ``$$(gg|gg)$$``. .. warning:: simint seems to be having some problems with Intel 2018 compilers. presently disabled in conda package. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/simint/badges/version.svg; :target: https://anaconda.org/psi4/simint. * SIMINT is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * The conda package is compiled to least-common-denominator, namely SSE instruction set. * If using the |PSIfour| binary, simint has already been installed alongside. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; simint can be obtained through ``conda install simint -c psi4``.; Then enable it as a feature with :makevar:`ENABLE_simint`,; hint its location with :makevar:`CMAKE_PREFIX_PATH`,; and rebuild |PSIfour| to detect simint and activate dependent code. .. * Previous bullet had details. To build |PSIfour| from source and use ; .. simint from conda without thinking, consult. * To remove a conda installation, ``conda remove simint``. **Source**. * .. image:: https://img.shields.io/github/tag/psi4/simint.svg?maxAge=2592000. .. :target: https://github.com/psi4/simint TODO BPP. * If using |PSIfour| built from source and you want simint built from; from source also,; enable it as a feature with :makevar:`ENABLE_simint`,; and let the build system fetch and build it and activate dependent code. .. _`cmake:simint`:. How to configure simint for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, simint is a library that provides alternate; integrals. * Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) simint. * Upstream Dependencies |w---w| simint |dr| None. **CMake Variables**. * :m",MatchSource.DOCS,doc/sphinxman/source/simint.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst:3498,Integrability,depend,dependent,3498,"Ubuntu shell). * The conda package is compiled to least-common-denominator, namely SSE instruction set. * If using the |PSIfour| binary, simint has already been installed alongside. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; simint can be obtained through ``conda install simint -c psi4``.; Then enable it as a feature with :makevar:`ENABLE_simint`,; hint its location with :makevar:`CMAKE_PREFIX_PATH`,; and rebuild |PSIfour| to detect simint and activate dependent code. .. * Previous bullet had details. To build |PSIfour| from source and use ; .. simint from conda without thinking, consult. * To remove a conda installation, ``conda remove simint``. **Source**. * .. image:: https://img.shields.io/github/tag/psi4/simint.svg?maxAge=2592000. .. :target: https://github.com/psi4/simint TODO BPP. * If using |PSIfour| built from source and you want simint built from; from source also,; enable it as a feature with :makevar:`ENABLE_simint`,; and let the build system fetch and build it and activate dependent code. .. _`cmake:simint`:. How to configure simint for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, simint is a library that provides alternate; integrals. * Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) simint. * Upstream Dependencies |w---w| simint |dr| None. **CMake Variables**. * :makevar:`ENABLE_simint` |w---w| CMake variable toggling whether |PSIfour| builds with simint; * :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing ``include/simint/simint.h``; * :makevar:`simint_DIR` |w---w| CMake variable to specify where pre-built simint can be found. Set to installation directory containing ``share/cmake/simint/simintConfig.cmake``; * :makevar:`CMAKE_DISABLE_FIND_PACKAGE_simint` |w---w| C",MatchSource.DOCS,doc/sphinxman/source/simint.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst:4057,Integrability,depend,dependencies,4057,"vious bullet had details. To build |PSIfour| from source and use ; .. simint from conda without thinking, consult. * To remove a conda installation, ``conda remove simint``. **Source**. * .. image:: https://img.shields.io/github/tag/psi4/simint.svg?maxAge=2592000. .. :target: https://github.com/psi4/simint TODO BPP. * If using |PSIfour| built from source and you want simint built from; from source also,; enable it as a feature with :makevar:`ENABLE_simint`,; and let the build system fetch and build it and activate dependent code. .. _`cmake:simint`:. How to configure simint for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, simint is a library that provides alternate; integrals. * Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) simint. * Upstream Dependencies |w---w| simint |dr| None. **CMake Variables**. * :makevar:`ENABLE_simint` |w---w| CMake variable toggling whether |PSIfour| builds with simint; * :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing ``include/simint/simint.h``; * :makevar:`simint_DIR` |w---w| CMake variable to specify where pre-built simint can be found. Set to installation directory containing ``share/cmake/simint/simintConfig.cmake``; * :makevar:`CMAKE_DISABLE_FIND_PACKAGE_simint` |w---w| CMake variable to force internal build of simint instead of detecting pre-built; * :makevar:`CMAKE_INSIST_FIND_PACKAGE_simint` |w---w| CMake variable to force detecting pre-built simint and not falling back on internal build; * :makevar:`SIMINT_VECTOR` |w---w| CMake variable for simint vectorization (i.e., scalar sse avx avxfma micavx512). Default is ``avx``, *not* detected, so ``sse`` may be required for older chipsets. See http://www.bennyp.org/research/simint/README.txt for details. **Examples**. A. Build bundled. .. code-block:: bash. >>> cmake -DENABLE_simint=ON. ",MatchSource.DOCS,doc/sphinxman/source/simint.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst:5420,Integrability,depend,dependencies,5420,"ild it and activate dependent code. .. _`cmake:simint`:. How to configure simint for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, simint is a library that provides alternate; integrals. * Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) simint. * Upstream Dependencies |w---w| simint |dr| None. **CMake Variables**. * :makevar:`ENABLE_simint` |w---w| CMake variable toggling whether |PSIfour| builds with simint; * :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing ``include/simint/simint.h``; * :makevar:`simint_DIR` |w---w| CMake variable to specify where pre-built simint can be found. Set to installation directory containing ``share/cmake/simint/simintConfig.cmake``; * :makevar:`CMAKE_DISABLE_FIND_PACKAGE_simint` |w---w| CMake variable to force internal build of simint instead of detecting pre-built; * :makevar:`CMAKE_INSIST_FIND_PACKAGE_simint` |w---w| CMake variable to force detecting pre-built simint and not falling back on internal build; * :makevar:`SIMINT_VECTOR` |w---w| CMake variable for simint vectorization (i.e., scalar sse avx avxfma micavx512). Default is ``avx``, *not* detected, so ``sse`` may be required for older chipsets. See http://www.bennyp.org/research/simint/README.txt for details. **Examples**. A. Build bundled. .. code-block:: bash. >>> cmake -DENABLE_simint=ON. B. Build *without* simint. .. code-block:: bash. >>> cmake. C. Link against pre-built. .. code-block:: bash. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/simint/root. .. code-block:: bash. >>> cmake -DENABLE_simint=ON -Dsimint_DIR=/path/to/simint/configdir. D. Build bundled despite pre-built being detectable. .. code-block:: bash. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/simint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_simint=ON. ",MatchSource.DOCS,doc/sphinxman/source/simint.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst:3542,Modifiability,config,configure,3542,"ongside. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; simint can be obtained through ``conda install simint -c psi4``.; Then enable it as a feature with :makevar:`ENABLE_simint`,; hint its location with :makevar:`CMAKE_PREFIX_PATH`,; and rebuild |PSIfour| to detect simint and activate dependent code. .. * Previous bullet had details. To build |PSIfour| from source and use ; .. simint from conda without thinking, consult. * To remove a conda installation, ``conda remove simint``. **Source**. * .. image:: https://img.shields.io/github/tag/psi4/simint.svg?maxAge=2592000. .. :target: https://github.com/psi4/simint TODO BPP. * If using |PSIfour| built from source and you want simint built from; from source also,; enable it as a feature with :makevar:`ENABLE_simint`,; and let the build system fetch and build it and activate dependent code. .. _`cmake:simint`:. How to configure simint for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, simint is a library that provides alternate; integrals. * Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) simint. * Upstream Dependencies |w---w| simint |dr| None. **CMake Variables**. * :makevar:`ENABLE_simint` |w---w| CMake variable toggling whether |PSIfour| builds with simint; * :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing ``include/simint/simint.h``; * :makevar:`simint_DIR` |w---w| CMake variable to specify where pre-built simint can be found. Set to installation directory containing ``share/cmake/simint/simintConfig.cmake``; * :makevar:`CMAKE_DISABLE_FIND_PACKAGE_simint` |w---w| CMake variable to force internal build of simint instead of detecting pre-built; * :makevar:`CMAKE_INSIST_FIND_PACKAGE_simint` |w---w| CMake variable to force detecting pre-b",MatchSource.DOCS,doc/sphinxman/source/simint.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst:3915,Modifiability,variab,variable,3915,"vious bullet had details. To build |PSIfour| from source and use ; .. simint from conda without thinking, consult. * To remove a conda installation, ``conda remove simint``. **Source**. * .. image:: https://img.shields.io/github/tag/psi4/simint.svg?maxAge=2592000. .. :target: https://github.com/psi4/simint TODO BPP. * If using |PSIfour| built from source and you want simint built from; from source also,; enable it as a feature with :makevar:`ENABLE_simint`,; and let the build system fetch and build it and activate dependent code. .. _`cmake:simint`:. How to configure simint for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, simint is a library that provides alternate; integrals. * Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) simint. * Upstream Dependencies |w---w| simint |dr| None. **CMake Variables**. * :makevar:`ENABLE_simint` |w---w| CMake variable toggling whether |PSIfour| builds with simint; * :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing ``include/simint/simint.h``; * :makevar:`simint_DIR` |w---w| CMake variable to specify where pre-built simint can be found. Set to installation directory containing ``share/cmake/simint/simintConfig.cmake``; * :makevar:`CMAKE_DISABLE_FIND_PACKAGE_simint` |w---w| CMake variable to force internal build of simint instead of detecting pre-built; * :makevar:`CMAKE_INSIST_FIND_PACKAGE_simint` |w---w| CMake variable to force detecting pre-built simint and not falling back on internal build; * :makevar:`SIMINT_VECTOR` |w---w| CMake variable for simint vectorization (i.e., scalar sse avx avxfma micavx512). Default is ``avx``, *not* detected, so ``sse`` may be required for older chipsets. See http://www.bennyp.org/research/simint/README.txt for details. **Examples**. A. Build bundled. .. code-block:: bash. >>> cmake -DENABLE_simint=ON. ",MatchSource.DOCS,doc/sphinxman/source/simint.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst:4021,Modifiability,variab,variable,4021,"vious bullet had details. To build |PSIfour| from source and use ; .. simint from conda without thinking, consult. * To remove a conda installation, ``conda remove simint``. **Source**. * .. image:: https://img.shields.io/github/tag/psi4/simint.svg?maxAge=2592000. .. :target: https://github.com/psi4/simint TODO BPP. * If using |PSIfour| built from source and you want simint built from; from source also,; enable it as a feature with :makevar:`ENABLE_simint`,; and let the build system fetch and build it and activate dependent code. .. _`cmake:simint`:. How to configure simint for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, simint is a library that provides alternate; integrals. * Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) simint. * Upstream Dependencies |w---w| simint |dr| None. **CMake Variables**. * :makevar:`ENABLE_simint` |w---w| CMake variable toggling whether |PSIfour| builds with simint; * :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing ``include/simint/simint.h``; * :makevar:`simint_DIR` |w---w| CMake variable to specify where pre-built simint can be found. Set to installation directory containing ``share/cmake/simint/simintConfig.cmake``; * :makevar:`CMAKE_DISABLE_FIND_PACKAGE_simint` |w---w| CMake variable to force internal build of simint instead of detecting pre-built; * :makevar:`CMAKE_INSIST_FIND_PACKAGE_simint` |w---w| CMake variable to force detecting pre-built simint and not falling back on internal build; * :makevar:`SIMINT_VECTOR` |w---w| CMake variable for simint vectorization (i.e., scalar sse avx avxfma micavx512). Default is ``avx``, *not* detected, so ``sse`` may be required for older chipsets. See http://www.bennyp.org/research/simint/README.txt for details. **Examples**. A. Build bundled. .. code-block:: bash. >>> cmake -DENABLE_simint=ON. ",MatchSource.DOCS,doc/sphinxman/source/simint.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst:4207,Modifiability,variab,variable,4207,"i4/simint.svg?maxAge=2592000. .. :target: https://github.com/psi4/simint TODO BPP. * If using |PSIfour| built from source and you want simint built from; from source also,; enable it as a feature with :makevar:`ENABLE_simint`,; and let the build system fetch and build it and activate dependent code. .. _`cmake:simint`:. How to configure simint for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, simint is a library that provides alternate; integrals. * Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) simint. * Upstream Dependencies |w---w| simint |dr| None. **CMake Variables**. * :makevar:`ENABLE_simint` |w---w| CMake variable toggling whether |PSIfour| builds with simint; * :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing ``include/simint/simint.h``; * :makevar:`simint_DIR` |w---w| CMake variable to specify where pre-built simint can be found. Set to installation directory containing ``share/cmake/simint/simintConfig.cmake``; * :makevar:`CMAKE_DISABLE_FIND_PACKAGE_simint` |w---w| CMake variable to force internal build of simint instead of detecting pre-built; * :makevar:`CMAKE_INSIST_FIND_PACKAGE_simint` |w---w| CMake variable to force detecting pre-built simint and not falling back on internal build; * :makevar:`SIMINT_VECTOR` |w---w| CMake variable for simint vectorization (i.e., scalar sse avx avxfma micavx512). Default is ``avx``, *not* detected, so ``sse`` may be required for older chipsets. See http://www.bennyp.org/research/simint/README.txt for details. **Examples**. A. Build bundled. .. code-block:: bash. >>> cmake -DENABLE_simint=ON. B. Build *without* simint. .. code-block:: bash. >>> cmake. C. Link against pre-built. .. code-block:: bash. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/simint/root. .. code-block:: bash. >>> cmake -DENABLE_simint=ON -Dsim",MatchSource.DOCS,doc/sphinxman/source/simint.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst:4409,Modifiability,variab,variable,4409,"ild it and activate dependent code. .. _`cmake:simint`:. How to configure simint for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, simint is a library that provides alternate; integrals. * Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) simint. * Upstream Dependencies |w---w| simint |dr| None. **CMake Variables**. * :makevar:`ENABLE_simint` |w---w| CMake variable toggling whether |PSIfour| builds with simint; * :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing ``include/simint/simint.h``; * :makevar:`simint_DIR` |w---w| CMake variable to specify where pre-built simint can be found. Set to installation directory containing ``share/cmake/simint/simintConfig.cmake``; * :makevar:`CMAKE_DISABLE_FIND_PACKAGE_simint` |w---w| CMake variable to force internal build of simint instead of detecting pre-built; * :makevar:`CMAKE_INSIST_FIND_PACKAGE_simint` |w---w| CMake variable to force detecting pre-built simint and not falling back on internal build; * :makevar:`SIMINT_VECTOR` |w---w| CMake variable for simint vectorization (i.e., scalar sse avx avxfma micavx512). Default is ``avx``, *not* detected, so ``sse`` may be required for older chipsets. See http://www.bennyp.org/research/simint/README.txt for details. **Examples**. A. Build bundled. .. code-block:: bash. >>> cmake -DENABLE_simint=ON. B. Build *without* simint. .. code-block:: bash. >>> cmake. C. Link against pre-built. .. code-block:: bash. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/simint/root. .. code-block:: bash. >>> cmake -DENABLE_simint=ON -Dsimint_DIR=/path/to/simint/configdir. D. Build bundled despite pre-built being detectable. .. code-block:: bash. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/simint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_simint=ON. ",MatchSource.DOCS,doc/sphinxman/source/simint.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst:4544,Modifiability,variab,variable,4544,"ild it and activate dependent code. .. _`cmake:simint`:. How to configure simint for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, simint is a library that provides alternate; integrals. * Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) simint. * Upstream Dependencies |w---w| simint |dr| None. **CMake Variables**. * :makevar:`ENABLE_simint` |w---w| CMake variable toggling whether |PSIfour| builds with simint; * :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing ``include/simint/simint.h``; * :makevar:`simint_DIR` |w---w| CMake variable to specify where pre-built simint can be found. Set to installation directory containing ``share/cmake/simint/simintConfig.cmake``; * :makevar:`CMAKE_DISABLE_FIND_PACKAGE_simint` |w---w| CMake variable to force internal build of simint instead of detecting pre-built; * :makevar:`CMAKE_INSIST_FIND_PACKAGE_simint` |w---w| CMake variable to force detecting pre-built simint and not falling back on internal build; * :makevar:`SIMINT_VECTOR` |w---w| CMake variable for simint vectorization (i.e., scalar sse avx avxfma micavx512). Default is ``avx``, *not* detected, so ``sse`` may be required for older chipsets. See http://www.bennyp.org/research/simint/README.txt for details. **Examples**. A. Build bundled. .. code-block:: bash. >>> cmake -DENABLE_simint=ON. B. Build *without* simint. .. code-block:: bash. >>> cmake. C. Link against pre-built. .. code-block:: bash. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/simint/root. .. code-block:: bash. >>> cmake -DENABLE_simint=ON -Dsimint_DIR=/path/to/simint/configdir. D. Build bundled despite pre-built being detectable. .. code-block:: bash. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/simint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_simint=ON. ",MatchSource.DOCS,doc/sphinxman/source/simint.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst:4670,Modifiability,variab,variable,4670,"ild it and activate dependent code. .. _`cmake:simint`:. How to configure simint for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, simint is a library that provides alternate; integrals. * Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) simint. * Upstream Dependencies |w---w| simint |dr| None. **CMake Variables**. * :makevar:`ENABLE_simint` |w---w| CMake variable toggling whether |PSIfour| builds with simint; * :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing ``include/simint/simint.h``; * :makevar:`simint_DIR` |w---w| CMake variable to specify where pre-built simint can be found. Set to installation directory containing ``share/cmake/simint/simintConfig.cmake``; * :makevar:`CMAKE_DISABLE_FIND_PACKAGE_simint` |w---w| CMake variable to force internal build of simint instead of detecting pre-built; * :makevar:`CMAKE_INSIST_FIND_PACKAGE_simint` |w---w| CMake variable to force detecting pre-built simint and not falling back on internal build; * :makevar:`SIMINT_VECTOR` |w---w| CMake variable for simint vectorization (i.e., scalar sse avx avxfma micavx512). Default is ``avx``, *not* detected, so ``sse`` may be required for older chipsets. See http://www.bennyp.org/research/simint/README.txt for details. **Examples**. A. Build bundled. .. code-block:: bash. >>> cmake -DENABLE_simint=ON. B. Build *without* simint. .. code-block:: bash. >>> cmake. C. Link against pre-built. .. code-block:: bash. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/simint/root. .. code-block:: bash. >>> cmake -DENABLE_simint=ON -Dsimint_DIR=/path/to/simint/configdir. D. Build bundled despite pre-built being detectable. .. code-block:: bash. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/simint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_simint=ON. ",MatchSource.DOCS,doc/sphinxman/source/simint.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst:5238,Modifiability,config,configdir,5238,"ild it and activate dependent code. .. _`cmake:simint`:. How to configure simint for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, simint is a library that provides alternate; integrals. * Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) simint. * Upstream Dependencies |w---w| simint |dr| None. **CMake Variables**. * :makevar:`ENABLE_simint` |w---w| CMake variable toggling whether |PSIfour| builds with simint; * :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing ``include/simint/simint.h``; * :makevar:`simint_DIR` |w---w| CMake variable to specify where pre-built simint can be found. Set to installation directory containing ``share/cmake/simint/simintConfig.cmake``; * :makevar:`CMAKE_DISABLE_FIND_PACKAGE_simint` |w---w| CMake variable to force internal build of simint instead of detecting pre-built; * :makevar:`CMAKE_INSIST_FIND_PACKAGE_simint` |w---w| CMake variable to force detecting pre-built simint and not falling back on internal build; * :makevar:`SIMINT_VECTOR` |w---w| CMake variable for simint vectorization (i.e., scalar sse avx avxfma micavx512). Default is ``avx``, *not* detected, so ``sse`` may be required for older chipsets. See http://www.bennyp.org/research/simint/README.txt for details. **Examples**. A. Build bundled. .. code-block:: bash. >>> cmake -DENABLE_simint=ON. B. Build *without* simint. .. code-block:: bash. >>> cmake. C. Link against pre-built. .. code-block:: bash. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/simint/root. .. code-block:: bash. >>> cmake -DENABLE_simint=ON -Dsimint_DIR=/path/to/simint/configdir. D. Build bundled despite pre-built being detectable. .. code-block:: bash. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/simint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_simint=ON. ",MatchSource.DOCS,doc/sphinxman/source/simint.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst:2927,Safety,detect,detect,2927,"psi4rc`` for universal effect); runs libderiv from Libint for derivative integrals and simint for; non-derivative integrals. Note that present AM maximum is ``$$(gg|gg)$$``. .. warning:: simint seems to be having some problems with Intel 2018 compilers. presently disabled in conda package. Installation; ~~~~~~~~~~~~. **Binary**. * .. image:: https://anaconda.org/psi4/simint/badges/version.svg; :target: https://anaconda.org/psi4/simint. * SIMINT is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell). * The conda package is compiled to least-common-denominator, namely SSE instruction set. * If using the |PSIfour| binary, simint has already been installed alongside. * If using |PSIfour| built from source, and anaconda or miniconda has; already been installed (instructions at :ref:`sec:quickconda`),; simint can be obtained through ``conda install simint -c psi4``.; Then enable it as a feature with :makevar:`ENABLE_simint`,; hint its location with :makevar:`CMAKE_PREFIX_PATH`,; and rebuild |PSIfour| to detect simint and activate dependent code. .. * Previous bullet had details. To build |PSIfour| from source and use ; .. simint from conda without thinking, consult. * To remove a conda installation, ``conda remove simint``. **Source**. * .. image:: https://img.shields.io/github/tag/psi4/simint.svg?maxAge=2592000. .. :target: https://github.com/psi4/simint TODO BPP. * If using |PSIfour| built from source and you want simint built from; from source also,; enable it as a feature with :makevar:`ENABLE_simint`,; and let the build system fetch and build it and activate dependent code. .. _`cmake:simint`:. How to configure simint for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, simint is a library that provides alternate; integrals. * Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) simint. * Upstream Dependencies |w---w| simint |dr| None. **CMake Variables**. * :m",MatchSource.DOCS,doc/sphinxman/source/simint.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst:4463,Safety,detect,detecting,4463,"ild it and activate dependent code. .. _`cmake:simint`:. How to configure simint for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, simint is a library that provides alternate; integrals. * Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) simint. * Upstream Dependencies |w---w| simint |dr| None. **CMake Variables**. * :makevar:`ENABLE_simint` |w---w| CMake variable toggling whether |PSIfour| builds with simint; * :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing ``include/simint/simint.h``; * :makevar:`simint_DIR` |w---w| CMake variable to specify where pre-built simint can be found. Set to installation directory containing ``share/cmake/simint/simintConfig.cmake``; * :makevar:`CMAKE_DISABLE_FIND_PACKAGE_simint` |w---w| CMake variable to force internal build of simint instead of detecting pre-built; * :makevar:`CMAKE_INSIST_FIND_PACKAGE_simint` |w---w| CMake variable to force detecting pre-built simint and not falling back on internal build; * :makevar:`SIMINT_VECTOR` |w---w| CMake variable for simint vectorization (i.e., scalar sse avx avxfma micavx512). Default is ``avx``, *not* detected, so ``sse`` may be required for older chipsets. See http://www.bennyp.org/research/simint/README.txt for details. **Examples**. A. Build bundled. .. code-block:: bash. >>> cmake -DENABLE_simint=ON. B. Build *without* simint. .. code-block:: bash. >>> cmake. C. Link against pre-built. .. code-block:: bash. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/simint/root. .. code-block:: bash. >>> cmake -DENABLE_simint=ON -Dsimint_DIR=/path/to/simint/configdir. D. Build bundled despite pre-built being detectable. .. code-block:: bash. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/simint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_simint=ON. ",MatchSource.DOCS,doc/sphinxman/source/simint.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst:4562,Safety,detect,detecting,4562,"ild it and activate dependent code. .. _`cmake:simint`:. How to configure simint for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, simint is a library that provides alternate; integrals. * Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) simint. * Upstream Dependencies |w---w| simint |dr| None. **CMake Variables**. * :makevar:`ENABLE_simint` |w---w| CMake variable toggling whether |PSIfour| builds with simint; * :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing ``include/simint/simint.h``; * :makevar:`simint_DIR` |w---w| CMake variable to specify where pre-built simint can be found. Set to installation directory containing ``share/cmake/simint/simintConfig.cmake``; * :makevar:`CMAKE_DISABLE_FIND_PACKAGE_simint` |w---w| CMake variable to force internal build of simint instead of detecting pre-built; * :makevar:`CMAKE_INSIST_FIND_PACKAGE_simint` |w---w| CMake variable to force detecting pre-built simint and not falling back on internal build; * :makevar:`SIMINT_VECTOR` |w---w| CMake variable for simint vectorization (i.e., scalar sse avx avxfma micavx512). Default is ``avx``, *not* detected, so ``sse`` may be required for older chipsets. See http://www.bennyp.org/research/simint/README.txt for details. **Examples**. A. Build bundled. .. code-block:: bash. >>> cmake -DENABLE_simint=ON. B. Build *without* simint. .. code-block:: bash. >>> cmake. C. Link against pre-built. .. code-block:: bash. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/simint/root. .. code-block:: bash. >>> cmake -DENABLE_simint=ON -Dsimint_DIR=/path/to/simint/configdir. D. Build bundled despite pre-built being detectable. .. code-block:: bash. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/simint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_simint=ON. ",MatchSource.DOCS,doc/sphinxman/source/simint.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst:4771,Safety,detect,detected,4771,"ild it and activate dependent code. .. _`cmake:simint`:. How to configure simint for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, simint is a library that provides alternate; integrals. * Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) simint. * Upstream Dependencies |w---w| simint |dr| None. **CMake Variables**. * :makevar:`ENABLE_simint` |w---w| CMake variable toggling whether |PSIfour| builds with simint; * :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing ``include/simint/simint.h``; * :makevar:`simint_DIR` |w---w| CMake variable to specify where pre-built simint can be found. Set to installation directory containing ``share/cmake/simint/simintConfig.cmake``; * :makevar:`CMAKE_DISABLE_FIND_PACKAGE_simint` |w---w| CMake variable to force internal build of simint instead of detecting pre-built; * :makevar:`CMAKE_INSIST_FIND_PACKAGE_simint` |w---w| CMake variable to force detecting pre-built simint and not falling back on internal build; * :makevar:`SIMINT_VECTOR` |w---w| CMake variable for simint vectorization (i.e., scalar sse avx avxfma micavx512). Default is ``avx``, *not* detected, so ``sse`` may be required for older chipsets. See http://www.bennyp.org/research/simint/README.txt for details. **Examples**. A. Build bundled. .. code-block:: bash. >>> cmake -DENABLE_simint=ON. B. Build *without* simint. .. code-block:: bash. >>> cmake. C. Link against pre-built. .. code-block:: bash. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/simint/root. .. code-block:: bash. >>> cmake -DENABLE_simint=ON -Dsimint_DIR=/path/to/simint/configdir. D. Build bundled despite pre-built being detectable. .. code-block:: bash. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/simint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_simint=ON. ",MatchSource.DOCS,doc/sphinxman/source/simint.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst:5290,Safety,detect,detectable,5290,"ild it and activate dependent code. .. _`cmake:simint`:. How to configure simint for building Psi4; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. **Role and Dependencies**. * Role |w---w| In |PSIfour|, simint is a library that provides alternate; integrals. * Downstream Dependencies |w---w| |PSIfour| (\ |dr| optional) simint. * Upstream Dependencies |w---w| simint |dr| None. **CMake Variables**. * :makevar:`ENABLE_simint` |w---w| CMake variable toggling whether |PSIfour| builds with simint; * :makevar:`CMAKE_PREFIX_PATH` |w---w| CMake list variable to specify where pre-built dependencies can be found. For simint, set to an installation directory containing ``include/simint/simint.h``; * :makevar:`simint_DIR` |w---w| CMake variable to specify where pre-built simint can be found. Set to installation directory containing ``share/cmake/simint/simintConfig.cmake``; * :makevar:`CMAKE_DISABLE_FIND_PACKAGE_simint` |w---w| CMake variable to force internal build of simint instead of detecting pre-built; * :makevar:`CMAKE_INSIST_FIND_PACKAGE_simint` |w---w| CMake variable to force detecting pre-built simint and not falling back on internal build; * :makevar:`SIMINT_VECTOR` |w---w| CMake variable for simint vectorization (i.e., scalar sse avx avxfma micavx512). Default is ``avx``, *not* detected, so ``sse`` may be required for older chipsets. See http://www.bennyp.org/research/simint/README.txt for details. **Examples**. A. Build bundled. .. code-block:: bash. >>> cmake -DENABLE_simint=ON. B. Build *without* simint. .. code-block:: bash. >>> cmake. C. Link against pre-built. .. code-block:: bash. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/simint/root. .. code-block:: bash. >>> cmake -DENABLE_simint=ON -Dsimint_DIR=/path/to/simint/configdir. D. Build bundled despite pre-built being detectable. .. code-block:: bash. >>> cmake -DENABLE_simint=ON -DCMAKE_PREFIX_PATH=/path/to/unwanted/simint/root/and/wanted/other/dependencies/root -DCMAKE_DISABLE_FIND_PACKAGE_simint=ON. ",MatchSource.DOCS,doc/sphinxman/source/simint.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/simint.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sowreap.rst:1489,Availability,avail,available,1489,"e Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:sowreap`:. Embarrassing Parallelism; ========================. Many of the tasks automated by Python wrappers consist of a number of; independent |PSIfour| calculations and are thus suited to an embarrassingly; parallel mode of operation. In Psithon, these have been dubbed sow/reap; procedures and have the following general structure. - Prepare an input file, simply adding ``mode='sow'`` to the; argument list of an available Python function. Run this quick job to; produce input files for lengthier calculations. - According to the instructions in the output file of the above step,; run the generated input files in any order on any variety of computers; and architectures. This is the time-intensive portion of the; calculation. - The 'sow' stage also produces a *master* input file (with a; ``mode='reap'`` directive). When all the jobs in the above step are; completed, place their output files in the same location as the; *master* input, and run this last, quick job to collect the results. - Sow/reap procedures are governed by the **mode** keyword, choices being; ``'continuous'``, ``'sow'``, and ``'reap'``. Only ``'sow'`` is likely to; be used by the user, as ``'continuous'`` is always the default, and; input files with ``'reap'`` are autogenerated. - Embarrassingly parallel algorithm available at present for:. - :ref:`sec:db()` ; - finite difference operation of :ref:`sec",MatchSource.DOCS,doc/sphinxman/source/sowreap.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sowreap.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sowreap.rst:2372,Availability,avail,available,2372,"treet, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:sowreap`:. Embarrassing Parallelism; ========================. Many of the tasks automated by Python wrappers consist of a number of; independent |PSIfour| calculations and are thus suited to an embarrassingly; parallel mode of operation. In Psithon, these have been dubbed sow/reap; procedures and have the following general structure. - Prepare an input file, simply adding ``mode='sow'`` to the; argument list of an available Python function. Run this quick job to; produce input files for lengthier calculations. - According to the instructions in the output file of the above step,; run the generated input files in any order on any variety of computers; and architectures. This is the time-intensive portion of the; calculation. - The 'sow' stage also produces a *master* input file (with a; ``mode='reap'`` directive). When all the jobs in the above step are; completed, place their output files in the same location as the; *master* input, and run this last, quick job to collect the results. - Sow/reap procedures are governed by the **mode** keyword, choices being; ``'continuous'``, ``'sow'``, and ``'reap'``. Only ``'sow'`` is likely to; be used by the user, as ``'continuous'`` is always the default, and; input files with ``'reap'`` are autogenerated. - Embarrassingly parallel algorithm available at present for:. - :ref:`sec:db()` ; - finite difference operation of :ref:`sec:opt()` ; - finite difference of energies of :ref:`sec:freq()`; - finite difference of gradients of :ref:`sec:freq()`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Local options (*e.g.*, ``set scf e_convergence 9``) will not get transmitted to the child jobs. - Array options (*e.g.*, ``set states_per_irrep [2, 1]``) will not get transmitted to the child jobs. - Function intercalls (*e.g.*, db(opt())) are not tested with sow/reap procedures. ",MatchSource.DOCS,doc/sphinxman/source/sowreap.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sowreap.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sowreap.rst:2149,Deployability,continuous,continuous,2149,"treet, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:sowreap`:. Embarrassing Parallelism; ========================. Many of the tasks automated by Python wrappers consist of a number of; independent |PSIfour| calculations and are thus suited to an embarrassingly; parallel mode of operation. In Psithon, these have been dubbed sow/reap; procedures and have the following general structure. - Prepare an input file, simply adding ``mode='sow'`` to the; argument list of an available Python function. Run this quick job to; produce input files for lengthier calculations. - According to the instructions in the output file of the above step,; run the generated input files in any order on any variety of computers; and architectures. This is the time-intensive portion of the; calculation. - The 'sow' stage also produces a *master* input file (with a; ``mode='reap'`` directive). When all the jobs in the above step are; completed, place their output files in the same location as the; *master* input, and run this last, quick job to collect the results. - Sow/reap procedures are governed by the **mode** keyword, choices being; ``'continuous'``, ``'sow'``, and ``'reap'``. Only ``'sow'`` is likely to; be used by the user, as ``'continuous'`` is always the default, and; input files with ``'reap'`` are autogenerated. - Embarrassingly parallel algorithm available at present for:. - :ref:`sec:db()` ; - finite difference operation of :ref:`sec:opt()` ; - finite difference of energies of :ref:`sec:freq()`; - finite difference of gradients of :ref:`sec:freq()`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Local options (*e.g.*, ``set scf e_convergence 9``) will not get transmitted to the child jobs. - Array options (*e.g.*, ``set states_per_irrep [2, 1]``) will not get transmitted to the child jobs. - Function intercalls (*e.g.*, db(opt())) are not tested with sow/reap procedures. ",MatchSource.DOCS,doc/sphinxman/source/sowreap.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sowreap.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sowreap.rst:2247,Deployability,continuous,continuous,2247,"treet, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:sowreap`:. Embarrassing Parallelism; ========================. Many of the tasks automated by Python wrappers consist of a number of; independent |PSIfour| calculations and are thus suited to an embarrassingly; parallel mode of operation. In Psithon, these have been dubbed sow/reap; procedures and have the following general structure. - Prepare an input file, simply adding ``mode='sow'`` to the; argument list of an available Python function. Run this quick job to; produce input files for lengthier calculations. - According to the instructions in the output file of the above step,; run the generated input files in any order on any variety of computers; and architectures. This is the time-intensive portion of the; calculation. - The 'sow' stage also produces a *master* input file (with a; ``mode='reap'`` directive). When all the jobs in the above step are; completed, place their output files in the same location as the; *master* input, and run this last, quick job to collect the results. - Sow/reap procedures are governed by the **mode** keyword, choices being; ``'continuous'``, ``'sow'``, and ``'reap'``. Only ``'sow'`` is likely to; be used by the user, as ``'continuous'`` is always the default, and; input files with ``'reap'`` are autogenerated. - Embarrassingly parallel algorithm available at present for:. - :ref:`sec:db()` ; - finite difference operation of :ref:`sec:opt()` ; - finite difference of energies of :ref:`sec:freq()`; - finite difference of gradients of :ref:`sec:freq()`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Local options (*e.g.*, ``set scf e_convergence 9``) will not get transmitted to the child jobs. - Array options (*e.g.*, ``set states_per_irrep [2, 1]``) will not get transmitted to the child jobs. - Function intercalls (*e.g.*, db(opt())) are not tested with sow/reap procedures. ",MatchSource.DOCS,doc/sphinxman/source/sowreap.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sowreap.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sowreap.rst:1171,Integrability,wrap,wrappers,1171,"ded in; .. # the corresponding files.; .. #; .. # This file is part of Psi4.; .. #; .. # Psi4 is free software; you can redistribute it and/or modify; .. # it under the terms of the GNU Lesser General Public License as published by; .. # the Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:sowreap`:. Embarrassing Parallelism; ========================. Many of the tasks automated by Python wrappers consist of a number of; independent |PSIfour| calculations and are thus suited to an embarrassingly; parallel mode of operation. In Psithon, these have been dubbed sow/reap; procedures and have the following general structure. - Prepare an input file, simply adding ``mode='sow'`` to the; argument list of an available Python function. Run this quick job to; produce input files for lengthier calculations. - According to the instructions in the output file of the above step,; run the generated input files in any order on any variety of computers; and architectures. This is the time-intensive portion of the; calculation. - The 'sow' stage also produces a *master* input file (with a; ``mode='reap'`` directive). When all the jobs in the above step are; completed, place their output files in the same location as the; *master* input, and run this last, quick job to collect the results. - Sow/reap procedures are governed by the **mode** keyword, choices being; ``'continuous'``, ``'sow'``, and ``'reap'``. Only ``'sow'`` is likely to; ",MatchSource.DOCS,doc/sphinxman/source/sowreap.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sowreap.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sowreap.rst:2908,Testability,test,tested,2908,"treet, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:sowreap`:. Embarrassing Parallelism; ========================. Many of the tasks automated by Python wrappers consist of a number of; independent |PSIfour| calculations and are thus suited to an embarrassingly; parallel mode of operation. In Psithon, these have been dubbed sow/reap; procedures and have the following general structure. - Prepare an input file, simply adding ``mode='sow'`` to the; argument list of an available Python function. Run this quick job to; produce input files for lengthier calculations. - According to the instructions in the output file of the above step,; run the generated input files in any order on any variety of computers; and architectures. This is the time-intensive portion of the; calculation. - The 'sow' stage also produces a *master* input file (with a; ``mode='reap'`` directive). When all the jobs in the above step are; completed, place their output files in the same location as the; *master* input, and run this last, quick job to collect the results. - Sow/reap procedures are governed by the **mode** keyword, choices being; ``'continuous'``, ``'sow'``, and ``'reap'``. Only ``'sow'`` is likely to; be used by the user, as ``'continuous'`` is always the default, and; input files with ``'reap'`` are autogenerated. - Embarrassingly parallel algorithm available at present for:. - :ref:`sec:db()` ; - finite difference operation of :ref:`sec:opt()` ; - finite difference of energies of :ref:`sec:freq()`; - finite difference of gradients of :ref:`sec:freq()`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Local options (*e.g.*, ``set scf e_convergence 9``) will not get transmitted to the child jobs. - Array options (*e.g.*, ``set states_per_irrep [2, 1]``) will not get transmitted to the child jobs. - Function intercalls (*e.g.*, db(opt())) are not tested with sow/reap procedures. ",MatchSource.DOCS,doc/sphinxman/source/sowreap.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sowreap.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sowreap.rst:1432,Usability,simpl,simply,1432,"e Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. _`sec:sowreap`:. Embarrassing Parallelism; ========================. Many of the tasks automated by Python wrappers consist of a number of; independent |PSIfour| calculations and are thus suited to an embarrassingly; parallel mode of operation. In Psithon, these have been dubbed sow/reap; procedures and have the following general structure. - Prepare an input file, simply adding ``mode='sow'`` to the; argument list of an available Python function. Run this quick job to; produce input files for lengthier calculations. - According to the instructions in the output file of the above step,; run the generated input files in any order on any variety of computers; and architectures. This is the time-intensive portion of the; calculation. - The 'sow' stage also produces a *master* input file (with a; ``mode='reap'`` directive). When all the jobs in the above step are; completed, place their output files in the same location as the; *master* input, and run this last, quick job to collect the results. - Sow/reap procedures are governed by the **mode** keyword, choices being; ``'continuous'``, ``'sow'``, and ``'reap'``. Only ``'sow'`` is likely to; be used by the user, as ``'continuous'`` is always the default, and; input files with ``'reap'`` are autogenerated. - Embarrassingly parallel algorithm available at present for:. - :ref:`sec:db()` ; - finite difference operation of :ref:`sec",MatchSource.DOCS,doc/sphinxman/source/sowreap.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/sowreap.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tdscf.rst:2875,Availability,toler,tolerance,2875," of using the TDSCF functionality is as follows::. molecule {; 0 1; O 0.000000 0.695000 -0.092486; O -0.000000 -0.695000 -0.092486; H -0.388142 0.895249 0.739888; H 0.388142 -0.895249 0.739888; symmetry c1; }. set {; tdscf_states 10; }. energy('td-scf/cc-pvdz'). This will seek to converge 10 singlet roots from a restricted Hartree--Fock reference. The roots are obtained with an iterative eigensolver and the following is the printout from the calculation::. ---------------------------------------------------------; TDSCF excitation energies; by Andrew M. James and Daniel G. A. Smith; ---------------------------------------------------------. ==> Options <==. Residual threshold : 1.0000e-04; Initial guess : denominators; Reference : RHF; Solver type : RPA (Hamiltonian). ==> Requested Excitations <==. 10 singlet states with A symmetry. ==> Seeking the lowest 10 singlet states with A symmetry. Generalized Hamiltonian Solver; By Andrew M. James. ==> Options <==. Max number of iterations = 60; Eigenvector tolerance = 1.0000e-04; Max number of expansion vectors = 2000. => Iterations <=; Max[D[value]] Max[|R|] # vectors; HamiltonianSolver iter 1: 5.64572e-01 3.65441e-01 40; HamiltonianSolver iter 2: 1.70649e-02 4.40807e-02 60; HamiltonianSolver iter 3: 2.42552e-04 6.95387e-03 80; HamiltonianSolver iter 4: 2.34146e-06 7.75689e-04 100; HamiltonianSolver iter 5: 1.75483e-08 6.17293e-05 120 Converged. When convergence is reached, |PSIfour| will output a report of excitation energies, oscillator strengths, and rotatory strenghts in atomic units::. Excitation Energy Total Energy Oscillator Strength Rotatory Strength; # Sym: GS->ES (Trans) au eV au au (length) au (velocity) au (length) au (velocity); ---- -------------------- --------------- --------------- --------------- --------------- --------------- --------------- ---------------; 1 A->A (1 A) 0.26945 7.33199 -150.50964 0.0017 0.0082 -0.0019 -0.0135; 2 A->A (1 A) 0.31534 8.58073 -150.46375 0.0000 0.0002 -0.0007 -0.0096; 3 A-",MatchSource.DOCS,doc/sphinxman/source/tdscf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tdscf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tdscf.rst:4761,Availability,robust,robust,4761,"1 A->A (1 A) 0.26945 7.33199 -150.50964 0.0017 0.0082 -0.0019 -0.0135; 2 A->A (1 A) 0.31534 8.58073 -150.46375 0.0000 0.0002 -0.0007 -0.0096; 3 A->A (1 A) 0.35760 9.73076 -150.42148 0.0040 0.0097 0.0227 0.0352; 4 A->A (1 A) 0.37522 10.21028 -150.40386 0.0144 0.0442 0.0729 0.1223; 5 A->A (1 A) 0.43252 11.76960 -150.34656 0.0890 0.1189 -0.1942 -0.2491; 6 A->A (1 A) 0.46952 12.77624 -150.30957 0.0640 0.1157 0.0175 0.0235; 7 A->A (1 A) 0.49186 13.38426 -150.28722 0.0016 0.0012 -0.0243 -0.0212; 8 A->A (1 A) 0.50405 13.71581 -150.27504 0.4557 0.4396 -0.0197 -0.0158; 9 A->A (1 A) 0.52971 14.41407 -150.24938 0.0799 0.0948 0.0546 0.0595; 10 A->A (1 A) 0.56083 15.26092 -150.21825 0.0497 0.0567 -0.0587 -0.0650. The solvers can be used to extract the first few roots of interest for the full; time-dependent DFT (TDDFT) equations, also known as the random-phase; approximation (RPA), or its Tamm--Dancoff approximation.; The former is a *generalized* eigenvalue problem and our solver leverages; the Hamiltonian structure of the equations to ensure robust convergence [stratmann:1998]_.; The latter is a Hermitian eigenvalue problem and we employ a Davidson solver. Known limitations; ~~~~~~~~~~~~~~~~~. .. warning:: The implementation cannot currently handle the following cases:; - Functionals with meta or VV10 components. .. warning:: The length-gauge rotatory strengths |PSIfour| computes are; currently **not** gauge-origin invariant. .. index::; pair: TDSCF; theory. Theory; ~~~~~~. The excitation energies and corresponding states are obtained from the following generalized; eigenvalue problem, also known as the *response eigenvalue problem*:. .. math::; \begin{pmatrix}; \mathbf{A} & \mathbf{B} \\; \mathbf{B}^{*} & \mathbf{A}^{*}; \end{pmatrix}; \begin{pmatrix}; \mathbf{X}_{n} \\; \mathbf{Y}_{n}; \end{pmatrix}; =; \omega_{n}; \begin{pmatrix}; \mathbf{1} & \mathbf{0} \\; \mathbf{0} & -\mathbf{1}; \end{pmatrix}; \begin{pmatrix}; \mathbf{X}_{n} \\; \mathbf{Y}_{n}; \end{pmatrix}. This appro",MatchSource.DOCS,doc/sphinxman/source/tdscf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tdscf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tdscf.rst:6690,Availability,down,down,6690,"s the advantage that there is no need to explicitly parametrize; the wavefunctions of the molecular excited states. Furthermore, the excitation; eigenvectors, :math:`(\mathbf{X}_{n} \mathbf{Y}_{n})^{t}`,; provide information on the nature of the transitions and can be used to form; spectroscopic observables, such as oscillator and rotatory strengths. The :math:`\mathbf{A}` and :math:`\mathbf{B}` matrices appearing on the left-hand side are; the blocks of the molecular electronic; Hessian, [Norman2018-tn]_; whose dimensionality is :math:`(OV)^{2}`, with :math:`O` and :math:`V` the number of occupied and; virtual molecular orbitals, respectively.; This prevents explicit formation of the full Hessian, and subspace iteration; methods need to be used to extract the first few roots.; In such methods, the eigenvectors are expanded in a subspace of trial vectors,; whose dimensionality is greatly lower than that of the full eigenproblem.; The Hessian is projected down to this subspace where conventional full; diagonalization algorithms can be applied. The subspace is augmented with new; trial vectors, until a suitable convergence criterion is met.; The efficiency of the subspace solver is determined by the first half-projection; of the Hessian in the trial subspace, that is, by the efficiency of the routines; performing the matrix-vector products. It is essential to note that, despite the hermiticity of the molecular; electronic Hessian, the response eigenvalue equation is not an Hermitian; eigenproblem, due to the nonunit metric on the right-hand side. Indeed the Davidson; solver, the standard subspace iteration method in quantum chemistry,; demonstrates very poor convergence, sometimes manifesting as spurious complex; eigenvalues.; The eigenproblem however has Hamiltonian symmetry: the; roots appear in pairs :math:`(\omega_{n}, -\omega_{n})`, as do the eigenvectors.; A robust subspace solver should preserve the Hamiltonian symmetry, by enforcing; the paired structure on th",MatchSource.DOCS,doc/sphinxman/source/tdscf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tdscf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tdscf.rst:7616,Availability,robust,robust,7616,"projected down to this subspace where conventional full; diagonalization algorithms can be applied. The subspace is augmented with new; trial vectors, until a suitable convergence criterion is met.; The efficiency of the subspace solver is determined by the first half-projection; of the Hessian in the trial subspace, that is, by the efficiency of the routines; performing the matrix-vector products. It is essential to note that, despite the hermiticity of the molecular; electronic Hessian, the response eigenvalue equation is not an Hermitian; eigenproblem, due to the nonunit metric on the right-hand side. Indeed the Davidson; solver, the standard subspace iteration method in quantum chemistry,; demonstrates very poor convergence, sometimes manifesting as spurious complex; eigenvalues.; The eigenproblem however has Hamiltonian symmetry: the; roots appear in pairs :math:`(\omega_{n}, -\omega_{n})`, as do the eigenvectors.; A robust subspace solver should preserve the Hamiltonian symmetry, by enforcing; the paired structure on the trial vectors themselves.; Since |PSIfour| employs real orbitals, the response eigenproblem can be brought; to the form:. .. math::; (\mathbf{A} - \mathbf{B})(\mathbf{A} + \mathbf{B})| \mathbf{X}_{n} + \mathbf{Y}_{n}\rangle; =; \omega^{2}_{n} | \mathbf{X}_{n} + \mathbf{Y}_{n}\rangle,. and further to the Hermitian form:. .. math::; (\mathbf{A} - \mathbf{B})^{\frac{1}{2}}(\mathbf{A} + \mathbf{B})(\mathbf{A} - \mathbf{B})^{\frac{1}{2}} \mathbf{T}_{n}; =; \omega^{2}_{n} \mathbf{T}_{n},. assuming the SCF reference is stable, *i.e.* :math:`(\mathbf{A}-\mathbf{B})` is positive-definite.; The paired vectors :math:`| \mathbf{X}_{n} - \mathbf{Y}_{n}\rangle` are left; eigenvectors and form a biorthonormal set together; with the right eigenvectors :math:`| \mathbf{X}_{n} + \mathbf{Y}_{n}\rangle`. The algorithm for the subspace iteration Hamiltonian solver implemented in |PSIfour|; was first described by Stratmann *et al.* [stratmann:1998]_.; As already me",MatchSource.DOCS,doc/sphinxman/source/tdscf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tdscf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tdscf.rst:2097,Energy Efficiency,energy,energy,2097,"ximation, TDA, Tamm--Dancoff approximation; .. _`sec:tdscf`:. TDSCF: Time-dependent Hartree--Fock and density-functional theory; =================================================================. .. codeauthor:: Andrew M. James, Daniel G. A. Smith, Ruhee Dcuhna, Roberto Di Remigio and Jeff Schriber; .. sectionauthor:: Roberto Di Remigio. *Module:* :ref:`Keywords <apdx:scftdscf>`, :ref:`PSI Variables <apdx:scf_psivar>`, :source:`LIBSCF_SOLVER <psi4/src/psi4/libscf_solver>`. .. _`sec:tdscfintro`:. Introduction; ~~~~~~~~~~~~. |PSIfour| provides the capability to calculate excitation energies and ground to; excited state transition properties for SCF reference wavefunctions in a linear; response formalism [Dreuw2005-wp]_. An illustrative example of using the TDSCF functionality is as follows::. molecule {; 0 1; O 0.000000 0.695000 -0.092486; O -0.000000 -0.695000 -0.092486; H -0.388142 0.895249 0.739888; H 0.388142 -0.895249 0.739888; symmetry c1; }. set {; tdscf_states 10; }. energy('td-scf/cc-pvdz'). This will seek to converge 10 singlet roots from a restricted Hartree--Fock reference. The roots are obtained with an iterative eigensolver and the following is the printout from the calculation::. ---------------------------------------------------------; TDSCF excitation energies; by Andrew M. James and Daniel G. A. Smith; ---------------------------------------------------------. ==> Options <==. Residual threshold : 1.0000e-04; Initial guess : denominators; Reference : RHF; Solver type : RPA (Hamiltonian). ==> Requested Excitations <==. 10 singlet states with A symmetry. ==> Seeking the lowest 10 singlet states with A symmetry. Generalized Hamiltonian Solver; By Andrew M. James. ==> Options <==. Max number of iterations = 60; Eigenvector tolerance = 1.0000e-04; Max number of expansion vectors = 2000. => Iterations <=; Max[D[value]] Max[|R|] # vectors; HamiltonianSolver iter 1: 5.64572e-01 3.65441e-01 40; HamiltonianSolver iter 2: 1.70649e-02 4.40807e-02 60; Hamiltonia",MatchSource.DOCS,doc/sphinxman/source/tdscf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tdscf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tdscf.rst:9071,Energy Efficiency,efficient,efficient,9071," math::; (\mathbf{A} - \mathbf{B})^{\frac{1}{2}}(\mathbf{A} + \mathbf{B})(\mathbf{A} - \mathbf{B})^{\frac{1}{2}} \mathbf{T}_{n}; =; \omega^{2}_{n} \mathbf{T}_{n},. assuming the SCF reference is stable, *i.e.* :math:`(\mathbf{A}-\mathbf{B})` is positive-definite.; The paired vectors :math:`| \mathbf{X}_{n} - \mathbf{Y}_{n}\rangle` are left; eigenvectors and form a biorthonormal set together; with the right eigenvectors :math:`| \mathbf{X}_{n} + \mathbf{Y}_{n}\rangle`. The algorithm for the subspace iteration Hamiltonian solver implemented in |PSIfour|; was first described by Stratmann *et al.* [stratmann:1998]_.; As already mentioned, the formation and storage of the matrix-vector products; :math:`(\mathbf{A}+\mathbf{B})\mathbf{b}_{i}` and; :math:`(\mathbf{A}-\mathbf{B})\mathbf{b}_{i}` for all trial vectors :math:`\mathbf{b}_{i}`; are the most compute- and memory-intensive operations in the Hamiltonian solver.; These matrix-vector products are equivalent to building generalized Fock; matrices and thus use the efficient :math:`JK` build infrastructure of |PSIfour|. The excitation energies and eigenvectors can then be used to compute transition moments, such as; electric and magnetic transition dipole moments, and spectroscopic intensities,; such as oscillator strengths and rotatory strengths [Pedersen1995-du]_, [Lestrange2015-xn]_.; For example, |PSIfour| will compute compute oscillator strengths from; the MO basis electric dipole moment integrals, :math:`\mathbf{\mu}_{u}`, and the right; excitation vectors, :math:`|\mathbf{X}_{n}+\mathbf{Y}_{n}\rangle`:. .. math::; f = \frac{2}{3} \omega_{n} \sum_{u=x,y,z}\sum_{ia}|(\mathbf{X}_{n}+\mathbf{Y}_{n})_{ia}\mu_{ai, u}|^{2}. Psithon keywords; ~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/scf__tdscf_states.rst; .. include:: autodir_options_c/scf__tdscf_triplets.rst; .. include:: autodir_options_c/scf__tdscf_tda.rst; .. include:: autodir_options_c/scf__tdscf_r_convergence.rst; .. include:: autodir_options_c/scf__tdscf_maxit",MatchSource.DOCS,doc/sphinxman/source/tdscf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tdscf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tdscf.rst:10827,Energy Efficiency,energy,energy,10827,"_triplets.rst; .. include:: autodir_options_c/scf__tdscf_tda.rst; .. include:: autodir_options_c/scf__tdscf_r_convergence.rst; .. include:: autodir_options_c/scf__tdscf_maxiter.rst; .. include:: autodir_options_c/scf__tdscf_guess.rst; .. include:: autodir_options_c/scf__tdscf_print.rst; .. include:: autodir_options_c/scf__tdscf_coeff_cutoff.rst; .. include:: autodir_options_c/scf__tdscf_tdm_print.rst. PsiAPI usage; ~~~~~~~~~~~~. The TDSCF functionality is also accessible from PsiAPI. The example calculation shown above can be carried out as follows:. .. code-block:: python. import psi4. from psi4.driver.procrouting.response.scf_response import tdscf_excitations. psi4.core.set_output_file(""h2o2.out""). h2o2 = psi4.geometry(""""""0 1; O 0.000000 0.695000 -0.092486; O -0.000000 -0.695000 -0.092486; H -0.388142 0.895249 0.739888; H 0.388142 -0.895249 0.739888; symmetry c1; """""", name=""H2O2""). psi4.set_options({; 'save_jk': True,; }). e, wfn = psi4.energy(""HF/cc-pvdz"", return_wfn=True, molecule=h2o2); res = tdscf_excitations(wfn, states=10). Plotting one-photon absorption and electronic circular dichroism spectra; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Excitation energies and corresponding spectroscopic observables can be used to; produce spectra for one-photon absorption (OPA) and electronic circular; dichroism (ECD) with phenomenological line broadening. |PSIfour| provides the ``spectrum`` function for this purpose implementing the; recommendations of Rizzo *et al.* [Rizzo2011-to]_.; This function will *not* plot the spectrum, but rather return a pair of NumPy; arrays containing the :math:`x` and :math:`y` values resulting from the; convolution with broadening of the computed spectroscopic observables. .. code-block:: python. import numpy as np. import psi4. from psi4.driver.procrouting.response.scf_response import tdscf_excitations; from psi4.driver.p4util import spectrum. psi4.core.set_output_file(""moxy.out""). moxy = psi4.geometry(""""""0 1",MatchSource.DOCS,doc/sphinxman/source/tdscf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tdscf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tdscf.rst:12278,Energy Efficiency,energy,energy,12278,"can be used to; produce spectra for one-photon absorption (OPA) and electronic circular; dichroism (ECD) with phenomenological line broadening. |PSIfour| provides the ``spectrum`` function for this purpose implementing the; recommendations of Rizzo *et al.* [Rizzo2011-to]_.; This function will *not* plot the spectrum, but rather return a pair of NumPy; arrays containing the :math:`x` and :math:`y` values resulting from the; convolution with broadening of the computed spectroscopic observables. .. code-block:: python. import numpy as np. import psi4. from psi4.driver.procrouting.response.scf_response import tdscf_excitations; from psi4.driver.p4util import spectrum. psi4.core.set_output_file(""moxy.out""). moxy = psi4.geometry(""""""0 1; C 0.152133 -0.035800 0.485797; C -1.039475 0.615938 -0.061249; C 1.507144 0.097806 -0.148460; O -0.828215 -0.788248 -0.239431; H 0.153725 -0.249258 1.552136; H -1.863178 0.881921 0.593333; H -0.949807 1.214210 -0.962771; H 2.076806 -0.826189 -0.036671; H 2.074465 0.901788 0.325106; H 1.414895 0.315852 -1.212218; """""", name=""(S)-methyloxirane""). psi4.set_options({; 'save_jk': True,; }). e, wfn = psi4.energy(""HF/cc-pvdz"", return_wfn=True, molecule=moxy); res = tdscf_excitations(wfn, states=8, triplets=""also""). # get poles and residues to plot OPA and ECD spectra; poles = [r[""EXCITATION ENERGY""] for r in res]; opa_residues = [np.linalg.norm(r[""LENGTH-GAUGE ELECTRIC DIPOLE TRANSITION MOMENT""])**2 for r in res]; ecd_residues = [r[""LENGTH-GAUGE ROTATORY STRENGTH""] for r in res]. opa_spectrum = spectrum(poles=poles, residues=opa_residues, gamma=0.01, out_units=""nm""); ecd_spectrum = spectrum(poles=poles, residues=ecd_residues, kind=""ECD"", gamma=0.01, out_units=""nm""). The data produced by running the above PsiAPI code can, for example, be used; with the Altair plotting library to produce the desired spectra. .. image:: /moxy.png; :align: center; :scale: 100%; :alt: (S)-methyloxirane one-photon absorption and electronic circular dichroism spectra.; ",MatchSource.DOCS,doc/sphinxman/source/tdscf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tdscf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tdscf.rst:1183,Integrability,depend,dependent,1183,"corresponding files.; .. #; .. # This file is part of Psi4.; .. #; .. # Psi4 is free software; you can redistribute it and/or modify; .. # it under the terms of the GNU Lesser General Public License as published by; .. # the Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index:: TDSCF, TDDFT, RPA, random phase approximation, TDA, Tamm--Dancoff approximation; .. _`sec:tdscf`:. TDSCF: Time-dependent Hartree--Fock and density-functional theory; =================================================================. .. codeauthor:: Andrew M. James, Daniel G. A. Smith, Ruhee Dcuhna, Roberto Di Remigio and Jeff Schriber; .. sectionauthor:: Roberto Di Remigio. *Module:* :ref:`Keywords <apdx:scftdscf>`, :ref:`PSI Variables <apdx:scf_psivar>`, :source:`LIBSCF_SOLVER <psi4/src/psi4/libscf_solver>`. .. _`sec:tdscfintro`:. Introduction; ~~~~~~~~~~~~. |PSIfour| provides the capability to calculate excitation energies and ground to; excited state transition properties for SCF reference wavefunctions in a linear; response formalism [Dreuw2005-wp]_. An illustrative example of using the TDSCF functionality is as follows::. molecule {; 0 1; O 0.000000 0.695000 -0.092486; O -0.000000 -0.695000 -0.092486; H -0.388142 0.895249 0.739888; H 0.388142 -0.895249 0.739888; symmetry c1; }. set {; tdscf_states 10; }. energy('td-scf/cc-pvdz'). This will seek to converge 10 singlet roots from a restricted Hartree--Fock reference. The roots are obtained with",MatchSource.DOCS,doc/sphinxman/source/tdscf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tdscf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tdscf.rst:4510,Integrability,depend,dependent,4510,"ength) au (velocity) au (length) au (velocity); ---- -------------------- --------------- --------------- --------------- --------------- --------------- --------------- ---------------; 1 A->A (1 A) 0.26945 7.33199 -150.50964 0.0017 0.0082 -0.0019 -0.0135; 2 A->A (1 A) 0.31534 8.58073 -150.46375 0.0000 0.0002 -0.0007 -0.0096; 3 A->A (1 A) 0.35760 9.73076 -150.42148 0.0040 0.0097 0.0227 0.0352; 4 A->A (1 A) 0.37522 10.21028 -150.40386 0.0144 0.0442 0.0729 0.1223; 5 A->A (1 A) 0.43252 11.76960 -150.34656 0.0890 0.1189 -0.1942 -0.2491; 6 A->A (1 A) 0.46952 12.77624 -150.30957 0.0640 0.1157 0.0175 0.0235; 7 A->A (1 A) 0.49186 13.38426 -150.28722 0.0016 0.0012 -0.0243 -0.0212; 8 A->A (1 A) 0.50405 13.71581 -150.27504 0.4557 0.4396 -0.0197 -0.0158; 9 A->A (1 A) 0.52971 14.41407 -150.24938 0.0799 0.0948 0.0546 0.0595; 10 A->A (1 A) 0.56083 15.26092 -150.21825 0.0497 0.0567 -0.0587 -0.0650. The solvers can be used to extract the first few roots of interest for the full; time-dependent DFT (TDDFT) equations, also known as the random-phase; approximation (RPA), or its Tamm--Dancoff approximation.; The former is a *generalized* eigenvalue problem and our solver leverages; the Hamiltonian structure of the equations to ensure robust convergence [stratmann:1998]_.; The latter is a Hermitian eigenvalue problem and we employ a Davidson solver. Known limitations; ~~~~~~~~~~~~~~~~~. .. warning:: The implementation cannot currently handle the following cases:; - Functionals with meta or VV10 components. .. warning:: The length-gauge rotatory strengths |PSIfour| computes are; currently **not** gauge-origin invariant. .. index::; pair: TDSCF; theory. Theory; ~~~~~~. The excitation energies and corresponding states are obtained from the following generalized; eigenvalue problem, also known as the *response eigenvalue problem*:. .. math::; \begin{pmatrix}; \mathbf{A} & \mathbf{B} \\; \mathbf{B}^{*} & \mathbf{A}^{*}; \end{pmatrix}; \begin{pmatrix}; \mathbf{X}_{n} \\; \mathbf{Y}_{n}; \end{",MatchSource.DOCS,doc/sphinxman/source/tdscf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tdscf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tdscf.rst:7033,Integrability,rout,routines,7033,"and can be used to form; spectroscopic observables, such as oscillator and rotatory strengths. The :math:`\mathbf{A}` and :math:`\mathbf{B}` matrices appearing on the left-hand side are; the blocks of the molecular electronic; Hessian, [Norman2018-tn]_; whose dimensionality is :math:`(OV)^{2}`, with :math:`O` and :math:`V` the number of occupied and; virtual molecular orbitals, respectively.; This prevents explicit formation of the full Hessian, and subspace iteration; methods need to be used to extract the first few roots.; In such methods, the eigenvectors are expanded in a subspace of trial vectors,; whose dimensionality is greatly lower than that of the full eigenproblem.; The Hessian is projected down to this subspace where conventional full; diagonalization algorithms can be applied. The subspace is augmented with new; trial vectors, until a suitable convergence criterion is met.; The efficiency of the subspace solver is determined by the first half-projection; of the Hessian in the trial subspace, that is, by the efficiency of the routines; performing the matrix-vector products. It is essential to note that, despite the hermiticity of the molecular; electronic Hessian, the response eigenvalue equation is not an Hermitian; eigenproblem, due to the nonunit metric on the right-hand side. Indeed the Davidson; solver, the standard subspace iteration method in quantum chemistry,; demonstrates very poor convergence, sometimes manifesting as spurious complex; eigenvalues.; The eigenproblem however has Hamiltonian symmetry: the; roots appear in pairs :math:`(\omega_{n}, -\omega_{n})`, as do the eigenvectors.; A robust subspace solver should preserve the Hamiltonian symmetry, by enforcing; the paired structure on the trial vectors themselves.; Since |PSIfour| employs real orbitals, the response eigenproblem can be brought; to the form:. .. math::; (\mathbf{A} - \mathbf{B})(\mathbf{A} + \mathbf{B})| \mathbf{X}_{n} + \mathbf{Y}_{n}\rangle; =; \omega^{2}_{n} | \mathbf{X}_",MatchSource.DOCS,doc/sphinxman/source/tdscf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tdscf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tdscf.rst:7043,Performance,perform,performing,7043,"and can be used to form; spectroscopic observables, such as oscillator and rotatory strengths. The :math:`\mathbf{A}` and :math:`\mathbf{B}` matrices appearing on the left-hand side are; the blocks of the molecular electronic; Hessian, [Norman2018-tn]_; whose dimensionality is :math:`(OV)^{2}`, with :math:`O` and :math:`V` the number of occupied and; virtual molecular orbitals, respectively.; This prevents explicit formation of the full Hessian, and subspace iteration; methods need to be used to extract the first few roots.; In such methods, the eigenvectors are expanded in a subspace of trial vectors,; whose dimensionality is greatly lower than that of the full eigenproblem.; The Hessian is projected down to this subspace where conventional full; diagonalization algorithms can be applied. The subspace is augmented with new; trial vectors, until a suitable convergence criterion is met.; The efficiency of the subspace solver is determined by the first half-projection; of the Hessian in the trial subspace, that is, by the efficiency of the routines; performing the matrix-vector products. It is essential to note that, despite the hermiticity of the molecular; electronic Hessian, the response eigenvalue equation is not an Hermitian; eigenproblem, due to the nonunit metric on the right-hand side. Indeed the Davidson; solver, the standard subspace iteration method in quantum chemistry,; demonstrates very poor convergence, sometimes manifesting as spurious complex; eigenvalues.; The eigenproblem however has Hamiltonian symmetry: the; roots appear in pairs :math:`(\omega_{n}, -\omega_{n})`, as do the eigenvectors.; A robust subspace solver should preserve the Hamiltonian symmetry, by enforcing; the paired structure on the trial vectors themselves.; Since |PSIfour| employs real orbitals, the response eigenproblem can be brought; to the form:. .. math::; (\mathbf{A} - \mathbf{B})(\mathbf{A} + \mathbf{B})| \mathbf{X}_{n} + \mathbf{Y}_{n}\rangle; =; \omega^{2}_{n} | \mathbf{X}_",MatchSource.DOCS,doc/sphinxman/source/tdscf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tdscf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tdscf.rst:10339,Security,access,accessible,10339," and rotatory strengths [Pedersen1995-du]_, [Lestrange2015-xn]_.; For example, |PSIfour| will compute compute oscillator strengths from; the MO basis electric dipole moment integrals, :math:`\mathbf{\mu}_{u}`, and the right; excitation vectors, :math:`|\mathbf{X}_{n}+\mathbf{Y}_{n}\rangle`:. .. math::; f = \frac{2}{3} \omega_{n} \sum_{u=x,y,z}\sum_{ia}|(\mathbf{X}_{n}+\mathbf{Y}_{n})_{ia}\mu_{ai, u}|^{2}. Psithon keywords; ~~~~~~~~~~~~~~~~. .. include:: autodir_options_c/scf__tdscf_states.rst; .. include:: autodir_options_c/scf__tdscf_triplets.rst; .. include:: autodir_options_c/scf__tdscf_tda.rst; .. include:: autodir_options_c/scf__tdscf_r_convergence.rst; .. include:: autodir_options_c/scf__tdscf_maxiter.rst; .. include:: autodir_options_c/scf__tdscf_guess.rst; .. include:: autodir_options_c/scf__tdscf_print.rst; .. include:: autodir_options_c/scf__tdscf_coeff_cutoff.rst; .. include:: autodir_options_c/scf__tdscf_tdm_print.rst. PsiAPI usage; ~~~~~~~~~~~~. The TDSCF functionality is also accessible from PsiAPI. The example calculation shown above can be carried out as follows:. .. code-block:: python. import psi4. from psi4.driver.procrouting.response.scf_response import tdscf_excitations. psi4.core.set_output_file(""h2o2.out""). h2o2 = psi4.geometry(""""""0 1; O 0.000000 0.695000 -0.092486; O -0.000000 -0.695000 -0.092486; H -0.388142 0.895249 0.739888; H 0.388142 -0.895249 0.739888; symmetry c1; """""", name=""H2O2""). psi4.set_options({; 'save_jk': True,; }). e, wfn = psi4.energy(""HF/cc-pvdz"", return_wfn=True, molecule=h2o2); res = tdscf_excitations(wfn, states=10). Plotting one-photon absorption and electronic circular dichroism spectra; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Excitation energies and corresponding spectroscopic observables can be used to; produce spectra for one-photon absorption (OPA) and electronic circular; dichroism (ECD) with phenomenological line broadening. |PSIfour| provides the ``spectrum`` function for this pu",MatchSource.DOCS,doc/sphinxman/source/tdscf.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tdscf.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/testsuite.rst:1589,Integrability,interface,interfaced,1589,"he Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. _`apdx:testSuite`:. Test Suite and Sample Inputs; ============================. |PSIfour| is distributed with an extensive test suite, which can; be found in :source:`tests`. After building the source code, these; can automatically be run by running ``ctest`` in the compilation; directory. More info on ``ctest`` options can be found; :ref:`here <faq:subsettests>`. Sample input files; can be found in the :source:`samples` subdirectory of the top-level Psi; directory. The samples and a brief description are provided below. Sample inputs accessible through :ref:`interfaced executables; <sec:interfacing>` are bulleted below. .. toctree::. autodoc_testsuite_brianqc.rst; autodoc_testsuite_cfour; autodoc_testsuite_chemps2; autodoc_testsuite_cookbook; autodoc_testsuite_dftd3; autodoc_testsuite_dftd4; autodoc_testsuite_dkh; autodoc_testsuite_libefp; autodoc_testsuite_erd; autodoc_testsuite_gcp; autodoc_testsuite_gdma; autodoc_testsuite_gpu_dfcc; autodoc_testsuite_json; autodoc_testsuite_mrcc; autodoc_testsuite_pcmsolver; autodoc_testsuite_psi4numpy; autodoc_testsuite_python; autodoc_testsuite_simint; autodoc_testsuite_snsmp2; autodoc_testsuite_v2rdm_casscf. Sample inputs for |PSIfour| as distributed are below. .. comment This toctree directive only here to suppress warning at build time.; include line below is doing the work. .. toctree::; :hidden:. autodoc_testsuite_corepsi4. .. include:: autodoc_testsuite_corepsi4.rst. ",MatchSource.DOCS,doc/sphinxman/source/testsuite.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/testsuite.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/testsuite.rst:1564,Security,access,accessible,1564,"he Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. _`apdx:testSuite`:. Test Suite and Sample Inputs; ============================. |PSIfour| is distributed with an extensive test suite, which can; be found in :source:`tests`. After building the source code, these; can automatically be run by running ``ctest`` in the compilation; directory. More info on ``ctest`` options can be found; :ref:`here <faq:subsettests>`. Sample input files; can be found in the :source:`samples` subdirectory of the top-level Psi; directory. The samples and a brief description are provided below. Sample inputs accessible through :ref:`interfaced executables; <sec:interfacing>` are bulleted below. .. toctree::. autodoc_testsuite_brianqc.rst; autodoc_testsuite_cfour; autodoc_testsuite_chemps2; autodoc_testsuite_cookbook; autodoc_testsuite_dftd3; autodoc_testsuite_dftd4; autodoc_testsuite_dkh; autodoc_testsuite_libefp; autodoc_testsuite_erd; autodoc_testsuite_gcp; autodoc_testsuite_gdma; autodoc_testsuite_gpu_dfcc; autodoc_testsuite_json; autodoc_testsuite_mrcc; autodoc_testsuite_pcmsolver; autodoc_testsuite_psi4numpy; autodoc_testsuite_python; autodoc_testsuite_simint; autodoc_testsuite_snsmp2; autodoc_testsuite_v2rdm_casscf. Sample inputs for |PSIfour| as distributed are below. .. comment This toctree directive only here to suppress warning at build time.; include line below is doing the work. .. toctree::; :hidden:. autodoc_testsuite_corepsi4. .. include:: autodoc_testsuite_corepsi4.rst. ",MatchSource.DOCS,doc/sphinxman/source/testsuite.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/testsuite.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/testsuite.rst:1030,Testability,test,testSuite,1030," .. # Psi4: an open-source quantum chemistry software package; .. #; .. # Copyright (c) 2007-2023 The Psi4 Developers.; .. #; .. # The copyrights for code used from other parties are included in; .. # the corresponding files.; .. #; .. # This file is part of Psi4.; .. #; .. # Psi4 is free software; you can redistribute it and/or modify; .. # it under the terms of the GNU Lesser General Public License as published by; .. # the Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. _`apdx:testSuite`:. Test Suite and Sample Inputs; ============================. |PSIfour| is distributed with an extensive test suite, which can; be found in :source:`tests`. After building the source code, these; can automatically be run by running ``ctest`` in the compilation; directory. More info on ``ctest`` options can be found; :ref:`here <faq:subsettests>`. Sample input files; can be found in the :source:`samples` subdirectory of the top-level Psi; directory. The samples and a brief description are provided below. Sample inputs accessible through :ref:`interfaced executables; <sec:interfacing>` are bulleted below. .. toctree::. autodoc_testsuite_brianqc.rst; autodoc_testsuite_cfour; autodoc_testsuite_chemps2; autodoc_testsuite_cookbook; autodoc_testsuite_dftd3; autodoc_testsuite_dftd4; autodoc_testsuite_dkh; autodoc_testsuite_libefp; autodoc_testsuite_erd; autodoc_testsuite_gcp; autodoc_testsuite_gdma; autodoc_testsuite_gpu_dfcc; autodoc_testsuite_json; autodoc_testsuite_mrcc; autodoc_te",MatchSource.DOCS,doc/sphinxman/source/testsuite.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/testsuite.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/testsuite.rst:1146,Testability,test,test,1146,".; .. #; .. # The copyrights for code used from other parties are included in; .. # the corresponding files.; .. #; .. # This file is part of Psi4.; .. #; .. # Psi4 is free software; you can redistribute it and/or modify; .. # it under the terms of the GNU Lesser General Public License as published by; .. # the Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. _`apdx:testSuite`:. Test Suite and Sample Inputs; ============================. |PSIfour| is distributed with an extensive test suite, which can; be found in :source:`tests`. After building the source code, these; can automatically be run by running ``ctest`` in the compilation; directory. More info on ``ctest`` options can be found; :ref:`here <faq:subsettests>`. Sample input files; can be found in the :source:`samples` subdirectory of the top-level Psi; directory. The samples and a brief description are provided below. Sample inputs accessible through :ref:`interfaced executables; <sec:interfacing>` are bulleted below. .. toctree::. autodoc_testsuite_brianqc.rst; autodoc_testsuite_cfour; autodoc_testsuite_chemps2; autodoc_testsuite_cookbook; autodoc_testsuite_dftd3; autodoc_testsuite_dftd4; autodoc_testsuite_dkh; autodoc_testsuite_libefp; autodoc_testsuite_erd; autodoc_testsuite_gcp; autodoc_testsuite_gdma; autodoc_testsuite_gpu_dfcc; autodoc_testsuite_json; autodoc_testsuite_mrcc; autodoc_testsuite_pcmsolver; autodoc_testsuite_psi4numpy; autodoc_testsuite_python; autodoc_testsuite_simint; autodoc_testsuite_",MatchSource.DOCS,doc/sphinxman/source/testsuite.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/testsuite.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/testsuite.rst:1190,Testability,test,tests,1190,".; .. #; .. # The copyrights for code used from other parties are included in; .. # the corresponding files.; .. #; .. # This file is part of Psi4.; .. #; .. # Psi4 is free software; you can redistribute it and/or modify; .. # it under the terms of the GNU Lesser General Public License as published by; .. # the Free Software Foundation, version 3.; .. #; .. # Psi4 is distributed in the hope that it will be useful,; .. # but WITHOUT ANY WARRANTY; without even the implied warranty of; .. # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; .. # GNU Lesser General Public License for more details.; .. #; .. # You should have received a copy of the GNU Lesser General Public License along; .. # with Psi4; if not, write to the Free Software Foundation, Inc.,; .. # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; .. #; .. # @END LICENSE; .. #. .. _`apdx:testSuite`:. Test Suite and Sample Inputs; ============================. |PSIfour| is distributed with an extensive test suite, which can; be found in :source:`tests`. After building the source code, these; can automatically be run by running ``ctest`` in the compilation; directory. More info on ``ctest`` options can be found; :ref:`here <faq:subsettests>`. Sample input files; can be found in the :source:`samples` subdirectory of the top-level Psi; directory. The samples and a brief description are provided below. Sample inputs accessible through :ref:`interfaced executables; <sec:interfacing>` are bulleted below. .. toctree::. autodoc_testsuite_brianqc.rst; autodoc_testsuite_cfour; autodoc_testsuite_chemps2; autodoc_testsuite_cookbook; autodoc_testsuite_dftd3; autodoc_testsuite_dftd4; autodoc_testsuite_dkh; autodoc_testsuite_libefp; autodoc_testsuite_erd; autodoc_testsuite_gcp; autodoc_testsuite_gdma; autodoc_testsuite_gpu_dfcc; autodoc_testsuite_json; autodoc_testsuite_mrcc; autodoc_testsuite_pcmsolver; autodoc_testsuite_psi4numpy; autodoc_testsuite_python; autodoc_testsuite_simint; autodoc_testsuite_",MatchSource.DOCS,doc/sphinxman/source/testsuite.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/testsuite.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/thermo.rst:2233,Energy Efficiency,energy,energy,2233,"l and Thermochemical Analysis; =======================================. .. codeauthor:: Rollin A. King and Lori A. Burns; .. sectionauthor:: Lori A. Burns. *Module:* :ref:`Keywords <apdx:thermo>`, :ref:`PSI Variables <apdx:thermo_psivar>`, :source:`THERMO <psi4/driver/qcdb/vib.py>`. .. caution:: It is important to know that |PSIfour|, like any other; quantum chemistry program, does *not* compute the usual enthalpies,; entropies, or Gibbs free energies *of formation* provided by most; reference books. Instead, quantum chemistry programs compute ""absolute""; thermodynamic properties relative to infinitely separated nuclei and; electrons, not ""formation"" values relative to elements in their standard; states. If you are computing thermodynamic differences, like a reaction; enthalpy computed as the enthalpy of the products minus the enthalpy; of the reactants, then these ""absolute"" enthalpies are perfectly valid; and usable. However, they cannot be mixed and matched with enthalpies of; formation from reference books, since the zero of energy is not the same.; Additionally, the ""thermal energies"" reported in kcal/mol are the ; finite-temperature *corrections* to the electronic total energy, and ; not the overall thermal energies themselves. If in doubt, use the; reported Total Energies in Hartree/particle. Keywords; ^^^^^^^^. .. include:: autodir_options_c/thermo__t.rst; .. include:: autodir_options_c/thermo__p.rst; .. include:: autodir_options_c/thermo__rotational_symmetry_number.rst. .. _`sec:thermoExamples`:. Examples; ^^^^^^^^. A thermochemical analysis is performed after any full (not just specific; symmetry subgroups). If the wavefunction is retained, it may be reused; at a different temperature, pressure, rotational symmetry number, or; isotopic substitution through the function :py:func:`psi4.driver.qcdb.vib.thermo`; as is shown in :srcsample:`freq-isotope2`. A few summary psivars are set: ""ZPVE"", ""THERMAL ENERGY CORRECTION"",; ""ENTHALPY CORRECTION"", ""GIBBS FREE ENE",MatchSource.DOCS,doc/sphinxman/source/thermo.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/thermo.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/thermo.rst:2383,Energy Efficiency,energy,energy,2383,"ule:* :ref:`Keywords <apdx:thermo>`, :ref:`PSI Variables <apdx:thermo_psivar>`, :source:`THERMO <psi4/driver/qcdb/vib.py>`. .. caution:: It is important to know that |PSIfour|, like any other; quantum chemistry program, does *not* compute the usual enthalpies,; entropies, or Gibbs free energies *of formation* provided by most; reference books. Instead, quantum chemistry programs compute ""absolute""; thermodynamic properties relative to infinitely separated nuclei and; electrons, not ""formation"" values relative to elements in their standard; states. If you are computing thermodynamic differences, like a reaction; enthalpy computed as the enthalpy of the products minus the enthalpy; of the reactants, then these ""absolute"" enthalpies are perfectly valid; and usable. However, they cannot be mixed and matched with enthalpies of; formation from reference books, since the zero of energy is not the same.; Additionally, the ""thermal energies"" reported in kcal/mol are the ; finite-temperature *corrections* to the electronic total energy, and ; not the overall thermal energies themselves. If in doubt, use the; reported Total Energies in Hartree/particle. Keywords; ^^^^^^^^. .. include:: autodir_options_c/thermo__t.rst; .. include:: autodir_options_c/thermo__p.rst; .. include:: autodir_options_c/thermo__rotational_symmetry_number.rst. .. _`sec:thermoExamples`:. Examples; ^^^^^^^^. A thermochemical analysis is performed after any full (not just specific; symmetry subgroups). If the wavefunction is retained, it may be reused; at a different temperature, pressure, rotational symmetry number, or; isotopic substitution through the function :py:func:`psi4.driver.qcdb.vib.thermo`; as is shown in :srcsample:`freq-isotope2`. A few summary psivars are set: ""ZPVE"", ""THERMAL ENERGY CORRECTION"",; ""ENTHALPY CORRECTION"", ""GIBBS FREE ENERGY CORRECTION"", ""ZERO K; ENTHALPHY"", ""THERMAL ENERGY"", ""ENTHALPY"", ""GIBBS FREE ENERGY"".; But additionally, every valid combination of {S, Cv, Cp, ZPE, E, H, G};",MatchSource.DOCS,doc/sphinxman/source/thermo.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/thermo.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/thermo.rst:2768,Performance,perform,performed,2768,"o infinitely separated nuclei and; electrons, not ""formation"" values relative to elements in their standard; states. If you are computing thermodynamic differences, like a reaction; enthalpy computed as the enthalpy of the products minus the enthalpy; of the reactants, then these ""absolute"" enthalpies are perfectly valid; and usable. However, they cannot be mixed and matched with enthalpies of; formation from reference books, since the zero of energy is not the same.; Additionally, the ""thermal energies"" reported in kcal/mol are the ; finite-temperature *corrections* to the electronic total energy, and ; not the overall thermal energies themselves. If in doubt, use the; reported Total Energies in Hartree/particle. Keywords; ^^^^^^^^. .. include:: autodir_options_c/thermo__t.rst; .. include:: autodir_options_c/thermo__p.rst; .. include:: autodir_options_c/thermo__rotational_symmetry_number.rst. .. _`sec:thermoExamples`:. Examples; ^^^^^^^^. A thermochemical analysis is performed after any full (not just specific; symmetry subgroups). If the wavefunction is retained, it may be reused; at a different temperature, pressure, rotational symmetry number, or; isotopic substitution through the function :py:func:`psi4.driver.qcdb.vib.thermo`; as is shown in :srcsample:`freq-isotope2`. A few summary psivars are set: ""ZPVE"", ""THERMAL ENERGY CORRECTION"",; ""ENTHALPY CORRECTION"", ""GIBBS FREE ENERGY CORRECTION"", ""ZERO K; ENTHALPHY"", ""THERMAL ENERGY"", ""ENTHALPY"", ""GIBBS FREE ENERGY"".; But additionally, every valid combination of {S, Cv, Cp, ZPE, E, H, G}; with {elec, trans, rot, vib, corr, tot} (e.g., vibrational entropy,; S_vib, and enthalpy correction, H_corr) is returned by dictionary; from the ``thermo`` function. See :source:`tests/pytests/test_vibanalysis.py`; (near the end) for an example. .. index::; pair: vibrational analysis; output. Output; ^^^^^^. The full list of keywords for thermo is provided in Appendix :ref:`apdx:thermo`. Information on the Psithon function that driv",MatchSource.DOCS,doc/sphinxman/source/thermo.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/thermo.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/thermo.rst:3529,Testability,test,tests,3529,"ive to elements in their standard; states. If you are computing thermodynamic differences, like a reaction; enthalpy computed as the enthalpy of the products minus the enthalpy; of the reactants, then these ""absolute"" enthalpies are perfectly valid; and usable. However, they cannot be mixed and matched with enthalpies of; formation from reference books, since the zero of energy is not the same.; Additionally, the ""thermal energies"" reported in kcal/mol are the ; finite-temperature *corrections* to the electronic total energy, and ; not the overall thermal energies themselves. If in doubt, use the; reported Total Energies in Hartree/particle. Keywords; ^^^^^^^^. .. include:: autodir_options_c/thermo__t.rst; .. include:: autodir_options_c/thermo__p.rst; .. include:: autodir_options_c/thermo__rotational_symmetry_number.rst. .. _`sec:thermoExamples`:. Examples; ^^^^^^^^. A thermochemical analysis is performed after any full (not just specific; symmetry subgroups). If the wavefunction is retained, it may be reused; at a different temperature, pressure, rotational symmetry number, or; isotopic substitution through the function :py:func:`psi4.driver.qcdb.vib.thermo`; as is shown in :srcsample:`freq-isotope2`. A few summary psivars are set: ""ZPVE"", ""THERMAL ENERGY CORRECTION"",; ""ENTHALPY CORRECTION"", ""GIBBS FREE ENERGY CORRECTION"", ""ZERO K; ENTHALPHY"", ""THERMAL ENERGY"", ""ENTHALPY"", ""GIBBS FREE ENERGY"".; But additionally, every valid combination of {S, Cv, Cp, ZPE, E, H, G}; with {elec, trans, rot, vib, corr, tot} (e.g., vibrational entropy,; S_vib, and enthalpy correction, H_corr) is returned by dictionary; from the ``thermo`` function. See :source:`tests/pytests/test_vibanalysis.py`; (near the end) for an example. .. index::; pair: vibrational analysis; output. Output; ^^^^^^. The full list of keywords for thermo is provided in Appendix :ref:`apdx:thermo`. Information on the Psithon function that drives frequency analyses is provided; at :py:func:`~psi4.driver.frequency`. ",MatchSource.DOCS,doc/sphinxman/source/thermo.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/thermo.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/thermo.rst:2113,Usability,usab,usable,2113,"SE; .. #. .. include:: autodoc_abbr_options_c.rst. .. index::; single: harmonic vibrational analysis, vibrational analysis, thermochemical analysis. .. _`sec:thermo`:. Vibrational and Thermochemical Analysis; =======================================. .. codeauthor:: Rollin A. King and Lori A. Burns; .. sectionauthor:: Lori A. Burns. *Module:* :ref:`Keywords <apdx:thermo>`, :ref:`PSI Variables <apdx:thermo_psivar>`, :source:`THERMO <psi4/driver/qcdb/vib.py>`. .. caution:: It is important to know that |PSIfour|, like any other; quantum chemistry program, does *not* compute the usual enthalpies,; entropies, or Gibbs free energies *of formation* provided by most; reference books. Instead, quantum chemistry programs compute ""absolute""; thermodynamic properties relative to infinitely separated nuclei and; electrons, not ""formation"" values relative to elements in their standard; states. If you are computing thermodynamic differences, like a reaction; enthalpy computed as the enthalpy of the products minus the enthalpy; of the reactants, then these ""absolute"" enthalpies are perfectly valid; and usable. However, they cannot be mixed and matched with enthalpies of; formation from reference books, since the zero of energy is not the same.; Additionally, the ""thermal energies"" reported in kcal/mol are the ; finite-temperature *corrections* to the electronic total energy, and ; not the overall thermal energies themselves. If in doubt, use the; reported Total Energies in Hartree/particle. Keywords; ^^^^^^^^. .. include:: autodir_options_c/thermo__t.rst; .. include:: autodir_options_c/thermo__p.rst; .. include:: autodir_options_c/thermo__rotational_symmetry_number.rst. .. _`sec:thermoExamples`:. Examples; ^^^^^^^^. A thermochemical analysis is performed after any full (not just specific; symmetry subgroups). If the wavefunction is retained, it may be reused; at a different temperature, pressure, rotational symmetry number, or; isotopic substitution through the function :py:func:`psi",MatchSource.DOCS,doc/sphinxman/source/thermo.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/thermo.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tutorial.rst:7338,Availability,down,downhill,7338,"ree--Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; ROHF). Geometry Optimization and Vibrational Frequency Analysis; ========================================================. The above examples were simple single-point energy computations; (as specified by the :py:func:`~psi4.driver.energy` function). Of course there are other; kinds of computations to perform, such as geometry optimizations and; vibrational frequency computations. These can be specified by replacing; :py:func:`~psi4.driver.energy` with :py:func:`~psi4.driver.optimize` or :py:func:`~psi4.driver.frequency`, respectively. Here's an example of optimizing the H\ :sub:`2`\ O molecule using Hartree--Fock with; a cc-pVDZ basis set (located in; :srcsample:`tu3-h2o-opt`). .. literalinclude:: @SFNX_INCLUDE@samples/tu3-h2o-opt/input.dat. This should perform a series of gradient computations. The gradient points; which way is downhill in energy, and the optimizer then modifies the; geometry to follow the gradient. After a few cycles, the geometry should; converge with a message like ``Optimization is complete!``. As indicated; in the following table (printed by the optimizer at the end of the; computation and grep-able with ``~``), the energy decreases with each step,; and the maximum force on each atom also decreases with each step (in; principle these numbers could increase in some iterations, but here they do; not). ::. --------------------------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------------------------- ~; 1 -76.026632734857 -76.026632734857 0.01523505 0.01245744 0.02742199 0.02277500 ~; 2 -76.027022668419 -0.000389933562 0.00178749 0.00142923 0.01007985 0.00594840 ~; 3 -76.027032729361 -0.000010060942 0.00014016 0.00008485 0",MatchSource.DOCS,doc/sphinxman/source/tutorial.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tutorial.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tutorial.rst:9852,Availability,error,errors,9852,"ational frequency analysis, being very careful to copy over the; optimized geometry from the *bottom* of the output file for the geometry; optimization. This geometry could be specified in either z-matrix or; Cartesian formats. However, there's a much easier way to do this. If we; specify a vibrational frequency analysis in the same input file as the; optimization, after the optimization function has been called, then the; optimized geometry will automatically be carried over. So, it's easiset to do the optimization and vibrational frequency analysis; together. This can be specified as follows (see test case; :srcsample:`tu4-h2o-freq`):. .. literalinclude:: @SFNX_INCLUDE@samples/tu4-h2o-freq/input.dat. The program will do the same optimization as in our previous example,; but then it will follow it with some computations to obtain the Hessian; (second derivative matrix) of the electronic energy with respect to; nuclear displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around 0.1 cm\ :sup:`-1`; may exist)::. Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6480; A1 4113.3794; B2 4212.1826; -----------------------------------------------. Notice that the symmetry type of the normal modes is specified (A1, A1,; B2). The program also prints out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at 1776 cm\ :sup:`-1` ; is::. Frequency: 1775.65; Force constant: 0.1193; X Y Z mass; O 0.000 0.000 -0.270 15.994915; H 0.000 0.417 0.538 1.007825; H 0.000 -0.417 0.538 1.007825. where the table shows the displacements in the X, Y, and Z dimensions for; each atom along the normal mode coordinate. (This information could be used; to animate the vibrational frequency using visualization software.). Because the vibrational frequencies are available, a thermodynamics; analysis is automatically performed at the end of the computation.; You ",MatchSource.DOCS,doc/sphinxman/source/tutorial.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tutorial.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tutorial.rst:10717,Availability,avail,available,10717,"uclear displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around 0.1 cm\ :sup:`-1`; may exist)::. Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6480; A1 4113.3794; B2 4212.1826; -----------------------------------------------. Notice that the symmetry type of the normal modes is specified (A1, A1,; B2). The program also prints out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at 1776 cm\ :sup:`-1` ; is::. Frequency: 1775.65; Force constant: 0.1193; X Y Z mass; O 0.000 0.000 -0.270 15.994915; H 0.000 0.417 0.538 1.007825; H 0.000 -0.417 0.538 1.007825. where the table shows the displacements in the X, Y, and Z dimensions for; each atom along the normal mode coordinate. (This information could be used; to animate the vibrational frequency using visualization software.). Because the vibrational frequencies are available, a thermodynamics; analysis is automatically performed at the end of the computation.; You can see this in the next section of the output file. The vibrational; frequencies are sufficient to obtain vibrational contributions to; enthalpy (H), entropy (S), and Gibbs free energy (G). Similarly, the; molecular geometry is used to obtain rotational constants, which are; then used to obtain rotational contributions to H, S, and G. .. _`sec:tutorial_tu5`:. Analysis of Intermolecular Interactions; =======================================. Now let's consider something a little more interesting. |PSIfour|; contains code to analyze the nature of intermolecular interactions; between two molecules, via symmetry-adapted perturbation theory; (SAPT) [Jeziorski:1994:1887]_. This kind of analysis gives a lot; of insight into the nature of intermolecular interactions, and |PSIfour|; makes these computations easier than ever. For a SAPT computation, the input needs to provide information on two; distinct molecules. This is",MatchSource.DOCS,doc/sphinxman/source/tutorial.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tutorial.rst
https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tutorial.rst:13335,Availability,error,error,13335," set {; basis jun-cc-pVDZ; scf_type DF; freeze_core True; }; ; energy('sapt0'). Before, we have been setting keywords individually with commands like; ``set basis cc-pVDZ``. Because we have a few more options now, it's; convenient to place them together into the ``set``; block, bounded by ``{...}``. This; will set all of these options as ""global"" options (meaning that they are; visible to all parts of the program). Most common |PSIfour| options can be; set in a globals section like this. If an option needs to be visible; only to one part of the program (*e.g.*, we only want to increase the; energy convergence in the SCF code, but not the rest of the; code), it can be placed in a section of input visible to that part of the; program (*e.g.*, ``set scf e_convergence 1.0E-8``). Back to our SAPT example, we have found that for basic-level SAPT; computations (*i.e.*, SAPT0), a good error cancellation is found; [Hohenstein:2012:WIREs]_ with the jun-cc-pVDZ basis (this is the; usual aug-cc-pVDZ basis, but without diffuse functions on hydrogen and; without diffuse :math:`d` functions on heavy atoms) [Papajak:2011:10]_. So,; we'll use that as our standard basis set. The SAPT code is designed to; use density fitting techniques, because they introduce minimal errors; while providing much faster computations [Hohenstein:2010:184111]_ ; [Hohenstein:2010:014101]_. Since we're using density fitting for the SAPT,; we might as well also use it for the Hartree--Fock computations that are; performed as part of the SAPT. We can specify that with ; ``scf_type DF``. Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, |PSIfour| is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that |PSIfour| correctly guesses that we want the jun-cc-pVDZ-JKFIT; a",MatchSource.DOCS,doc/sphinxman/source/tutorial.rst,psi4,psi4,v1.9.1,https://psicode.org,https://github.com/psi4/psi4/tree/v1.9.1/doc/sphinxman/source/tutorial.rst
