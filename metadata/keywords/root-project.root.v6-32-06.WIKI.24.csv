quality_attribute,keyword,matched_word,sentence,source,filename,author,repo,version,wiki,url
Energy Efficiency,power,powerful,". RooStats::NumberCountingPdfFactory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::NumberCountingPdfFactory. class RooStats::NumberCountingPdfFactory. A factory for building PDFs and data for a number counting combination. ; The factory produces a PDF for N channels with uncorrelated background ; uncertainty. Correlations can be added by extending this PDF with additional terms.; The factory relates the signal in each channel to a master signal strength times the ; expected signal in each channel. Thus, the final test is performed on the master signal strength.; This yields a more powerful test than letting signal in each channel be independent. The problem has been studied in these references:. http://arxiv.org/abs/physics/0511028; http://arxiv.org/abs/physics/0702156; http://cdsweb.cern.ch/record/1099969?ln=en. One can incorporate uncertainty on the expected signal by adding additional terms.; For the future, perhaps this factory should be extended to include the efficiency terms automatically. Function Members (Methods); public:. virtual~NumberCountingPdfFactory(); voidAddData(Double_t* mainMeas, Double_t* bkgMeas, Double_t* db, Int_t nbins, RooWorkspace* ws, const char* dsName = ""NumberCountingData""); voidAddDataWithSideband(Double_t* mainMeas, Double_t* sideband, Double_t* tau, Int_t nbins, RooWorkspace* ws, const char* dsName = ""ExpectedNumberCountingData""); voidAddExpData(Double_t* sigExp, Double_t* bkgExp, Double_t* db, Int_t nbins, RooWorkspace* ws, const char* dsName = ""ExpectedNumberCountingData""); voidAddExpDataWithSideband(Double_t* sigExp, Double_t* bkgExp, Double_t* tau, Int_t nbins, RooWorkspace* ws, const char* dsName = ""NumberCountingData""); voidAddModel(Double_t* sigExp, Int_t nchan, RooWorkspace* ws, const char* pdfName = ""CombinedPdf"", const char* ",MatchSource.WIKI,root/html530/RooStats__NumberCountingPdfFactory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__NumberCountingPdfFactory.html
Modifiability,extend,extending,". RooStats::NumberCountingPdfFactory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::NumberCountingPdfFactory. class RooStats::NumberCountingPdfFactory. A factory for building PDFs and data for a number counting combination. ; The factory produces a PDF for N channels with uncorrelated background ; uncertainty. Correlations can be added by extending this PDF with additional terms.; The factory relates the signal in each channel to a master signal strength times the ; expected signal in each channel. Thus, the final test is performed on the master signal strength.; This yields a more powerful test than letting signal in each channel be independent. The problem has been studied in these references:. http://arxiv.org/abs/physics/0511028; http://arxiv.org/abs/physics/0702156; http://cdsweb.cern.ch/record/1099969?ln=en. One can incorporate uncertainty on the expected signal by adding additional terms.; For the future, perhaps this factory should be extended to include the efficiency terms automatically. Function Members (Methods); public:. virtual~NumberCountingPdfFactory(); voidAddData(Double_t* mainMeas, Double_t* bkgMeas, Double_t* db, Int_t nbins, RooWorkspace* ws, const char* dsName = ""NumberCountingData""); voidAddDataWithSideband(Double_t* mainMeas, Double_t* sideband, Double_t* tau, Int_t nbins, RooWorkspace* ws, const char* dsName = ""ExpectedNumberCountingData""); voidAddExpData(Double_t* sigExp, Double_t* bkgExp, Double_t* db, Int_t nbins, RooWorkspace* ws, const char* dsName = ""ExpectedNumberCountingData""); voidAddExpDataWithSideband(Double_t* sigExp, Double_t* bkgExp, Double_t* tau, Int_t nbins, RooWorkspace* ws, const char* dsName = ""NumberCountingData""); voidAddModel(Double_t* sigExp, Int_t nchan, RooWorkspace* ws, const char* pdfName = ""CombinedPdf"", const char* ",MatchSource.WIKI,root/html530/RooStats__NumberCountingPdfFactory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__NumberCountingPdfFactory.html
Performance,perform,performed,". RooStats::NumberCountingPdfFactory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::NumberCountingPdfFactory. class RooStats::NumberCountingPdfFactory. A factory for building PDFs and data for a number counting combination. ; The factory produces a PDF for N channels with uncorrelated background ; uncertainty. Correlations can be added by extending this PDF with additional terms.; The factory relates the signal in each channel to a master signal strength times the ; expected signal in each channel. Thus, the final test is performed on the master signal strength.; This yields a more powerful test than letting signal in each channel be independent. The problem has been studied in these references:. http://arxiv.org/abs/physics/0511028; http://arxiv.org/abs/physics/0702156; http://cdsweb.cern.ch/record/1099969?ln=en. One can incorporate uncertainty on the expected signal by adding additional terms.; For the future, perhaps this factory should be extended to include the efficiency terms automatically. Function Members (Methods); public:. virtual~NumberCountingPdfFactory(); voidAddData(Double_t* mainMeas, Double_t* bkgMeas, Double_t* db, Int_t nbins, RooWorkspace* ws, const char* dsName = ""NumberCountingData""); voidAddDataWithSideband(Double_t* mainMeas, Double_t* sideband, Double_t* tau, Int_t nbins, RooWorkspace* ws, const char* dsName = ""ExpectedNumberCountingData""); voidAddExpData(Double_t* sigExp, Double_t* bkgExp, Double_t* db, Int_t nbins, RooWorkspace* ws, const char* dsName = ""ExpectedNumberCountingData""); voidAddExpDataWithSideband(Double_t* sigExp, Double_t* bkgExp, Double_t* tau, Int_t nbins, RooWorkspace* ws, const char* dsName = ""NumberCountingData""); voidAddModel(Double_t* sigExp, Int_t nchan, RooWorkspace* ws, const char* pdfName = ""CombinedPdf"", const char* ",MatchSource.WIKI,root/html530/RooStats__NumberCountingPdfFactory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__NumberCountingPdfFactory.html
Testability,test,test,". RooStats::NumberCountingPdfFactory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::NumberCountingPdfFactory. class RooStats::NumberCountingPdfFactory. A factory for building PDFs and data for a number counting combination. ; The factory produces a PDF for N channels with uncorrelated background ; uncertainty. Correlations can be added by extending this PDF with additional terms.; The factory relates the signal in each channel to a master signal strength times the ; expected signal in each channel. Thus, the final test is performed on the master signal strength.; This yields a more powerful test than letting signal in each channel be independent. The problem has been studied in these references:. http://arxiv.org/abs/physics/0511028; http://arxiv.org/abs/physics/0702156; http://cdsweb.cern.ch/record/1099969?ln=en. One can incorporate uncertainty on the expected signal by adding additional terms.; For the future, perhaps this factory should be extended to include the efficiency terms automatically. Function Members (Methods); public:. virtual~NumberCountingPdfFactory(); voidAddData(Double_t* mainMeas, Double_t* bkgMeas, Double_t* db, Int_t nbins, RooWorkspace* ws, const char* dsName = ""NumberCountingData""); voidAddDataWithSideband(Double_t* mainMeas, Double_t* sideband, Double_t* tau, Int_t nbins, RooWorkspace* ws, const char* dsName = ""ExpectedNumberCountingData""); voidAddExpData(Double_t* sigExp, Double_t* bkgExp, Double_t* db, Int_t nbins, RooWorkspace* ws, const char* dsName = ""ExpectedNumberCountingData""); voidAddExpDataWithSideband(Double_t* sigExp, Double_t* bkgExp, Double_t* tau, Int_t nbins, RooWorkspace* ws, const char* dsName = ""NumberCountingData""); voidAddModel(Double_t* sigExp, Int_t nchan, RooWorkspace* ws, const char* pdfName = ""CombinedPdf"", const char* ",MatchSource.WIKI,root/html530/RooStats__NumberCountingPdfFactory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__NumberCountingPdfFactory.html
Testability,test,test,". RooStats::NumberCountingUtils. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; namespace description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::NumberCountingUtils. namespace RooStats::NumberCountingUtils. NumberCountingUtils. These are RooStats standalone utilities; that calculate the p-value or Z value (eg. significance in; 1-sided Gaussian standard deviations) for a number counting experiment.; This is a hypothesis test between background only and signal-plus-background.; The background estimate has uncertainty derived from an auxiliary or sideband; measurement. This is based on code and comments from Bob Cousins ; and on the following papers:. Evaluation of three methods for calculating statistical significance when incorporating a; systematic uncertainty into a test of the background-only hypothesis for a Poisson process; Authors: Robert D. Cousins, James T. Linnemann, Jordan Tucker; http://arxiv.org/abs/physics/0702156; NIM A 595 (2008) 480--501. Statistical Challenges for Searches for New Physics at the LHC; Authors: Kyle Cranmer; http://arxiv.org/abs/physics/0511028. Measures of Significance in HEP and Astrophysics; Authors: J. T. Linnemann; http://arxiv.org/abs/physics/0312059. The problem is treated in a fully frequentist fashion by ; interpreting the relative background uncertainty as; being due to an auxiliary or sideband observation ; that is also Poisson distributed with only background.; Finally, one considers the test as a ratio of Poisson means; where an interval is well known based on the conditioning on the total; number of events and the binomial distribution. In short, this is an exact frequentist solution to the problem of; a main measurement x distributed as a Poisson around s+b and a sideband or ; auxiliary measurement y distributed as a Poisson around tau*b. Eg. . Naming conventions:; Exp = Expected; Obs = Observed; P = p-value;",MatchSource.WIKI,root/html530/RooStats__NumberCountingUtils.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__NumberCountingUtils.html
Integrability,interface,interface,". RooStats::NumEventsTestStat. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::NumEventsTestStat. class RooStats::NumEventsTestStat: public RooStats::TestStatistic. NumEventsTestStat is a simple implementation of the TestStatistic interface used for simple number counting.; It should probably support simple cuts as well. Function Members (Methods); public:. virtual~NumEventsTestStat(); static TClass*Class(); virtual Double_tEvaluate(RooAbsData& data, RooArgSet&); virtual const RooAbsArg*GetTestStatistic() const; virtual const TStringGetVarName() const; virtual TClass*IsA() const; RooStats::NumEventsTestStatNumEventsTestStat(); RooStats::NumEventsTestStatNumEventsTestStat(RooAbsPdf& pdf); RooStats::NumEventsTestStatNumEventsTestStat(const RooStats::NumEventsTestStat&); RooStats::NumEventsTestStat&operator=(const RooStats::NumEventsTestStat&); virtual boolRooStats::TestStatistic::PValueIsRightTail() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. RooAbsPdf*fPdf. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; NumEventsTestStat(); { }. NumEventsTestStat(RooAbsPdf& pdf). virtual ~NumEventsTestStat(); delete fRand;; delete fTestStatistic;. Double_t Evaluate(RooAbsData& data, RooArgSet& ); Main interface to evaluate the test statistic on a dataset. const RooAbsArg* GetTestStatistic() const; Get the TestStatistic. {return fPdf;}. const TString GetVarName() const; {return ""Number of events"";}. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: NumEventsTestStat.h 39391 2011-05-26 09:51:59Z moneta $ » Last generated: 2011-07-04 15:24; This page has ",MatchSource.WIKI,root/html530/RooStats__NumEventsTestStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__NumEventsTestStat.html
Testability,test,test,"ions:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::NumEventsTestStat. class RooStats::NumEventsTestStat: public RooStats::TestStatistic. NumEventsTestStat is a simple implementation of the TestStatistic interface used for simple number counting.; It should probably support simple cuts as well. Function Members (Methods); public:. virtual~NumEventsTestStat(); static TClass*Class(); virtual Double_tEvaluate(RooAbsData& data, RooArgSet&); virtual const RooAbsArg*GetTestStatistic() const; virtual const TStringGetVarName() const; virtual TClass*IsA() const; RooStats::NumEventsTestStatNumEventsTestStat(); RooStats::NumEventsTestStatNumEventsTestStat(RooAbsPdf& pdf); RooStats::NumEventsTestStatNumEventsTestStat(const RooStats::NumEventsTestStat&); RooStats::NumEventsTestStat&operator=(const RooStats::NumEventsTestStat&); virtual boolRooStats::TestStatistic::PValueIsRightTail() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. RooAbsPdf*fPdf. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; NumEventsTestStat(); { }. NumEventsTestStat(RooAbsPdf& pdf). virtual ~NumEventsTestStat(); delete fRand;; delete fTestStatistic;. Double_t Evaluate(RooAbsData& data, RooArgSet& ); Main interface to evaluate the test statistic on a dataset. const RooAbsArg* GetTestStatistic() const; Get the TestStatistic. {return fPdf;}. const TString GetVarName() const; {return ""Number of events"";}. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: NumEventsTestStat.h 39391 2011-05-26 09:51:59Z moneta $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooStats__NumEventsTestStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__NumEventsTestStat.html
Usability,simpl,simple,". RooStats::NumEventsTestStat. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::NumEventsTestStat. class RooStats::NumEventsTestStat: public RooStats::TestStatistic. NumEventsTestStat is a simple implementation of the TestStatistic interface used for simple number counting.; It should probably support simple cuts as well. Function Members (Methods); public:. virtual~NumEventsTestStat(); static TClass*Class(); virtual Double_tEvaluate(RooAbsData& data, RooArgSet&); virtual const RooAbsArg*GetTestStatistic() const; virtual const TStringGetVarName() const; virtual TClass*IsA() const; RooStats::NumEventsTestStatNumEventsTestStat(); RooStats::NumEventsTestStatNumEventsTestStat(RooAbsPdf& pdf); RooStats::NumEventsTestStatNumEventsTestStat(const RooStats::NumEventsTestStat&); RooStats::NumEventsTestStat&operator=(const RooStats::NumEventsTestStat&); virtual boolRooStats::TestStatistic::PValueIsRightTail() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. RooAbsPdf*fPdf. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; NumEventsTestStat(); { }. NumEventsTestStat(RooAbsPdf& pdf). virtual ~NumEventsTestStat(); delete fRand;; delete fTestStatistic;. Double_t Evaluate(RooAbsData& data, RooArgSet& ); Main interface to evaluate the test statistic on a dataset. const RooAbsArg* GetTestStatistic() const; Get the TestStatistic. {return fPdf;}. const TString GetVarName() const; {return ""Number of events"";}. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: NumEventsTestStat.h 39391 2011-05-26 09:51:59Z moneta $ » Last generated: 2011-07-04 15:24; This page has ",MatchSource.WIKI,root/html530/RooStats__NumEventsTestStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__NumEventsTestStat.html
Availability,error,error," voidAddMapping(RooRealVar& proposalParam, RooAbsReal& update); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual boolRooStats::ProposalFunction::CheckParameters(RooArgSet& params); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const RooAbsPdf*GetPdf() const; virtual Double_tGetProposalDensity(RooArgSet& x1, RooArgSet& x2); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(con",MatchSource.WIKI,root/html530/RooStats__PdfProposal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__PdfProposal.html
Deployability,update,updated,"Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::PdfProposal. class RooStats::PdfProposal: public RooStats::ProposalFunction. PdfProposal is a concrete implementation of the ProposalFunction interface.; It proposes points across the parameter space in the distribution of the; given PDF. To make Propose(xPrime, x) dependent on x, configure with; PdfProposal::AddMapping(varToUpdate, valueToUse). For example, suppose we have:. // our parameter; RooRealVar p(""p"", ""p"", 5, 0, 10);; // create mean and sigma for gaussian proposal function; RooRealVar meanP(""meanP"", ""meanP"", 0, 10);; RooRealVar sigma(""sigma"", ""sigma"", 1, 0, 5);; RooGaussian pGaussian(""pGaussian"", ""pGaussian"", p, meanP, sigma);; // configure proposal function; PdfProposal pdfProposal(pGaussian);; pdfProposal.AddMapping(meanP, p); // each call of Propose(xPrime, x), meanP in; // the proposal function will be updated to; // the value of p in x. this will center the; // proposal function about x's p when; // proposing for xPrime; // To improve performance, PdfProposal has the ability to cache a specified; // number of proposals. If you don't call this function, the default cache size; // is 1, which can be slow.; pdfProposal.SetCacheSize(desiredCacheSize);. PdfProposal currently uses a fixed cache size. Adaptive caching methods are in the works; for future versions. Function Members (Methods); public:. virtual~PdfProposal(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddMapping(RooRealVar& proposalParam, RooAbsReal& update); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual boolRooStats::ProposalFunction::CheckParameters(RooArgSet& params); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clon",MatchSource.WIKI,root/html530/RooStats__PdfProposal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__PdfProposal.html
Integrability,interface,interface,". RooStats::PdfProposal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::PdfProposal. class RooStats::PdfProposal: public RooStats::ProposalFunction. PdfProposal is a concrete implementation of the ProposalFunction interface.; It proposes points across the parameter space in the distribution of the; given PDF. To make Propose(xPrime, x) dependent on x, configure with; PdfProposal::AddMapping(varToUpdate, valueToUse). For example, suppose we have:. // our parameter; RooRealVar p(""p"", ""p"", 5, 0, 10);; // create mean and sigma for gaussian proposal function; RooRealVar meanP(""meanP"", ""meanP"", 0, 10);; RooRealVar sigma(""sigma"", ""sigma"", 1, 0, 5);; RooGaussian pGaussian(""pGaussian"", ""pGaussian"", p, meanP, sigma);; // configure proposal function; PdfProposal pdfProposal(pGaussian);; pdfProposal.AddMapping(meanP, p); // each call of Propose(xPrime, x), meanP in; // the proposal function will be updated to; // the value of p in x. this will center the; // proposal function about x's p when; // proposing for xPrime; // To improve performance, PdfProposal has the ability to cache a specified; // number of proposals. If you don't call this function, the default cache size; // is 1, which can be slow.; pdfProposal.SetCacheSize(desiredCacheSize);. PdfProposal currently uses a fixed cache size. Adaptive caching methods are in the works; for future versions. Function Members (Methods); public:. virtual~PdfProposal(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddMapping(RooRealVar& proposalParam, RooAbsReal& update); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual boolRooStats::ProposalFunction::CheckParameters(RooArgSet& params); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual",MatchSource.WIKI,root/html530/RooStats__PdfProposal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__PdfProposal.html
Modifiability,config,configure,". RooStats::PdfProposal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::PdfProposal. class RooStats::PdfProposal: public RooStats::ProposalFunction. PdfProposal is a concrete implementation of the ProposalFunction interface.; It proposes points across the parameter space in the distribution of the; given PDF. To make Propose(xPrime, x) dependent on x, configure with; PdfProposal::AddMapping(varToUpdate, valueToUse). For example, suppose we have:. // our parameter; RooRealVar p(""p"", ""p"", 5, 0, 10);; // create mean and sigma for gaussian proposal function; RooRealVar meanP(""meanP"", ""meanP"", 0, 10);; RooRealVar sigma(""sigma"", ""sigma"", 1, 0, 5);; RooGaussian pGaussian(""pGaussian"", ""pGaussian"", p, meanP, sigma);; // configure proposal function; PdfProposal pdfProposal(pGaussian);; pdfProposal.AddMapping(meanP, p); // each call of Propose(xPrime, x), meanP in; // the proposal function will be updated to; // the value of p in x. this will center the; // proposal function about x's p when; // proposing for xPrime; // To improve performance, PdfProposal has the ability to cache a specified; // number of proposals. If you don't call this function, the default cache size; // is 1, which can be slow.; pdfProposal.SetCacheSize(desiredCacheSize);. PdfProposal currently uses a fixed cache size. Adaptive caching methods are in the works; for future versions. Function Members (Methods); public:. virtual~PdfProposal(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddMapping(RooRealVar& proposalParam, RooAbsReal& update); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual boolRooStats::ProposalFunction::CheckParameters(RooArgSet& params); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual",MatchSource.WIKI,root/html530/RooStats__PdfProposal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__PdfProposal.html
Performance,perform,performance,"ts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::PdfProposal. class RooStats::PdfProposal: public RooStats::ProposalFunction. PdfProposal is a concrete implementation of the ProposalFunction interface.; It proposes points across the parameter space in the distribution of the; given PDF. To make Propose(xPrime, x) dependent on x, configure with; PdfProposal::AddMapping(varToUpdate, valueToUse). For example, suppose we have:. // our parameter; RooRealVar p(""p"", ""p"", 5, 0, 10);; // create mean and sigma for gaussian proposal function; RooRealVar meanP(""meanP"", ""meanP"", 0, 10);; RooRealVar sigma(""sigma"", ""sigma"", 1, 0, 5);; RooGaussian pGaussian(""pGaussian"", ""pGaussian"", p, meanP, sigma);; // configure proposal function; PdfProposal pdfProposal(pGaussian);; pdfProposal.AddMapping(meanP, p); // each call of Propose(xPrime, x), meanP in; // the proposal function will be updated to; // the value of p in x. this will center the; // proposal function about x's p when; // proposing for xPrime; // To improve performance, PdfProposal has the ability to cache a specified; // number of proposals. If you don't call this function, the default cache size; // is 1, which can be slow.; pdfProposal.SetCacheSize(desiredCacheSize);. PdfProposal currently uses a fixed cache size. Adaptive caching methods are in the works; for future versions. Function Members (Methods); public:. virtual~PdfProposal(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddMapping(RooRealVar& proposalParam, RooAbsReal& update); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual boolRooStats::ProposalFunction::CheckParameters(RooArgSet& params); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject:",MatchSource.WIKI,root/html530/RooStats__PdfProposal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__PdfProposal.html
Availability,error,error,"AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tCheckParameters(const RooArgSet&) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tConfidenceLevel() const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; RooAbsData*GetParameterPoints() const; virtual RooArgSet*GetParameters() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voi",MatchSource.WIKI,root/html530/RooStats__PointSetInterval.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__PointSetInterval.html
Integrability,interface,interface,". RooStats::PointSetInterval. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::PointSetInterval. class RooStats::PointSetInterval: public RooStats::ConfInterval. PointSetInterval is a concrete implementation of the ConfInterval interface. ; It implements simple general purpose interval of arbitrary dimensions and shape.; It does not assume the interval is connected.; It uses either a RooDataSet (eg. a list of parameter points in the interval) or; a RooDataHist (eg. a Histogram-like object for small regions of the parameter space) to; store the interval. ; . Function Members (Methods); public:. virtual~PointSetInterval(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tCheckParameters(const RooArgSet&) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tConfidenceLevel() const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); ",MatchSource.WIKI,root/html530/RooStats__PointSetInterval.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__PointSetInterval.html
Usability,simpl,simple,". RooStats::PointSetInterval. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::PointSetInterval. class RooStats::PointSetInterval: public RooStats::ConfInterval. PointSetInterval is a concrete implementation of the ConfInterval interface. ; It implements simple general purpose interval of arbitrary dimensions and shape.; It does not assume the interval is connected.; It uses either a RooDataSet (eg. a list of parameter points in the interval) or; a RooDataHist (eg. a Histogram-like object for small regions of the parameter space) to; store the interval. ; . Function Members (Methods); public:. virtual~PointSetInterval(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tCheckParameters(const RooArgSet&) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tConfidenceLevel() const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); ",MatchSource.WIKI,root/html530/RooStats__PointSetInterval.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__PointSetInterval.html
Modifiability,config,config,". RooStats::ProfileInspector. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::ProfileInspector. class RooStats::ProfileInspector. ProfileInspector :. Utility class to plot conditional MLE of nuisance parameters vs. Parameters of Interest. Function Members (Methods); public:. virtual~ProfileInspector(); static TClass*Class(); TList*GetListOfProfilePlots(RooAbsData& data, RooStats::ModelConfig* config); virtual TClass*IsA() const; RooStats::ProfileInspector&operator=(const RooStats::ProfileInspector&); RooStats::ProfileInspectorProfileInspector(); RooStats::ProfileInspectorProfileInspector(const RooStats::ProfileInspector&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ProfileInspector(). ~ProfileInspector(); ProfileInspector destructor. TList* GetListOfProfilePlots(RooAbsData& data, RooStats::ModelConfig* config). ProfileInspector(). » Last changed: root/roostats:$Id: ProfileInspector.h 31793 2009-12-10 14:43:51Z cranmer $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooStats__ProfileInspector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__ProfileInspector.html
Availability,error,error,"tRooStats::CombinedCalculator::Size() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidDoGlobalFit() const; voidDoReset() const; RooAbsData*RooStats::CombinedCalculator::GetData() const; RooAbsPdf*RooStats::CombinedCalculator::GetPdf() const. Data Members; public:. RooFitResult*fFitResultinternal result of gloabl fit . protected:. RooArgSetRooStats::CombinedCalculator::fAlternateParamsRooArgSet specifying alternate parameters for hypothesis test // Is it used ????; RooAbsData*RooStats::CombinedCalculator::fData; RooArgSetRooStats::CombinedCalculator::fNuisParamsRooArgSet specifying nuisance parameters for interval; RooArgSetRooStats::CombinedCalculator::fNullParamsRooArgSet specifying null parameters for hypothesis test; RooArgSetRooStats::CombinedCalculator::fPOIRooArgSet specifying parameters of interest for interval; RooAbsPdf*RooStats::CombinedCalculator::fPdf; Double_tRooStats::CombinedCalculator::fSizesize of the test (eg. specified rate of Type I error). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ProfileLikelihoodCalculator(); default constructor. ProfileLikelihoodCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& paramsOfInterest, Double_t size = 0.05, const RooArgSet* nullParams = 0); constructor from pdf and parameters; the pdf must contain eventually the nuisance parameters. ProfileLikelihoodCalculator(RooAbsData& data, RooStats::ModelConfig& model, Double_t size = 0.05); construct from a ModelConfig. Assume data model.GetPdf() will provide full description of model including; constraint term on the nuisances parameters. ~ProfileLikelihoodCalculator(); destructor; cannot delete prod pdf because it will delete all the composing pdf's; if (fOwnPdf) delete fPdf;; fPdf = 0;. void DoReset() const; reset and clear fit result; to be called when a new model or data are set in the calculator. void DoGlobalFit() const; perform a global fit of the likelihood letting w",MatchSource.WIKI,root/html530/RooStats__ProfileLikelihoodCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__ProfileLikelihoodCalculator.html
Deployability,integrat,integration,"f the CombinedCalculator, so that it can be configured by specifying:. a model common model (eg. a family of specific models which includes both the null and alternate),; a data set, ; a set of parameters of interest. The nuisance parameters will be all other parameters of the model ; a set of parameters of which specify the null hypothesis (including values and const/non-const status) . The interface allows one to pass the model, data, and parameters either directly or via a ModelConfig class.; The alternate hypothesis leaves the parameter free to take any value other than those specified by the null hypotesis. There is therefore no need to ; specify the alternate parameters. . After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer). The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods); public:. virtual~ProfileLikelihoodCalculator(); static TClass*Class(); virtual Double_tRooStats::CombinedCalculator::ConfidenceLevel() const; virtual RooStats::HypoTestResult*GetHypoTest() const; virtual RooStats::LikelihoodInterval*GetInterval() const; virtual TClass*IsA() const; RooStats::ProfileLikelihoodCalculator&operator=(const RooStats::ProfileLikelihoodCalculator&); RooStats::ProfileLikelihoodCalculatorProfileLikelihoodCalculator(); RooStats::ProfileLikelihoodCalculatorProfileLikelihoodCalculator(const RooStats::ProfileLikelihoodCalculator&); RooStats::ProfileLikelihoodCalculatorProfileLikelihoodCalculator(RooAbsData& data, RooStats::ModelConfig& model, Double_t size = 0.05); RooStats::ProfileLikelihoodCalculatorProfil",MatchSource.WIKI,root/html530/RooStats__ProfileLikelihoodCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__ProfileLikelihoodCalculator.html
Integrability,interface,interface,". RooStats::ProfileLikelihoodCalculator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::ProfileLikelihoodCalculator. class RooStats::ProfileLikelihoodCalculator: public RooStats::CombinedCalculator. ProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator ; (the interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals). ; The tool uses the profile likelihood ratio as a test statistic, and assumes that Wilks' theorem is valid. ; Wilks' theorem states that -2* log (profile likelihood ratio) is asymptotically distributed as a chi^2 distribution ; with N-dof, where N is the number of degrees of freedom. Thus, p-values can be constructed and the profile likelihood ratio; can be used to construct a LikelihoodInterval.; (In the future, this class could be extended to use toy Monte Carlo to calibrate the distribution of the test statistic). Usage: It uses the interface of the CombinedCalculator, so that it can be configured by specifying:. a model common model (eg. a family of specific models which includes both the null and alternate),; a data set, ; a set of parameters of interest. The nuisance parameters will be all other parameters of the model ; a set of parameters of which specify the null hypothesis (including values and const/non-const status) . The interface allows one to pass the model, data, and parameters either directly or via a ModelConfig class.; The alternate hypothesis leaves the parameter free to take any value other than those specified by the null hypotesis. There is therefore no need to ; specify the alternate parameters. . After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer). Th",MatchSource.WIKI,root/html530/RooStats__ProfileLikelihoodCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__ProfileLikelihoodCalculator.html
Modifiability,extend,extended,"Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::ProfileLikelihoodCalculator. class RooStats::ProfileLikelihoodCalculator: public RooStats::CombinedCalculator. ProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator ; (the interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals). ; The tool uses the profile likelihood ratio as a test statistic, and assumes that Wilks' theorem is valid. ; Wilks' theorem states that -2* log (profile likelihood ratio) is asymptotically distributed as a chi^2 distribution ; with N-dof, where N is the number of degrees of freedom. Thus, p-values can be constructed and the profile likelihood ratio; can be used to construct a LikelihoodInterval.; (In the future, this class could be extended to use toy Monte Carlo to calibrate the distribution of the test statistic). Usage: It uses the interface of the CombinedCalculator, so that it can be configured by specifying:. a model common model (eg. a family of specific models which includes both the null and alternate),; a data set, ; a set of parameters of interest. The nuisance parameters will be all other parameters of the model ; a set of parameters of which specify the null hypothesis (including values and const/non-const status) . The interface allows one to pass the model, data, and parameters either directly or via a ModelConfig class.; The alternate hypothesis leaves the parameter free to take any value other than those specified by the null hypotesis. There is therefore no need to ; specify the alternate parameters. . After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer). The concrete implementations of this interf",MatchSource.WIKI,root/html530/RooStats__ProfileLikelihoodCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__ProfileLikelihoodCalculator.html
Performance,perform,perform," error). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ProfileLikelihoodCalculator(); default constructor. ProfileLikelihoodCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& paramsOfInterest, Double_t size = 0.05, const RooArgSet* nullParams = 0); constructor from pdf and parameters; the pdf must contain eventually the nuisance parameters. ProfileLikelihoodCalculator(RooAbsData& data, RooStats::ModelConfig& model, Double_t size = 0.05); construct from a ModelConfig. Assume data model.GetPdf() will provide full description of model including; constraint term on the nuisances parameters. ~ProfileLikelihoodCalculator(); destructor; cannot delete prod pdf because it will delete all the composing pdf's; if (fOwnPdf) delete fPdf;; fPdf = 0;. void DoReset() const; reset and clear fit result; to be called when a new model or data are set in the calculator. void DoGlobalFit() const; perform a global fit of the likelihood letting with all parameter of interest and; nuisance parameters; keep the list of fitted parameters. LikelihoodInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval.; It constructs a profile likelihood ratio and uses that to construct a RooStats::LikelihoodInterval. HypoTestResult* GetHypoTest() const; Main interface to get a HypoTestResult.; It does two fits:; the first lets the null parameters float, so it's a maximum likelihood estimate; the second is to the null (fixing null parameters to their specified values): eg. a conditional maximum likelihood; the ratio of the likelihood at the conditional MLE to the MLE is the profile likelihood ratio.; Wilks' theorem is used to get p-values. ProfileLikelihoodCalculator(); default constructor (needed for I/O). » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: ProfileLikelihoodCalculator.h 39391 2011-05-26 09:51:59Z mo",MatchSource.WIKI,root/html530/RooStats__ProfileLikelihoodCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__ProfileLikelihoodCalculator.html
Testability,test,test,". RooStats::ProfileLikelihoodCalculator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::ProfileLikelihoodCalculator. class RooStats::ProfileLikelihoodCalculator: public RooStats::CombinedCalculator. ProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator ; (the interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals). ; The tool uses the profile likelihood ratio as a test statistic, and assumes that Wilks' theorem is valid. ; Wilks' theorem states that -2* log (profile likelihood ratio) is asymptotically distributed as a chi^2 distribution ; with N-dof, where N is the number of degrees of freedom. Thus, p-values can be constructed and the profile likelihood ratio; can be used to construct a LikelihoodInterval.; (In the future, this class could be extended to use toy Monte Carlo to calibrate the distribution of the test statistic). Usage: It uses the interface of the CombinedCalculator, so that it can be configured by specifying:. a model common model (eg. a family of specific models which includes both the null and alternate),; a data set, ; a set of parameters of interest. The nuisance parameters will be all other parameters of the model ; a set of parameters of which specify the null hypothesis (including values and const/non-const status) . The interface allows one to pass the model, data, and parameters either directly or via a ModelConfig class.; The alternate hypothesis leaves the parameter free to take any value other than those specified by the null hypotesis. There is therefore no need to ; specify the alternate parameters. . After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer). Th",MatchSource.WIKI,root/html530/RooStats__ProfileLikelihoodCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__ProfileLikelihoodCalculator.html
Usability,clear,clear,"rval; RooAbsPdf*RooStats::CombinedCalculator::fPdf; Double_tRooStats::CombinedCalculator::fSizesize of the test (eg. specified rate of Type I error). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ProfileLikelihoodCalculator(); default constructor. ProfileLikelihoodCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& paramsOfInterest, Double_t size = 0.05, const RooArgSet* nullParams = 0); constructor from pdf and parameters; the pdf must contain eventually the nuisance parameters. ProfileLikelihoodCalculator(RooAbsData& data, RooStats::ModelConfig& model, Double_t size = 0.05); construct from a ModelConfig. Assume data model.GetPdf() will provide full description of model including; constraint term on the nuisances parameters. ~ProfileLikelihoodCalculator(); destructor; cannot delete prod pdf because it will delete all the composing pdf's; if (fOwnPdf) delete fPdf;; fPdf = 0;. void DoReset() const; reset and clear fit result; to be called when a new model or data are set in the calculator. void DoGlobalFit() const; perform a global fit of the likelihood letting with all parameter of interest and; nuisance parameters; keep the list of fitted parameters. LikelihoodInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval.; It constructs a profile likelihood ratio and uses that to construct a RooStats::LikelihoodInterval. HypoTestResult* GetHypoTest() const; Main interface to get a HypoTestResult.; It does two fits:; the first lets the null parameters float, so it's a maximum likelihood estimate; the second is to the null (fixing null parameters to their specified values): eg. a conditional maximum likelihood; the ratio of the likelihood at the conditional MLE to the MLE is the profile likelihood ratio.; Wilks' theorem is used to get p-values. ProfileLikelihoodCalculator(); default constructor (needed for I/O). » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C)",MatchSource.WIKI,root/html530/RooStats__ProfileLikelihoodCalculator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__ProfileLikelihoodCalculator.html
Integrability,interface,interface,". RooStats::ProfileLikelihoodTestStat. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::ProfileLikelihoodTestStat. class RooStats::ProfileLikelihoodTestStat: public RooStats::TestStatistic. ProfileLikelihoodTestStat is an implementation of the TestStatistic interface that calculates the profile; likelihood ratio at a particular parameter point given a dataset. It does not constitute a statistical test, for that one may either use:. the ProfileLikelihoodCalculator that relies on asymptotic properties of the Profile Likelihood Ratio; the Neyman Construction classes with this class as a test statistic; the Hybrid Calculator class with this class as a test statistic. Function Members (Methods); public:. virtual~ProfileLikelihoodTestStat(); static TClass*Class(); virtual Double_tEvaluate(RooAbsData& data, RooArgSet& paramsOfInterest); virtual const TStringGetVarName() const; virtual TClass*IsA() const; RooStats::TestStatistic&RooStats::TestStatistic::operator=(const RooStats::TestStatistic&); RooStats::ProfileLikelihoodTestStatProfileLikelihoodTestStat(); RooStats::ProfileLikelihoodTestStatProfileLikelihoodTestStat(RooAbsPdf& pdf); RooStats::ProfileLikelihoodTestStatProfileLikelihoodTestStat(const RooStats::ProfileLikelihoodTestStat&); virtual boolRooStats::TestStatistic::PValueIsRightTail() const; static voidSetAlwaysReuseNLL(Bool_t flag); voidSetOneSided(Bool_t flag = true); voidSetReuseNLL(Bool_t flag); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. const RooArgSet*fCachedBestFitParams; RooAbsData*fLastData; RooNLLVar*fNll!; Bool_tfOneSided; RooAbsPdf*fPdf; RooProfileLL*fProfile!; Bool_tfReuseNll; static Bool_tfgAlwaysReuseNll. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function doc",MatchSource.WIKI,root/html530/RooStats__ProfileLikelihoodTestStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__ProfileLikelihoodTestStat.html
Testability,test,test,". RooStats::ProfileLikelihoodTestStat. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::ProfileLikelihoodTestStat. class RooStats::ProfileLikelihoodTestStat: public RooStats::TestStatistic. ProfileLikelihoodTestStat is an implementation of the TestStatistic interface that calculates the profile; likelihood ratio at a particular parameter point given a dataset. It does not constitute a statistical test, for that one may either use:. the ProfileLikelihoodCalculator that relies on asymptotic properties of the Profile Likelihood Ratio; the Neyman Construction classes with this class as a test statistic; the Hybrid Calculator class with this class as a test statistic. Function Members (Methods); public:. virtual~ProfileLikelihoodTestStat(); static TClass*Class(); virtual Double_tEvaluate(RooAbsData& data, RooArgSet& paramsOfInterest); virtual const TStringGetVarName() const; virtual TClass*IsA() const; RooStats::TestStatistic&RooStats::TestStatistic::operator=(const RooStats::TestStatistic&); RooStats::ProfileLikelihoodTestStatProfileLikelihoodTestStat(); RooStats::ProfileLikelihoodTestStatProfileLikelihoodTestStat(RooAbsPdf& pdf); RooStats::ProfileLikelihoodTestStatProfileLikelihoodTestStat(const RooStats::ProfileLikelihoodTestStat&); virtual boolRooStats::TestStatistic::PValueIsRightTail() const; static voidSetAlwaysReuseNLL(Bool_t flag); voidSetOneSided(Bool_t flag = true); voidSetReuseNLL(Bool_t flag); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. const RooArgSet*fCachedBestFitParams; RooAbsData*fLastData; RooNLLVar*fNll!; Bool_tfOneSided; RooAbsPdf*fPdf; RooProfileLL*fProfile!; Bool_tfReuseNll; static Bool_tfgAlwaysReuseNll. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function doc",MatchSource.WIKI,root/html530/RooStats__ProfileLikelihoodTestStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__ProfileLikelihoodTestStat.html
Deployability,configurat,configuration,". RooStats::ProofConfig. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::ProofConfig. class RooStats::ProofConfig. Holds configuration options for proof and proof-lite.; This class will be expanded in the future to hold more specific configuration; options for the tools in RooStats. Access to TProof::Mgr for configuration is still possible as usual; (e.g. to set Root Version to be used on workers). You can do:. TProof::Mgr(""my.server.url"")->ShowROOTVersions(); TProof::Mgr(""my.server.url"")->SetROOTVersion(""v5-27-06_dbg""). See doc: http://root.cern.ch/drupal/content/changing-default-root-version. Function Members (Methods); public:. virtual~ProofConfig(); static TClass*Class(); static voidCloseProof(Option_t* option = ""s""); const char*GetHost(); Int_tGetNExperiments(); Bool_tGetShowGui(); RooWorkspace&GetWorkspace(); virtual TClass*IsA() const; RooStats::ProofConfigProofConfig(const RooStats::ProofConfig&); RooStats::ProofConfigProofConfig(RooWorkspace& w, Int_t nExperiments = 8, const char* host = """", Bool_t showGui = kFALSE); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. const char*fHostProof hostname. Use empty string (ie """") for proof-lite. Can also handle options like ""workers=2"" to run on two nodes.; Int_tfNExperimentsnumber of experiments. This is sometimes called ""events"" in proof; ""experiments"" in RooStudyManager.; Bool_tfShowGuiWhether to show the Proof Progress window.; RooWorkspace&fWorkspaceworkspace that is to be used with the RooStudyManager. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ProofConfig(RooWorkspace& w, Int_t nExperiments = 8, const char* host = """", Bool_t showGui = kFALSE). virtual ~ProofConfig(). CloseProof(). RooWorkspace& GetW",MatchSource.WIKI,root/html530/RooStats__ProofConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__ProofConfig.html
Modifiability,config,configuration,". RooStats::ProofConfig. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::ProofConfig. class RooStats::ProofConfig. Holds configuration options for proof and proof-lite.; This class will be expanded in the future to hold more specific configuration; options for the tools in RooStats. Access to TProof::Mgr for configuration is still possible as usual; (e.g. to set Root Version to be used on workers). You can do:. TProof::Mgr(""my.server.url"")->ShowROOTVersions(); TProof::Mgr(""my.server.url"")->SetROOTVersion(""v5-27-06_dbg""). See doc: http://root.cern.ch/drupal/content/changing-default-root-version. Function Members (Methods); public:. virtual~ProofConfig(); static TClass*Class(); static voidCloseProof(Option_t* option = ""s""); const char*GetHost(); Int_tGetNExperiments(); Bool_tGetShowGui(); RooWorkspace&GetWorkspace(); virtual TClass*IsA() const; RooStats::ProofConfigProofConfig(const RooStats::ProofConfig&); RooStats::ProofConfigProofConfig(RooWorkspace& w, Int_t nExperiments = 8, const char* host = """", Bool_t showGui = kFALSE); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. const char*fHostProof hostname. Use empty string (ie """") for proof-lite. Can also handle options like ""workers=2"" to run on two nodes.; Int_tfNExperimentsnumber of experiments. This is sometimes called ""events"" in proof; ""experiments"" in RooStudyManager.; Bool_tfShowGuiWhether to show the Proof Progress window.; RooWorkspace&fWorkspaceworkspace that is to be used with the RooStudyManager. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ProofConfig(RooWorkspace& w, Int_t nExperiments = 8, const char* host = """", Bool_t showGui = kFALSE). virtual ~ProofConfig(). CloseProof(). RooWorkspace& GetW",MatchSource.WIKI,root/html530/RooStats__ProofConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__ProofConfig.html
Availability,avail,available,"s::ProposalFunction. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::ProposalFunction. class RooStats::ProposalFunction: public TObject. ProposalFunction is an interface for all proposal functions that would be used with a Markov Chain Monte Carlo algorithm. ; Given a current point in the parameter space it proposes a new point. ; Proposal functions may or may not be symmetric, in the sense that the probability to propose X1 given we are at X2 ; need not be the same as the probability to propose X2 given that we are at X1. In this case, the IsSymmetric method; should return false, and the Metropolis algorithm will need to take into account the proposal density to maintain detailed balance. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~ProposalFunction(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual boolCheckParameters(RooArgSet& params); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method",MatchSource.WIKI,root/html530/RooStats__ProposalFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__ProposalFunction.html
Integrability,interface,interface,". RooStats::ProposalFunction. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::ProposalFunction. class RooStats::ProposalFunction: public TObject. ProposalFunction is an interface for all proposal functions that would be used with a Markov Chain Monte Carlo algorithm. ; Given a current point in the parameter space it proposes a new point. ; Proposal functions may or may not be symmetric, in the sense that the probability to propose X1 given we are at X2 ; need not be the same as the probability to propose X2 given that we are at X1. In this case, the IsSymmetric method; should return false, and the Metropolis algorithm will need to take into account the proposal density to maintain detailed balance. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~ProposalFunction(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual boolCheckParameters(RooArgSet& params); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const cha",MatchSource.WIKI,root/html530/RooStats__ProposalFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__ProposalFunction.html
Availability,error,error," virtual~ProposalHelper(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const",MatchSource.WIKI,root/html530/RooStats__ProposalHelper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__ProposalHelper.html
Deployability,update,updateParams,"Object::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; RooStats::ProposalHelperProposalHelper(); RooStats::ProposalHelperProposalHelper(const RooStats::ProposalHelper&); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCacheSize(Int_t size); virtual voidSetClues(RooDataSet& clues); virtual voidSetCluesFraction(Double_t cluesFrac); virtual voidSetCluesOptions(Option_t* options); virtual voidSetCovMatrix(const TMatrixDSym& covMatrix); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPdf(RooAbsPdf& pdf); virtual voidSetUniformFraction(Double_t uniFrac); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetUpdateProposalParameters(Bool_t updateParams); virtual voidSetVariables(RooArgList& vars); virtual voidSetVariables(const RooArgList& vars); virtual voidSetVariables(RooArgSet& vars); virtual voidSetWidthRangeDivisor(Double_t divisor); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html530/RooStats__ProposalHelper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__ProposalHelper.html
Modifiability,variab,variable,"teUniformPdf(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfCacheSizefor generating proposals from PDFs; RooDataSet*fCluesdata set of clues; Double_tfCluesFracwhat fraction of the PDF integral comes from clues; Option_t*fCluesOptionsoption string for clues RooNDKeysPdf; RooAbsPdf*fCluesPdfproposal dens. func. with clues for certain points; TMatrixDSym*fCovMatrixcovariance matrix for multi var gaussian pdf; Bool_tfOwnsCluesPdfwhether we created (and own) the clues pdf; Bool_tfOwnsPdfwhether we created (and own) the main pdf; Bool_tfOwnsPdfPropwhether we own the PdfProposal; equivalent to:; Bool_tfOwnsVarswhether we own fVars; RooAbsPdf*fPdfthe main proposal density function; RooStats::PdfProposal*fPdfPropthe PdfProposal we are (probably) going to return; Double_tfSigmaRangeDivisorrange divisor to get sigma for each variable; Double_tfUniFracwhat fraction of the PDF integral is uniform; RooAbsPdf*fUniformPdfuniform proposal dens. func.; Bool_tfUseUpdateswhether to set updates for proposal params in PdfProposal; RooArgList*fVarsthe RooRealVars to generate proposals for. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ProposalHelper(). ProposalFunction* GetProposalFunction(). void CreatePdf(); kbelasco: check here for memory leaks:; does RooMultiVarGaussian make copies of xVec and muVec?; or should we delete them?. void CreateCovMatrix(RooArgList& xVec). void CreateCluesPdf(). void CreateUniformPdf(). ProposalHelper(). void SetPdf(RooAbsPdf& pdf); Set the PDF to be the proposal density function. { fPdf = &pdf; }. void SetClues(RooDataSet& clues); Set the bank o",MatchSource.WIKI,root/html530/RooStats__ProposalHelper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__ProposalHelper.html
Testability,log,log,"stStatRatioOfProfiledLikelihoodsTestStat(); RooStats::RatioOfProfiledLikelihoodsTestStatRatioOfProfiledLikelihoodsTestStat(const RooStats::RatioOfProfiledLikelihoodsTestStat&); RooStats::RatioOfProfiledLikelihoodsTestStatRatioOfProfiledLikelihoodsTestStat(RooAbsPdf& nullPdf, RooAbsPdf& altPdf, const RooArgSet* altPOI = 0); voidSetSubtractMLE(bool subtract); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. RooArgSet*fAltPOI; RooAbsPdf*fAltPdf; RooAbsPdf*fNullPdf; Bool_tfSubtractMLE. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RatioOfProfiledLikelihoodsTestStat(); Proof constructor. Don't use. RatioOfProfiledLikelihoodsTestStat(RooAbsPdf& nullPdf, RooAbsPdf& altPdf, const RooArgSet* altPOI = 0). Calculates the ratio of profiled likelihoods. 	 By default the calculation is:. 	 Lambda(mu_alt , conditional MLE for alt nuisance); 	log --------------------------------------------; 	 Lambda(mu_null , conditional MLE for null nuisance). 	where Lambda is the profile likeihood ratio, so the; 	MLE for the null and alternate are subtracted off. 	If SetSubtractMLE(false) then it calculates:. 	 L(mu_alt , conditional MLE for alt nuisance); 	log --------------------------------------------; 	 L(mu_null , conditional MLE for null nuisance). 	The values of the parameters of interest for the alternative; 	hypothesis are taken at the time of the construction.; 	If empty, it treats all free parameters as nuisance parameters. 	The value of the parameters of interest for the null hypotheses; 	are given at each call of Evaluate(data,nullPOI). ~RatioOfProfiledLikelihoodsTestStat(void). Double_t ProfiledLikelihood(RooAbsData& data, RooArgSet& poi, RooAbsPdf& pdf). Double_t Evaluate(RooAbsData& data, RooArgSet& nullParamsOfInterest). const TString GetVarName() const. void SetSubtractMLE(bool subtract); const bool PValueIsRightTail(void) { return false; } //",MatchSource.WIKI,root/html530/RooStats__RatioOfProfiledLikelihoodsTestStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__RatioOfProfiledLikelihoodsTestStat.html
Availability,error,error,":Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* options = 0); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidDumpToFile(const char* RootFileName, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TH1F*GetTH1F(const RooStats::SamplingDistribution* samplDist); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(co",MatchSource.WIKI,root/html530/RooStats__SamplingDistPlot.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__SamplingDistPlot.html
Modifiability,variab,variable,"ect* obj, Option_t* drawOptions = 0); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidGetAbsoluteInterval(Float_t& theMin, Float_t& theMax, Float_t& theYMax) const; voidTObject::MakeZombie(); voidSetSampleWeights(const RooStats::SamplingDistribution* samplingDist). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. static Int_tRooPrintable::_nameLength; Bool_tfApplyStyle; Style_tfFillStyle; TH1F*fHist; RooListfItemsholds TH1Fs only; TIterator*fIteratorTODO remove class variable and instantiate locally as necessary; TLegend*fLegend; Bool_tfLogXaxis; Bool_tfLogYaxis; TStringTNamed::fNameobject identifier; RooListfOtherItemsother objects to be drawn like TLine etc.; RooPlot*fRooPlot; TStringTNamed::fTitleobject title. private:. Int_tfBins; Int_tfColor; Bool_tfIsWeighted; Int_tfMarkerType; vector<Double_t>fSampleWeights; vector<Double_t>fSamplingDistr; TStringfVarName. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SamplingDistPlot(Int_t nbins = 100); SamplingDistPlot default constructor with bin size. Double_t AddSamplingDistribution(const RooStats::SamplingDistribution* samplingDist, Option_t* drawOptions = ""NORMALIZE HIST""); adds sampling distribution (and normalizes if ""NORMALIZE"" is given as an option). Double_t AddSamplingDistributionShaded(const RooStats::SamplingDistribution* samplingDist, Double_t minShaded, Double_t maxShaded, Option_t* drawOptions = ""NORMALIZE HIST""). void AddLine(Double_t x1, Double_t y1, Double_t x2,",MatchSource.WIKI,root/html530/RooStats__SamplingDistPlot.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__SamplingDistPlot.html
Testability,log,log,"tions specified in our add...(); methods will be used to draw each object we contain. void ApplyDefaultStyle(void). void GetAbsoluteInterval(Float_t& theMin, Float_t& theMax, Float_t& theYMax) const. void SetLineColor(Color_t color, const RooStats::SamplingDistribution* samplDist = 0); Sets line color for given sampling distribution and; fill color for the associated shaded TH1F. void SetLineWidth(Width_t lwidth, const RooStats::SamplingDistribution* samplDist = 0). void SetLineStyle(Style_t style, const RooStats::SamplingDistribution* samplDist = 0). void SetMarkerStyle(Style_t style, const RooStats::SamplingDistribution* samplDist = 0). void SetMarkerColor(Color_t color, const RooStats::SamplingDistribution* samplDist = 0). void SetMarkerSize(Size_t size, const RooStats::SamplingDistribution* samplDist = 0). TH1F* GetTH1F(const RooStats::SamplingDistribution* samplDist). void RebinDistribution(Int_t rebinFactor, const RooStats::SamplingDistribution* samplDist = 0). void DumpToFile(const char* RootFileName, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); All the objects are written to rootfile. virtual ~SamplingDistPlot(); SamplingDistPlot(const char* name, const char* title, Int_t nbins, Double_t xmin, Double_t xmax);; Destructor of SamplingDistribution. {}. void SetAxisTitle(char* varName); { fVarName = TString(varName); }. void SetApplyStyle(Bool_t s); If you do not want SamplingDistPlot to interfere with your style settings, call this; function with ""false"" before Draw(). { fApplyStyle = s; }. void SetLogXaxis(Bool_t lx); changes plot to log scale on x axis. { fLogXaxis = lx; }. void SetLogYaxis(Bool_t ly); changes plot to log scale on y axis. { fLogYaxis = ly; }. » Last changed: root/roostats:$Id: SamplingDistPlot.h 39391 2011-05-26 09:51:59Z moneta $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooStats__SamplingDistPlot.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__SamplingDistPlot.html
Usability,simpl,simple,". RooStats::SamplingDistPlot. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::SamplingDistPlot. class RooStats::SamplingDistPlot: public TNamed, public RooPrintable. SamplingDistPlot :. This class provides simple and straightforward utilities to plot SamplingDistribution; objects. Function Members (Methods); public:. virtual~SamplingDistPlot(); voidTObject::AbstractMethod(const char* method) const; voidAddLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2, const char* title = NULL); Double_tAddSamplingDistribution(const RooStats::SamplingDistribution* samplingDist, Option_t* drawOptions = ""NORMALIZE HIST""); Double_tAddSamplingDistributionShaded(const RooStats::SamplingDistribution* samplingDist, Double_t minShaded, Double_t maxShaded, Option_t* drawOptions = ""NORMALIZE HIST""); virtual voidTObject::AppendPad(Option_t* option = """"); voidApplyDefaultStyle(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* options = 0); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidDumpToFile(const char* RootFileName, Option_t* option = """,MatchSource.WIKI,root/html530/RooStats__SamplingDistPlot.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__SamplingDistPlot.html
Availability,error,error,"idTObject::AbstractMethod(const char* method) const; voidAdd(const RooStats::SamplingDistribution* other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tCDF(Double_t x) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const vector<Double_t>&GetSampleWeights() const; const vector<Double_t>&GetSamplingDistribution() const; Int_tGetSize() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const TStringGetVarName() const; virtual Bool_tTObje",MatchSource.WIKI,root/html530/RooStats__SamplingDistribution.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__SamplingDistribution.html
Integrability,depend,depending,"er); Merge SamplingDistributions (does nothing if NULL is given).; If variable name was not set before, it is copied from the added; SamplingDistribution. Double_t Integral(Double_t low, Double_t high, Bool_t normalize = kTRUE, Bool_t lowClosed = kTRUE, Bool_t highClosed = kFALSE) const; Returns the integral in the open/closed/mixed interval. Default is [low,high) interval.; Normalization can be turned off. Double_t IntegralAndError(Double_t& error, Double_t low, Double_t high, Bool_t normalize = kTRUE, Bool_t lowClosed = kTRUE, Bool_t highClosed = kFALSE) const; Returns the integral in the open/closed/mixed interval. Default is [low,high) interval.; Normalization can be turned off.; compute also the error on the integral. Double_t CDF(Double_t x) const; returns the closed integral [-inf,x]. Double_t InverseCDF(Double_t pvalue); returns the inverse of the cumulative distribution function. Double_t InverseCDF(Double_t pvalue, Double_t sigmaVariaton, Double_t& inverseVariation); returns the inverse of the cumulative distribution function, with variations depending on number of samples. Double_t InverseCDFInterpolate(Double_t pvalue); returns the inverse of the cumulative distribution function. SamplingDistribution(const char* name, const char* title, vector<Double_t>& samplingDist, const char* varName = 0); Constructor for SamplingDistribution. Int_t GetSize() const; size of samples. {return fSamplingDist.size();}. const std::vector<Double_t> & GetSamplingDistribution() const; Get test statistics values. {return fSamplingDist;}. const std::vector<Double_t> & GetSampleWeights() const; Get the sampling weights. {return fSampleWeights;}. const TString GetVarName() const; {return fVarName;}. » Last changed: root/roostats:$Id: SamplingDistribution.h 39391 2011-05-26 09:51:59Z moneta $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooStats__SamplingDistribution.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__SamplingDistribution.html
Modifiability,variab,variables,"or of points for the sampling distribution; TStringfVarName. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SamplingDistribution(const char* name, const char* title, vector<Double_t>& samplingDist, const char* varName = 0); SamplingDistribution constructor. SamplingDistribution(const char* name, const char* title, vector<Double_t>& samplingDist, vector<Double_t>& sampleWeights, const char* varName = 0); SamplingDistribution constructor. SamplingDistribution(const char* name, const char* title, const char* varName = 0); SamplingDistribution constructor (with name and title). SamplingDistribution(const char* name, const char* title, RooDataSet& dataSet, const char* varName = 0); Creates a SamplingDistribution from a RooDataSet for debugging; purposes; e.g. if you need a Gaussian type SamplingDistribution; you can generate it from a Gaussian pdf and use the resulting; RooDataSet with this constructor. The result is the projected distribution onto varName; marginalizing the other variables. If varName is not given, the first variable will be used.; This is useful mostly for RooDataSets with only one observable. SamplingDistribution(); SamplingDistribution default constructor. ~SamplingDistribution(); SamplingDistribution destructor. void Add(const RooStats::SamplingDistribution* other); Merge SamplingDistributions (does nothing if NULL is given).; If variable name was not set before, it is copied from the added; SamplingDistribution. Double_t Integral(Double_t low, Double_t high, Bool_t normalize = kTRUE, Bool_t lowClosed = kTRUE, Bool_t highClosed = kFALSE) const; Returns the integral in the open/closed/mixed interval. Default is [low,high) interval.; Normalization can be turned off. Double_t IntegralAndError(Double_t& error, Double_t low, Double_t high, Bool_t normalize = kTRUE, Bool_t lowClosed = kTRUE, Bool_t highClosed = kFALSE) const; Returns the integral in the open/closed/mixed interval. Default is [low,high) interval.",MatchSource.WIKI,root/html530/RooStats__SamplingDistribution.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__SamplingDistribution.html
Testability,test,test,". RooStats::SamplingDistribution. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::SamplingDistribution. class RooStats::SamplingDistribution: public TNamed. SamplingDistribution :. This class simply holds a sampling distribution of some test statistic.; The distribution can either be an empirical distribution (eg. the samples themselves) or; a weighted set of points (eg. for the FFT method).; The class supports merging. Function Members (Methods); public:. virtual~SamplingDistribution(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const RooStats::SamplingDistribution* other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tCDF(Double_t x) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::",MatchSource.WIKI,root/html530/RooStats__SamplingDistribution.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__SamplingDistribution.html
Usability,simpl,simply,". RooStats::SamplingDistribution. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::SamplingDistribution. class RooStats::SamplingDistribution: public TNamed. SamplingDistribution :. This class simply holds a sampling distribution of some test statistic.; The distribution can either be an empirical distribution (eg. the samples themselves) or; a weighted set of points (eg. for the FFT method).; The class supports merging. Function Members (Methods); public:. virtual~SamplingDistribution(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const RooStats::SamplingDistribution* other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tCDF(Double_t x) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::",MatchSource.WIKI,root/html530/RooStats__SamplingDistribution.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__SamplingDistribution.html
Availability,error,error," virtual~SamplingSummary(); voidTObject::AbstractMethod(const char* method) const; voidAddAcceptanceRegion(RooStats::AcceptanceRegion& ar); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooStats::AcceptanceRegion&GetAcceptanceRegion(Int_t index = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetParameterPointIndex(); RooStats::SamplingDistribution*GetSamplingDistribution(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObj",MatchSource.WIKI,root/html530/RooStats__SamplingSummary.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__SamplingSummary.html
Availability,error,error," virtual~SamplingSummaryLookup(); voidTObject::AbstractMethod(const char* method) const; voidAdd(Double_t cl, Double_t leftside); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetConfidenceLevel(Int_t index); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Double_tGetLeftSideTailFraction(Int_t index); Int_tGetLookupIndex(Double_t cl, Double_t leftside); virtu",MatchSource.WIKI,root/html530/RooStats__SamplingSummaryLookup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__SamplingSummaryLookup.html
Availability,error,error,"posal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual boolRooStats::ProposalFunction::CheckParameters(RooArgSet& params); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Double_tGetProposalDensity(RooArgSet& x1, RooArgSet& x2); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) con",MatchSource.WIKI,root/html530/RooStats__SequentialProposal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__SequentialProposal.html
Availability,error,error,"AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tCheckParameters(const RooArgSet&) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tConfidenceLevel() const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual RooArgSet*GetParameters() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, cons",MatchSource.WIKI,root/html530/RooStats__SimpleInterval.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__SimpleInterval.html
Integrability,interface,interface,". RooStats::SimpleInterval. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::SimpleInterval. class RooStats::SimpleInterval: public RooStats::ConfInterval. SimpleInterval is a concrete implementation of the ConfInterval interface. ; It implements simple 1-dimensional intervals in a range [a,b].; In addition, you can ask it for the upper- or lower-bound.; . Function Members (Methods); public:. virtual~SimpleInterval(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tCheckParameters(const RooArgSet&) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tConfidenceLevel() const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::",MatchSource.WIKI,root/html530/RooStats__SimpleInterval.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__SimpleInterval.html
Usability,simpl,simple,". RooStats::SimpleInterval. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::SimpleInterval. class RooStats::SimpleInterval: public RooStats::ConfInterval. SimpleInterval is a concrete implementation of the ConfInterval interface. ; It implements simple 1-dimensional intervals in a range [a,b].; In addition, you can ask it for the upper- or lower-bound.; . Function Members (Methods); public:. virtual~SimpleInterval(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tCheckParameters(const RooArgSet&) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tConfidenceLevel() const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::",MatchSource.WIKI,root/html530/RooStats__SimpleInterval.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__SimpleInterval.html
Testability,log,log,". RooStats::SimpleLikelihoodRatioTestStat. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::SimpleLikelihoodRatioTestStat. class RooStats::SimpleLikelihoodRatioTestStat: public RooStats::TestStatistic. ; SimpleLikelihoodRatioTestStat: TestStatistic that returns -log(L[null] / L[alt]) where; L is the likelihood.; . Function Members (Methods); public:. virtual~SimpleLikelihoodRatioTestStat(); static TClass*Class(); virtual Double_tEvaluate(RooAbsData& data, RooArgSet& nullPOI); virtual const TStringGetVarName() const; virtual TClass*IsA() const; RooStats::SimpleLikelihoodRatioTestStat&operator=(const RooStats::SimpleLikelihoodRatioTestStat&); boolParamsAreEqual(); virtual boolRooStats::TestStatistic::PValueIsRightTail() const; voidSetAltParameters(const RooArgSet& altParameters); static voidsetAlwaysReuseNLL(Bool_t flag); voidSetNullParameters(const RooArgSet& nullParameters); voidsetReuseNLL(Bool_t flag); virtual voidShowMembers(TMemberInspector& insp); RooStats::SimpleLikelihoodRatioTestStatSimpleLikelihoodRatioTestStat(); RooStats::SimpleLikelihoodRatioTestStatSimpleLikelihoodRatioTestStat(const RooStats::SimpleLikelihoodRatioTestStat&); RooStats::SimpleLikelihoodRatioTestStatSimpleLikelihoodRatioTestStat(RooAbsPdf& nullPdf, RooAbsPdf& altPdf); RooStats::SimpleLikelihoodRatioTestStatSimpleLikelihoodRatioTestStat(RooAbsPdf& nullPdf, RooAbsPdf& altPdf, const RooArgSet& nullParameters, const RooArgSet& altParameters); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. RooArgSet*fAltParameters; RooAbsPdf*fAltPdf; static Bool_tfAlwaysReuseNll; boolfFirstEval; RooNLLVar*fNllAlt; RooNLLVar*fNllNull; RooArgSet*fNullParameters; RooAbsPdf*fNullPdf; Bool_tfReuseNll; RooWorkspacew. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentat",MatchSource.WIKI,root/html530/RooStats__SimpleLikelihoodRatioTestStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__SimpleLikelihoodRatioTestStat.html
Availability,error,error,"const; voidAddSWeight(RooAbsPdf* pdf, const RooArgList& yieldsTmp, const RooArgSet& projDeps = RooArgSet(), bool includeWeights = kTRUE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; Int_tGetNumSWeightVars() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; RooDataSet*GetSDataSet() const; Double_tGetSumOfEventSWeight(Int_t numEvent) const; Double_tGetSWeight(Int_t numEvent, const char* sVariable) const; RooArgListGetSWeightVars() const; virtual const char*TNamed::GetTitle() const; virtual ",MatchSource.WIKI,root/html530/RooStats__SPlot.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__SPlot.html
Modifiability,variab,variable,". RooStats::SPlot. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::SPlot. class RooStats::SPlot: public TNamed. This class calculates sWeights used to create an sPlot. ; The code is based on ; ``SPlot: A statistical tool to unfold data distributions,'' ; Nucl. Instrum. Meth. A 555, 356 (2005) ; [arXiv:physics/0402083].; An SPlot gives us the distribution of some variable, x in our ; data sample for a given species (eg. signal or background). ; The result is similar to a likelihood projection plot, but no cuts are made, ; so every event contributes to the distribution.; [Usage]; To use this class, you first must have a pdf that includes; yields for (possibly several) different species.; Create an instance of the class by supplying a data set,; the pdf, and a list of the yield variables. The SPlot Class; will calculate SWeights and include these as columns in the RooDataSet. Function Members (Methods); public:. virtual~SPlot(); voidTObject::AbstractMethod(const char* method) const; voidAddSWeight(RooAbsPdf* pdf, const RooArgList& yieldsTmp, const RooArgSet& projDeps = RooArgSet(), bool includeWeights = kTRUE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual",MatchSource.WIKI,root/html530/RooStats__SPlot.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__SPlot.html
Availability,avail,available,". RooStats::TestStatistic. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::TestStatistic. class RooStats::TestStatistic. TestStatistic is an interface class to provide a facility for construction test statistics; distributions to the NeymanConstruction class. All the actual samplers inherit from this class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TestStatistic(); static TClass*Class(); virtual Double_tEvaluate(RooAbsData& data, RooArgSet& nullPOI); virtual const TStringGetVarName() const; virtual TClass*IsA() const; RooStats::TestStatistic&operator=(const RooStats::TestStatistic&); virtual boolPValueIsRightTail() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TestStatistic(); TestStatistic();. Double_t Evaluate(RooAbsData& data, RooArgSet& nullPOI); Main interface to evaluate the test statistic on a dataset given the; values for the Null Parameters Of Interest. const TString GetVarName() const. bool PValueIsRightTail(void); Defines the sign convention of the test statistic. Overwrite function if necessary. { return true; }. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: TestStatistic.h 39391 2011-05-26 09:51:59Z moneta $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooStats__TestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__TestStatistic.html
Integrability,interface,interface,". RooStats::TestStatistic. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::TestStatistic. class RooStats::TestStatistic. TestStatistic is an interface class to provide a facility for construction test statistics; distributions to the NeymanConstruction class. All the actual samplers inherit from this class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TestStatistic(); static TClass*Class(); virtual Double_tEvaluate(RooAbsData& data, RooArgSet& nullPOI); virtual const TStringGetVarName() const; virtual TClass*IsA() const; RooStats::TestStatistic&operator=(const RooStats::TestStatistic&); virtual boolPValueIsRightTail() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TestStatistic(); TestStatistic();. Double_t Evaluate(RooAbsData& data, RooArgSet& nullPOI); Main interface to evaluate the test statistic on a dataset given the; values for the Null Parameters Of Interest. const TString GetVarName() const. bool PValueIsRightTail(void); Defines the sign convention of the test statistic. Overwrite function if necessary. { return true; }. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: TestStatistic.h 39391 2011-05-26 09:51:59Z moneta $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooStats__TestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__TestStatistic.html
Modifiability,inherit,inherit,". RooStats::TestStatistic. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::TestStatistic. class RooStats::TestStatistic. TestStatistic is an interface class to provide a facility for construction test statistics; distributions to the NeymanConstruction class. All the actual samplers inherit from this class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TestStatistic(); static TClass*Class(); virtual Double_tEvaluate(RooAbsData& data, RooArgSet& nullPOI); virtual const TStringGetVarName() const; virtual TClass*IsA() const; RooStats::TestStatistic&operator=(const RooStats::TestStatistic&); virtual boolPValueIsRightTail() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TestStatistic(); TestStatistic();. Double_t Evaluate(RooAbsData& data, RooArgSet& nullPOI); Main interface to evaluate the test statistic on a dataset given the; values for the Null Parameters Of Interest. const TString GetVarName() const. bool PValueIsRightTail(void); Defines the sign convention of the test statistic. Overwrite function if necessary. { return true; }. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: TestStatistic.h 39391 2011-05-26 09:51:59Z moneta $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooStats__TestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__TestStatistic.html
Testability,test,test,". RooStats::TestStatistic. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::TestStatistic. class RooStats::TestStatistic. TestStatistic is an interface class to provide a facility for construction test statistics; distributions to the NeymanConstruction class. All the actual samplers inherit from this class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TestStatistic(); static TClass*Class(); virtual Double_tEvaluate(RooAbsData& data, RooArgSet& nullPOI); virtual const TStringGetVarName() const; virtual TClass*IsA() const; RooStats::TestStatistic&operator=(const RooStats::TestStatistic&); virtual boolPValueIsRightTail() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TestStatistic(); TestStatistic();. Double_t Evaluate(RooAbsData& data, RooArgSet& nullPOI); Main interface to evaluate the test statistic on a dataset given the; values for the Null Parameters Of Interest. const TString GetVarName() const. bool PValueIsRightTail(void); Defines the sign convention of the test statistic. Overwrite function if necessary. { return true; }. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: TestStatistic.h 39391 2011-05-26 09:51:59Z moneta $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooStats__TestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__TestStatistic.html
Availability,avail,available,". RooStats::TestStatSampler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::TestStatSampler. class RooStats::TestStatSampler. TestStatSampler is an interface class for a tools which produce RooStats SamplingDistributions. ; Tools that implement this interface are expected to be used for coverage studies, the Neyman Construction, etc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TestStatSampler(); static TClass*Class(); virtual Double_tConfidenceLevel() const; virtual Double_tEvaluateTestStatistic(RooAbsData& data, RooArgSet& paramsOfInterest); virtual RooStats::SamplingDistribution*GetSamplingDistribution(RooArgSet& paramsOfInterest); virtual RooStats::TestStatistic*GetTestStatistic() const; virtual voidInitialize(RooAbsArg& testStatistic, RooArgSet& paramsOfInterest, RooArgSet& nuisanceParameters); virtual TClass*IsA() const; RooStats::TestStatSampler&operator=(const RooStats::TestStatSampler&); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetGlobalObservables(const RooArgSet&); virtual voidSetNuisanceParameters(const RooArgSet&); virtual voidSetObservables(const RooArgSet&); virtual voidSetParametersForTestStat(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); virtual voidSetPriorNuisance(RooAbsPdf*); virtual voidSetSamplingDistName(const char* name); virtual voidSetTestSize(Double_t size); virtual voidSetTestStatistic(RooStats::TestStatistic* testStatistic); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TestStatSampler(); TestStatSampler();. {}. SamplingDistribution* GetSamplingDist",MatchSource.WIKI,root/html530/RooStats__TestStatSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__TestStatSampler.html
Integrability,interface,interface,". RooStats::TestStatSampler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::TestStatSampler. class RooStats::TestStatSampler. TestStatSampler is an interface class for a tools which produce RooStats SamplingDistributions. ; Tools that implement this interface are expected to be used for coverage studies, the Neyman Construction, etc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TestStatSampler(); static TClass*Class(); virtual Double_tConfidenceLevel() const; virtual Double_tEvaluateTestStatistic(RooAbsData& data, RooArgSet& paramsOfInterest); virtual RooStats::SamplingDistribution*GetSamplingDistribution(RooArgSet& paramsOfInterest); virtual RooStats::TestStatistic*GetTestStatistic() const; virtual voidInitialize(RooAbsArg& testStatistic, RooArgSet& paramsOfInterest, RooArgSet& nuisanceParameters); virtual TClass*IsA() const; RooStats::TestStatSampler&operator=(const RooStats::TestStatSampler&); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetGlobalObservables(const RooArgSet&); virtual voidSetNuisanceParameters(const RooArgSet&); virtual voidSetObservables(const RooArgSet&); virtual voidSetParametersForTestStat(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); virtual voidSetPriorNuisance(RooAbsPdf*); virtual voidSetSamplingDistName(const char* name); virtual voidSetTestSize(Double_t size); virtual voidSetTestStatistic(RooStats::TestStatistic* testStatistic); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TestStatSampler(); TestStatSampler();. {}. SamplingDistribution* GetSamplingDist",MatchSource.WIKI,root/html530/RooStats__TestStatSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__TestStatSampler.html
Testability,test,testStatistic,"s::TestStatSampler. class RooStats::TestStatSampler. TestStatSampler is an interface class for a tools which produce RooStats SamplingDistributions. ; Tools that implement this interface are expected to be used for coverage studies, the Neyman Construction, etc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TestStatSampler(); static TClass*Class(); virtual Double_tConfidenceLevel() const; virtual Double_tEvaluateTestStatistic(RooAbsData& data, RooArgSet& paramsOfInterest); virtual RooStats::SamplingDistribution*GetSamplingDistribution(RooArgSet& paramsOfInterest); virtual RooStats::TestStatistic*GetTestStatistic() const; virtual voidInitialize(RooAbsArg& testStatistic, RooArgSet& paramsOfInterest, RooArgSet& nuisanceParameters); virtual TClass*IsA() const; RooStats::TestStatSampler&operator=(const RooStats::TestStatSampler&); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetGlobalObservables(const RooArgSet&); virtual voidSetNuisanceParameters(const RooArgSet&); virtual voidSetObservables(const RooArgSet&); virtual voidSetParametersForTestStat(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); virtual voidSetPriorNuisance(RooAbsPdf*); virtual voidSetSamplingDistName(const char* name); virtual voidSetTestSize(Double_t size); virtual voidSetTestStatistic(RooStats::TestStatistic* testStatistic); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TestStatSampler(); TestStatSampler();. {}. SamplingDistribution* GetSamplingDistribution(RooArgSet& paramsOfInterest); Main interface to get a ConfInterval, pure virtual. Double_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& paramsOfInterest); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetT",MatchSource.WIKI,root/html530/RooStats__TestStatSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__TestStatSampler.html
Availability,error,error,"t ntoy); { fNToys = ntoy; }. void SetNEventsPerToy(const Int_t nevents); Forces n events even for extended PDFs. Set NEvents=0 to; use the Poisson distributed events from the extended PDF. void SetParametersForTestStat(const RooArgSet& nullpoi); specify the values of parameters used when evaluating test statistic. void SetPdf(RooAbsPdf& pdf); Set the Pdf, add to the the workspace if not already there. { fPdf = &pdf; }. void SetPriorNuisance(RooAbsPdf* pdf); How to randomize the prior. Set to NULL to deactivate randomization. { fPriorNuisance = pdf; }. void SetNuisanceParameters(const RooArgSet& np); specify the nuisance parameters (eg. the rest of the parameters). { fNuisancePars = &np; }. void SetObservables(const RooArgSet& o); specify the observables in the dataset (needed to evaluate the test statistic). { fObservables = &o; }. void SetGlobalObservables(const RooArgSet& o); specify the conditional observables. { fGlobalObservables = &o; }. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). { fSize = size; }. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). { fSize = 1. - cl; }. void SetTestStatistic(RooStats::TestStatistic* testStatistic); Set the TestStatistic (want the argument to be a function of the data & parameter points. { fTestStat = testStatistic; }. void SetExpectedNuisancePar(Bool_t i = kTRUE); { fExpectedNuisancePar = i; }. void SetAsimovNuisancePar(Bool_t i = kTRUE); { fExpectedNuisancePar = i; }. void SetGenerateBinned(bool binned = true); control to use bin data generation. { fGenerateBinned = binned; }. void SetSamplingDistName(const char* name); Set the name of the sampling distribution used for plotting. { if(name) fSamplingDistName = name; }. string GetSamplingDistName(void); { return fSamplingDistName; }. void SetMaxToys(Double_t t); This option forces a maximum number of total toys. { fMaxToys = t; ",MatchSource.WIKI,root/html530/RooStats__ToyMCSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__ToyMCSampler.html
Integrability,depend,depending,"erNVirtual(TBuffer& b); RooStats::ToyMCSamplerToyMCSampler(); RooStats::ToyMCSamplerToyMCSampler(const RooStats::ToyMCSampler&); RooStats::ToyMCSamplerToyMCSampler(RooStats::TestStatistic& ts, Int_t ntoys). protected:. RooAbsData*Generate(RooAbsPdf& pdf, RooArgSet& observables, const RooDataSet* protoData = NULL, int forceEvents = 0) const. Data Members; protected:. RooArgSet*_allVars! ; RooAbsPdf::GenSpec*_gs1! GenSpec #1 ; RooAbsPdf::GenSpec*_gs2! GenSpec #2; RooAbsPdf::GenSpec*_gs3! GenSpec #3; RooAbsPdf::GenSpec*_gs4! GenSpec #4; list<RooAbsPdf::GenSpec*>_gsList! ; list<RooArgSet*>_obsList!; list<RooAbsPdf*>_pdfList!; Double_tfAdaptiveHighLimit; Double_tfAdaptiveLowLimit; Bool_tfExpectedNuisanceParwhether to use expectation values for nuisance parameters (ie Asimov data set); Bool_tfGenerateBinned; const RooArgSet*fGlobalObservables; RooAbsPdf*fImportanceDensityin dev; const RooArgSet*fImportanceSnapshotin dev; Double_tfMaxToys; Int_tfNEventsnumber of events per toy (may be ignored depending on settings); Int_tfNToysnumber of toys to generate; RooStats::NuisanceParametersSampler*fNuisanceParametersSampler!; const RooArgSet*fNuisancePars; RooArgSet*fNullPOIparameters of interest; const RooArgSet*fObservables; RooAbsPdf*fPdfmodel; RooAbsPdf*fPriorNuisanceprior pdf for nuisance parameters; RooStats::ProofConfig*fProofConfig!; const RooDataSet*fProtoDatain dev; stringfSamplingDistNamename of the model; Double_tfSize; RooStats::TestStatistic*fTestStattest statistic that is being sampled; Double_tfToysInTails; Bool_tfUseMultiGenUse PrepareMultiGen?; static Bool_tfgAlwaysUseMultiGenUse PrepareMultiGen always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~ToyMCSampler(). Bool_t CheckConfig(void); only checks, no guessing/determination (do this in calculators,; e.g. using ModelConfig::GuessObsAndNuisance(...)). SamplingDistribution* GetSamplingDistribution(RooArgSet& paramPoint); Use for serial and parallel runs. SamplingDistr",MatchSource.WIKI,root/html530/RooStats__ToyMCSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__ToyMCSampler.html
Modifiability,variab,variables,"nheritance; Inherited Members; Includes; Libraries. Function documentation; ~ToyMCSampler(). Bool_t CheckConfig(void); only checks, no guessing/determination (do this in calculators,; e.g. using ModelConfig::GuessObsAndNuisance(...)). SamplingDistribution* GetSamplingDistribution(RooArgSet& paramPoint); Use for serial and parallel runs. SamplingDistribution* GetSamplingDistributionSingleWorker(RooArgSet& paramPoint); This is the main function for serial runs. It is called automatically; from inside GetSamplingDistribution when no ProofConfig is given.; You should not call this function yourself. This function should; be used by ToyMCStudy on the workers (ie. when you explicitly want; a serial run although ProofConfig is present). void GenerateGlobalObservables() const. RooAbsData* GenerateToyData(RooArgSet& paramPoint, double& weight) const; This method generates a toy data set for the given parameter point taking; global observables into account.; The values of the generated global observables remain in the pdf's variables.; They have to have those values for the subsequent evaluation of the; test statistics. RooAbsData* GenerateToyDataImportanceSampling(RooArgSet& paramPoint, double& weight) const; This method generates a toy data set for importance sampling for the given parameter point taking; global observables into account.; The values of the generated global observables remain in the pdf's variables.; They have to have those values for the subsequent evaluation of the; test statistics. RooAbsData* Generate(RooAbsPdf& pdf, RooArgSet& observables, const RooDataSet* protoData = NULL, int forceEvents = 0) const; This is the generate function to use in the context of the ToyMCSampler; instead of the standard RooAbsPdf::generate(...).; It takes into account whether the number of events is given explicitly; or whether it should use the expected number of events. It also takes; into account the option to generate a binned data set (ie RooDataHist). ToyMCSampler(); Pro",MatchSource.WIKI,root/html530/RooStats__ToyMCSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__ToyMCSampler.html
Testability,test,testStatistic,"oys(); stringGetSamplingDistName(); virtual RooStats::SamplingDistribution*GetSamplingDistribution(RooArgSet& paramPoint); virtual RooStats::SamplingDistribution*GetSamplingDistributionSingleWorker(RooArgSet& paramPoint); virtual RooStats::TestStatistic*GetTestStatistic() const; virtual voidInitialize(RooAbsArg&, RooArgSet&, RooArgSet&); virtual TClass*IsA() const; RooStats::TestStatSampler&RooStats::TestStatSampler::operator=(const RooStats::TestStatSampler&); static voidSetAlwaysUseMultiGen(Bool_t flag); virtual voidSetAsimovNuisancePar(Bool_t i = kTRUE); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetExpectedNuisancePar(Bool_t i = kTRUE); voidSetGenerateBinned(bool binned = true); virtual voidSetGlobalObservables(const RooArgSet& o); voidSetImportanceDensity(RooAbsPdf* p); voidSetImportanceSnapshot(const RooArgSet& s); voidSetMaxToys(Double_t t); virtual voidSetNEventsPerToy(const Int_t nevents); virtual voidSetNToys(const Int_t ntoy); virtual voidSetNuisanceParameters(const RooArgSet& np); virtual voidSetObservables(const RooArgSet& o); virtual voidSetParametersForTestStat(const RooArgSet& nullpoi); virtual voidSetPdf(RooAbsPdf& pdf); virtual voidSetPriorNuisance(RooAbsPdf* pdf); voidSetProofConfig(RooStats::ProofConfig* pc = NULL); voidSetProtoData(const RooDataSet* d); virtual voidSetSamplingDistName(const char* name); virtual voidSetTestSize(Double_t size); virtual voidSetTestStatistic(RooStats::TestStatistic* testStatistic); voidSetToysBothTails(Double_t toys, Double_t low_threshold, Double_t high_threshold); voidSetToysLeftTail(Double_t toys, Double_t threshold); voidSetToysRightTail(Double_t toys, Double_t threshold); voidSetUseMultiGen(Bool_t flag); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); RooStats::ToyMCSamplerToyMCSampler(); RooStats::ToyMCSamplerToyMCSampler(const RooStats::ToyMCSampler&); RooStats::ToyMCSamplerToyMCSampler(RooStats::TestStatistic& ts, Int_t ntoys).",MatchSource.WIKI,root/html530/RooStats__ToyMCSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__ToyMCSampler.html
Availability,error,error,"add to the the workspace if not already there. void SetPdf(RooAbsPdf& pdf); Set the Pdf, add to the the workspace if not already there. void SetData(const char* name); specify the name of the dataset in the workspace to be used. {fDataName = name;}. void SetPdf(const char* name); specify the name of the PDF in the workspace to be used. {fPdfName = name;}. void SetPriorNuisance(RooAbsPdf* ); How to randomize the prior. Set to NULL to deactivate randomization. {}. void SetParametersForTestStat(const RooArgSet& nullpoi); specify the values of parameters used when evaluating test statistic. {fNullPOI = (RooArgSet*)nullpoi.snapshot();}. void SetNuisanceParameters(const RooArgSet& set); specify the nuisance parameters (eg. the rest of the parameters). {fNuisParams = &set;}. void SetObservables(const RooArgSet& set); specify the observables in the dataset (needed to evaluate the test statistic). {fObservables = &set;}. void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. {}. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. void SetTestStatistic(RooStats::TestStatistic* testStat); Set the TestStatistic (want the argument to be a function of the data & parameter points. void SetSamplingDistName(const char* name); Set the name of the sampling distribution used for plotting. { if(name) fSamplingDistName = name; }. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: ToyMCSamplerOld.h 40096 2011-07-01 10:08:17Z moneta $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooStats__ToyMCSamplerOld.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__ToyMCSamplerOld.html
Deployability,integrat,integrated,". RooStats::ToyMCSamplerOld. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::ToyMCSamplerOld. class RooStats::ToyMCSamplerOld: public RooStats::TestStatSampler. ToyMCSamplerOld is a simple implementation of the TestStatSampler interface.; It generates Toy Monte Carlo for a given parameter point, and evaluates a ; test statistic that the user specifies (passed via the RooStats::TestStatistic interface).; Development notes: We need to provide a nice way for the user to:. specify the number of toy experiments (needed to probe a given confidence level); specify if the number of events per toy experiment should be fixed (conditioning) or floating (unconditional); specify if any auxiliary observations should be fixed (conditioning) or floating (unconditional); specify if nuisance paramters should be part of the toy MC: eg: integrated out (Bayesian marginalization). All of these should be made fairly explicit in the interface. Function Members (Methods); public:. virtual~ToyMCSamplerOld(); virtual RooStats::SamplingDistribution*AppendSamplingDistribution(RooArgSet& allParameters, RooStats::SamplingDistribution* last, Int_t additionalMC); static TClass*Class(); virtual Double_tConfidenceLevel() const; virtual Double_tEvaluateTestStatistic(RooAbsData& data, RooArgSet& allParameters); virtual RooAbsData*GenerateToyData(RooArgSet& allParameters) const; virtual RooStats::SamplingDistribution*GetSamplingDistribution(RooArgSet& allParameters); virtual RooStats::TestStatistic*GetTestStatistic() const; virtual voidInitialize(RooAbsArg&, RooArgSet&, RooArgSet&); virtual TClass*IsA() const; stringMakeName(RooArgSet&); RooStats::TestStatSampler&RooStats::TestStatSampler::operator=(const RooStats::TestStatSampler&); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData& data); virtual voidSetD",MatchSource.WIKI,root/html530/RooStats__ToyMCSamplerOld.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__ToyMCSamplerOld.html
Integrability,interface,interface,". RooStats::ToyMCSamplerOld. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::ToyMCSamplerOld. class RooStats::ToyMCSamplerOld: public RooStats::TestStatSampler. ToyMCSamplerOld is a simple implementation of the TestStatSampler interface.; It generates Toy Monte Carlo for a given parameter point, and evaluates a ; test statistic that the user specifies (passed via the RooStats::TestStatistic interface).; Development notes: We need to provide a nice way for the user to:. specify the number of toy experiments (needed to probe a given confidence level); specify if the number of events per toy experiment should be fixed (conditioning) or floating (unconditional); specify if any auxiliary observations should be fixed (conditioning) or floating (unconditional); specify if nuisance paramters should be part of the toy MC: eg: integrated out (Bayesian marginalization). All of these should be made fairly explicit in the interface. Function Members (Methods); public:. virtual~ToyMCSamplerOld(); virtual RooStats::SamplingDistribution*AppendSamplingDistribution(RooArgSet& allParameters, RooStats::SamplingDistribution* last, Int_t additionalMC); static TClass*Class(); virtual Double_tConfidenceLevel() const; virtual Double_tEvaluateTestStatistic(RooAbsData& data, RooArgSet& allParameters); virtual RooAbsData*GenerateToyData(RooArgSet& allParameters) const; virtual RooStats::SamplingDistribution*GetSamplingDistribution(RooArgSet& allParameters); virtual RooStats::TestStatistic*GetTestStatistic() const; virtual voidInitialize(RooAbsArg&, RooArgSet&, RooArgSet&); virtual TClass*IsA() const; stringMakeName(RooArgSet&); RooStats::TestStatSampler&RooStats::TestStatSampler::operator=(const RooStats::TestStatSampler&); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData& data); virtual voidSetD",MatchSource.WIKI,root/html530/RooStats__ToyMCSamplerOld.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__ToyMCSamplerOld.html
Testability,test,test,". RooStats::ToyMCSamplerOld. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::ToyMCSamplerOld. class RooStats::ToyMCSamplerOld: public RooStats::TestStatSampler. ToyMCSamplerOld is a simple implementation of the TestStatSampler interface.; It generates Toy Monte Carlo for a given parameter point, and evaluates a ; test statistic that the user specifies (passed via the RooStats::TestStatistic interface).; Development notes: We need to provide a nice way for the user to:. specify the number of toy experiments (needed to probe a given confidence level); specify if the number of events per toy experiment should be fixed (conditioning) or floating (unconditional); specify if any auxiliary observations should be fixed (conditioning) or floating (unconditional); specify if nuisance paramters should be part of the toy MC: eg: integrated out (Bayesian marginalization). All of these should be made fairly explicit in the interface. Function Members (Methods); public:. virtual~ToyMCSamplerOld(); virtual RooStats::SamplingDistribution*AppendSamplingDistribution(RooArgSet& allParameters, RooStats::SamplingDistribution* last, Int_t additionalMC); static TClass*Class(); virtual Double_tConfidenceLevel() const; virtual Double_tEvaluateTestStatistic(RooAbsData& data, RooArgSet& allParameters); virtual RooAbsData*GenerateToyData(RooArgSet& allParameters) const; virtual RooStats::SamplingDistribution*GetSamplingDistribution(RooArgSet& allParameters); virtual RooStats::TestStatistic*GetTestStatistic() const; virtual voidInitialize(RooAbsArg&, RooArgSet&, RooArgSet&); virtual TClass*IsA() const; stringMakeName(RooArgSet&); RooStats::TestStatSampler&RooStats::TestStatSampler::operator=(const RooStats::TestStatSampler&); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData& data); virtual voidSetD",MatchSource.WIKI,root/html530/RooStats__ToyMCSamplerOld.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__ToyMCSamplerOld.html
Usability,simpl,simple,". RooStats::ToyMCSamplerOld. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::ToyMCSamplerOld. class RooStats::ToyMCSamplerOld: public RooStats::TestStatSampler. ToyMCSamplerOld is a simple implementation of the TestStatSampler interface.; It generates Toy Monte Carlo for a given parameter point, and evaluates a ; test statistic that the user specifies (passed via the RooStats::TestStatistic interface).; Development notes: We need to provide a nice way for the user to:. specify the number of toy experiments (needed to probe a given confidence level); specify if the number of events per toy experiment should be fixed (conditioning) or floating (unconditional); specify if any auxiliary observations should be fixed (conditioning) or floating (unconditional); specify if nuisance paramters should be part of the toy MC: eg: integrated out (Bayesian marginalization). All of these should be made fairly explicit in the interface. Function Members (Methods); public:. virtual~ToyMCSamplerOld(); virtual RooStats::SamplingDistribution*AppendSamplingDistribution(RooArgSet& allParameters, RooStats::SamplingDistribution* last, Int_t additionalMC); static TClass*Class(); virtual Double_tConfidenceLevel() const; virtual Double_tEvaluateTestStatistic(RooAbsData& data, RooArgSet& allParameters); virtual RooAbsData*GenerateToyData(RooArgSet& allParameters) const; virtual RooStats::SamplingDistribution*GetSamplingDistribution(RooArgSet& allParameters); virtual RooStats::TestStatistic*GetTestStatistic() const; virtual voidInitialize(RooAbsArg&, RooArgSet&, RooArgSet&); virtual TClass*IsA() const; stringMakeName(RooArgSet&); RooStats::TestStatSampler&RooStats::TestStatSampler::operator=(const RooStats::TestStatSampler&); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData& data); virtual voidSetD",MatchSource.WIKI,root/html530/RooStats__ToyMCSamplerOld.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__ToyMCSamplerOld.html
Availability,error,error,"RooAbsStudy::attach(RooWorkspace&); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsStudy*clone(const char* = """") const; virtual TObject*RooAbsStudy::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; RooLinkedList*RooAbsStudy::detailedData(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidRooAbsStudy::dump(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Bool_texecute(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual Bool_tfinalize(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt)",MatchSource.WIKI,root/html530/RooStats__ToyMCStudy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__ToyMCStudy.html
Deployability,release,releaseDetailData,"al voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; Bool_tmerge(RooStats::SamplingDistribution& result); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooStats::ToyMCStudy&operator=(const RooStats::ToyMCStudy&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidRooAbsStudy::releaseDetailData(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetParamPoint(const RooArgSet& poi); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidSetToyMCSampler(RooStats::ToyMCSampler& t); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; voidRooAbsStudy::storeDetailedOutput(Bool_t flag); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); RooDataSet*RooAbsStudy::summaryData(); v",MatchSource.WIKI,root/html530/RooStats__ToyMCStudy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__ToyMCStudy.html
Availability,error,error,"posal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual boolRooStats::ProposalFunction::CheckParameters(RooArgSet& params); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Double_tGetProposalDensity(RooArgSet& x1, RooArgSet& x2); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) con",MatchSource.WIKI,root/html530/RooStats__UniformProposal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__UniformProposal.html
Integrability,interface,interface,". RooStats::UniformProposal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::UniformProposal. class RooStats::UniformProposal: public RooStats::ProposalFunction. UniformProposal is a concrete implementation of the ProposalFunction interface; for use with a Markov Chain Monte Carlo algorithm. This proposal function is; a uniformly random distribution over the parameter space. The proposal; ignores the current point when it proposes a new point. The proposal; function is symmetric, though it may not cause a MetropolisHastings run to; converge as quickly as other proposal functions. Function Members (Methods); public:. virtual~UniformProposal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual boolRooStats::ProposalFunction::CheckParameters(RooArgSet& params); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py);",MatchSource.WIKI,root/html530/RooStats__UniformProposal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__UniformProposal.html
Availability,error,error,"perLimitMCSModule(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tRooAbsMCStudyModule::doInitializeInstance(RooMCStudy&); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual RooDataSet*finalizeRun(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char*",MatchSource.WIKI,root/html530/RooStats__UpperLimitMCSModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__UpperLimitMCSModule.html
Integrability,depend,dependents,"Module(const RooStats::UpperLimitMCSModule& other); RooStats::UpperLimitMCSModuleUpperLimitMCSModule(const RooArgSet* poi, Double_t CL = 0.95); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. RooArgSet*RooAbsMCStudyModule::allDependents(); Bool_tRooAbsMCStudyModule::binGenData(); RooArgSet*RooAbsMCStudyModule::dependents(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Bool_tRooAbsMCStudyModule::extendedGen(); RooArgSet*RooAbsMCStudyModule::fitInitParams(); RooAbsPdf*RooAbsMCStudyModule::fitModel(); const char*RooAbsMCStudyModule::fitOptions(); RooLinkedList*RooAbsMCStudyModule::fitOptList(); RooArgSet*RooAbsMCStudyModule::fitParams(); RooAbsGenContext*RooAbsMCStudyModule::genContext(); RooArgSet*RooAbsMCStudyModule::genInitParams(); RooAbsPdf*RooAbsMCStudyModule::genModel(); RooArgSet*RooAbsMCStudyModule::genParams(); const RooDataSet*RooAbsMCStudyModule::genProtoData(); RooAbsData*RooAbsMCStudyModule::genSample(); voidTObject::MakeZombie(); RooRealVar*RooAbsMCStudyModule::nllVar(); Double_tRooAbsMCStudyModule::numExpGen(); RooArgSet*RooAbsMCStudyModule::projDeps(); Bool_tRooAbsMCStudyModule::randProto(); RooFitResult*RooAbsMCStudyModule::refit(RooAbsData* inGenSample = 0); Bool_tRooAbsMCStudyModule::verboseGen(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_t_cl; RooDataSet*_dataSummary dataset to store results; RooAbsPdf*_model;",MatchSource.WIKI,root/html530/RooStats__UpperLimitMCSModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__UpperLimitMCSModule.html
Modifiability,extend,extendedGen,"Module(const RooStats::UpperLimitMCSModule& other); RooStats::UpperLimitMCSModuleUpperLimitMCSModule(const RooArgSet* poi, Double_t CL = 0.95); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. RooArgSet*RooAbsMCStudyModule::allDependents(); Bool_tRooAbsMCStudyModule::binGenData(); RooArgSet*RooAbsMCStudyModule::dependents(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Bool_tRooAbsMCStudyModule::extendedGen(); RooArgSet*RooAbsMCStudyModule::fitInitParams(); RooAbsPdf*RooAbsMCStudyModule::fitModel(); const char*RooAbsMCStudyModule::fitOptions(); RooLinkedList*RooAbsMCStudyModule::fitOptList(); RooArgSet*RooAbsMCStudyModule::fitParams(); RooAbsGenContext*RooAbsMCStudyModule::genContext(); RooArgSet*RooAbsMCStudyModule::genInitParams(); RooAbsPdf*RooAbsMCStudyModule::genModel(); RooArgSet*RooAbsMCStudyModule::genParams(); const RooDataSet*RooAbsMCStudyModule::genProtoData(); RooAbsData*RooAbsMCStudyModule::genSample(); voidTObject::MakeZombie(); RooRealVar*RooAbsMCStudyModule::nllVar(); Double_tRooAbsMCStudyModule::numExpGen(); RooArgSet*RooAbsMCStudyModule::projDeps(); Bool_tRooAbsMCStudyModule::randProto(); RooFitResult*RooAbsMCStudyModule::refit(RooAbsData* inGenSample = 0); Bool_tRooAbsMCStudyModule::verboseGen(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_t_cl; RooDataSet*_dataSummary dataset to store results; RooAbsPdf*_model;",MatchSource.WIKI,root/html530/RooStats__UpperLimitMCSModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__UpperLimitMCSModule.html
Testability,log,log,"mple(); voidTObject::MakeZombie(); RooRealVar*RooAbsMCStudyModule::nllVar(); Double_tRooAbsMCStudyModule::numExpGen(); RooArgSet*RooAbsMCStudyModule::projDeps(); Bool_tRooAbsMCStudyModule::randProto(); RooFitResult*RooAbsMCStudyModule::refit(RooAbsData* inGenSample = 0); Bool_tRooAbsMCStudyModule::verboseGen(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_t_cl; RooDataSet*_dataSummary dataset to store results; RooAbsPdf*_model; string_parNameName of Nsignal parameter; RooStats::ProfileLikelihoodCalculator*_plc; const RooArgSet*_poiparameters of interest; RooRealVar*_ul. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; UpperLimitMCSModule(const RooArgSet* poi, Double_t CL = 0.95). UpperLimitMCSModule(const RooStats::UpperLimitMCSModule& other); Copy constructor. Bool_t initializeInstance(); Initialize module after attachment to RooMCStudy object. Bool_t initializeRun(Int_t ); Initialize module at beginning of RooCMStudy run. RooDataSet* finalizeRun(); Return auxiliary dataset with results of delta(-log(L)); calculations of this module so that it is merged with; RooMCStudy::fitParDataSet() by RooMCStudy. Bool_t processBetweenGenAndFit(Int_t ). virtual ~UpperLimitMCSModule(). » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke, Nils Ruthmann » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: UpperLimitMCSModule.h 39391 2011-05-26 09:51:59Z moneta $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooStats__UpperLimitMCSModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStats__UpperLimitMCSModule.html
Availability,error,error,,MatchSource.WIKI,root/html530/RooStepFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStepFunction.html
Deployability,integrat,integration,"RooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::",MatchSource.WIKI,root/html530/RooStepFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStepFunction.html
Integrability,depend,dependentVars,"const char* rangeName = 0) const; virtual RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt)",MatchSource.WIKI,root/html530/RooStepFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStepFunction.html
Modifiability,config,config,"bject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNum",MatchSource.WIKI,root/html530/RooStepFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStepFunction.html
Performance,cache,cacheUniqueSuffix,"shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; const RooArgList&boundaries(); voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root/html530/RooStepFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStepFunction.html
Security,validat,validate,,MatchSource.WIKI,root/html530/RooStepFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStepFunction.html
Testability,test,testArg,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooStepFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStepFunction.html
Usability,clear,clearEvalErrorLog,", const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefficients(); virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const Ro",MatchSource.WIKI,root/html530/RooStepFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStepFunction.html
Availability,error,errorPrefix,"ing& expected, Bool_t zapOnError = kFALSE); TStringgetPunctuation() const; virtual TClass*IsA() const; Bool_tisPunctChar(char c) const; RooStreamParser&operator=(const RooStreamParser&); Bool_treadDouble(Double_t& value, Bool_t zapOnError = kFALSE); Bool_treadInteger(Int_t& value, Bool_t zapOnError = kFALSE); TStringreadLine(); Bool_treadString(TString& value, Bool_t zapOnError = kFALSE); TStringreadToken(); voidsetPunctuation(const TString& punct); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidzapToEnd(Bool_t inclContLines = kFALSE). Data Members; protected:. Bool_t_atEOF; Bool_t_atEOL; istream*_is; TString_prefix; TString_punct. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooStreamParser(istream& is); Construct parser on given input stream. RooStreamParser(istream& is, const TString& errPrefix); Construct parser on given input stream. Use given errorPrefix to; prefix any parsing error messages. ~RooStreamParser(); Destructor. Bool_t atEOL(); If true, parser is at end of line in stream. void setPunctuation(const TString& punct); Change list of characters interpreted as punctuation. Bool_t isPunctChar(char c) const; Check if given char is considered punctuation. TString readToken(); Read one token separated by any of the know punctuation characters; This function recognizes and handles comment lines in the istream (those; starting with '#', quoted strings ("""") the content of which is not tokenized; and '+-.' characters that are part of a floating point numbers and are exempt; from being interpreted as a token separator in case '+-.' are defined as; token separators. TString readLine(); Read an entire line from the stream and return as TString; This method recognizes the use of '\\' in the istream; as line continuation token. void zapToEnd(Bool_t inclContLines = kFALSE); Eat all characters up to and including then end of the; current line. If inclC",MatchSource.WIKI,root/html530/RooStreamParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStreamParser.html
Integrability,message,messages,"ing& expected, Bool_t zapOnError = kFALSE); TStringgetPunctuation() const; virtual TClass*IsA() const; Bool_tisPunctChar(char c) const; RooStreamParser&operator=(const RooStreamParser&); Bool_treadDouble(Double_t& value, Bool_t zapOnError = kFALSE); Bool_treadInteger(Int_t& value, Bool_t zapOnError = kFALSE); TStringreadLine(); Bool_treadString(TString& value, Bool_t zapOnError = kFALSE); TStringreadToken(); voidsetPunctuation(const TString& punct); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidzapToEnd(Bool_t inclContLines = kFALSE). Data Members; protected:. Bool_t_atEOF; Bool_t_atEOL; istream*_is; TString_prefix; TString_punct. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooStreamParser(istream& is); Construct parser on given input stream. RooStreamParser(istream& is, const TString& errPrefix); Construct parser on given input stream. Use given errorPrefix to; prefix any parsing error messages. ~RooStreamParser(); Destructor. Bool_t atEOL(); If true, parser is at end of line in stream. void setPunctuation(const TString& punct); Change list of characters interpreted as punctuation. Bool_t isPunctChar(char c) const; Check if given char is considered punctuation. TString readToken(); Read one token separated by any of the know punctuation characters; This function recognizes and handles comment lines in the istream (those; starting with '#', quoted strings ("""") the content of which is not tokenized; and '+-.' characters that are part of a floating point numbers and are exempt; from being interpreted as a token separator in case '+-.' are defined as; token separators. TString readLine(); Read an entire line from the stream and return as TString; This method recognizes the use of '\\' in the istream; as line continuation token. void zapToEnd(Bool_t inclContLines = kFALSE); Eat all characters up to and including then end of the; current line. If inclC",MatchSource.WIKI,root/html530/RooStreamParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStreamParser.html
Modifiability,variab,variable,". RooStreamParser. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooStreamParser. class RooStreamParser. RooStreamParser is a utility class to parse istreams into tokens and optionally; convert them into basic types (double,int,string). The general tokenizing philosophy is that there are two kinds of tokens: value; and punctuation. The former are variable length, the latter always; one character. A token is terminated if one of the following conditions; occur; - space character found (' ',tab,newline); - change of token type (value -> punctuation or vv); - end of fixed-length token (punctuation only); - start or end of quoted string. The parser is aware of floating point notation and will assign leading; minus signs, decimal points etc to a value token when this is obvious; from the context. The definition of what is punctuation can be redefined. Function Members (Methods); public:. RooStreamParser(istream& is); RooStreamParser(const RooStreamParser&); RooStreamParser(istream& is, const TString& errPrefix); virtual~RooStreamParser(); Bool_tatEOF(); Bool_tatEOL(); static TClass*Class(); Bool_tconvertToDouble(const TString& token, Double_t& value); Bool_tconvertToInteger(const TString& token, Int_t& value); Bool_tconvertToString(const TString& token, TString& string); Bool_texpectToken(const TString& expected, Bool_t zapOnError = kFALSE); TStringgetPunctuation() const; virtual TClass*IsA() const; Bool_tisPunctChar(char c) const; RooStreamParser&operator=(const RooStreamParser&); Bool_treadDouble(Double_t& value, Bool_t zapOnError = kFALSE); Bool_treadInteger(Int_t& value, Bool_t zapOnError = kFALSE); TStringreadLine(); Bool_treadString(TString& value, Bool_t zapOnError = kFALSE); TStringreadToken(); voidsetPunctuation(const TString& punct); virtual voidShowMembers(TMemberInspecto",MatchSource.WIKI,root/html530/RooStreamParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStreamParser.html
Availability,error,error,", const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; Ro",MatchSource.WIKI,root/html530/RooStringVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStringVar.html
Integrability,depend,dependentOverlaps,"idRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsString::createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method,",MatchSource.WIKI,root/html530/RooStringVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStringVar.html
Performance,cache,cacheUniqueSuffix,"tle, const char* value, Int_t size = 1024); virtual~RooStringVar(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsSt",MatchSource.WIKI,root/html530/RooStringVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStringVar.html
Testability,test,testArg,"learValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsString::createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTO",MatchSource.WIKI,root/html530/RooStringVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStringVar.html
Usability,clear,clearShapeDirty,"peProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsString::createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbs",MatchSource.WIKI,root/html530/RooStringVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStringVar.html
Availability,error,error,"; voidTObject::AbstractMethod(const char* method) const; voidaddStudy(RooAbsStudy& study); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; static voidcloseProof(Option_t* option = ""s""); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObj",MatchSource.WIKI,root/html530/RooStudyManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStudyManager.html
Availability,error,error,"dyPackage&); ~RooStudyPackage(); voidTObject::AbstractMethod(const char* method) const; voidaddStudy(RooAbsStudy& study); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voiddriver(Int_t nExperiments); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidexportData(TList* olist, Int_t seqno); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); voidfinalize(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const ",MatchSource.WIKI,root/html530/RooStudyPackage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooStudyPackage.html
Availability,error,error,", const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; vi",MatchSource.WIKI,root/html530/RooSuperCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooSuperCategory.html
Deployability,update,updated,". RooSuperCategory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSuperCategory. class RooSuperCategory: public RooAbsCategoryLValue. RooSuperCategory consolidates several RooAbsCategoryLValue objects into; a single category. The states of the super category consist of all the permutations; of the input categories. The super category is an lvalue and requires that; all input categories are lvalues as well as modification; of its state will back propagate into a modification of its input categories.; To define a consolidated category of multiple non-lvalye categories; use class RooMultiCategory; ; RooSuperCategory state are automatically defined and updated whenever an input; category modifies its list of states; . Function Members (Methods); public:. RooSuperCategory(); RooSuperCategory(const RooSuperCategory& other, const char* name = 0); RooSuperCategory(const char* name, const char* title, const RooArgSet& inputCatList); virtual~RooSuperCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFA",MatchSource.WIKI,root/html530/RooSuperCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooSuperCategory.html
Integrability,depend,dependentOverlaps,"y() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method,",MatchSource.WIKI,root/html530/RooSuperCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooSuperCategory.html
Performance,cache,cacheUniqueSuffix," title, const RooArgSet& inputCatList); virtual~RooSuperCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCa",MatchSource.WIKI,root/html530/RooSuperCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooSuperCategory.html
Testability,test,testArg,"; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTO",MatchSource.WIKI,root/html530/RooSuperCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooSuperCategory.html
Usability,clear,clearShapeDirty,"peProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t*",MatchSource.WIKI,root/html530/RooSuperCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooSuperCategory.html
Security,access,accessable,". ROOT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; namespace description; function members; data members; class charts. ROOT; » CORE; » BASE; » ROOT. namespace ROOT. TROOT. The TROOT object is the entry point to the system.; The single instance of TROOT is accessable via the global gROOT.; Using the gROOT pointer one has access to basically every object; created in a ROOT based program. The TROOT object is essentially a; ""dispatcher"" with several lists pointing to the ROOT main objects. Function Members (Methods); public:. voidAddClass(const char* cname, Version_t id, const type_info& info, VoidFuncPtr_t dict, Int_t pragmabits); voidAddClass(const char* cname, Version_t id, const type_info& info, VoidFuncPtr_t dict, Int_t pragmabits); voidAddClass(const char* cname, Version_t id, const type_info& info, VoidFuncPtr_t dict, Int_t pragmabits); voidAddClass(const char* cname, Version_t id, const type_info& info, VoidFuncPtr_t dict, Int_t pragmabits); voidAddClass(const char* cname, Version_t id, const type_info& info, VoidFuncPtr_t dict, Int_t pragmabits); voidAddClass(const char* cname, Version_t id, const type_info& info, VoidFuncPtr_t dict, Int_t pragmabits); voidAddClass(const char* cname, Version_t id, const type_info& info, VoidFuncPtr_t dict, Int_t pragmabits); intCompressionSettings(ROOT::ECompressionAlgorithm algorithm, int compressionLevel); TClass*CreateClass(const char* cname, Version_t id, const char* dfil, const char* ifil, Int_t dl, Int_t il); TClass*CreateClass(const char* cname, Version_t id, const char* dfil, const char* ifil, Int_t dl, Int_t il); TClass*CreateClass(const char* cname, Version_t id, const char* dfil, const char* ifil, Int_t dl, Int_t il); TClass*CreateClass(const char* cname, Version_t id, const type_info& info, TVirtualIsAProxy* isa, ShowMembersFunc_t show, const char* dfil, const char* ifil, Int_t dl, Int_t il); TClass*CreateClass(const char* cname, Version_t id",MatchSource.WIKI,root/html530/ROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT.html
Availability,avail,available,". RooTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooTable. class RooTable: public TNamed, public RooPrintable. RooTable is the abstract interface for table objects.; Table objects are the category equivalent of RooPlot objects; (which are used for real-valued objects); . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooTable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char*",MatchSource.WIKI,root/html530/RooTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTable.html
Integrability,interface,interface,". RooTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooTable. class RooTable: public TNamed, public RooPrintable. RooTable is the abstract interface for table objects.; Table objects are the category equivalent of RooPlot objects; (which are used for real-valued objects); . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooTable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char*",MatchSource.WIKI,root/html530/RooTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTable.html
Availability,error,error,,MatchSource.WIKI,root/html530/RooTFnBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTFnBinding.html
Deployability,integrat,integration,"RooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::",MatchSource.WIKI,root/html530/RooTFnBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTFnBinding.html
Integrability,depend,dependentVars,"const char* rangeName = 0) const; virtual RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt)",MatchSource.WIKI,root/html530/RooTFnBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTFnBinding.html
Modifiability,config,config,"bject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNum",MatchSource.WIKI,root/html530/RooTFnBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTFnBinding.html
Performance,cache,cacheUniqueSuffix,"ol_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root/html530/RooTFnBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTFnBinding.html
Security,validat,validate,,MatchSource.WIKI,root/html530/RooTFnBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTFnBinding.html
Testability,test,testArg,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooTFnBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTFnBinding.html
Usability,clear,clearEvalErrorLog,", const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none()",MatchSource.WIKI,root/html530/RooTFnBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTFnBinding.html
Availability,error,error,,MatchSource.WIKI,root/html530/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTFnPdfBinding.html
Deployability,integrat,integration,<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; ,MatchSource.WIKI,root/html530/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTFnPdfBinding.html
Integrability,depend,dependentVars,"), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); virtual RooAbsReal*RooAbsPdf::createNLL(RooAbsData& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsPdf::createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t",MatchSource.WIKI,root/html530/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTFnPdfBinding.html
Modifiability,extend,extendedTerm,,MatchSource.WIKI,root/html530/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTFnPdfBinding.html
Performance,cache,cacheUniqueSuffix,"ool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAb",MatchSource.WIKI,root/html530/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTFnPdfBinding.html
Security,validat,validate,,MatchSource.WIKI,root/html530/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTFnPdfBinding.html
Testability,test,testArg,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTFnPdfBinding.html
Usability,clear,clearEvalError,"g::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCm",MatchSource.WIKI,root/html530/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTFnPdfBinding.html
Availability,error,error,"Binding(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); RooRealBinding&binding(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(Int_t ndim, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html530/RooTFoamBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTFoamBinding.html
Energy Efficiency,adapt,adaptor,". RooTFoamBinding. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooTFoamBinding. class RooTFoamBinding: public TFoamIntegrand. Lightweight interface adaptor that binds a RooAbsPdf to TFOAM; . Function Members (Methods); public:. RooTFoamBinding(const RooTFoamBinding&); RooTFoamBinding(const RooAbsReal& pdf, const RooArgSet& observables); virtual~RooTFoamBinding(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); RooRealBinding&binding(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(Int_t ndim, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtua",MatchSource.WIKI,root/html530/RooTFoamBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTFoamBinding.html
Integrability,interface,interface,". RooTFoamBinding. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooTFoamBinding. class RooTFoamBinding: public TFoamIntegrand. Lightweight interface adaptor that binds a RooAbsPdf to TFOAM; . Function Members (Methods); public:. RooTFoamBinding(const RooTFoamBinding&); RooTFoamBinding(const RooAbsReal& pdf, const RooArgSet& observables); virtual~RooTFoamBinding(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); RooRealBinding&binding(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(Int_t ndim, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtua",MatchSource.WIKI,root/html530/RooTFoamBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTFoamBinding.html
Modifiability,adapt,adaptor,". RooTFoamBinding. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooTFoamBinding. class RooTFoamBinding: public TFoamIntegrand. Lightweight interface adaptor that binds a RooAbsPdf to TFOAM; . Function Members (Methods); public:. RooTFoamBinding(const RooTFoamBinding&); RooTFoamBinding(const RooAbsReal& pdf, const RooArgSet& observables); virtual~RooTFoamBinding(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); RooRealBinding&binding(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(Int_t ndim, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtua",MatchSource.WIKI,root/html530/RooTFoamBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTFoamBinding.html
Availability,error,error,"other); RooThreshEntry(Double_t thresh, const RooCatType& cat); virtual~RooThreshEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); const RooCatType&cat() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*Clone(const char*) const; virtual Int_tCompare(const TObject*) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html530/RooThreshEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooThreshEntry.html
Availability,error,error,", const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; Ro",MatchSource.WIKI,root/html530/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooThresholdCategory.html
Integrability,depend,dependentOverlaps,"y() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method,",MatchSource.WIKI,root/html530/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooThresholdCategory.html
Performance,cache,cacheUniqueSuffix,"ractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); Bool_taddThreshold(Double_t upperLimit, const char* catName, Int_t catIdx = -99999); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCa",MatchSource.WIKI,root/html530/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooThresholdCategory.html
Testability,test,testArg,"; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTO",MatchSource.WIKI,root/html530/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooThresholdCategory.html
Usability,clear,clearShapeDirty,"alueProp = kTRUE, Bool_t shapeProp = kFALSE); Bool_taddThreshold(Double_t upperLimit, const char* catName, Int_t catIdx = -99999); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t*",MatchSource.WIKI,root/html530/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooThresholdCategory.html
Availability,error,error,"her); RooTObjWrap(TObject* inObj, Bool_t isArray = kFALSE); virtual~RooTObjWrap(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObj",MatchSource.WIKI,root/html530/RooTObjWrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTObjWrap.html
Integrability,message,messages,". RooTrace. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooTrace. class RooTrace. Class RooTrace controls the memory tracing hooks in all RooFit; objects. When tracing is active, a table of live RooFit objects; is kept that can be queried at any time. In verbose mode, messages; are printed in addition at the construction and destruction of; each object.; . Function Members (Methods); public:. RooTrace(); RooTrace(const RooTrace&); virtual~RooTrace(); static voidactive(Bool_t flag); static TClass*Class(); static voidcreate(const TObject* obj); static voiddestroy(const TObject* obj); static voiddump(); static voiddump(ostream& os, Bool_t sinceMarked = kFALSE); virtual TClass*IsA() const; static voidmark(); RooTrace&operator=(const RooTrace&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); static voidverbose(Bool_t flag). protected:. voidaddPad(const TObject* ref, Bool_t doPad); static voidcreate2(const TObject* obj); static voiddestroy2(const TObject* obj); Bool_tremovePad(const TObject* ref). Data Members; protected:. static Bool_t_active; static RooLinkedList_list; static RooLinkedList_markList; static Bool_t_verbose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void create(const TObject* obj); Register creation of object 'obj'. void destroy(const TObject* obj); Register deletion of object 'obj'. void active(Bool_t flag); If flag is true, memory tracing is activated. void verbose(Bool_t flag); If flag is true, a message will be printed at each; object creation or deletion. void create2(const TObject* obj); Back end function of create(), register creation of object 'obj'. void destroy2(const TObject* obj); Back end function of destroy(), register deletion of obje",MatchSource.WIKI,root/html530/RooTrace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTrace.html
Availability,avail,available,". RooTreeData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooTreeData. class RooTreeData: public RooAbsData. RooTreeData is the abstract base class for data collection that; use a TTree as internal storage mechanism; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~RooTreeData(); voidTObject::AbstractMethod(const char* method) const; virtual voidRooAbsData::add(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); voidRooAbsData::addOwnedComponent(const char* idxlabel, RooAbsData& data); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsData::canSplitFast() const; virtual Bool_tRooAbsData::changeObservableName(const char* from, const char* to); voidRooAbsData::checkInit() const; static voidRooAbsData::claimVars(RooAbsData*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Double_tRooAbsData::correlation(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; TMatrixDSym*RooAbsData::correlationMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; TMatrixDSym*RooAbsData::correlationMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; Double_tRooAbsData::covariance(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; TMatrixDSym*RooAbsData::covarianceMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; TMatrixDSym*RooAbsData::",MatchSource.WIKI,root/html530/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTreeData.html
Deployability,release,releaseVars,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsData::setDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); Double_tRooAbsData::sigma(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) co",MatchSource.WIKI,root/html530/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTreeData.html
Energy Efficiency,reduce,reduce,"dArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual voidTObject::Pop(); virtual voidRooAbsData::Print(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UI",MatchSource.WIKI,root/html530/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTreeData.html
Modifiability,variab,variables,"effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; RooArgSetRooAbsData::_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TString_blindStringBlinding string (optionally read from ASCII files) ; TTree*_treeTTree holding the data points; RooArgSet_truthTruth variables . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Last changed: Mon Jul 4 15:24:43 2011 » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTreeData.html
Performance,cache,cachedVars,"t; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); virtual RooAbsData*RooAbsData::cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoCo",MatchSource.WIKI,root/html530/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTreeData.html
Availability,error,error,"t; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsDataStore::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tfill(); Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*get(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Stat_tGetEntries() const; Int_tGetEntry(Int_t entry = 0, Int_t getall = 0); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject",MatchSource.WIKI,root/html530/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTreeDataStore.html
Modifiability,variab,variables,"anvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; const RooAbsArg*_cacheOwner! Object owning cache contents; TTree*_cacheTree! TTree holding the cached function values; RooArgSetRooAbsDataStore::_cachedVars; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Bool_t_defCtor! Was object constructed with default ctor?; static Int_t_defTreeBufSize; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; TTree*_treeTTree holding the data points; RooArgSetRooAbsDataStore::_vars; RooArgSet_varsww; RooRealVar*_wgtVarPointer to weight variable (if set); TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTreeDataStore(). RooTreeDataStore(TTree* t, const RooArgSet& vars, const char* wgtVarName = 0); Constructor to facilitate reading of legacy RooDataSets. RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooAr",MatchSource.WIKI,root/html530/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTreeDataStore.html
Performance,cache,cachedVars,"t char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const RooFormulaVar& select, const char* wgtVarName = 0); RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const char* selExpr = 0, const char* wgtVarName = 0); RooTreeDataStore(const char* name, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t, const char* wgtVarName = 0); virtual~RooTreeDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); const RooArgSet&RooAbsDataStore::cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidcheckInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsDataStore::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t",MatchSource.WIKI,root/html530/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTreeDataStore.html
Security,access,access," automatically identified as such; and will be precalculated when fitting to a dataset. By forcibly precalculating functions with non-trivial Jacobians,; or functions of multiple variables occurring in the data set,; using addColumn(), you may alter the outcome of the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& b); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const RooArgSet& vars, co",MatchSource.WIKI,root/html530/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTreeDataStore.html
Usability,clear,cleared,"the data set,; using addColumn(), you may alter the outcome of the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& b); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooTreeDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. TTree& tree(); Tree access. { return *_tree ; }",MatchSource.WIKI,root/html530/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTreeDataStore.html
Availability,error,error,,MatchSource.WIKI,root/html530/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTruthModel.html
Deployability,integrat,integration,<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for abo,MatchSource.WIKI,root/html530/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTruthModel.html
Integrability,depend,dependentVars,"), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); virtual RooAbsReal*RooAbsPdf::createNLL(RooAbsData& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsPdf::createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t",MatchSource.WIKI,root/html530/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTruthModel.html
Modifiability,extend,extendedTerm,,MatchSource.WIKI,root/html530/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTruthModel.html
Performance,cache,cacheUniqueSuffix,"t code, const char* rangeName = 0) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; const RooFormulaVar&RooResolutionModel::basis() const; virtual Int_tbasisCode(const char* name) const; const RooRealVar&RooResolutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidR",MatchSource.WIKI,root/html530/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTruthModel.html
Security,validat,validate,,MatchSource.WIKI,root/html530/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTruthModel.html
Testability,test,testArg,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTruthModel.html
Usability,clear,clearEvalError,"onst; virtual Int_tbasisCode(const char* name) const; const RooRealVar&RooResolutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, cons",MatchSource.WIKI,root/html530/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooTruthModel.html
Availability,error,error,". ROOT::Fit::BinData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::BinData. class ROOT::Fit::BinData: public ROOT::Fit::FitData. Class describing the binned data sets :; vectors of x coordinates, y values and optionally error on y values and error on coordinates; The dimension of the coordinate is free; There are 4 different options:; - only coordinates and values (for binned likelihood fits) : kNoError; - coordinate, values and error on values (for normal least square fits) : kValueError; - coordinate, values, error on values and coordinates (for effective least square fits) : kCoordError; - corrdinate, values, error on coordinates and asymmettric error on valyes : kAsymError. In addition there is the option to construct Bindata copying the data in (using the DataVector class); or using pointer to external data (DataWrapper) class.; In general is found to be more efficient to copy the data.; In case of really large data sets for limiting memory consumption then the other option can be used; Specialized constructor exists for data up to 3 dimensions. When the data are copying in the number of points can be set later (or re-set) using Initialize and; the data are inserted one by one using the Add method.; It is mandatory to set the size before using the Add method. @ingroup FitData. Function Members (Methods); public:. virtual~BinData(); voidAdd(double x, double y); voidAdd(const double* x, double val); voidAdd(double x, double y, double ey); voidAdd(const double* x, double val, double eval); voidAdd(double x, double y, double ex, double ey); voidAdd(const double* x, double val, const double* ex, double eval); voidAdd(double x, double y, double ex, double eyl, double eyh); voidAdd(const double* x, double val, const double* ex, double elval, double ehval); voidAddBinUpEdge(const double* xup); RO",MatchSource.WIKI,root/html530/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__BinData.html
Energy Efficiency,efficient,efficient,"Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::BinData. class ROOT::Fit::BinData: public ROOT::Fit::FitData. Class describing the binned data sets :; vectors of x coordinates, y values and optionally error on y values and error on coordinates; The dimension of the coordinate is free; There are 4 different options:; - only coordinates and values (for binned likelihood fits) : kNoError; - coordinate, values and error on values (for normal least square fits) : kValueError; - coordinate, values, error on values and coordinates (for effective least square fits) : kCoordError; - corrdinate, values, error on coordinates and asymmettric error on valyes : kAsymError. In addition there is the option to construct Bindata copying the data in (using the DataVector class); or using pointer to external data (DataWrapper) class.; In general is found to be more efficient to copy the data.; In case of really large data sets for limiting memory consumption then the other option can be used; Specialized constructor exists for data up to 3 dimensions. When the data are copying in the number of points can be set later (or re-set) using Initialize and; the data are inserted one by one using the Add method.; It is mandatory to set the size before using the Add method. @ingroup FitData. Function Members (Methods); public:. virtual~BinData(); voidAdd(double x, double y); voidAdd(const double* x, double val); voidAdd(double x, double y, double ey); voidAdd(const double* x, double val, double eval); voidAdd(double x, double y, double ex, double ey); voidAdd(const double* x, double val, const double* ex, double eval); voidAdd(double x, double y, double ex, double eyl, double eyh); voidAdd(const double* x, double val, const double* ex, double elval, double ehval); voidAddBinUpEdge(const double* xup); ROOT::Fit::BinDataBinData(const ROOT::Fit::BinData&)",MatchSource.WIKI,root/html530/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__BinData.html
Integrability,wrap,wrapper," ROOT::Fit::BinData&LogTransform(); static unsigned intROOT::Fit::FitData::MaxSize(); unsigned intNDim() const; unsigned intNPoints() const; ROOT::Fit::BinData&operator=(const ROOT::Fit::BinData&); const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt(); unsigned intPointSize() const; const ROOT::Fit::DataRange&ROOT::Fit::FitData::Range() const; doubleRefVolume() const; voidResize(unsigned int npoints); voidSetRefVolume(double value); unsigned intSize() const; doubleValue(unsigned int ipoint) const. protected:. voidSetNPoints(unsigned int n). Data Members; public:. enum ErrorType { kNoError; kValueError; kCoordError; kAsymError; };. private:. vector<double>fBinEdgevector containing the bin upper edge (coordinate will contain low edge) ; ROOT::Fit::DataVector*fDataVectorpointer to the copied in data vector; ROOT::Fit::DataWrapper*fDataWrapperpointer to the external data wrapper structure; unsigned intfDimcoordinate dimension; unsigned intfNPointsnumber of contained points in the data set (can be different than size of vector); unsigned intfPointSizetotal point size including value and errors (= fDim + 2 for error in only Y ) ; doublefRefVolumereference bin volume - used to normalize the bins in case of variable bins data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const ROOT::Fit:",MatchSource.WIKI,root/html530/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__BinData.html
Modifiability,variab,variable," ROOT::Fit::BinData&LogTransform(); static unsigned intROOT::Fit::FitData::MaxSize(); unsigned intNDim() const; unsigned intNPoints() const; ROOT::Fit::BinData&operator=(const ROOT::Fit::BinData&); const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt(); unsigned intPointSize() const; const ROOT::Fit::DataRange&ROOT::Fit::FitData::Range() const; doubleRefVolume() const; voidResize(unsigned int npoints); voidSetRefVolume(double value); unsigned intSize() const; doubleValue(unsigned int ipoint) const. protected:. voidSetNPoints(unsigned int n). Data Members; public:. enum ErrorType { kNoError; kValueError; kCoordError; kAsymError; };. private:. vector<double>fBinEdgevector containing the bin upper edge (coordinate will contain low edge) ; ROOT::Fit::DataVector*fDataVectorpointer to the copied in data vector; ROOT::Fit::DataWrapper*fDataWrapperpointer to the external data wrapper structure; unsigned intfDimcoordinate dimension; unsigned intfNPointsnumber of contained points in the data set (can be different than size of vector); unsigned intfPointSizetotal point size including value and errors (= fDim + 2 for error in only Y ) ; doublefRefVolumereference bin volume - used to normalize the bins in case of variable bins data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const ROOT::Fit:",MatchSource.WIKI,root/html530/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__BinData.html
Testability,assert,assert,"t. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const double * GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const. Get errors on the point (coordinate errors and asymmetric value errors) for the; given fit point.; It must be called only when the coordinate errors and asymmetric errors are stored; otherwise it will produce an assert. void Resize(unsigned int npoints). resize the vector to the new given npoints; if vector does not exists is created using existing point size. unsigned int NPoints() const. return number of fit points. { return fNPoints; }. unsigned int Size() const. return number of fit points. { return fNPoints; }. unsigned int NDim() const. return coordinate data dimension. { return fDim; }. BinData & LogTransform(). apply a Log transformation of the data values; can be used for example when fitting an exponential or gaussian; Transform the data in place need to copy if want to preserve original data; The ",MatchSource.WIKI,root/html530/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__BinData.html
Integrability,interface,interface,":Math::IBaseFunctionMultiDim>&); virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::UpdateNCalls() const. protected:. virtual voidSetNFitPoints(unsigned int n) const. private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const. Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::BinData&fData; const ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; unsigned intfNEffPointsnumber of effective points used in the fit . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function. unsigned int NFitPoints() const; effective points used in the fit (exclude the rejected one). { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th chi-square residual. void Gradient(const double* x, double* g) const; need to be virtual to be instantited. void SetNFitPoints(unsigned int n) const; set number of fit points (need to be called in const methods, make it const). { fNEffPoints = n; }. double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives. » Author: L. Moneta Tue Sep 5 09:13:32 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: Chi2FCN.h 37232 2010-12-03 18:09:43Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Fit__Chi2FCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__Chi2FCN_-p0Math__IBaseFunctionMultiDim_.html
Integrability,interface,interface,"tionMultiDim>&); virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::UpdateNCalls() const. protected:. virtual voidSetNFitPoints(unsigned int n) const. private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const. Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::BinData&fData; const ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; unsigned intfNEffPointsnumber of effective points used in the fit . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function. unsigned int NFitPoints() const; effective points used in the fit (exclude the rejected one). { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th chi-square residual. void Gradient(const double* x, double* g) const; need to be virtual to be instantited. void SetNFitPoints(unsigned int n) const; set number of fit points (need to be called in const methods, make it const). { fNEffPoints = n; }. double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives. » Author: L. Moneta Tue Sep 5 09:13:32 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: Chi2FCN.h 37232 2010-12-03 18:09:43Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Fit__Chi2FCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__Chi2FCN_-p0Math__IGradientFunctionMultiDim_.html
Availability,error,errors,". ROOT::Fit::DataOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::DataOptions. class ROOT::Fit::DataOptions. DataOptions : simple structure holding the options on how the data are filled. @ingroup FitData. Function Members (Methods); public:. ~DataOptions(); ROOT::Fit::DataOptionsDataOptions(); ROOT::Fit::DataOptionsDataOptions(const ROOT::Fit::DataOptions&); ROOT::Fit::DataOptions&operator=(const ROOT::Fit::DataOptions&). Data Members; public:. boolfAsymErrorsuse asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true); boolfBinVolumenormalize data by the bin volume (it is used in the Poisson likelihood fits); boolfCoordErrorsuse errors on the x coordinates when available (default is true); boolfErrors1use all errors equal to 1, i.e. fit without errors (default is false) ; boolfIntegraluse integral of bin content instead of bin center (default is false); boolfUseEmptyuse empty bins (default is false) with a fixed error of 1; boolfUseRangeuse the function range when creating the fit data (default is false). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DataOptions(). Default constructor: use the default options. {}. » Author: L. Moneta Wed Aug 30 11:04:59 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: DataOptions.h 31180 2009-11-16 10:54:05Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Fit__DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__DataOptions.html
Usability,simpl,simple,". ROOT::Fit::DataOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::DataOptions. class ROOT::Fit::DataOptions. DataOptions : simple structure holding the options on how the data are filled. @ingroup FitData. Function Members (Methods); public:. ~DataOptions(); ROOT::Fit::DataOptionsDataOptions(); ROOT::Fit::DataOptionsDataOptions(const ROOT::Fit::DataOptions&); ROOT::Fit::DataOptions&operator=(const ROOT::Fit::DataOptions&). Data Members; public:. boolfAsymErrorsuse asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true); boolfBinVolumenormalize data by the bin volume (it is used in the Poisson likelihood fits); boolfCoordErrorsuse errors on the x coordinates when available (default is true); boolfErrors1use all errors equal to 1, i.e. fit without errors (default is false) ; boolfIntegraluse integral of bin content instead of bin center (default is false); boolfUseEmptyuse empty bins (default is false) with a fixed error of 1; boolfUseRangeuse the function range when creating the fit data (default is false). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DataOptions(). Default constructor: use the default options. {}. » Author: L. Moneta Wed Aug 30 11:04:59 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: DataOptions.h 31180 2009-11-16 10:54:05Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Fit__DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__DataOptions.html
Usability,clear,clear," a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate. { AddRange(0,xmin,xmax); AddRange(1,ymin,ymax); }. void AddRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax). add a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate and; [zmin,zmax] for the third coordinate. void SetRange(unsigned int icoord, double xmin, double xmax). set a range [xmin,xmax] for the new coordinate icoord; If more range exists for other coordinates, delete the existing one and use it the new one; Use Add range if want to keep the union of the existing ranges. void SetRange(double xmin, double xmax). set a range [xmin,xmax] for the first coordinate icoord. { SetRange(0,xmin,xmax); }. void SetRange(double xmin, double xmax, double ymin, double ymax). set a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate. { SetRange(0,xmin,xmax); SetRange(1,ymin,ymax); }. void SetRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax). set a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate and; [zmin,zmax] for the third coordinate. void Clear(unsigned int icoord = 0). clear all ranges in one coordinate (is now -inf, +inf). bool IsInside(double x, unsigned int icoord = 0) const. check if a point is inside the range for the given coordinate. void CleanRangeSet(unsigned int icoord, double xmin, double xmax). internal function to remove all the existing ranges between xmin and xmax; called when a new range is inserted. void GetInfRange(double& x1, double& x2); get the full range (-inf, +inf). » Author: L. Moneta Wed Aug 30 11:05:02 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: DataRange.h 36558 2010-11-09 15:13:13Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Fit__DataRange.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__DataRange.html
Availability,error,error,">&ParamsSettings() const; vector<ROOT::Fit::ParameterSettings>&ParamsSettings(); const ROOT::Fit::ParameterSettings&ParSettings(unsigned int i) const; ROOT::Fit::ParameterSettings&ParSettings(unsigned int i); static voidSetDefaultMinimizer(const char* type, const char* algo = 0); voidSetFromFitResult(const ROOT::Fit::FitResult& rhs); voidSetMinimizer(const char* type, const char* algo = 0); voidSetMinosErrors(bool on = true); voidSetMinosErrors(const vector<unsigned int>& paramInd); voidSetNormErrors(bool on = true); voidSetParabErrors(bool on = true); voidSetParamsSettings(unsigned int npar, const double* params, const double* vstep = 0); voidSetUpdateAfterFit(bool on = true); boolUpdateAfterFit() const. Data Members; private:. ROOT::Math::MinimizerOptionsfMinimizerOptsminimizer control parameters including name and algo type; boolfMinosErrorsdo full error analysis using Minos; vector<unsigned int>fMinosParamsvector with the parameter indeces for running Minos; boolfNormErrorsflag for error normalization; boolfParabErrorsget correct parabolic errors estimate (call Hesse after minimizing) ; vector<ROOT::Fit::ParameterSettings>fSettingsvector with the parameter settings; boolfUpdateAfterFitupdate the configuration after a fit using the result. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitConfig(unsigned int npar = 0). Default constructor. FitConfig(const ROOT::Fit::FitConfig& rhs). Copy constructor. ~FitConfig(). Destructor. FitConfig & operator=(const ROOT::Fit::FitConfig& rhs). Assignment operator. const ParameterSettings & ParSettings(unsigned int i) const. get the parameter settings for the i-th parameter (const method). { return fSettings.at(i); }. ParameterSettings & ParSettings(unsigned int i). get the parameter settings for the i-th parameter (non-const method). { return fSettings.at(i); }. const std::vector<ROOT::Fit::ParameterSettings> & ParamsSettings() const. get the vector of parameter settings (const meth",MatchSource.WIKI,root/html530/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__FitConfig.html
Deployability,configurat,configuration,". ROOT::Fit::FitConfig. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::FitConfig. class ROOT::Fit::FitConfig. Class describing the configuration of the fit, options and parameter settings; using the ROOT::Fit::ParameterSettings class. @ingroup FitMain. Function Members (Methods); public:. ~FitConfig(); ROOT::Math::Minimizer*CreateMinimizer(); voidCreateParamsSettings(const ROOT::Math::IParamMultiFunction& func); ROOT::Fit::FitConfigFitConfig(unsigned int npar = 0); ROOT::Fit::FitConfigFitConfig(const ROOT::Fit::FitConfig& rhs); const string&MinimizerAlgoType() const; ROOT::Math::MinimizerOptions&MinimizerOptions(); const string&MinimizerType() const; boolMinosErrors() const; const vector<unsigned int>&MinosParams() const; boolNormalizeErrors() const; unsigned intNPar() const; ROOT::Fit::FitConfig&operator=(const ROOT::Fit::FitConfig& rhs); boolParabErrors() const; const vector<ROOT::Fit::ParameterSettings>&ParamsSettings() const; vector<ROOT::Fit::ParameterSettings>&ParamsSettings(); const ROOT::Fit::ParameterSettings&ParSettings(unsigned int i) const; ROOT::Fit::ParameterSettings&ParSettings(unsigned int i); static voidSetDefaultMinimizer(const char* type, const char* algo = 0); voidSetFromFitResult(const ROOT::Fit::FitResult& rhs); voidSetMinimizer(const char* type, const char* algo = 0); voidSetMinosErrors(bool on = true); voidSetMinosErrors(const vector<unsigned int>& paramInd); voidSetNormErrors(bool on = true); voidSetParabErrors(bool on = true); voidSetParamsSettings(unsigned int npar, const double* params, const double* vstep = 0); voidSetUpdateAfterFit(bool on = true); boolUpdateAfterFit() const. Data Members; private:. ROOT::Math::MinimizerOptionsfMinimizerOptsminimizer control parameters including name and algo type; boolfMinosErrorsdo full error analysis using Minos; vector<unsigned ",MatchSource.WIKI,root/html530/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__FitConfig.html
Modifiability,config,configuration,". ROOT::Fit::FitConfig. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::FitConfig. class ROOT::Fit::FitConfig. Class describing the configuration of the fit, options and parameter settings; using the ROOT::Fit::ParameterSettings class. @ingroup FitMain. Function Members (Methods); public:. ~FitConfig(); ROOT::Math::Minimizer*CreateMinimizer(); voidCreateParamsSettings(const ROOT::Math::IParamMultiFunction& func); ROOT::Fit::FitConfigFitConfig(unsigned int npar = 0); ROOT::Fit::FitConfigFitConfig(const ROOT::Fit::FitConfig& rhs); const string&MinimizerAlgoType() const; ROOT::Math::MinimizerOptions&MinimizerOptions(); const string&MinimizerType() const; boolMinosErrors() const; const vector<unsigned int>&MinosParams() const; boolNormalizeErrors() const; unsigned intNPar() const; ROOT::Fit::FitConfig&operator=(const ROOT::Fit::FitConfig& rhs); boolParabErrors() const; const vector<ROOT::Fit::ParameterSettings>&ParamsSettings() const; vector<ROOT::Fit::ParameterSettings>&ParamsSettings(); const ROOT::Fit::ParameterSettings&ParSettings(unsigned int i) const; ROOT::Fit::ParameterSettings&ParSettings(unsigned int i); static voidSetDefaultMinimizer(const char* type, const char* algo = 0); voidSetFromFitResult(const ROOT::Fit::FitResult& rhs); voidSetMinimizer(const char* type, const char* algo = 0); voidSetMinosErrors(bool on = true); voidSetMinosErrors(const vector<unsigned int>& paramInd); voidSetNormErrors(bool on = true); voidSetParabErrors(bool on = true); voidSetParamsSettings(unsigned int npar, const double* params, const double* vstep = 0); voidSetUpdateAfterFit(bool on = true); boolUpdateAfterFit() const. Data Members; private:. ROOT::Math::MinimizerOptionsfMinimizerOptsminimizer control parameters including name and algo type; boolfMinosErrorsdo full error analysis using Minos; vector<unsigned ",MatchSource.WIKI,root/html530/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__FitConfig.html
Safety,avoid,avoid,". ROOT::Fit::FitData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::FitData. class ROOT::Fit::FitData. Function Members (Methods); public:. virtual~FitData(); ROOT::Fit::FitDataFitData(); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataFitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); static unsigned intMaxSize(); ROOT::Fit::FitData&operator=(const ROOT::Fit::FitData&); const ROOT::Fit::DataOptions&Opt() const; ROOT::Fit::DataOptions&Opt(); const ROOT::Fit::DataRange&Range() const. Data Members; private:. ROOT::Fit::DataOptionsfOptions; ROOT::Fit::DataRangefRange. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitData(); construct with default option and data range. {}. virtual ~FitData(); dummy virtual destructor. {}. FitData(const DataOptions & opt); construct passing options and default data range. {}. FitData(const DataRange & range); construct passing range and default options. {}. FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); construct passing options and data range. {}. unsigned int MaxSize(); range cannot be modified afterwards; since fit method functions use all data. define a max size to avoid allocating too large arrays. » Author: L. Moneta Wed Aug 30 11:15:23 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: DataVector.h 28946 2009-06-11 15:39:14Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Fit__FitData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__FitData.html
Availability,error,error,". ROOT::Fit::FitResult. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::FitResult. class ROOT::Fit::FitResult. class containg the result of the fit and all the related information; (fitted parameter values, error, covariance matrix and minimizer result information); Contains a pointer also to the fitted (model) function, modified with the fit parameter values.; When the fit is valid, it is constructed from a Minimizer and a model function pointer. @ingroup FitMain. Function Members (Methods); public:. ~FitResult(); doubleChi2() const; doubleCorrelation(unsigned int i, unsigned int j) const; doubleCovMatrix(unsigned int i, unsigned int j) const; intCovMatrixStatus() const; doubleEdm() const; doubleError(unsigned int i) const; const vector<double>&Errors() const; ROOT::Fit::FitResultFitResult(); ROOT::Fit::FitResultFitResult(const ROOT::Fit::FitConfig& fconfig); ROOT::Fit::FitResultFitResult(const ROOT::Fit::FitResult&); ROOT::Fit::FitResultFitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0); const ROOT::Fit::FitResult::IModelFunction*FittedFunction() const; voidGetConfidenceIntervals(const ROOT::Fit::BinData& data, double* ci, double cl = 0.95, bool norm = true) const; voidGetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double* x, double* ci, double cl = 0.95, bool norm = true) const; voidGetCorrelationMatrix(TMatrixTSym<double>& mat) const; voidGetCorrelationMatrix<TMatrixDSym>(TMatrixTSym<double>& mat) const; voidGetCovarianceMatrix(TMatrixTSym<double>& mat) const; voidGetCovarianceMatrix<TMatrixDSym>(TMatrixTSym<double>& mat) const; const double*Get",MatchSource.WIKI,root/html530/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__FitResult.html
Deployability,configurat,configuration,"parameter vector) ; unsigned intfNdfnumber of degree of freedom; boolfNormalizedflag for indicating is errors are normalized; vector<std::string>fParNamesparameter names (only with FCN only fits, when fFitFunc=0); vector<double>fParamsparameter values. Size is total number of parameters; intfStatusminimizer status code; doublefValminimum function value; boolfValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitResult(). Default constructor for an empty (non valid) fit result. FitResult(const FitConfig & fconfig). Constructor from a fit-config for a dummy fit; (e.g. when only one fcn evaluation is done). FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0). Construct from a Minimizer instance after fitting; Run also Minos if requested from the configuration. FitResult(const FitResult &). Copy constructor. ~FitResult(). Destructor. bool Update(const ROOT::Math::Minimizer& min, bool isValid, unsigned int ncalls = 0). Update the fit result with a new minimization status; To be run only if same fit is performed with same configuration; Note that in this case MINOS is not re-run. If one wants to run also MINOS; a new result must be created. const std::string & MinimizerType() const; minimization quantities ; minimizer type. { return fMinimType; }. bool IsValid() const; True if fit successful, otherwise false. { return fValid; }. bool IsEmpty() const; True if a fit result does not exist (even invalid) with parameter values. { return (fParams.size() == 0); }. double MinFcnValue() const; Return value of the objective function (chi2 or likelihood) used in the fit. { return fVal; }. unsigned int NCalls() const; Number of function calls to find minimum. { return fNCalls; }. double Edm() const; Expec",MatchSource.WIKI,root/html530/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__FitResult.html
Energy Efficiency,allocate,allocates,"or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int i) const; query if parameter i has the Minos error. double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetCovarianceMatrix(TMatrixTSym<double>& mat) const; fill covariance matrix elements using a generic matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetCorrelationMatrix(TMatrixTSym<double>& mat) const; fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double* x, double* ci, double cl = 0.95, bool norm = true) const. get confidence intervals for an array of n points x.; stride1 indicates the stride in the coordinate space while stride2 the stride in dimension space.; For 1-dim points : stride1=1, stride2=1; for multi-dim points arranged as (x0,x1,...,xN,y0,....yN) stride1=1 stride2=n; for multi-dim points arraged as (x0,y0,..,x1,y1,...,xN,yN,..) stride1=ndim, stride2=1. the confidence interval are returned in the array ci; cl is the desired confidedence interval value; norm is a flag to control if the inte",MatchSource.WIKI,root/html530/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__FitResult.html
Modifiability,config,config,"ctor<unsigned int>fFixedParamslist of fixed parameters; vector<double>fGlobalCCglobal Correlation coefficient; stringfMinimTypestring indicating type of minimizer; map<unsigned int,std::pair<double,double> >fMinosErrorsmap contains the two Minos errors; unsigned intfNCallsnumber of function calls; unsigned intfNFreenumber of fit free parameters (total parameters are in size of parameter vector) ; unsigned intfNdfnumber of degree of freedom; boolfNormalizedflag for indicating is errors are normalized; vector<std::string>fParNamesparameter names (only with FCN only fits, when fFitFunc=0); vector<double>fParamsparameter values. Size is total number of parameters; intfStatusminimizer status code; doublefValminimum function value; boolfValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitResult(). Default constructor for an empty (non valid) fit result. FitResult(const FitConfig & fconfig). Constructor from a fit-config for a dummy fit; (e.g. when only one fcn evaluation is done). FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0). Construct from a Minimizer instance after fitting; Run also Minos if requested from the configuration. FitResult(const FitResult &). Copy constructor. ~FitResult(). Destructor. bool Update(const ROOT::Math::Minimizer& min, bool isValid, unsigned int ncalls = 0). Update the fit result with a new minimization status; To be run only if same fit is performed with same configuration; Note that in this case MINOS is not re-run. If one wants to run also MINOS; a new result must be created. const std::string & MinimizerType() const; minimization quantities ; minimizer type. { return fMinimType; }. bool IsValid() const; True if fit successful, otherwise false. { return fV",MatchSource.WIKI,root/html530/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__FitResult.html
Performance,perform,performed,"Statusminimizer status code; doublefValminimum function value; boolfValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitResult(). Default constructor for an empty (non valid) fit result. FitResult(const FitConfig & fconfig). Constructor from a fit-config for a dummy fit; (e.g. when only one fcn evaluation is done). FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0). Construct from a Minimizer instance after fitting; Run also Minos if requested from the configuration. FitResult(const FitResult &). Copy constructor. ~FitResult(). Destructor. bool Update(const ROOT::Math::Minimizer& min, bool isValid, unsigned int ncalls = 0). Update the fit result with a new minimization status; To be run only if same fit is performed with same configuration; Note that in this case MINOS is not re-run. If one wants to run also MINOS; a new result must be created. const std::string & MinimizerType() const; minimization quantities ; minimizer type. { return fMinimType; }. bool IsValid() const; True if fit successful, otherwise false. { return fValid; }. bool IsEmpty() const; True if a fit result does not exist (even invalid) with parameter values. { return (fParams.size() == 0); }. double MinFcnValue() const; Return value of the objective function (chi2 or likelihood) used in the fit. { return fVal; }. unsigned int NCalls() const; Number of function calls to find minimum. { return fNCalls; }. double Edm() const; Expected distance from minimum. { return fEdm; }. unsigned int NTotalParameters() const; get total number of parameters. { return fParams.size(); }. unsigned int NPar() const; total number of parameters (abbreviation). { return NTotalParameters(); }. unsigned int NFreeParameters() const; get total",MatchSource.WIKI,root/html530/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__FitResult.html
Availability,error,errors,". ROOT::Fit::Fitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::Fitter. class ROOT::Fit::Fitter. Fitter class, entry point for performing all type of fits.; Fits are performed using the generic ROOT::Fit::Fitter::Fit method.; The inputs are the data points and a model function (using a ROOT::Math::IParamFunction); The result of the fit is returned and kept internally in the ROOT::Fit::FitResult class.; The configuration of the fit (parameters, options, etc...) are specified in the; ROOT::Math::FitConfig class.; After fitting the config of the fit will be modified to have the new values the resulting; parameter of the fit with step sizes equal to the errors. FitConfig can be preserved with; initial parameters by calling FitConfig.SetUpdateAfterFit(false);. @ingroup FitMain. Function Members (Methods); public:. ~Fitter(); boolApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2); boolCalculateHessErrors(); boolCalculateMinosErrors(); const ROOT::Fit::FitConfig&Config() const; ROOT::Fit::FitConfig&Config(); boolEvalFCN(); boolFit(const ROOT::Fit::BinData& data); boolFit(const ROOT::Fit::UnBinData& data, bool useWeight = false); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFitFCN(); boolFitFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(ROOT::Fit::Fitter::MinuitFCN",MatchSource.WIKI,root/html530/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__Fitter.html
Deployability,configurat,configuration,". ROOT::Fit::Fitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::Fitter. class ROOT::Fit::Fitter. Fitter class, entry point for performing all type of fits.; Fits are performed using the generic ROOT::Fit::Fitter::Fit method.; The inputs are the data points and a model function (using a ROOT::Math::IParamFunction); The result of the fit is returned and kept internally in the ROOT::Fit::FitResult class.; The configuration of the fit (parameters, options, etc...) are specified in the; ROOT::Math::FitConfig class.; After fitting the config of the fit will be modified to have the new values the resulting; parameter of the fit with step sizes equal to the errors. FitConfig can be preserved with; initial parameters by calling FitConfig.SetUpdateAfterFit(false);. @ingroup FitMain. Function Members (Methods); public:. ~Fitter(); boolApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2); boolCalculateHessErrors(); boolCalculateMinosErrors(); const ROOT::Fit::FitConfig&Config() const; ROOT::Fit::FitConfig&Config(); boolEvalFCN(); boolFit(const ROOT::Fit::BinData& data); boolFit(const ROOT::Fit::UnBinData& data, bool useWeight = false); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFitFCN(); boolFitFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(ROOT::Fit::Fitter::MinuitFCN",MatchSource.WIKI,root/html530/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__Fitter.html
Integrability,interface,interface,"Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..). bool FitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the given FCN function represented by a multi-dimensional function interface; (ROOT::Math::IMultiGenFunction).; Give optionally the initial arameter values, data size to have the fit Ndf correctly; set in the FitResult and flag specifying if it is a chi2 fit.; Note that if the parameters values are not given (params=0) the; current parameter settings are used. The parameter settings can be created before; by using the FitConfig::SetParamsSetting. If they have not been created they are created; automatically when the params pointer is not zero.; Note that passing a params != 0 will set the parameter settings to the new value AND also the; step sizes to some pre-defined value (stepsize = 0.3 * abs(parameter_value) ). bool SetFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using a FitMethodFunction interface. Same as method above, but now extra information; can be taken from the function class. Set the FCN function represented by a multi-dimensional function in",MatchSource.WIKI,root/html530/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__Fitter.html
Modifiability,config,configuration,". ROOT::Fit::Fitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::Fitter. class ROOT::Fit::Fitter. Fitter class, entry point for performing all type of fits.; Fits are performed using the generic ROOT::Fit::Fitter::Fit method.; The inputs are the data points and a model function (using a ROOT::Math::IParamFunction); The result of the fit is returned and kept internally in the ROOT::Fit::FitResult class.; The configuration of the fit (parameters, options, etc...) are specified in the; ROOT::Math::FitConfig class.; After fitting the config of the fit will be modified to have the new values the resulting; parameter of the fit with step sizes equal to the errors. FitConfig can be preserved with; initial parameters by calling FitConfig.SetUpdateAfterFit(false);. @ingroup FitMain. Function Members (Methods); public:. ~Fitter(); boolApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2); boolCalculateHessErrors(); boolCalculateMinosErrors(); const ROOT::Fit::FitConfig&Config() const; ROOT::Fit::FitConfig&Config(); boolEvalFCN(); boolFit(const ROOT::Fit::BinData& data); boolFit(const ROOT::Fit::UnBinData& data, bool useWeight = false); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFitFCN(); boolFitFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(ROOT::Fit::Fitter::MinuitFCN",MatchSource.WIKI,root/html530/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__Fitter.html
Performance,perform,performing,". ROOT::Fit::Fitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::Fitter. class ROOT::Fit::Fitter. Fitter class, entry point for performing all type of fits.; Fits are performed using the generic ROOT::Fit::Fitter::Fit method.; The inputs are the data points and a model function (using a ROOT::Math::IParamFunction); The result of the fit is returned and kept internally in the ROOT::Fit::FitResult class.; The configuration of the fit (parameters, options, etc...) are specified in the; ROOT::Math::FitConfig class.; After fitting the config of the fit will be modified to have the new values the resulting; parameter of the fit with step sizes equal to the errors. FitConfig can be preserved with; initial parameters by calling FitConfig.SetUpdateAfterFit(false);. @ingroup FitMain. Function Members (Methods); public:. ~Fitter(); boolApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2); boolCalculateHessErrors(); boolCalculateMinosErrors(); const ROOT::Fit::FitConfig&Config() const; ROOT::Fit::FitConfig&Config(); boolEvalFCN(); boolFit(const ROOT::Fit::BinData& data); boolFit(const ROOT::Fit::UnBinData& data, bool useWeight = false); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFitFCN(); boolFitFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(ROOT::Fit::Fitter::MinuitFCN",MatchSource.WIKI,root/html530/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__Fitter.html
Testability,log,loglikelihood,"t. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fitter(). Default constructor. ~Fitter(). Destructor. Fitter(const ROOT::Fit::Fitter& ). Copy constructor (disabled, class is not copyable). bool Fit( const Data & data, const Function & func). fit a data set using any generic model function; Pre-requisite on the function:. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). fit a binned data set (default method: use chi2); To be implemented option to do likelihood bin fit. return DoLeastSquareFit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::UnBinData& data, bool useWeight = false). fit an binned data set using loglikelihood method. return DoLikelihoodFit(data, useWeight). bool LikelihoodFit(const Data & data, bool useWeight = false). Likelihood fit. return DoLikelihoodFit(data, useWeight). bool LikelihoodFit( const Data & data, const Function & func, bool useWeight = false). fit a data set using any generic model function; Pre-requisite on the function:. SetFunction(func). bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set a generic FCN function as a C++ callable object implementing; ",MatchSource.WIKI,root/html530/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__Fitter.html
Usability,simpl,simple,"e given FCN function representing a multi-dimensional gradient function; interface (ROOT::Math::IMultiGradFunction). In this case the minimizer will use the; gradient information provided by the function.; For the options same consideration as in the previous method. bool FitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0). Fit using a FitMethodGradFunction interface. Same as method above, but now extra information; can be taken from the function class. bool SetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set the FCN function represented by a multi-dimensional gradient function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be a",MatchSource.WIKI,root/html530/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__Fitter.html
Integrability,interface,interface,"itMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::UpdateNCalls() const. private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; unsigned intfNEffPointsnumber of effective points used in the fit . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc); }. unsigned int NFitPoints() const; using BaseObjFunction::operator();; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood contribution and its gradient. void Gradient(const double* x, double* g) const; need to be virtual to be instantited. double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives. » Author: L. Moneta Fri Aug 17 14:29:24 2007 » Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: LogLikelihoodFCN.h 37232 2010-12-03 18:09:43Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
Integrability,interface,interface,":IGradientFunctionMultiDim>::UpdateNCalls() const. private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; unsigned intfNEffPointsnumber of effective points used in the fit . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc); }. unsigned int NFitPoints() const; using BaseObjFunction::operator();; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood contribution and its gradient. void Gradient(const double* x, double* g) const; need to be virtual to be instantited. double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives. » Author: L. Moneta Fri Aug 17 14:29:24 2007 » Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: LogLikelihoodFCN.h 37232 2010-12-03 18:09:43Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
Deployability,release,release,"e limited Parameter. SetLimits(double low, double up). ParameterSettings(const string& name, double val); constructor for fixed Parameter. {}. void Set(const string& name, double value, double step); set value and name (unlimited parameter). SetName(const string& name). SetValue(double val). SetStepSize(double err). void Set(const string& name, double value, double step, double lower, double upper); set a limited parameter. void Set(const string& name, double value); set a fixed parameter. Fix(). ~ParameterSettings(). Destructor (no operations). {}. double Value() const; copy constructor and assignment operators (leave them to the compiler); return parameter value. { return fValue; }. double StepSize() const; return step size. { return fStepSize; }. double LowerLimit() const; return lower limit value. {return fLowerLimit;}. double UpperLimit() const; return upper limit value. {return fUpperLimit;}. bool IsFixed() const; check if is fixed. { return fFix; }. bool HasLowerLimit() const; check if parameter has lower limit. {return fHasLowerLimit; }. bool HasUpperLimit() const; check if parameter has upper limit. {return fHasUpperLimit; }. bool IsBound() const; check if is bound. { return fHasLowerLimit || fHasUpperLimit; }. bool IsDoubleBound() const; check if is double bound (upper AND lower limit). { return fHasLowerLimit && fHasUpperLimit; }. const std::string & Name() const; return name. { return fName; }. void Release(); release the parameter. {fFix = false;}. RemoveLimits(). void SetUpperLimit(double up); set a single upper limit. void SetLowerLimit(double low); set a single lower limit. » Author: L. Moneta Thu Sep 21 16:21:48 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: ParameterSettings.h 37706 2011-01-05 08:54:28Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Fit__ParameterSettings.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__ParameterSettings.html
Availability,error,errors,"N<ROOT::Math::IBaseFunctionMultiDim>&); ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::BinData&fData; const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; unsigned intfNEffPointsnumber of effective points used in the fit; intfWeightflag to indicate if needs to evaluate using weight or weight squared . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new PoissonLikelihoodFCN(fData,fFunc,fWeight); }. unsigned int NFitPoints() const; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood element and its gradient. void Gradient(const double* x, double* g) const; evaluate gradient. bool IsWeighted() const; { return (fWeight != 0); }. void UseSumOfWeights(); Use the weights in evaluating the likelihood. void UseSumOfWeightSquare(); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives. » Author: L. Moneta Fri Aug 17 14:29:24 2007 » Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: PoissonLikelihoodFCN.h 39382 2011-05-26 08:31:43Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
Integrability,interface,interface,"N<ROOT::Math::IBaseFunctionMultiDim>&); ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::BinData&fData; const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; unsigned intfNEffPointsnumber of effective points used in the fit; intfWeightflag to indicate if needs to evaluate using weight or weight squared . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new PoissonLikelihoodFCN(fData,fFunc,fWeight); }. unsigned int NFitPoints() const; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood element and its gradient. void Gradient(const double* x, double* g) const; evaluate gradient. bool IsWeighted() const; { return (fWeight != 0); }. void UseSumOfWeights(); Use the weights in evaluating the likelihood. void UseSumOfWeightSquare(); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives. » Author: L. Moneta Fri Aug 17 14:29:24 2007 » Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: PoissonLikelihoodFCN.h 39382 2011-05-26 08:31:43Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
Testability,log,log,". ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>. class ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>: public ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>. class evaluating the log likelihood; for binned Poisson likelihood fits; it is template to distinguish gradient and non-gradient case. @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::PoissonLLFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IMultiGenFunction>. Function Members (Methods); public:. virtual~PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::BinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; virtual voidGradient(const double* x, double* g) const; boolIsWeighted() const; virtual const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::BinData& data, const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>:",MatchSource.WIKI,root/html530/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
Availability,error,errors,"entFunctionMultiDim>&); ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::BinData&fData; const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; unsigned intfNEffPointsnumber of effective points used in the fit; intfWeightflag to indicate if needs to evaluate using weight or weight squared . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new PoissonLikelihoodFCN(fData,fFunc,fWeight); }. unsigned int NFitPoints() const; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood element and its gradient. void Gradient(const double* x, double* g) const; evaluate gradient. bool IsWeighted() const; { return (fWeight != 0); }. void UseSumOfWeights(); Use the weights in evaluating the likelihood. void UseSumOfWeightSquare(); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives. » Author: L. Moneta Fri Aug 17 14:29:24 2007 » Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: PoissonLikelihoodFCN.h 39382 2011-05-26 08:31:43Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
Integrability,interface,interface,"entFunctionMultiDim>&); ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::BinData&fData; const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; unsigned intfNEffPointsnumber of effective points used in the fit; intfWeightflag to indicate if needs to evaluate using weight or weight squared . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new PoissonLikelihoodFCN(fData,fFunc,fWeight); }. unsigned int NFitPoints() const; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood element and its gradient. void Gradient(const double* x, double* g) const; evaluate gradient. bool IsWeighted() const; { return (fWeight != 0); }. void UseSumOfWeights(); Use the weights in evaluating the likelihood. void UseSumOfWeightSquare(); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives. » Author: L. Moneta Fri Aug 17 14:29:24 2007 » Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: PoissonLikelihoodFCN.h 39382 2011-05-26 08:31:43Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
Testability,log,log,". ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>. class ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>: public ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>. class evaluating the log likelihood; for binned Poisson likelihood fits; it is template to distinguish gradient and non-gradient case. @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::PoissonLLGradFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IMultiGradFunction>. Function Members (Methods); public:. virtual~PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(); virtual ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::BinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* g) const; boolIsWeighted() const; virtual const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const d",MatchSource.WIKI,root/html530/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
Availability,error,error,". ROOT::Fit::SparseData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::SparseData. class ROOT::Fit::SparseData: public ROOT::Fit::FitData. Function Members (Methods); public:. virtual~SparseData(); voidAdd(vector<double>& min, vector<double>& max, const double content, const double error = 1.0); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); voidGetBinData(ROOT::Fit::BinData&) const; voidGetBinDataIntegral(ROOT::Fit::BinData&) const; voidGetBinDataNoZeros(ROOT::Fit::BinData&) const; voidGetPoint(const unsigned int i, vector<double>& min, vector<double>& max, double& content, double& error); static unsigned intROOT::Fit::FitData::MaxSize(); unsigned intNDim() const; unsigned intNPoints() const; ROOT::Fit::SparseData&operator=(const ROOT::Fit::SparseData&); const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt(); voidPrintList() const; const ROOT::Fit::DataRange&ROOT::Fit::FitData::Range() const; ROOT::Fit::SparseDataSparseData(const ROOT::Fit::SparseData&); ROOT::Fit::SparseDataSparseData(vector<double>& min, vector<double>& max); ROOT::Fit::SparseDataSparseData(const unsigned int dim, double* min, double* max). Data Members; private:. ROOT::Fit::ProxyListBox*fList. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SparseData(vector<double>& min, vector<double>& max); Constructor with a vector. SparseData(const unsigned int dim, double* min, double* m",MatchSource.WIKI,root/html530/ROOT__Fit__SparseData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__SparseData.html
Energy Efficiency,efficient,efficient,". ROOT::Fit::UnBinData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Fit::UnBinData. class ROOT::Fit::UnBinData: public ROOT::Fit::FitData. Class describing the unbinned data sets (just x coordinates values) of any dimensions. There is the option to construct UnBindata copying the data in (using the DataVector class); or using pointer to external data (DataWrapper) class.; In general is found to be more efficient to copy the data.; In case of really large data sets for limiting memory consumption then the other option can be used; Specialized constructor exists for using external data up to 3 dimensions. When the data are copying in the number of points can be set later (or re-set) using Initialize and; the data are inserted one by one using the Add method.; It is mandatory to set the size before using the Add method. @ingroup FitData. Function Members (Methods); public:. virtual~UnBinData(); voidAdd(double x); voidAdd(const double* x); voidAdd(double x, double y); voidAdd(double x, double y, double z); const double*Coords(unsigned int ipoint) const; unsigned intDataSize() const; ROOT::Fit::FitDataROOT::Fit::FitData::FitData(); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); voidInitialize(unsigned int maxpoints, unsigned int dim = 1); static unsigned intROOT::Fit::FitData::MaxSize(); unsigned intNDim() const; unsigned intNPoints() const; const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt(); unsigned intPointSize() const; const ROOT::Fit::D",MatchSource.WIKI,root/html530/ROOT__Fit__UnBinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__UnBinData.html
Integrability,wrap,wrapping,"; ROOT::Fit::UnBinDataUnBinData(unsigned int maxpoints, const double* dataX, const ROOT::Fit::DataRange& range); ROOT::Fit::UnBinDataUnBinData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1); ROOT::Fit::UnBinDataUnBinData(unsigned int n, const double* dataX, const double* dataY, const double* dataZ); ROOT::Fit::UnBinDataUnBinData(unsigned int maxpoints, const double* dataX, const double* dataY, const ROOT::Fit::DataRange& range); ROOT::Fit::UnBinDataUnBinData(unsigned int maxpoints, const double* dataX, const double* dataY, const double* dataZ, const ROOT::Fit::DataRange& range). protected:. voidSetNPoints(unsigned int n). private:. ROOT::Fit::UnBinData&operator=(const ROOT::Fit::UnBinData&); ROOT::Fit::UnBinDataUnBinData(const ROOT::Fit::UnBinData&). Data Members; private:. ROOT::Fit::DataVector*fDataVectorpointer to internal data vector (null for external data); ROOT::Fit::DataWrapper*fDataWrapperpointer to structure wrapping external data (null when data are copied in); unsigned intfDimcoordinate data dimension; unsigned intfNPointsnumer of fit points. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; explicit UnBinData(unsigned int maxpoints = 0, unsigned int dim = 1). constructor from dimension of point and max number of points (to pre-allocate vector). explicit UnBinData(const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1). constructor from range and default option. UnBinData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1). constructor from options and range. UnBinData(unsigned int n, const double* dataX). constructor for 1D external data (data are not copied inside). UnBinData(unsigned int n, const double* dataX, const double* dataY). constructor for 2D external data (data are not copied inside). UnBinData(unsigned int n, const double* dataX, con",MatchSource.WIKI,root/html530/ROOT__Fit__UnBinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__UnBinData.html
Modifiability,extend,extend,"uld be the std::vector<const double *>::begin. UnBinData(unsigned int maxpoints, const double * dataX, const DataRange & range). constructor for 1D data and a range (data are copied inside according to the given range). UnBinData(unsigned int maxpoints, const double* dataX, const double* dataY, const ROOT::Fit::DataRange& range). constructor for 2D data and a range (data are copied inside according to the given range). UnBinData(unsigned int maxpoints, const double* dataX, const double* dataY, const double* dataZ, const ROOT::Fit::DataRange& range). constructor for 3D data and a range (data are copied inside according to the given range). UnBinData & operator=(const ROOT::Fit::UnBinData& ); assignment operator (private). { return *this; }. virtual ~UnBinData(). destructor, delete pointer to internal data or external data wrapper. void Initialize(unsigned int maxpoints, unsigned int dim = 1). preallocate a data set given size and dimension; if a vector already exists with correct dimension (point size) extend the existing one; to a total size of maxpoints (equivalent to a Resize). unsigned int PointSize() const. return fit point size (for unbin data is equivalent to coordinate dimension). unsigned int DataSize() const. return size of internal data vector (is 0 for external data). void Add(double x). add one dim coordinate data. void Add(double x, double y). add 2-dim coordinate data. void Add(double x, double y, double z). add 3-dim coordinate data. void Add(const double* x). add multi-dim coordinate data. const double * Coords(unsigned int ipoint) const. return pointer to coordinate data. void Resize(unsigned int npoints). resize the vector to the given npoints. unsigned int NPoints() const. return number of contained points. { return fNPoints; }. unsigned int Size() const. return number of contained points. { return fNPoints; }. unsigned int NDim() const. return coordinate data dimension. { return fDim; }. void SetNPoints(unsigned int n); { fNPoints = n; }. » Autho",MatchSource.WIKI,root/html530/ROOT__Fit__UnBinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Fit__UnBinData.html
Deployability,release,releases,"s; Function documentation; double beta_quantile(double x, double a, double b); @defgroup QuantFunc Quantile Functions; * @ingroup StatFunc; *; * Inverse functions of the cumulative distribution functions; * and the inverse of the complement of the cumulative distribution functions; * for various distributions.; * The functions with the extension <em>_quantile</em> calculate the; * inverse of the <em>_cdf</em> function, the; * lower tail integral of the probability density function; * \f$D^{-1}(z)\f$ where; *; * \f[ D(x) = \int_{-\infty}^{x} p(x') dx' \f]; *; * while those with the <em>_quantile_c</em> extension calculate the; * inverse of the <em>_cdf_c</em> functions, the upper tail integral of the probability; * density function \f$D^{-1}(z) \f$ where; *; * \f[ D(x) = \int_{x}^{+\infty} p(x') dx' \f]; *; * These functions are defined in the header file <em>Math/ProbFunc.h<em> or in the global one; * including all statistical dunctions <em>Math/DistFunc.h<em>; *; *; * <strong>NOTE:</strong> In the old releases (< 5.14) the <em>_quantile</em> functions were called; * <em>_quant_inv</em> and the <em>_quantile_c</em> functions were called; * <em>_prob_inv</em>.; * These names are currently kept for backward compatibility, but; * their usage is deprecated.; *. @name Quantile Functions from MathCore; * The implementation is provided in MathCore and for the majority of the function comes from; * <A HREF=""http://www.netlib.org/cephes"">Cephes</A>. @{. Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the upper tail of the beta distribution; (#beta_cdf_c).; It is implemented using the function incbi from <A HREF=""http://www.netlib.org/cephes"">Cephes</A>. @ingroup QuantFunc. double beta_quantile_c(double x, double a, double b). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the lower tail of the beta distribution; (#beta_cdf).; It is implemented using; the function incbi from <A HREF=""http://www.netlib.org/cephes"">Cephes</A>. @ingrou",MatchSource.WIKI,root/html530/ROOT__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math.html
Testability,log,lognormal,"the cumulative distribution; function of the upper tail of the normal (Gaussian) distribution; (#gaussian_cdf_c). For detailed description see; <A HREF=""http://mathworld.wolfram.com/NormalDistribution.html"">; Mathworld</A>. It can also be evaluated using #normal_quantile_c which will; call the same implementation. @ingroup QuantFunc. double gaussian_quantile(double z, double sigma). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the lower tail of the normal (Gaussian) distribution; (#gaussian_cdf). For detailed description see; <A HREF=""http://mathworld.wolfram.com/NormalDistribution.html"">; Mathworld</A>. It can also be evaluated using #normal_quantile which will; call the same implementation.; It is implemented using the function ROOT::Math::Cephes::ndtri taken from; <A HREF=""http://www.netlib.org/cephes"">Cephes</A>. @ingroup QuantFunc. double lognormal_quantile_c(double x, double m, double s). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the upper tail of the lognormal distribution; (#lognormal_cdf_c). For detailed description see; <A HREF=""http://mathworld.wolfram.com/LogNormalDistribution.html"">; Mathworld</A>. The implementation used is that of; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_19.html#SEC302"">GSL</A>. @ingroup QuantFunc. double lognormal_quantile(double x, double m, double s). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the lower tail of the lognormal distribution; (#lognormal_cdf). For detailed description see; <A HREF=""http://mathworld.wolfram.com/LogNormalDistribution.html"">; Mathworld</A>. The implementation used is that of; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_19.html#SEC302"">GSL</A>. @ingroup QuantFunc. double normal_quantile_c(double z, double sigma). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the upper tail of the normal (Gaussian) distribution; (#normal_cdf_c). For detailed description see; <A HREF=""http://mat",MatchSource.WIKI,root/html530/ROOT__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math.html
Availability,toler,tolerance,"th::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidSetRelTolerance(double relTol); voidSetSize(unsigned int size); virtual intStatus() const; virtual ROOT::Math::IntegrationMultiDim::TypeROOT::Math::VirtualIntegratorMultiDim::Type() const. protected:. doubleDoIntegral(const double* xmin, const double* xmax, bool absVal = false). Data Members; private:. doublefAbsTolabsolute tolerance; unsigned intfDimdimentionality of integrand; doublefErrorintegration error ; const ROOT::Math::IMultiGenFunction*fFunpointer to integrand function ; unsigned intfMaxPtsmaximum number of function evaluation requested ; unsigned intfMinPtsminimum number of function evaluation requested ; intfNEvalnumber of function evaluation; doublefRelErrorRelative error; doublefRelTolrelative tolerance; doublefResultlast integration result ; unsigned intfSizemax size of working array (explode with dimension); intfStatusstatus of algorithm (error if not zero). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; AdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0). construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array.; The size of working array represents the number of sub-division used for calculating the integral.; Higher the dimension, larger sizes are required for getting the same accuracy.; The size must be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDi",MatchSource.WIKI,root/html530/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__AdaptiveIntegratorMultiDim.html
Deployability,integrat,integration,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOption",MatchSource.WIKI,root/html530/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__AdaptiveIntegratorMultiDim.html
Energy Efficiency,adapt,adaptive,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOption",MatchSource.WIKI,root/html530/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__AdaptiveIntegratorMultiDim.html
Integrability,integrat,integration,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOption",MatchSource.WIKI,root/html530/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__AdaptiveIntegratorMultiDim.html
Modifiability,adapt,adaptive,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOption",MatchSource.WIKI,root/html530/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__AdaptiveIntegratorMultiDim.html
Security,access,access,"AxisAngle(const ROOT::Math::AxisAngle& ); ======== Construction From other Rotation Forms ==================. Construct from another supported rotation type (see gv_detail::convert ). {gv_detail::convert(r,*this);}. AxisAngle & operator=( OtherRotation const & r ). Assign from another supported rotation type (see gv_detail::convert ). void SetComponents(double* begin, double* end); ======== Components ==============. Set the axis and then the angle given a pair of pointers or iterators; defining the beginning and end of an array of four Scalars.; Precondition: The first three components are assumed to represent; the rotation axis vector and the 4-th the rotation angle.; The angle is assumed to be in the range (-pi,pi].; The axis vector is automatically normalized to be a unit vector. void GetComponents(IT begin, IT end). Get the axis and then the angle into data specified by an iterator begin; and another to the end of the desired data (4 past start). Scalar Angle() const. access to rotation angle. { return fAngle; }. XYZVector operator()(const ROOT::Math::AxisAngle::XYZVector& v) const. AVector operator*(const AVector & v). Overload operator * for rotation on a vector. void Invert(). Invert an AxisAngle rotation in place. { fAngle = -fAngle; }. AxisAngle Inverse() const. Return inverse of an AxisAngle rotation. { AxisAngle result(*this); result.Invert(); return result; }. return ! operator==(rhs). void RectifyAngle(). double Pi(); { return 3.14159265358979323; }. AxisAngle operator*(RotationX const & r1, AxisAngle const & r2). Multiplication of an axial rotation by an AxisAngle. AxisAngle operator*(RotationY const & r1, AxisAngle const & r2). AxisAngle operator*(RotationZ const & r1, AxisAngle const & r2). » Last changed: root/mathcore:$Id: AxisAngle.h 22516 2008-03-07 15:14:26Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROO",MatchSource.WIKI,root/html530/ROOT__Math__AxisAngle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__AxisAngle.html
Availability,avail,available,". ROOT::Math::BaseIntegratorOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::BaseIntegratorOptions. class ROOT::Math::BaseIntegratorOptions. Base class for Numerical integration options; common in 1D and multi-dimension; This is an internal class and is not supposed to be instantiated by the user. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~BaseIntegratorOptions(); doubleAbsTolerance() const; ROOT::Math::IOptions*ExtraOptions() const; virtual stringIntegrator() const; ROOT::Math::BaseIntegratorOptions&operator=(const ROOT::Math::BaseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WK",MatchSource.WIKI,root/html530/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__BaseIntegratorOptions.html
Deployability,integrat,integration,". ROOT::Math::BaseIntegratorOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::BaseIntegratorOptions. class ROOT::Math::BaseIntegratorOptions. Base class for Numerical integration options; common in 1D and multi-dimension; This is an internal class and is not supposed to be instantiated by the user. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~BaseIntegratorOptions(); doubleAbsTolerance() const; ROOT::Math::IOptions*ExtraOptions() const; virtual stringIntegrator() const; ROOT::Math::BaseIntegratorOptions&operator=(const ROOT::Math::BaseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WK",MatchSource.WIKI,root/html530/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__BaseIntegratorOptions.html
Integrability,integrat,integration,". ROOT::Math::BaseIntegratorOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::BaseIntegratorOptions. class ROOT::Math::BaseIntegratorOptions. Base class for Numerical integration options; common in 1D and multi-dimension; This is an internal class and is not supposed to be instantiated by the user. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~BaseIntegratorOptions(); doubleAbsTolerance() const; ROOT::Math::IOptions*ExtraOptions() const; virtual stringIntegrator() const; ROOT::Math::BaseIntegratorOptions&operator=(const ROOT::Math::BaseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WK",MatchSource.WIKI,root/html530/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__BaseIntegratorOptions.html
Safety,avoid,avoid,":. virtual~BaseIntegratorOptions(); doubleAbsTolerance() const; ROOT::Math::IOptions*ExtraOptions() const; virtual stringIntegrator() const; ROOT::Math::BaseIntegratorOptions&operator=(const ROOT::Math::BaseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol); set the relative tolerance. { fRelTolerance = tol; }. void SetWKSize(unsigned int size); set workspace size. { fWKSize = size; }. void SetExtraOptions(const ROOT::Math::IOptions& opt); set extra options (in this case pointer is cloned). void ClearExtra(). » Author: L. Moneta Fri Aug 15 2008 » Copyright (c) 2008 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/ma",MatchSource.WIKI,root/html530/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__BaseIntegratorOptions.html
Availability,avail,available," » ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>. class ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>: public ROOT::Math::IBaseFunctionMultiDim. FitMethodFunction class; Interface for objective functions (like chi2 and likelihood used in the fit); In addition to normal function interface provide interface for calculating each; data contrinution to the function which is required by some algorithm (like Fumili). @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseObjFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::BaseObjFunction, ROOT::Math::FitMethodFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseObjFunction, ROOT::Math::BasicFitMethodFunction<ROOT::Math::IMultiGenFunction>. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual doubleDataElement(const double* x, unsigned int i, double* g = 0) const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&); virtual voidResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidUpdateNCalls() const. Data Members; public:. enum Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. unsigned intfNCallsnumber of function calls; unsigned intfNDimfunction dimension ; unsigned intfNPointssize of the data. C",MatchSource.WIKI,root/html530/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html
Deployability,update,update,"() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&); virtual voidResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidUpdateNCalls() const. Data Members; public:. enum Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. unsigned intfNCallsnumber of function calls; unsigned intfNDimfunction dimension ; unsigned intfNPointssize of the data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int NDim() const. Number of dimension (parameters) . From IGenMultiFunction interface. { return fNDim; }. double DataElement(const double* x, unsigned int i, double* g = 0) const. method returning the data i-th contribution to the fit objective function; For example the residual for the least square functions or the pdf element for the; likelihood functions.; Estimating eventually also the gradient of the data element if the passed pointer is not null. unsigned int NPoints() const. return the number of data points used in evaluating the function. { return fNPoints; }. unsigned int NCalls() const. return the total number of function calls (overrided if needed). { return fNCalls; }. void UpdateNCalls() const. update number of calls. { fNCalls++; }. void ResetNCalls(). reset number of function calls. { fNCalls = 0; }. » Author: L. Moneta Thu Aug 16 15:40:28 2007 » Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: FitMethodFunction.h 31763 2009-12-10 10:40:21Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html
Integrability,interface,interface,". ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>. class ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>: public ROOT::Math::IBaseFunctionMultiDim. FitMethodFunction class; Interface for objective functions (like chi2 and likelihood used in the fit); In addition to normal function interface provide interface for calculating each; data contrinution to the function which is required by some algorithm (like Fumili). @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseObjFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::BaseObjFunction, ROOT::Math::FitMethodFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseObjFunction, ROOT::Math::BasicFitMethodFunction<ROOT::Math::IMultiGenFunction>. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual doubleDataElement(const double* x, unsigned int i, double* g = 0) const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&); virtual voidResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctio",MatchSource.WIKI,root/html530/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html
Availability,avail,available,"Function<ROOT::Math::IGradientFunctionMultiDim>. class ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>: public ROOT::Math::IGradientFunctionMultiDim. FitMethodFunction class; Interface for objective functions (like chi2 and likelihood used in the fit); In addition to normal function interface provide interface for calculating each; data contrinution to the function which is required by some algorithm (like Fumili). @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::BaseObjFunction, ROOT::Math::BasicFitMethodFunction<ROOT::Math::IMultiGradFunction>, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseObjFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseObjFunction, ROOT::Math::FitMethodGradFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual doubleDataElement(const double* x, unsigned int i, double* g = 0) const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidROOT::Math::IGradientFunctionMultiDim::Gradient(const double* x, double* grad) const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>&); virtual voidResetNCalls(); virtual ROOT::Math::BasicFitMethodFunct",MatchSource.WIKI,root/html530/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html
Deployability,update,update,"rtual unsigned intNDim() const; virtual unsigned intNPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>&); virtual voidResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidUpdateNCalls() const. Data Members; public:. enum Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. unsigned intfNCallsnumber of function calls; unsigned intfNDimfunction dimension ; unsigned intfNPointssize of the data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int NDim() const. Number of dimension (parameters) . From IGenMultiFunction interface. { return fNDim; }. double DataElement(const double* x, unsigned int i, double* g = 0) const. method returning the data i-th contribution to the fit objective function; For example the residual for the least square functions or the pdf element for the; likelihood functions.; Estimating eventually also the gradient of the data element if the passed pointer is not null. unsigned int NPoints() const. return the number of data points used in evaluating the function. { return fNPoints; }. unsigned int NCalls() const. return the total number of function calls (overrided if needed). { return fNCalls; }. void UpdateNCalls() const. update number of calls. { fNCalls++; }. void ResetNCalls(). reset number of function calls. { fNCalls = 0; }. » Author: L. Moneta Thu Aug 16 15:40:28 2007 » Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: FitMethodFunction.h 31763 2009-12-10 10:40:21Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html
Integrability,interface,interface,". ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>. class ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>: public ROOT::Math::IGradientFunctionMultiDim. FitMethodFunction class; Interface for objective functions (like chi2 and likelihood used in the fit); In addition to normal function interface provide interface for calculating each; data contrinution to the function which is required by some algorithm (like Fumili). @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::BaseObjFunction, ROOT::Math::BasicFitMethodFunction<ROOT::Math::IMultiGradFunction>, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseObjFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseObjFunction, ROOT::Math::FitMethodGradFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual doubleDataElement(const double* x, unsigned int i, double* g = 0) const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidROOT::Math::IGradientFunctionMultiDim::Gradient(const double* x, double* grad) const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() co",MatchSource.WIKI,root/html530/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html
Availability,error,error," use the Brent Method for function minimization in a given interval.; First, a grid search is used to bracket the minimum value; with the a step size = (xmax-xmin)/npx. The step size; can be controlled via the SetNpx() function. A default value of npx = 100 is used.; The default value con be changed using the static method SetDefaultNpx.; If the function is unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval.; If the Brent method fails to converge the bracketing is repeted on the latest best estimate of the; interval. The procedure is repeted with a maximum value (default =10) which can be set for all; BrentRootFinder classes with the method SetDefaultNSearch. This class is implemented from TF1::GetMinimum. To use the class, three steps have to be taken:; 1. Create the class.; 2. Set a function within an interval to look for the minimum.; 3. Call the Minimize function with the error parameters. If another minimization is to be performed, repeat the last two steps. @ingroup Min1D. Function Members (Methods); public:. virtual~BrentMinimizer1D(); ROOT::Math::BrentMinimizer1DBrentMinimizer1D(); ROOT::Math::BrentMinimizer1DBrentMinimizer1D(const ROOT::Math::BrentMinimizer1D&); virtual doubleFValLower() const; virtual doubleFValMinimum() const; virtual doubleFValUpper() const; virtual intIterations() const; virtual boolMinimize(int maxIter, double absTol = 1.E-8, double relTol = 1.E-10); virtual const char*Name() const; static voidSetDefaultNpx(int npx); static voidSetDefaultNSearch(int n); voidSetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); voidSetLogScan(bool on); voidSetNpx(int npx); virtual intStatus() const; virtual doubleXLower() const; virtual doubleXMinimum() const; virtual doubleXUpper() const. private:. ROOT::Math::IMinimizer1D&ROOT::Math::IMinimizer1D::operator=(const ROOT::Math::IMinimizer1D&). Data Members; private:.",MatchSource.WIKI,root/html530/ROOT__Math__BrentMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__BrentMinimizer1D.html
Performance,perform,performing,". ROOT::Math::BrentMinimizer1D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::BrentMinimizer1D. class ROOT::Math::BrentMinimizer1D: private ROOT::Math::IMinimizer1D. User class for performing function minimization. It will use the Brent Method for function minimization in a given interval.; First, a grid search is used to bracket the minimum value; with the a step size = (xmax-xmin)/npx. The step size; can be controlled via the SetNpx() function. A default value of npx = 100 is used.; The default value con be changed using the static method SetDefaultNpx.; If the function is unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval.; If the Brent method fails to converge the bracketing is repeted on the latest best estimate of the; interval. The procedure is repeted with a maximum value (default =10) which can be set for all; BrentRootFinder classes with the method SetDefaultNSearch. This class is implemented from TF1::GetMinimum. To use the class, three steps have to be taken:; 1. Create the class.; 2. Set a function within an interval to look for the minimum.; 3. Call the Minimize function with the error parameters. If another minimization is to be performed, repeat the last two steps. @ingroup Min1D. Function Members (Methods); public:. virtual~BrentMinimizer1D(); ROOT::Math::BrentMinimizer1DBrentMinimizer1D(); ROOT::Math::BrentMinimizer1DBrentMinimizer1D(const ROOT::Math::BrentMinimizer1D&); virtual doubleFValLower() const; virtual doubleFValMinimum() const; virtual doubleFValUpper() const; virtual intIterations() const; virtual boolMinimize(int maxIter, double absTol = 1.E-8, double relTol = 1.E-10); virtual const char*Name() const; static voidSetDefaultNpx(int npx); static vo",MatchSource.WIKI,root/html530/ROOT__Math__BrentMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__BrentMinimizer1D.html
Testability,log,log,"on Members (Methods); public:. virtual~BrentMinimizer1D(); ROOT::Math::BrentMinimizer1DBrentMinimizer1D(); ROOT::Math::BrentMinimizer1DBrentMinimizer1D(const ROOT::Math::BrentMinimizer1D&); virtual doubleFValLower() const; virtual doubleFValMinimum() const; virtual doubleFValUpper() const; virtual intIterations() const; virtual boolMinimize(int maxIter, double absTol = 1.E-8, double relTol = 1.E-10); virtual const char*Name() const; static voidSetDefaultNpx(int npx); static voidSetDefaultNSearch(int n); voidSetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); voidSetLogScan(bool on); voidSetNpx(int npx); virtual intStatus() const; virtual doubleXLower() const; virtual doubleXMinimum() const; virtual doubleXUpper() const. private:. ROOT::Math::IMinimizer1D&ROOT::Math::IMinimizer1D::operator=(const ROOT::Math::IMinimizer1D&). Data Members; private:. const ROOT::Math::IGenFunction*fFunctionPointer to the function.; boolfLogScanflag to control usage of a log scan; intfNIterNumber of iterations needed for the last estimation.; intfNpxNumber of points to bracket minimum with grid (def is 100); intfStatusStatus of code of the last estimate; doublefXMaxUpper bound of the search interval; doublefXMinLower bound of the search interval.; doublefXMinimumPosition of the stimated minimum. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BrentMinimizer1D(); Default Constructor. . virtual ~BrentMinimizer1D(); Default Destructor. . {}. double XMinimum() const; Return current estimate of the position of the minimum. . { return fXMinimum; }. double XLower() const; Return current lower bound of the minimization interval. . { return fXMin; }. double XUpper() const; Return current upper bound of the minimization interval. . { return fXMax; }. double FValMinimum() const; Return function value at current estimate of the minimum. . double FValLower() const; Return function value at current lower bound of the minimization interval",MatchSource.WIKI,root/html530/ROOT__Math__BrentMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__BrentMinimizer1D.html
Availability,error,error,"StatusStatus of code of the last estimate; doublefXMaxUpper bound of the search interval; doublefXMinLower bound of the search interval. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BrentRootFinder(); Default Constructor. . virtual ~BrentRootFinder(); Default Destructor. . {}. bool SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). bool Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); Returns the X value corresponding to the function value fy for (xmin<x<xmax).; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval. \@param maxIter maximum number of iterations.; \@param absTol desired absolute error in the minimum position.; \@param absTol desired relative error in the minimum position. void SetNpx(int npx); Set the number of point used to bracket root using a grid . { fNpx = npx; }. void SetLogScan(bool on). Set a log grid scan (default is equidistant bins); will work only if xlow > 0. { fLogScan = on; }. double Root() const; Returns root value. Need to call first Solve(). . { return fRoot; }. int Status() const; Returns status of last estimate. If = 0 is OK . { return fStatus; }. int Iterations() const; Return number of iteration used to find minimum . { return fNIter; }. const char* Name() const; Return name of root finder algorithm (""BrentRootFinder""). . void SetDefaultNpx(int npx); static function used to modify the default parameters; set number of default Npx used at construction time (when SetNpx is not called); Default value is 100. void SetDefaultNSearch(int n); set number of times the bracketing search in combination with is done to find a good interval; Default",MatchSource.WIKI,root/html530/ROOT__Math__BrentRootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__BrentRootFinder.html
Testability,log,log,"ethod SetDefaultNSearch. This class is implemented from TF1::GetX() method. @ingroup RootFinders. Function Members (Methods); public:. virtual~BrentRootFinder(); ROOT::Math::BrentRootFinderBrentRootFinder(); ROOT::Math::BrentRootFinderBrentRootFinder(const ROOT::Math::BrentRootFinder&); virtual intROOT::Math::IRootFinderMethod::Iterate(); virtual intIterations() const; virtual const char*Name() const; ROOT::Math::IRootFinderMethod&ROOT::Math::IRootFinderMethod::operator=(const ROOT::Math::IRootFinderMethod&); virtual doubleRoot() const; static voidSetDefaultNpx(int npx); static voidSetDefaultNSearch(int n); virtual boolSetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); voidSetLogScan(bool on); voidSetNpx(int npx); virtual boolSolve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); virtual intStatus() const. Data Members; private:. const ROOT::Math::IGenFunction*fFunctionPointer to the function.; boolfLogScanflag to control usage of a log scan ; intfNIterNumber of iterations needed for the last estimation.; intfNpxNumber of points to bracket root with initial grid (def is 100); doublefRootCurrent stimation of the function root.; intfStatusStatus of code of the last estimate; doublefXMaxUpper bound of the search interval; doublefXMinLower bound of the search interval. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BrentRootFinder(); Default Constructor. . virtual ~BrentRootFinder(); Default Destructor. . {}. bool SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). bool Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); Returns the X value corresponding to the function value fy for (xmin<x<xmax).; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a",MatchSource.WIKI,root/html530/ROOT__Math__BrentRootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__BrentRootFinder.html
Availability,error,error,"nction; size_tfOrder; ROOT::Math::GSLChebSeries*fSeries. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Chebyshev(const ROOT::Math::IGenFunction& f, double a, double b, size_t n). Construct a Chebyshev series approximation to a Function f in range [a,b];; constructor based on functions of type IGenFunction. Chebyshev(ROOT::Math::GSLFuncPointer f, void* p, double a, double b, size_t n). Construct a Chebyshev series approximation to a Function f in range [a,b];; constructor based on free functions with gsl_function type signature. virtual ~Chebyshev(); destructor. Chebyshev(size_t n). construct a Chebyshev series or order n; The series must be initialized from a function. Chebyshev(const ROOT::Math::Chebyshev& ); usually copying is non trivial, so we make this unaccessible. double operator()(double x) const. Evaluate the series at a given point x. std::pair<double, double> EvalErr(double x) const. Evaluate the series at a given point x estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. double operator()(double x, size_t n) const. Evaluate the series at a given point, to (at most) the given order n. std::pair<double, double> EvalErr(double x, size_t n) const. evaluate the series at a given point x to the given order n,; estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. Chebyshev * Deriv(). Compute the derivative of the series and return a pointer to a new Chebyshev series with the; derivatives coefficients. The returned pointer must be managed by the user. TO DO: implement copying to return by value. Chebyshev * Integral(). Compute the integral of the series and return a pointer to a new Chebyshev series with the; integral coefficients. The lower limit of the integration i",MatchSource.WIKI,root/html530/ROOT__Math__Chebyshev.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Chebyshev.html
Deployability,integrat,integration,"based on free functions with gsl_function type signature. virtual ~Chebyshev(); destructor. Chebyshev(size_t n). construct a Chebyshev series or order n; The series must be initialized from a function. Chebyshev(const ROOT::Math::Chebyshev& ); usually copying is non trivial, so we make this unaccessible. double operator()(double x) const. Evaluate the series at a given point x. std::pair<double, double> EvalErr(double x) const. Evaluate the series at a given point x estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. double operator()(double x, size_t n) const. Evaluate the series at a given point, to (at most) the given order n. std::pair<double, double> EvalErr(double x, size_t n) const. evaluate the series at a given point x to the given order n,; estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. Chebyshev * Deriv(). Compute the derivative of the series and return a pointer to a new Chebyshev series with the; derivatives coefficients. The returned pointer must be managed by the user. TO DO: implement copying to return by value. Chebyshev * Integral(). Compute the integral of the series and return a pointer to a new Chebyshev series with the; integral coefficients. The lower limit of the integration is the left range value a.; The returned pointer must be managed by the user. TO DO: implement copying to return by value. void Initialize(ROOT::Math::GSLFuncPointer f, void* params, double a, double b). Initialize series passing function and range. » Last changed: root/mathmore:$Id: Chebyshev.h 38026 2011-02-10 11:46:12Z rdm $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__Chebyshev.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Chebyshev.html
Integrability,integrat,integration,"based on free functions with gsl_function type signature. virtual ~Chebyshev(); destructor. Chebyshev(size_t n). construct a Chebyshev series or order n; The series must be initialized from a function. Chebyshev(const ROOT::Math::Chebyshev& ); usually copying is non trivial, so we make this unaccessible. double operator()(double x) const. Evaluate the series at a given point x. std::pair<double, double> EvalErr(double x) const. Evaluate the series at a given point x estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. double operator()(double x, size_t n) const. Evaluate the series at a given point, to (at most) the given order n. std::pair<double, double> EvalErr(double x, size_t n) const. evaluate the series at a given point x to the given order n,; estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. Chebyshev * Deriv(). Compute the derivative of the series and return a pointer to a new Chebyshev series with the; derivatives coefficients. The returned pointer must be managed by the user. TO DO: implement copying to return by value. Chebyshev * Integral(). Compute the integral of the series and return a pointer to a new Chebyshev series with the; integral coefficients. The lower limit of the integration is the left range value a.; The returned pointer must be managed by the user. TO DO: implement copying to return by value. void Initialize(ROOT::Math::GSLFuncPointer f, void* params, double a, double b). Initialize series passing function and range. » Last changed: root/mathmore:$Id: Chebyshev.h 38026 2011-02-10 11:46:12Z rdm $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__Chebyshev.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Chebyshev.html
Security,access,accessors,"ates(const ROOT::Math::Cylindrical3D<Double32_t>::Scalar* src). Set internal data based on an array of 3 Scalar numbers ( rho, z , phi). { fRho=src[0]; fZ=src[1]; fPhi=src[2]; Restrict(); }. void GetCoordinates(ROOT::Math::Cylindrical3D<Double32_t>::Scalar* dest) const. get internal data into an array of 3 Scalar numbers ( rho, z , phi). { dest[0] = fRho; dest[1] = fZ; dest[2] = fPhi; }. void SetCoordinates(ROOT::Math::Cylindrical3D<Double32_t>::Scalar rho, ROOT::Math::Cylindrical3D<Double32_t>::Scalar zz, ROOT::Math::Cylindrical3D<Double32_t>::Scalar phi). Set internal data based on 3 Scalar numbers ( rho, z , phi). { fRho=rho; fZ=zz; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::Cylindrical3D<Double32_t>::Scalar& rho, ROOT::Math::Cylindrical3D<Double32_t>::Scalar& zz, ROOT::Math::Cylindrical3D<Double32_t>::Scalar& phi) const. get internal data into 3 Scalar numbers ( rho, z , phi). {rho=fRho; zz=fZ; phi=fPhi;}. Scalar pi(); { return M_PI; }. void Restrict(). Scalar Rho() const; accessors. { return fRho; }. Scalar Z() const; { return fZ; }. Scalar Phi() const; { return fPhi; }. Scalar X() const; { return fRho*std::cos(fPhi); }. Scalar Y() const; { return fRho*std::sin(fPhi); }. Scalar Mag2() const; { return fRho*fRho + fZ*fZ; }. Scalar R() const; { return std::sqrt( Mag2()); }. Scalar Perp2() const; { return fRho*fRho; }. Scalar Theta() const; { return (fRho==0 && fZ==0 ) ? 0 : atan2(fRho,fZ); }. Scalar Eta() const; pseudorapidity - use same implementation as in Cartesian3D. void SetRho(Double32_t rho); setters (only for data members). set the rho coordinate value keeping z and phi constant. void SetZ(Double32_t zz). set the z coordinate value keeping rho and phi constant. void SetPhi(Double32_t phi). set the phi coordinate value keeping rho and z constant. void SetXYZ(ROOT::Math::Cylindrical3D<Double32_t>::Scalar xx, ROOT::Math::Cylindrical3D<Double32_t>::Scalar yy, ROOT::Math::Cylindrical3D<Double32_t>::Scalar zz). set all values using cartesian coordin",MatchSource.WIKI,root/html530/ROOT__Math__Cylindrical3D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Cylindrical3D_Double32_t_.html
Security,access,accessors,"gnment operator. void SetCoordinates(const ROOT::Math::Cylindrical3D<double>::Scalar* src). Set internal data based on an array of 3 Scalar numbers ( rho, z , phi). { fRho=src[0]; fZ=src[1]; fPhi=src[2]; Restrict(); }. void GetCoordinates(ROOT::Math::Cylindrical3D<double>::Scalar* dest) const. get internal data into an array of 3 Scalar numbers ( rho, z , phi). { dest[0] = fRho; dest[1] = fZ; dest[2] = fPhi; }. void SetCoordinates(ROOT::Math::Cylindrical3D<double>::Scalar rho, ROOT::Math::Cylindrical3D<double>::Scalar zz, ROOT::Math::Cylindrical3D<double>::Scalar phi). Set internal data based on 3 Scalar numbers ( rho, z , phi). { fRho=rho; fZ=zz; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::Cylindrical3D<double>::Scalar& rho, ROOT::Math::Cylindrical3D<double>::Scalar& zz, ROOT::Math::Cylindrical3D<double>::Scalar& phi) const. get internal data into 3 Scalar numbers ( rho, z , phi). {rho=fRho; zz=fZ; phi=fPhi;}. Scalar pi(); { return M_PI; }. void Restrict(). Scalar Rho() const; accessors. { return fRho; }. Scalar Z() const; { return fZ; }. Scalar Phi() const; { return fPhi; }. Scalar X() const; { return fRho*std::cos(fPhi); }. Scalar Y() const; { return fRho*std::sin(fPhi); }. Scalar Mag2() const; { return fRho*fRho + fZ*fZ; }. Scalar R() const; { return std::sqrt( Mag2()); }. Scalar Perp2() const; { return fRho*fRho; }. Scalar Theta() const; { return (fRho==0 && fZ==0 ) ? 0 : atan2(fRho,fZ); }. Scalar Eta() const; pseudorapidity - use same implementation as in Cartesian3D. void SetRho(double rho); setters (only for data members). set the rho coordinate value keeping z and phi constant. void SetZ(double zz). set the z coordinate value keeping rho and phi constant. void SetPhi(double phi). set the phi coordinate value keeping rho and z constant. void SetXYZ(ROOT::Math::Cylindrical3D<double>::Scalar xx, ROOT::Math::Cylindrical3D<double>::Scalar yy, ROOT::Math::Cylindrical3D<double>::Scalar zz). set all values using cartesian coordinates. void Scale(double ",MatchSource.WIKI,root/html530/ROOT__Math__Cylindrical3D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Cylindrical3D_double_.html
Security,access,accessors,"ment operator. void SetCoordinates(const ROOT::Math::CylindricalEta3D<Double32_t>::Scalar* src). Set internal data based on an array of 3 Scalar numbers. { fRho=src[0]; fEta=src[1]; fPhi=src[2]; Restrict(); }. void GetCoordinates(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar* dest) const. get internal data into an array of 3 Scalar numbers. { dest[0] = fRho; dest[1] = fEta; dest[2] = fPhi; }. void SetCoordinates(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar rho, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar eta, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar phi). Set internal data based on 3 Scalar numbers. { fRho=rho; fEta=eta; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar& rho, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar& eta, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar& phi) const. get internal data into 3 Scalar numbers. {rho=fRho; eta=fEta; phi=fPhi;}. Scalar pi(); { return M_PI; }. void Restrict(). T Rho() const; accessors. { return fRho; }. T Eta() const; { return fEta; }. T Phi() const; { return fPhi; }. T X() const; { return fRho*std::cos(fPhi); }. T Y() const; { return fRho*std::sin(fPhi); }. T Z() const. T R() const. T Mag2() const; { return R()*R(); }. T Perp2() const; { return fRho*fRho; }. T Theta() const. void SetRho(Double32_t rho); setters (only for data members). set the rho coordinate value keeping eta and phi constant. void SetEta(Double32_t eta). set the eta coordinate value keeping rho and phi constant. void SetPhi(Double32_t phi). set the phi coordinate value keeping rho and eta constant. void SetXYZ(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar xx, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar yy, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar zz). set all values using cartesian coordinates. void Scale(Double32_t a). scale by a scalar quantity a --; for cylindrical eta coords, as long as a >= 0, only rho changes!. Negate(). bool operator==(const ROOT::Math::Cylindri",MatchSource.WIKI,root/html530/ROOT__Math__CylindricalEta3D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__CylindricalEta3D_Double32_t_.html
Testability,test,test,"onst; { return fRho*std::cos(fPhi); }. T Y() const; { return fRho*std::sin(fPhi); }. T Z() const. T R() const. T Mag2() const; { return R()*R(); }. T Perp2() const; { return fRho*fRho; }. T Theta() const. void SetRho(Double32_t rho); setters (only for data members). set the rho coordinate value keeping eta and phi constant. void SetEta(Double32_t eta). set the eta coordinate value keeping rho and phi constant. void SetPhi(Double32_t phi). set the phi coordinate value keeping rho and eta constant. void SetXYZ(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar xx, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar yy, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar zz). set all values using cartesian coordinates. void Scale(Double32_t a). scale by a scalar quantity a --; for cylindrical eta coords, as long as a >= 0, only rho changes!. Negate(). bool operator==(const ROOT::Math::CylindricalEta3D<Double32_t>& rhs) const. Exact component-by-component equality; Note: Peculiar representaions of the zero vector such as (0,1,0) will; not test as equal to one another. bool operator!=(const ROOT::Math::CylindricalEta3D<Double32_t>& rhs) const; {return !(operator==(rhs));}. T x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X();}. T y() const; { return Y();}. T z() const; { return Z(); }. void SetX(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar xx); ============= Specializations for improved speed ==================; (none); ====== Set member functions for coordinates in other systems =======. void SetY(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar yy). void SetZ(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar zz). void SetR(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar r). void SetTheta(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar theta). » Last changed: root/mathcore:$Id: CylindricalEta3D.h 31938 2009-12-18 1",MatchSource.WIKI,root/html530/ROOT__Math__CylindricalEta3D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__CylindricalEta3D_Double32_t_.html
Security,access,accessors,"ndricalEta3D<double>& v). assignment operator. void SetCoordinates(const ROOT::Math::CylindricalEta3D<double>::Scalar* src). Set internal data based on an array of 3 Scalar numbers. { fRho=src[0]; fEta=src[1]; fPhi=src[2]; Restrict(); }. void GetCoordinates(ROOT::Math::CylindricalEta3D<double>::Scalar* dest) const. get internal data into an array of 3 Scalar numbers. { dest[0] = fRho; dest[1] = fEta; dest[2] = fPhi; }. void SetCoordinates(ROOT::Math::CylindricalEta3D<double>::Scalar rho, ROOT::Math::CylindricalEta3D<double>::Scalar eta, ROOT::Math::CylindricalEta3D<double>::Scalar phi). Set internal data based on 3 Scalar numbers. { fRho=rho; fEta=eta; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::CylindricalEta3D<double>::Scalar& rho, ROOT::Math::CylindricalEta3D<double>::Scalar& eta, ROOT::Math::CylindricalEta3D<double>::Scalar& phi) const. get internal data into 3 Scalar numbers. {rho=fRho; eta=fEta; phi=fPhi;}. Scalar pi(); { return M_PI; }. void Restrict(). T Rho() const; accessors. { return fRho; }. T Eta() const; { return fEta; }. T Phi() const; { return fPhi; }. T X() const; { return fRho*std::cos(fPhi); }. T Y() const; { return fRho*std::sin(fPhi); }. T Z() const. T R() const. T Mag2() const; { return R()*R(); }. T Perp2() const; { return fRho*fRho; }. T Theta() const. void SetRho(double rho); setters (only for data members). set the rho coordinate value keeping eta and phi constant. void SetEta(double eta). set the eta coordinate value keeping rho and phi constant. void SetPhi(double phi). set the phi coordinate value keeping rho and eta constant. void SetXYZ(ROOT::Math::CylindricalEta3D<double>::Scalar xx, ROOT::Math::CylindricalEta3D<double>::Scalar yy, ROOT::Math::CylindricalEta3D<double>::Scalar zz). set all values using cartesian coordinates. void Scale(double a). scale by a scalar quantity a --; for cylindrical eta coords, as long as a >= 0, only rho changes!. Negate(). bool operator==(const ROOT::Math::CylindricalEta3D<double>& rhs) const",MatchSource.WIKI,root/html530/ROOT__Math__CylindricalEta3D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__CylindricalEta3D_double_.html
Testability,test,test,"const; { return fPhi; }. T X() const; { return fRho*std::cos(fPhi); }. T Y() const; { return fRho*std::sin(fPhi); }. T Z() const. T R() const. T Mag2() const; { return R()*R(); }. T Perp2() const; { return fRho*fRho; }. T Theta() const. void SetRho(double rho); setters (only for data members). set the rho coordinate value keeping eta and phi constant. void SetEta(double eta). set the eta coordinate value keeping rho and phi constant. void SetPhi(double phi). set the phi coordinate value keeping rho and eta constant. void SetXYZ(ROOT::Math::CylindricalEta3D<double>::Scalar xx, ROOT::Math::CylindricalEta3D<double>::Scalar yy, ROOT::Math::CylindricalEta3D<double>::Scalar zz). set all values using cartesian coordinates. void Scale(double a). scale by a scalar quantity a --; for cylindrical eta coords, as long as a >= 0, only rho changes!. Negate(). bool operator==(const ROOT::Math::CylindricalEta3D<double>& rhs) const. Exact component-by-component equality; Note: Peculiar representaions of the zero vector such as (0,1,0) will; not test as equal to one another. bool operator!=(const ROOT::Math::CylindricalEta3D<double>& rhs) const; {return !(operator==(rhs));}. T x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X();}. T y() const; { return Y();}. T z() const; { return Z(); }. void SetX(ROOT::Math::CylindricalEta3D<double>::Scalar xx); ============= Specializations for improved speed ==================; (none); ====== Set member functions for coordinates in other systems =======. void SetY(ROOT::Math::CylindricalEta3D<double>::Scalar yy). void SetZ(ROOT::Math::CylindricalEta3D<double>::Scalar zz). void SetR(ROOT::Math::CylindricalEta3D<double>::Scalar r). void SetTheta(ROOT::Math::CylindricalEta3D<double>::Scalar theta). » Last changed: root/mathcore:$Id: CylindricalEta3D.h 31938 2009-12-18 14:49:38Z moneta $ » Last",MatchSource.WIKI,root/html530/ROOT__Math__CylindricalEta3D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__CylindricalEta3D_double_.html
Availability,error,error,"ical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IMultiGenFunction& f, const double* x, unsigned int icoord = 0, double h = 1E-8); Derivatives for multi-dimension functions. Evaluate the partial derivative of a multi-dim function; with respect coordinate x_icoord at the point x[]. double Eval(ROOT::Math::IParamFunction& f, double x, const double* p, unsigned int ipar = 0, double h = 1E-8). Evaluate the derivative with respect a parameter for one-dim parameteric function; at the point ( x,p[]) with respect the parameter p_ipar. double Eval(ROOT::Math::IParamMultiFunction& f, const double* x, const double* p, unsigned int ipar = 0, double h = 1E-8). Evaluate the derivative with respect a parameter for a multi-dim parameteric function; at the point ( x[],p[]) with respect the parameter p_ipar. int Status() const. return the error status of the last derivative calculation. double Result() const. return the result of the last derivative calculation. double Error() const. return the estimate of the absolute error of the last derivative calculation. » Last changed: root/mathmore:$Id: Derivator.h 21503 2007-12-19 17:34:54Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Derivator.html
Energy Efficiency,adapt,adaptive,"n afterwards with Derivator::SetFunction. explicit Derivator(const IGenFunction &f). Construct using a ROOT::Math::IGenFunction interface. explicit Derivator(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). Construct using a GSL function pointer type; @param f : free function pointer of the GSL required type; @param p : pointer to the object carrying the function state; (for example the function object itself). virtual ~Derivator(); destructor. Derivator(const Derivator &); disable copying. void SetFunction(const ROOT::Math::IGenFunction& f). Template methods for generic functions; Set the function f for evaluating the derivative.; The function type must implement the assigment operator,; <em> double operator() ( double x ) </em>. SetFunction(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). double Eval(double x, double h = 1E-8) const. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numeric",MatchSource.WIKI,root/html530/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Derivator.html
Integrability,interface,interface,"EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); doubleEvalCentral(double x, double h = 1E-8) const; static doubleEvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); doubleEvalForward(double x, double h = 1E-8) const; static doubleEvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); doubleResult() const; voidSetFunction(const ROOT::Math::IGenFunction& f); voidSetFunction(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0); intStatus() const. private:. ROOT::Math::DerivatorDerivator(const ROOT::Math::Derivator&); ROOT::Math::Derivator&operator=(const ROOT::Math::Derivator&). Data Members; private:. ROOT::Math::GSLDerivator*fDerivator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Derivator(). Empty Construct for a Derivator class; Need to set the function afterwards with Derivator::SetFunction. explicit Derivator(const IGenFunction &f). Construct using a ROOT::Math::IGenFunction interface. explicit Derivator(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). Construct using a GSL function pointer type; @param f : free function pointer of the GSL required type; @param p : pointer to the object carrying the function state; (for example the function object itself). virtual ~Derivator(); destructor. Derivator(const Derivator &); disable copying. void SetFunction(const ROOT::Math::IGenFunction& f). Template methods for generic functions; Set the function f for evaluating the derivative.; The function type must implement the assigment operator,; <em> double operator() ( double x ) </em>. SetFunction(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). double Eval(double x, double h = 1E-8) const. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(double x, double h = 1E-8) c",MatchSource.WIKI,root/html530/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Derivator.html
Modifiability,adapt,adaptive,"n afterwards with Derivator::SetFunction. explicit Derivator(const IGenFunction &f). Construct using a ROOT::Math::IGenFunction interface. explicit Derivator(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). Construct using a GSL function pointer type; @param f : free function pointer of the GSL required type; @param p : pointer to the object carrying the function state; (for example the function object itself). virtual ~Derivator(); destructor. Derivator(const Derivator &); disable copying. void SetFunction(const ROOT::Math::IGenFunction& f). Template methods for generic functions; Set the function f for evaluating the derivative.; The function type must implement the assigment operator,; <em> double operator() ( double x ) </em>. SetFunction(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). double Eval(double x, double h = 1E-8) const. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numeric",MatchSource.WIKI,root/html530/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Derivator.html
Security,access,access,"T::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const. Data Members; private:. ROOT::Math::Cartesian2D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXY(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). DisplacementVector2D & operator=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 2D vector type, for example, Hep2Vector; Precondition: v must implement methods x() and y(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector2D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::DisplacementVector2D<RO",MatchSource.WIKI,root/html530/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_Double32_t__-p1DefaultCoordinateSystemTag_.html
Security,access,access,"g>::Scalarx() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const. Data Members; private:. ROOT::Math::Cartesian2D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXY(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). DisplacementVector2D & operator=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 2D vector type, for example, Hep2Vector; Precondition: v must implement methods x() and y(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector2D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::DisplacementVector2D<ROOT::Math::Cartes",MatchSource.WIKI,root/html530/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html
Security,access,access,"g>::Scalarx() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const. Data Members; private:. ROOT::Math::Polar2D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXY(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). DisplacementVector2D & operator=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 2D vector type, for example, Hep2Vector; Precondition: v must implement methods x() and y(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector2D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2",MatchSource.WIKI,root/html530/ROOT__Math__DisplacementVector2D_-p1Polar2D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__DisplacementVector2D_-p1Polar2D_Double32_t__-p1DefaultCoordinateSystemTag_.html
Security,access,access,"efaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const. Data Members; private:. ROOT::Math::Polar2D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXY(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). DisplacementVector2D & operator=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 2D vector type, for example, Hep2Vector; Precondition: v must implement methods x() and y(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector2D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::",MatchSource.WIKI,root/html530/ROOT__Math__DisplacementVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__DisplacementVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html
Security,access,access,"OT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cartesian3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT:",MatchSource.WIKI,root/html530/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
Security,access,access,"t; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cartesian3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Mat",MatchSource.WIKI,root/html530/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html
Security,access,access," const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cartesian3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::L",MatchSource.WIKI,root/html530/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html
Performance,perform,perform,"3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector b",MatchSource.WIKI,root/html530/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html
Safety,avoid,avoid,"th::DefaultCoordinateSystemTag>::Scalar ang). Change Theta - Polar3D coordinates only. { fCoordinates.SetTheta(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetPhi(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementin",MatchSource.WIKI,root/html530/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html
Security,access,access,"isplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cartesian3D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordi",MatchSource.WIKI,root/html530/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html
Security,access,access,"splacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cylindrical3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double3",MatchSource.WIKI,root/html530/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
Performance,perform,perform,"calar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v) const; ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this ",MatchSource.WIKI,root/html530/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html
Safety,avoid,avoid,"). Change Theta - Polar3D coordinates only. { fCoordinates.SetTheta(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetPhi(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v) const; ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::D",MatchSource.WIKI,root/html530/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html
Security,access,access,"ector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cylindrical3D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::Def",MatchSource.WIKI,root/html530/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html
Security,access,access,"<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::CylindricalEta3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindric",MatchSource.WIKI,root/html530/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
Security,access,access,"tor3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::CylindricalEta3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEt",MatchSource.WIKI,root/html530/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html
Security,access,access,"ntVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::CylindricalEta3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<",MatchSource.WIKI,root/html530/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html
Performance,perform,perform,"CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vec",MatchSource.WIKI,root/html530/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html
Safety,avoid,avoid,"dinateSystemTag>::Scalar ang). Change Theta - Polar3D coordinates only. { fCoordinates.SetTheta(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetPhi(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementin",MatchSource.WIKI,root/html530/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html
Security,access,access,"::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::CylindricalEta3D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,",MatchSource.WIKI,root/html530/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html
Security,access,access,"ag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Polar3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordi",MatchSource.WIKI,root/html530/ROOT__Math__DisplacementVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__DisplacementVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
Performance,perform,perform,"cementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a ",MatchSource.WIKI,root/html530/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html
Safety,avoid,avoid,"le>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Theta - Polar3D coordinates only. { fCoordinates.SetTheta(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetPhi(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementin",MatchSource.WIKI,root/html530/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html
Security,access,access,"y() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Polar3D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scal",MatchSource.WIKI,root/html530/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html
Availability,avail,available,". ROOT::Math::DistSampler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::DistSampler. class ROOT::Math::DistSampler. Interface class for generic sampling of a distribution,; i.e. generating random numbers according to arbitrary distributions. @ingroup Random. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~DistSampler(); virtual boolGenerate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolGenerate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolGenerate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intNDim() const; const ROOT::Math::IMultiGenFunction&ParentPdf() const; const double*Sample(); virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolSampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& func); virtual voidSetMode(double); virtual voidSetRandom(TRandom*); voidSetRange(const ROOT::Fit::DataRange& range); voidSetRange(const double* xmin, const double* xmax); voidSetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int). protected:. virtual voidDoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolIsInitialized(); const ROOT::Fit::DataRange&PdfRange() const. Data Members; private:. vector<double>fDatainternal arr",MatchSource.WIKI,root/html530/ROOT__Math__DistSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__DistSampler.html
Modifiability,extend,extend," class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::DistSampler. class ROOT::Math::DistSampler. Interface class for generic sampling of a distribution,; i.e. generating random numbers according to arbitrary distributions. @ingroup Random. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~DistSampler(); virtual boolGenerate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolGenerate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolGenerate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intNDim() const; const ROOT::Math::IMultiGenFunction&ParentPdf() const; const double*Sample(); virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolSampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& func); virtual voidSetMode(double); virtual voidSetRandom(TRandom*); voidSetRange(const ROOT::Fit::DataRange& range); voidSetRange(const double* xmin, const double* xmax); voidSetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int). protected:. virtual voidDoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolIsInitialized(); const ROOT::Fit::DataRange&PdfRange() const. Data Members; private:. vector<double>fDatainternal array used to cached the sample data ; const ROOT::Math::IMultiGenFunction*fFuncinternal function (ND); boolfOwnFuncflag to indicate if the function is owned; ROOT::Fit::DataRange*fRangedata range ",MatchSource.WIKI,root/html530/ROOT__Math__DistSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__DistSampler.html
Performance,cache,cached,"Math::IMultiGenFunction&ParentPdf() const; const double*Sample(); virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolSampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& func); virtual voidSetMode(double); virtual voidSetRandom(TRandom*); voidSetRange(const ROOT::Fit::DataRange& range); voidSetRange(const double* xmin, const double* xmax); voidSetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int). protected:. virtual voidDoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolIsInitialized(); const ROOT::Fit::DataRange&PdfRange() const. Data Members; private:. vector<double>fDatainternal array used to cached the sample data ; const ROOT::Math::IMultiGenFunction*fFuncinternal function (ND); boolfOwnFuncflag to indicate if the function is owned; ROOT::Fit::DataRange*fRangedata range . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~DistSampler(); virtual destructor. void SetFunction(Function & func, unsigned int dim); set the parent function distribution to use for sampling (generic case). DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); need to clone to avoid temporary. void SetFunction(const ROOT::Math::IGenFunction& func); set the parent function distribution to use for random sampling (one dim case). unsigned int NDim() const; return the dimension of the parent distribution (and the data). { return fData.size(); }. bool Init(const char* = """"). initialize the generators with the given algorithm; Implemented by derived classes who needs it; (like UnuranSampler); If nothing is specified use default algorithm; from DistSamplerOptions::SetDefaultAlgorithm. { return true;}. bool Init(c",MatchSource.WIKI,root/html530/ROOT__Math__DistSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__DistSampler.html
Safety,avoid,avoid,"ltiGenFunction& func); virtual voidSetMode(double); virtual voidSetRandom(TRandom*); voidSetRange(const ROOT::Fit::DataRange& range); voidSetRange(const double* xmin, const double* xmax); voidSetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int). protected:. virtual voidDoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolIsInitialized(); const ROOT::Fit::DataRange&PdfRange() const. Data Members; private:. vector<double>fDatainternal array used to cached the sample data ; const ROOT::Math::IMultiGenFunction*fFuncinternal function (ND); boolfOwnFuncflag to indicate if the function is owned; ROOT::Fit::DataRange*fRangedata range . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~DistSampler(); virtual destructor. void SetFunction(Function & func, unsigned int dim); set the parent function distribution to use for sampling (generic case). DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); need to clone to avoid temporary. void SetFunction(const ROOT::Math::IGenFunction& func); set the parent function distribution to use for random sampling (one dim case). unsigned int NDim() const; return the dimension of the parent distribution (and the data). { return fData.size(); }. bool Init(const char* = """"). initialize the generators with the given algorithm; Implemented by derived classes who needs it; (like UnuranSampler); If nothing is specified use default algorithm; from DistSamplerOptions::SetDefaultAlgorithm. { return true;}. bool Init(const ROOT::Math::DistSamplerOptions& opt). initialize the generators with the given option; which my include the algorithm but also more if; the method is re-impelmented by derived class; The default implementation calls the above method; passing just the algorithm name. void SetRandom(TRandom* ). Set the random engine to be used; To be implemented by the derived classes who provides; random sampling. {}. void SetSeed(unsi",MatchSource.WIKI,root/html530/ROOT__Math__DistSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__DistSampler.html
Integrability,interface,interfaces,". ROOT::Math::Factory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::Factory. class ROOT::Math::Factory. Factory class holding static functions to create the interfaces like ROOT::Math::Minimizer; via the Plugin Manager. Function Members (Methods); public:. ~Factory(); static ROOT::Math::DistSampler*CreateDistSampler(const string& samplerType = """"); static ROOT::Math::Minimizer*CreateMinimizer(const string& minimizerType = """", const string& algoType = """"); ROOT::Math::FactoryFactory(); ROOT::Math::FactoryFactory(const ROOT::Math::Factory&); ROOT::Math::Factory&operator=(const ROOT::Math::Factory&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ROOT::Math::Minimizer * CreateMinimizer(const string& minimizerType = """", const string& algoType = """"). static method to create the corrisponding Minimizer given the string; Supported Minimizers types are:; Minuit (TMinuit), Minuit2, GSLMultiMin, GSLMultiFit, GSLSimAn, Linear, Fumili, Genetic; If no name is given use default values defined in MinimizerOptions. ROOT::Math::DistSampler * CreateDistSampler(const string& samplerType = """"). static method to create the distribution sampler class given a string specifying the type; Supported sampler types are:; Unuran, Foam; If no name is given use default values defined in DistSamplerOptions. » Author: L. Moneta Fri Dec 22 14:43:33 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: Factory.h 37448 2010-12-09 20:20:56Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__Factory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Factory.html
Integrability,wrap,wrap,". ROOT::Math::Functor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::Functor. class ROOT::Math::Functor: public ROOT::Math::IBaseFunctionMultiDim. Documentation for class Functor class.; It is used to wrap in a very simple and convenient way multi-dimensional function objects.; It can wrap all the following types:; <ul>; <li> any C++ callable object implemention double operator()( const double * ); <li> a free C function of type double ()(double * ); <li> a member function with the correct signature like Foo::Eval(const double * ).; In this case one pass the object pointer and a pointer to the member function (&Foo::Eval); </ul>; The function dimension is required when constructing the functor. @ingroup GenFunc. Function Members (Methods); public:. virtual~Functor(); virtual ROOT::Math::Functor::ImplBase*Clone() const; ROOT::Math::FunctorFunctor(); ROOT::Math::FunctorFunctor(const ROOT::Math::Functor&); ROOT::Math::FunctorFunctor(void* p, unsigned int dim, const char* className = 0, const char* methodName = 0); virtual unsigned intNDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::Functor&operator=(const ROOT::Math::Functor& rhs). private:. virtual doubleDoEval(const double* x) const. Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionMultiDim>fImplpointer to base functor handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunc * Clone() const; clone of the function handler (use copy-ctor). unsigned int NDim() const; constructor for multi-dimensional functions. double DoEval(const double* x) const. Functor(). Default constructor. {}. Functor(const PtrObj& p, MemFn memFn, unsigned int dim ). construct from a pointer to member function (multi-dim type). {}. Functor( const Func & f, unsig",MatchSource.WIKI,root/html530/ROOT__Math__Functor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Functor.html
Usability,simpl,simple,". ROOT::Math::Functor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::Functor. class ROOT::Math::Functor: public ROOT::Math::IBaseFunctionMultiDim. Documentation for class Functor class.; It is used to wrap in a very simple and convenient way multi-dimensional function objects.; It can wrap all the following types:; <ul>; <li> any C++ callable object implemention double operator()( const double * ); <li> a free C function of type double ()(double * ); <li> a member function with the correct signature like Foo::Eval(const double * ).; In this case one pass the object pointer and a pointer to the member function (&Foo::Eval); </ul>; The function dimension is required when constructing the functor. @ingroup GenFunc. Function Members (Methods); public:. virtual~Functor(); virtual ROOT::Math::Functor::ImplBase*Clone() const; ROOT::Math::FunctorFunctor(); ROOT::Math::FunctorFunctor(const ROOT::Math::Functor&); ROOT::Math::FunctorFunctor(void* p, unsigned int dim, const char* className = 0, const char* methodName = 0); virtual unsigned intNDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::Functor&operator=(const ROOT::Math::Functor& rhs). private:. virtual doubleDoEval(const double* x) const. Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionMultiDim>fImplpointer to base functor handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunc * Clone() const; clone of the function handler (use copy-ctor). unsigned int NDim() const; constructor for multi-dimensional functions. double DoEval(const double* x) const. Functor(). Default constructor. {}. Functor(const PtrObj& p, MemFn memFn, unsigned int dim ). construct from a pointer to member function (multi-dim type). {}. Functor( const Func & f, unsig",MatchSource.WIKI,root/html530/ROOT__Math__Functor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Functor.html
Integrability,wrap,wrap,". ROOT::Math::Functor1D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::Functor1D. class ROOT::Math::Functor1D: public ROOT::Math::IBaseFunctionOneDim. Documentation for class Functor class.; It is used to wrap in a very simple and convenient way multi-dimensional function objects.; It can wrap all the following types:; <ul>; <li> any C++ callable object implemention double operator()( const double * ); <li> a free C function of type double ()(double * ); <li> a member function with the correct signature like Foo::Eval(const double * ).; In this case one pass the object pointer and a pointer to the member function (&Foo::Eval); </ul>; The function dimension is required when constructing the functor. @ingroup GenFunc. Function Members (Methods); public:. virtual~Functor1D(); virtual ROOT::Math::Functor1D::ImplBase*Clone() const; ROOT::Math::Functor1DFunctor1D(); ROOT::Math::Functor1DFunctor1D(const ROOT::Math::Functor1D&); ROOT::Math::Functor1DFunctor1D(void* p, const char* className = 0, const char* methodName = 0); doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::Functor1D&operator=(const ROOT::Math::Functor1D& rhs). private:. virtual doubleDoEval(double x) const. Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionOneDim>fImplpointer to base functor handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunc * Clone() const; clone of the function handler (use copy-ctor). double DoEval(double x) const. Functor1D(). Default constructor. {}. Functor1D(const PtrObj& p, MemFn memFn). construct from a pointer to member function (1D type). {}. Functor1D(const ROOT::Math::Functor1D& ). construct from a callable object with the right signature; ",MatchSource.WIKI,root/html530/ROOT__Math__Functor1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Functor1D.html
Usability,simpl,simple,". ROOT::Math::Functor1D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::Functor1D. class ROOT::Math::Functor1D: public ROOT::Math::IBaseFunctionOneDim. Documentation for class Functor class.; It is used to wrap in a very simple and convenient way multi-dimensional function objects.; It can wrap all the following types:; <ul>; <li> any C++ callable object implemention double operator()( const double * ); <li> a free C function of type double ()(double * ); <li> a member function with the correct signature like Foo::Eval(const double * ).; In this case one pass the object pointer and a pointer to the member function (&Foo::Eval); </ul>; The function dimension is required when constructing the functor. @ingroup GenFunc. Function Members (Methods); public:. virtual~Functor1D(); virtual ROOT::Math::Functor1D::ImplBase*Clone() const; ROOT::Math::Functor1DFunctor1D(); ROOT::Math::Functor1DFunctor1D(const ROOT::Math::Functor1D&); ROOT::Math::Functor1DFunctor1D(void* p, const char* className = 0, const char* methodName = 0); doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::Functor1D&operator=(const ROOT::Math::Functor1D& rhs). private:. virtual doubleDoEval(double x) const. Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionOneDim>fImplpointer to base functor handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunc * Clone() const; clone of the function handler (use copy-ctor). double DoEval(double x) const. Functor1D(). Default constructor. {}. Functor1D(const PtrObj& p, MemFn memFn). construct from a pointer to member function (1D type). {}. Functor1D(const ROOT::Math::Functor1D& ). construct from a callable object with the right signature; ",MatchSource.WIKI,root/html530/ROOT__Math__Functor1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Functor1D.html
Availability,error,error,"tegrator&); virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doublefEpsilonRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; doublefLastErrorError from the last stimation.; doublefLastResultResult from the last stimation.; boolfUsedOnceBool value to check if the function was at least called once.; static boolfgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~GaussIntegrator(); Destructor . GaussIntegrator(double relTol = 1.E-12); Default Constructor. . void AbsValue(bool flag); Static function: set the fgAbsValue flag.; By default TF1::Integral uses the original function value to compute the integral; However, TF1::Moment, CentralMoment require to compute the integral; using the absolute value of the function. void SetRelTolerance(double ); Implementing VirtualIntegrator Interface; Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . double Result() const; Returns the resu",MatchSource.WIKI,root/html530/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GaussIntegrator.html
Deployability,integrat,integration,". ROOT::Math::GaussIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::GaussIntegrator. class ROOT::Math::GaussIntegrator: public ROOT::Math::VirtualIntegratorOneDim. User class for performing function integration. It will use the Gauss Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussIntegrator(); voidAbsValue(bool flag); virtual doubleError() const; ROOT::Math::GaussIntegratorGaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorGaussIntegrator(const ROOT::Math::GaussIntegrator&); virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doublefEpsilonRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; doublefLastErrorError from the last stimation.; doublefLastResultResult from the last stimation.; boolfUsedOnceBool val",MatchSource.WIKI,root/html530/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GaussIntegrator.html
Integrability,integrat,integration,". ROOT::Math::GaussIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::GaussIntegrator. class ROOT::Math::GaussIntegrator: public ROOT::Math::VirtualIntegratorOneDim. User class for performing function integration. It will use the Gauss Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussIntegrator(); voidAbsValue(bool flag); virtual doubleError() const; ROOT::Math::GaussIntegratorGaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorGaussIntegrator(const ROOT::Math::GaussIntegrator&); virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doublefEpsilonRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; doublefLastErrorError from the last stimation.; doublefLastResultResult from the last stimation.; boolfUsedOnceBool val",MatchSource.WIKI,root/html530/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GaussIntegrator.html
Performance,perform,performing,". ROOT::Math::GaussIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::GaussIntegrator. class ROOT::Math::GaussIntegrator: public ROOT::Math::VirtualIntegratorOneDim. User class for performing function integration. It will use the Gauss Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussIntegrator(); voidAbsValue(bool flag); virtual doubleError() const; ROOT::Math::GaussIntegratorGaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorGaussIntegrator(const ROOT::Math::GaussIntegrator&); virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doublefEpsilonRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; doublefLastErrorError from the last stimation.; doublefLastResultResult from the last stimation.; boolfUsedOnceBool val",MatchSource.WIKI,root/html530/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GaussIntegrator.html
Availability,error,error,"ual doubleROOT::Math::GaussIntegrator::IntegralLow(double b); virtual doubleROOT::Math::GaussIntegrator::IntegralUp(double a); virtual intNEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::GaussIntegrator::Result() const; virtual voidSetAbsTolerance(double); virtual voidROOT::Math::GaussIntegrator::SetFunction(const ROOT::Math::IGenFunction&); voidSetNumberPoints(int num); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intROOT::Math::GaussIntegrator::Status() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. voidCalcGaussLegendreSamplingPoints(); virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doubleROOT::Math::GaussIntegrator::fEpsilonRelative error.; const ROOT::Math::IGenFunction*ROOT::Math::GaussIntegrator::fFunctionPointer to function used.; doubleROOT::Math::GaussIntegrator::fLastErrorError from the last stimation.; doubleROOT::Math::GaussIntegrator::fLastResultResult from the last stimation.; intfNumNumber of points used in the stimation of the integral.; boolROOT::Math::GaussIntegrator::fUsedOnceBool value to check if the function was at least called once.; double*fWWeights of the points used.; double*fXAbscisa of the points used.; static boolROOT::Math::GaussIntegrator::fgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GaussLegendreIntegrator(int num = 10, double eps = 1e-12); Basic contructor of GaussLegendreIntegrator.; \@param num Number of desired points to calculate the integration.; \@param eps Desired relative error. virtual ~GaussLegendreIntegrator(); Default Destructor . void SetNumber",MatchSource.WIKI,root/html530/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GaussLegendreIntegrator.html
Deployability,integrat,integration,". ROOT::Math::GaussLegendreIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::GaussLegendreIntegrator. class ROOT::Math::GaussLegendreIntegrator: public ROOT::Math::GaussIntegrator. User class for performing function integration. It will use the Gauss-Legendre Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussLegendreIntegrator(); voidROOT::Math::GaussIntegrator::AbsValue(bool flag); virtual doubleROOT::Math::GaussIntegrator::Error() const; ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(const ROOT::Math::GaussLegendreIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(int num = 10, double eps = 1e-12); intGetNumberPoints() const; voidGetWeightVectors(double* x, double* w) const; virtual doubleROOT::Math::GaussIntegrator::Integral(); virtual doubleROOT::Math::GaussIntegrator::Integral(const vector<double>& pts); virtual doubleROOT::Math::GaussIntegrator::Integral(double a, double b); virtual doubleROOT::Math::GaussIntegrator::IntegralCauchy(double a, double b, double c); virtual doubleROOT::Math::GaussIntegrator::IntegralLow(double b); virtual doubleROOT::Math::GaussIntegrator::IntegralUp(double a); virtual intNEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::GaussIntegrator::Result() const; virtual voidSetAbsTolerance(double); virtual voidROOT::Math::Gaus",MatchSource.WIKI,root/html530/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GaussLegendreIntegrator.html
Integrability,integrat,integration,". ROOT::Math::GaussLegendreIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::GaussLegendreIntegrator. class ROOT::Math::GaussLegendreIntegrator: public ROOT::Math::GaussIntegrator. User class for performing function integration. It will use the Gauss-Legendre Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussLegendreIntegrator(); voidROOT::Math::GaussIntegrator::AbsValue(bool flag); virtual doubleROOT::Math::GaussIntegrator::Error() const; ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(const ROOT::Math::GaussLegendreIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(int num = 10, double eps = 1e-12); intGetNumberPoints() const; voidGetWeightVectors(double* x, double* w) const; virtual doubleROOT::Math::GaussIntegrator::Integral(); virtual doubleROOT::Math::GaussIntegrator::Integral(const vector<double>& pts); virtual doubleROOT::Math::GaussIntegrator::Integral(double a, double b); virtual doubleROOT::Math::GaussIntegrator::IntegralCauchy(double a, double b, double c); virtual doubleROOT::Math::GaussIntegrator::IntegralLow(double b); virtual doubleROOT::Math::GaussIntegrator::IntegralUp(double a); virtual intNEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::GaussIntegrator::Result() const; virtual voidSetAbsTolerance(double); virtual voidROOT::Math::Gaus",MatchSource.WIKI,root/html530/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GaussLegendreIntegrator.html
Performance,perform,performing,". ROOT::Math::GaussLegendreIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::GaussLegendreIntegrator. class ROOT::Math::GaussLegendreIntegrator: public ROOT::Math::GaussIntegrator. User class for performing function integration. It will use the Gauss-Legendre Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussLegendreIntegrator(); voidROOT::Math::GaussIntegrator::AbsValue(bool flag); virtual doubleROOT::Math::GaussIntegrator::Error() const; ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(const ROOT::Math::GaussLegendreIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(int num = 10, double eps = 1e-12); intGetNumberPoints() const; voidGetWeightVectors(double* x, double* w) const; virtual doubleROOT::Math::GaussIntegrator::Integral(); virtual doubleROOT::Math::GaussIntegrator::Integral(const vector<double>& pts); virtual doubleROOT::Math::GaussIntegrator::Integral(double a, double b); virtual doubleROOT::Math::GaussIntegrator::IntegralCauchy(double a, double b, double c); virtual doubleROOT::Math::GaussIntegrator::IntegralLow(double b); virtual doubleROOT::Math::GaussIntegrator::IntegralUp(double a); virtual intNEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::GaussIntegrator::Result() const; virtual voidSetAbsTolerance(double); virtual voidROOT::Math::Gaus",MatchSource.WIKI,root/html530/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GaussLegendreIntegrator.html
Safety,unsafe,unsafe,"LegendreIntegrator.; \@param num Number of desired points to calculate the integration.; \@param eps Desired relative error. virtual ~GaussLegendreIntegrator(); Default Destructor . void SetNumberPoints(int num); Set the number of points used in the calculation of the; integral . void SetRelTolerance(double ); Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . void GetWeightVectors(double* x, double* w) const; Returns the arrays x and w containing the abscissa and weight of; the Gauss-Legendre n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. int GetNumberPoints() const; { return fNum; }. int NEval() const. return number of function evaluations in calculating the integral; This is equivalent to the number of points. { return fNum; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Reimplement method of GaussIntegrator using CalcGaussLegendreSamplingPoints. void CalcGaussLegendreSamplingPoints(). Type: unsafe but fast interface filling the arrays x and w (static method). Given the number of sampling points this routine fills the arrays x and w; of length num, containing the abscissa and weight of the Gauss-Legendre; n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. num is the number of sampling points (>0); x and w are arrays of size num; eps is the relative precision. If num<=0 or eps<=0 no action is done. Reference: Numerical Recipes in C, Second Edition. » Last changed: root/mathcore:$Id: GaussLegendreIntegrator.h 36764 2010-11-19 10:02:00Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GaussLegendreIntegrator.html
Availability,error,errors,"boolSetVariable(unsigned int ivar, const string& name, double val, double step); virtual boolROOT::Math::Minimizer::SetVariableValue(unsigned int, double); virtual boolROOT::Math::Minimizer::SetVariableValues(const double* x); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string&) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int) const; virtual const double*X() const. protected:. voidGetGeneticOptions(ROOT::Math::MinimizerOptions& opt) const. Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; TMVA::IFitterTarget*fFitness; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; ROOT::Math::GeneticMinimizerParametersfParameters; doubleROOT::Math::Minimizer::fPrecprecision; vector<TMVA::Interval*>fRanges; vector<double>fResult; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticMinimizer(int = 0). virtual ~GeneticMinimizer(). void Clear(). void SetFunction(const ROOT::Math::IMultiGenFunction& func). bool SetLimitedVariable(unsigned int , const string& , double , double , double , double ). bool SetVariable(unsigned int ivar, const string& name, double val, double step). bool Minimize(). double MinValue() const. double Edm() const. const double * X() const. const double * MinGradient() const. unsigned int NCalls() const. unsigned int NDim() const. unsigned int NFree() const. bool ProvidesError() const. co",MatchSource.WIKI,root/html530/ROOT__Math__GeneticMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GeneticMinimizer.html
Security,validat,validated,"boolSetVariable(unsigned int ivar, const string& name, double val, double step); virtual boolROOT::Math::Minimizer::SetVariableValue(unsigned int, double); virtual boolROOT::Math::Minimizer::SetVariableValues(const double* x); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string&) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int) const; virtual const double*X() const. protected:. voidGetGeneticOptions(ROOT::Math::MinimizerOptions& opt) const. Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; TMVA::IFitterTarget*fFitness; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; ROOT::Math::GeneticMinimizerParametersfParameters; doubleROOT::Math::Minimizer::fPrecprecision; vector<TMVA::Interval*>fRanges; vector<double>fResult; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticMinimizer(int = 0). virtual ~GeneticMinimizer(). void Clear(). void SetFunction(const ROOT::Math::IMultiGenFunction& func). bool SetLimitedVariable(unsigned int , const string& , double , double , double , double ). bool SetVariable(unsigned int ivar, const string& name, double val, double step). bool Minimize(). double MinValue() const. double Edm() const. const double * X() const. const double * MinGradient() const. unsigned int NCalls() const. unsigned int NDim() const. unsigned int NFree() const. bool ProvidesError() const. co",MatchSource.WIKI,root/html530/ROOT__Math__GeneticMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GeneticMinimizer.html
Integrability,interface,interface,"Math::GoFTest::EDistributionfDist; Double_tfMean; vector<std::vector<Double_t> >fSamples; Double_tfSigma; Bool_tfTestSampleFromH0. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GoFTest(UInt_t sample1Size, const Double_t* sample1, UInt_t sample2Size, const Double_t* sample2); Constructor for using only with 2-samples tests. GoFTest(UInt_t sampleSize, const Double_t* sample, ROOT::Math::GoFTest::EDistribution dist = kUndefined); Constructor for using only with 1-sample tests with a specified distribution. GoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Templated constructor for using only with 1-sample tests with a user specified distribution. Instantiate(const Double_t* sample, UInt_t sampleSize). GoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Specialization using IGenFunction interface. SetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0). SetDistributionFunction(const ROOT::Math::IGenFunction& cdf, Bool_t isPDF, Double_t xmin, Double_t xmax). void SetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax = 0); Sets the user input distribution as a probability density function for 1-sample tests. void SetUserCDF(const ROOT::Math::IGenFunction& cdf, Double_t xmin = 1, Double_t xmax = 0); Sets the user input distribution as a cumulative distribution function for 1-sample tests; The CDF must return zero. void SetDistribution(ROOT::Math::GoFTest::EDistribution dist); Sets the distribution for the predefined distribution types. virtual ~GoFTest(). Double_t AndersonDarling2SamplesTest(const Char_t* option = ""p"") const. The Anderson-Darling K",MatchSource.WIKI,root/html530/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GoFTest.html
Testability,test,testStat,"ctions:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::GoFTest. class ROOT::Math::GoFTest. Function Members (Methods); public:. virtual~GoFTest(); Double_tAndersonDarling2SamplesTest(const Char_t* option = ""p"") const; voidAndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const; Double_tAndersonDarlingTest(const Char_t* option = ""p"") const; voidAndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const; ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, ROOT::Math::GoFTest::EDistribution dist = kUndefined); ROOT::Math::GoFTestGoFTest(UInt_t sample1Size, const Double_t* sample1, UInt_t sample2Size, const Double_t* sample2); ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Double_tKolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const; Double_tKolmogorovSmirnovTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const; Double_toperator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const; voidoperator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; voidSetDistribution(ROOT::Math::GoFTest::EDistribution dist); voidSetUserCDF(const ROOT::Math::IGenFunction& cdf, Double_t xmin = 1, Double_t xmax = 0); voidSetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); voidSetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax = 0). private:. Double_tExponentialCDF(Double_t x) const; Double_tGaussianCDF(Double_t x) const; Double_tGetSigmaN(UInt_t N) const; ROOT::Math::GoFTestGoFTest(); ROOT::Math::GoFTestGoFTest(RO",MatchSource.WIKI,root/html530/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GoFTest.html
Integrability,wrap,wrap,". ROOT::Math::GradFunctor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::GradFunctor. class ROOT::Math::GradFunctor: public ROOT::Math::IGradientFunctionMultiDim. Documentation for class Functor class.; It is used to wrap in a very simple and convenient way multi-dimensional function objects.; It can wrap all the following types:; <ul>; <li> any C++ callable object implemention double operator()( const double * ); <li> a free C function of type double ()(double * ); <li> a member function with the correct signature like Foo::Eval(const double * ).; In this case one pass the object pointer and a pointer to the member function (&Foo::Eval); </ul>; The function dimension is required when constructing the functor. @ingroup GenFunc. Function Members (Methods); public:. virtual~GradFunctor(); virtual ROOT::Math::GradFunctor::ImplBase*Clone() const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; ROOT::Math::GradFunctorGradFunctor(); ROOT::Math::GradFunctorGradFunctor(const ROOT::Math::GradFunctor&); ROOT::Math::GradFunctorGradFunctor(void* p1, void* p2, unsigned int dim); ROOT::Math::GradFunctorGradFunctor(void* p1, unsigned int dim, const char* className, const char* methodName, const char* derivName); virtual voidROOT::Math::IGradientFunctionMultiDim::Gradient(const double* x, double* grad) const; virtual unsigned intNDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::GradFunctor&operator=(const ROOT::Math::GradFunctor& rhs). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const. Data Members; private:. auto_ptr<ROOT::Math::IGrad",MatchSource.WIKI,root/html530/ROOT__Math__GradFunctor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GradFunctor.html
Usability,simpl,simple,". ROOT::Math::GradFunctor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::GradFunctor. class ROOT::Math::GradFunctor: public ROOT::Math::IGradientFunctionMultiDim. Documentation for class Functor class.; It is used to wrap in a very simple and convenient way multi-dimensional function objects.; It can wrap all the following types:; <ul>; <li> any C++ callable object implemention double operator()( const double * ); <li> a free C function of type double ()(double * ); <li> a member function with the correct signature like Foo::Eval(const double * ).; In this case one pass the object pointer and a pointer to the member function (&Foo::Eval); </ul>; The function dimension is required when constructing the functor. @ingroup GenFunc. Function Members (Methods); public:. virtual~GradFunctor(); virtual ROOT::Math::GradFunctor::ImplBase*Clone() const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; ROOT::Math::GradFunctorGradFunctor(); ROOT::Math::GradFunctorGradFunctor(const ROOT::Math::GradFunctor&); ROOT::Math::GradFunctorGradFunctor(void* p1, void* p2, unsigned int dim); ROOT::Math::GradFunctorGradFunctor(void* p1, unsigned int dim, const char* className, const char* methodName, const char* derivName); virtual voidROOT::Math::IGradientFunctionMultiDim::Gradient(const double* x, double* grad) const; virtual unsigned intNDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::GradFunctor&operator=(const ROOT::Math::GradFunctor& rhs). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const. Data Members; private:. auto_ptr<ROOT::Math::IGrad",MatchSource.WIKI,root/html530/ROOT__Math__GradFunctor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GradFunctor.html
Integrability,wrap,wrap,". ROOT::Math::GradFunctor1D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::GradFunctor1D. class ROOT::Math::GradFunctor1D: public ROOT::Math::IGradientFunctionOneDim. Documentation for class Functor class.; It is used to wrap in a very simple and convenient way multi-dimensional function objects.; It can wrap all the following types:; <ul>; <li> any C++ callable object implemention double operator()( const double * ); <li> a free C function of type double ()(double * ); <li> a member function with the correct signature like Foo::Eval(const double * ).; In this case one pass the object pointer and a pointer to the member function (&Foo::Eval); </ul>; The function dimension is required when constructing the functor. @ingroup GenFunc. Function Members (Methods); public:. virtual~GradFunctor1D(); virtual ROOT::Math::GradFunctor1D::ImplBase*Clone() const; doubleROOT::Math::IGradientOneDim::Derivative(double x) const; doubleROOT::Math::IGradientOneDim::Derivative(const double* x) const; virtual voidROOT::Math::IGradientFunctionOneDim::FdF(double x, double& f, double& df) const; ROOT::Math::GradFunctor1DGradFunctor1D(); ROOT::Math::GradFunctor1DGradFunctor1D(const ROOT::Math::GradFunctor1D&); ROOT::Math::GradFunctor1DGradFunctor1D(void* p1, void* p2); ROOT::Math::GradFunctor1DGradFunctor1D(void* p1, const char* className, const char* methodName, const char* derivName); voidROOT::Math::IGradientOneDim::Gradient(const double* x, double* g) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::GradFunctor1D&operator=(const ROOT::Math::GradFunctor1D& rhs). private:. virtual doubleDoDerivative(double x) const; virtual doubleDoEval(double x) const. Data Members; private:. auto_ptr<ROOT::Math::IGradient",MatchSource.WIKI,root/html530/ROOT__Math__GradFunctor1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GradFunctor1D.html
Usability,simpl,simple,". ROOT::Math::GradFunctor1D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::GradFunctor1D. class ROOT::Math::GradFunctor1D: public ROOT::Math::IGradientFunctionOneDim. Documentation for class Functor class.; It is used to wrap in a very simple and convenient way multi-dimensional function objects.; It can wrap all the following types:; <ul>; <li> any C++ callable object implemention double operator()( const double * ); <li> a free C function of type double ()(double * ); <li> a member function with the correct signature like Foo::Eval(const double * ).; In this case one pass the object pointer and a pointer to the member function (&Foo::Eval); </ul>; The function dimension is required when constructing the functor. @ingroup GenFunc. Function Members (Methods); public:. virtual~GradFunctor1D(); virtual ROOT::Math::GradFunctor1D::ImplBase*Clone() const; doubleROOT::Math::IGradientOneDim::Derivative(double x) const; doubleROOT::Math::IGradientOneDim::Derivative(const double* x) const; virtual voidROOT::Math::IGradientFunctionOneDim::FdF(double x, double& f, double& df) const; ROOT::Math::GradFunctor1DGradFunctor1D(); ROOT::Math::GradFunctor1DGradFunctor1D(const ROOT::Math::GradFunctor1D&); ROOT::Math::GradFunctor1DGradFunctor1D(void* p1, void* p2); ROOT::Math::GradFunctor1DGradFunctor1D(void* p1, const char* className, const char* methodName, const char* derivName); voidROOT::Math::IGradientOneDim::Gradient(const double* x, double* g) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::GradFunctor1D&operator=(const ROOT::Math::GradFunctor1D& rhs). private:. virtual doubleDoDerivative(double x) const; virtual doubleDoEval(double x) const. Data Members; private:. auto_ptr<ROOT::Math::IGradient",MatchSource.WIKI,root/html530/ROOT__Math__GradFunctor1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GradFunctor1D.html
Deployability,integrat,integration,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html530/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLIntegrator.html
Energy Efficiency,adapt,adaptive,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html530/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLIntegrator.html
Integrability,integrat,integration,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html530/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLIntegrator.html
Modifiability,adapt,adaptive,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html530/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLIntegrator.html
Performance,perform,performing,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html530/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLIntegrator.html
Availability,error,error,":Math::IntegratorMultiDimOptions& opt). set the integration options. void SetGenerator(ROOT::Math::GSLRngWrapper* r). 	 set random number generator. void SetType(ROOT::Math::IntegrationMultiDim::Type type). 	 set integration method. void SetTypeName(const char* typeName). 	 set integration method using a name instead of an enumeration. void SetMode(ROOT::Math::MCIntegration::Mode mode). 	 set integration mode for VEGAS method; The possible MODE are :; MCIntegration::kIMPORTANCE (default) : VEGAS will use importance sampling; MCIntegration::kSTRATIFIED : VEGAS will use stratified sampling if certain condition are satisfied; MCIntegration::kIMPORTANCE_ONLY : VEGAS will always use importance smapling. void SetParameters(const VegasParameters &p). 	 set default parameters for VEGAS method. void SetParameters(const MiserParameters &p). 	 set default parameters for MISER method. double Sigma(). 	 set parameters for PLAIN method. void SetPParameters(const PlainParameters &p);. 	 returns the error sigma from the last iteration of the Vegas algorithm. double ChiSqr(). 	 returns chi-squared per degree of freedom for the estimate of the integral in the Vegas algorithm. MCIntegration::Type GetType() const. return the type; (need to be called GetType to avois a conflict with typedef). { return fType; }. const char * GetTypeName() const. return the name. ROOT::Math::IOptions * ExtraOptions() const. get the specific options (for Vegas or Miser); in term of string- name. bool CheckFunction(); internal method to check validity of GSL function pointer. void DoInitialize(); set internally the type of integration method. » Author: Magdalena Slawinska 08/2007 » Copyright (c) 2007 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: GSLMCIntegrator.h 36806 2010-11-20 11:09:14Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLMCIntegrator.html
Deployability,integrat,integration,". ROOT::Math::GSLMCIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLMCIntegrator. class ROOT::Math::GSLMCIntegrator: public ROOT::Math::VirtualIntegratorMultiDim. Class for performing numerical integration of a multidimensional function.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be; instantiate using the plugin manager (plugin name is ""GSLMCIntegrator""). @ingroup MCIntegration. Function Members (Methods); public:. virtual~GSLMCIntegrator(); doubleChiSqr(); virtual doubleError() const; ROOT::Math::IOptions*ExtraOptions() const; ROOT::Math::IntegrationMultiDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLMCIntegratorGSLMCIntegrator(ROOT::Math::IntegrationMultiDim::Type type = MCIntegration::kVEGAS, double absTol = 0, double relTol = 0, unsigned int calls = 0); ROOT::Math::GSLMCIntegratorGSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); virtual doubleIntegral(const double* a, const double* b); doubleIntegral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); virtual intNEval() const; virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, ",MatchSource.WIKI,root/html530/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLMCIntegrator.html
Integrability,integrat,integration,". ROOT::Math::GSLMCIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLMCIntegrator. class ROOT::Math::GSLMCIntegrator: public ROOT::Math::VirtualIntegratorMultiDim. Class for performing numerical integration of a multidimensional function.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be; instantiate using the plugin manager (plugin name is ""GSLMCIntegrator""). @ingroup MCIntegration. Function Members (Methods); public:. virtual~GSLMCIntegrator(); doubleChiSqr(); virtual doubleError() const; ROOT::Math::IOptions*ExtraOptions() const; ROOT::Math::IntegrationMultiDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLMCIntegratorGSLMCIntegrator(ROOT::Math::IntegrationMultiDim::Type type = MCIntegration::kVEGAS, double absTol = 0, double relTol = 0, unsigned int calls = 0); ROOT::Math::GSLMCIntegratorGSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); virtual doubleIntegral(const double* a, const double* b); doubleIntegral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); virtual intNEval() const; virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, ",MatchSource.WIKI,root/html530/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLMCIntegrator.html
Modifiability,plugin,plugin,". ROOT::Math::GSLMCIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLMCIntegrator. class ROOT::Math::GSLMCIntegrator: public ROOT::Math::VirtualIntegratorMultiDim. Class for performing numerical integration of a multidimensional function.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be; instantiate using the plugin manager (plugin name is ""GSLMCIntegrator""). @ingroup MCIntegration. Function Members (Methods); public:. virtual~GSLMCIntegrator(); doubleChiSqr(); virtual doubleError() const; ROOT::Math::IOptions*ExtraOptions() const; ROOT::Math::IntegrationMultiDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLMCIntegratorGSLMCIntegrator(ROOT::Math::IntegrationMultiDim::Type type = MCIntegration::kVEGAS, double absTol = 0, double relTol = 0, unsigned int calls = 0); ROOT::Math::GSLMCIntegratorGSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); virtual doubleIntegral(const double* a, const double* b); doubleIntegral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); virtual intNEval() const; virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, ",MatchSource.WIKI,root/html530/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLMCIntegrator.html
Performance,perform,performing,". ROOT::Math::GSLMCIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLMCIntegrator. class ROOT::Math::GSLMCIntegrator: public ROOT::Math::VirtualIntegratorMultiDim. Class for performing numerical integration of a multidimensional function.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be; instantiate using the plugin manager (plugin name is ""GSLMCIntegrator""). @ingroup MCIntegration. Function Members (Methods); public:. virtual~GSLMCIntegrator(); doubleChiSqr(); virtual doubleError() const; ROOT::Math::IOptions*ExtraOptions() const; ROOT::Math::IntegrationMultiDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLMCIntegratorGSLMCIntegrator(ROOT::Math::IntegrationMultiDim::Type type = MCIntegration::kVEGAS, double absTol = 0, double relTol = 0, unsigned int calls = 0); ROOT::Math::GSLMCIntegratorGSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); virtual doubleIntegral(const double* a, const double* b); doubleIntegral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); virtual intNEval() const; virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, ",MatchSource.WIKI,root/html530/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLMCIntegrator.html
Availability,error,errors,"string& name, double val, double step); virtual boolSetVariableValue(unsigned int ivar, double val); virtual boolSetVariableValues(const double* x); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; doubleROOT::Math::Minimizer::Tolerance() const; const ROOT::Math::MinimTransformFunction*TransformFunction() const; virtual intROOT::Math::Minimizer::VariableIndex(const string&) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int) const; virtual const double*X() const. private:. ROOT::Math::GSLMinimizerGSLMinimizer(const ROOT::Math::GSLMinimizer&); ROOT::Math::GSLMinimizer&operator=(const ROOT::Math::GSLMinimizer& rhs). Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; doubleROOT::Math::Minimizer::fPrecprecision; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. map<unsigned int,std::pair<double,double> >fBoundsmap specifying the bound using as key the parameter index; unsigned intfDim; ROOT::Math::GSLMultiMinimizer*fGSLMultiMin; doublefLSToleranceLine Search Tolerance; doublefMinVal; vector<std::string>fNames; const ROOT::Math::IMultiGradFunction*fObjFunc; vector<double>fSteps; vector<double>fValues; vector<ROOT::Math::EMinimVariableType>fVarTypesvector specifyng the type of variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLMinimizer(ROOT::Math::EGSLMinimizerType type = ROOT::Math::kConjugateFR). Default constructor. GSLMinimizer(const char* type). Constructor with a string giving name ",MatchSource.WIKI,root/html530/ROOT__Math__GSLMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLMinimizer.html
Integrability,interface,interface,". ROOT::Math::GSLMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLMinimizer. class ROOT::Math::GSLMinimizer: public ROOT::Math::Minimizer. GSLMinimizer class.; Implementation of the ROOT::Math::Minimizer interface using the GSL multi-dimensional; minimization algorithms. See <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Multidimensional-Minimization.html"">GSL doc</A>; from more info on the GSL minimization algorithms. The class implements the ROOT::Math::Minimizer interface and can be instantiated using the; ROOT plugin manager (plugin name is ""GSLMultiMin""). The varius minimization algorithms; (conjugatefr, conjugatepr, bfgs, etc..) can be passed as enumerations and also as a string.; The default algorithm is conjugatefr (Fletcher-Reeves conjugate gradient algorithm). @ingroup MultiMin. Function Members (Methods); public:. virtual~GSLMinimizer(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int, unsigned int, unsigned int&, double*, double*); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int, unsigned int) const; virtual intROOT::Math::Minimizer::CovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::GetCovMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int, double& errLow, double& errUp, int = 0); virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int) const; ROOT::Math::GSLMinimizerGSLMinimizer(ROOT::Math::EGSLMinimizerType type = ROOT::Math::kConjugateFR); ROOT::Math::GSLMinimizerGSLMinimizer(const char* type); virtual boolROO",MatchSource.WIKI,root/html530/ROOT__Math__GSLMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLMinimizer.html
Modifiability,plugin,plugin,". ROOT::Math::GSLMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLMinimizer. class ROOT::Math::GSLMinimizer: public ROOT::Math::Minimizer. GSLMinimizer class.; Implementation of the ROOT::Math::Minimizer interface using the GSL multi-dimensional; minimization algorithms. See <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Multidimensional-Minimization.html"">GSL doc</A>; from more info on the GSL minimization algorithms. The class implements the ROOT::Math::Minimizer interface and can be instantiated using the; ROOT plugin manager (plugin name is ""GSLMultiMin""). The varius minimization algorithms; (conjugatefr, conjugatepr, bfgs, etc..) can be passed as enumerations and also as a string.; The default algorithm is conjugatefr (Fletcher-Reeves conjugate gradient algorithm). @ingroup MultiMin. Function Members (Methods); public:. virtual~GSLMinimizer(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int, unsigned int, unsigned int&, double*, double*); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int, unsigned int) const; virtual intROOT::Math::Minimizer::CovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::GetCovMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int, double& errLow, double& errUp, int = 0); virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int) const; ROOT::Math::GSLMinimizerGSLMinimizer(ROOT::Math::EGSLMinimizerType type = ROOT::Math::kConjugateFR); ROOT::Math::GSLMinimizerGSLMinimizer(const char* type); virtual boolROO",MatchSource.WIKI,root/html530/ROOT__Math__GSLMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLMinimizer.html
Performance,perform,perform,"ble(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set upper/lower limited variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int ivar, double val); set the value of an existing variable. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of existing parameters). bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. const double * X() const; return pointer to X values at the minimum. { return &fValues.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fValues.size(); }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total number of free parameters. { return fObjFunc->NDim(); }. bool ProvidesError() const; minimizer provides error and error matrix. { return false; }. const double * Errors() const; return errors at the minimum. double CovMatrix(unsigned int , unsigned int ) const; return covariance ",MatchSource.WIKI,root/html530/ROOT__Math__GSLMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLMinimizer.html
Security,validat,validated,"string& name, double val, double step); virtual boolSetVariableValue(unsigned int ivar, double val); virtual boolSetVariableValues(const double* x); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; doubleROOT::Math::Minimizer::Tolerance() const; const ROOT::Math::MinimTransformFunction*TransformFunction() const; virtual intROOT::Math::Minimizer::VariableIndex(const string&) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int) const; virtual const double*X() const. private:. ROOT::Math::GSLMinimizerGSLMinimizer(const ROOT::Math::GSLMinimizer&); ROOT::Math::GSLMinimizer&operator=(const ROOT::Math::GSLMinimizer& rhs). Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; doubleROOT::Math::Minimizer::fPrecprecision; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. map<unsigned int,std::pair<double,double> >fBoundsmap specifying the bound using as key the parameter index; unsigned intfDim; ROOT::Math::GSLMultiMinimizer*fGSLMultiMin; doublefLSToleranceLine Search Tolerance; doublefMinVal; vector<std::string>fNames; const ROOT::Math::IMultiGradFunction*fObjFunc; vector<double>fSteps; vector<double>fValues; vector<ROOT::Math::EMinimVariableType>fVarTypesvector specifyng the type of variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLMinimizer(ROOT::Math::EGSLMinimizerType type = ROOT::Math::kConjugateFR). Default constructor. GSLMinimizer(const char* type). Constructor with a string giving name ",MatchSource.WIKI,root/html530/ROOT__Math__GSLMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLMinimizer.html
Availability,error,error,"h::GSLFunctionWrapper*fFunction; boolfIsSet; intfIter; doublefLow; doublefMin; ROOT::Math::GSL1DMinimizerWrapper*fMinimizer; intfStatusstatus of last minimization (==0 ok =1 failed); doublefUp; doublefXlow; doublefXmin; doublefXup. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; explicit GSLMinimizer1D(Minim1D::Type type=Minim1D::kBRENT). Construct the minimizer passing the minimizer type using the Minim1D::Algorithm enumeration. virtual ~GSLMinimizer1D(). Destructor: free allocated resources. GSLMinimizer1D(const GSLMinimizer1D &); usually copying is non trivial, so we make this unaccessible. void SetFunction( const UserFunc & f, double xmin, double xlow, double xup). Set, or reset, minimizer to use the function f and the initial search interval [xlow, xup], with a guess for the location of the minimum xmin.; The condition : \f$ f(xlow) > f(xmin) < f(xup)\f$ must be satisfied. int Iterate(). Perform a minimizer iteration and; if an unexepcted problem occurr then an error code will be returned. double XMinimum() const. Return current estimate of the position of the minimum. double XLower() const. Return current lower bound of the minimization interval. double XUpper() const. Return current upper bound of the minimization interval. double FValMinimum() const. Return function value at current estimate of the minimum. double FValLower() const. Return function value at current lower bound of the minimization interval. double FValUpper() const. Return function value at current upper bound of the minimization interval. bool Minimize(int maxIter, double absTol, double relTol). Find minimum position iterating until convergence specified by the absolute and relative tolerance or; the maximum number of iteration is reached; Return true is result is successfull; \@param maxIter maximum number of iteration; \@param absTol desired absolute error in the minimum position; \@param absTol desired relative error in the minimum position. int ",MatchSource.WIKI,root/html530/ROOT__Math__GSLMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLMinimizer1D.html
Energy Efficiency,allocate,allocated,"ion(ROOT::Math::GSLFuncPointer f, void* params, double xmin, double xlow, double xup); virtual intStatus() const; static intTestInterval(double xlow, double xup, double epsAbs, double epsRel); virtual doubleXLower() const; virtual doubleXMinimum() const; virtual doubleXUpper() const. private:. ROOT::Math::GSLMinimizer1DGSLMinimizer1D(const ROOT::Math::GSLMinimizer1D&); ROOT::Math::GSLMinimizer1D&operator=(const ROOT::Math::GSLMinimizer1D&). Data Members; private:. ROOT::Math::GSLFunctionWrapper*fFunction; boolfIsSet; intfIter; doublefLow; doublefMin; ROOT::Math::GSL1DMinimizerWrapper*fMinimizer; intfStatusstatus of last minimization (==0 ok =1 failed); doublefUp; doublefXlow; doublefXmin; doublefXup. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; explicit GSLMinimizer1D(Minim1D::Type type=Minim1D::kBRENT). Construct the minimizer passing the minimizer type using the Minim1D::Algorithm enumeration. virtual ~GSLMinimizer1D(). Destructor: free allocated resources. GSLMinimizer1D(const GSLMinimizer1D &); usually copying is non trivial, so we make this unaccessible. void SetFunction( const UserFunc & f, double xmin, double xlow, double xup). Set, or reset, minimizer to use the function f and the initial search interval [xlow, xup], with a guess for the location of the minimum xmin.; The condition : \f$ f(xlow) > f(xmin) < f(xup)\f$ must be satisfied. int Iterate(). Perform a minimizer iteration and; if an unexepcted problem occurr then an error code will be returned. double XMinimum() const. Return current estimate of the position of the minimum. double XLower() const. Return current lower bound of the minimization interval. double XUpper() const. Return current upper bound of the minimization interval. double FValMinimum() const. Return function value at current estimate of the minimum. double FValLower() const. Return function value at current lower bound of the minimization interval. double FValUpper() const. Return function",MatchSource.WIKI,root/html530/ROOT__Math__GSLMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLMinimizer1D.html
Testability,test,test," initial search interval [xlow, xup], with a guess for the location of the minimum xmin.; The condition : \f$ f(xlow) > f(xmin) < f(xup)\f$ must be satisfied. int Iterate(). Perform a minimizer iteration and; if an unexepcted problem occurr then an error code will be returned. double XMinimum() const. Return current estimate of the position of the minimum. double XLower() const. Return current lower bound of the minimization interval. double XUpper() const. Return current upper bound of the minimization interval. double FValMinimum() const. Return function value at current estimate of the minimum. double FValLower() const. Return function value at current lower bound of the minimization interval. double FValUpper() const. Return function value at current upper bound of the minimization interval. bool Minimize(int maxIter, double absTol, double relTol). Find minimum position iterating until convergence specified by the absolute and relative tolerance or; the maximum number of iteration is reached; Return true is result is successfull; \@param maxIter maximum number of iteration; \@param absTol desired absolute error in the minimum position; \@param absTol desired relative error in the minimum position. int Iterations() const. Return number of iteration used to find minimum. int Status() const. Return status of last minimization. { return fStatus; }. const char * Name() const. Return name of minimization algorithm. int TestInterval(double xlow, double xup, double epsAbs, double epsRel). Test convergence of the interval.; The test returns success if; \f[; |x_{min}-x_{truemin}| < epsAbs + epsRel *x_{truemin}; \f]. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 moneta, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: GSLMinimizer1D.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__GSLMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLMinimizer1D.html
Usability,simpl,simplest,". ROOT::Math::GSLMinimizer1D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLMinimizer1D. class ROOT::Math::GSLMinimizer1D: public ROOT::Math::IMinimizer1D. Minimizer for arbitrary one dimensional functions. Implemented using GSL, for detailed description see:; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/One-dimensional-Minimization.html"">GSL online doc</A>. The algorithms uspported are only bracketing algorithm which do not use derivatives information.; The algorithms which can be choosen at construction time are GOLDENSECTION, whic is the simplest method; but the slowest and BRENT (the default one) which combines the golden section with a parabolic interpolation. This class does not support copying; @ingroup Min1D. Function Members (Methods); public:. virtual~GSLMinimizer1D(); virtual doubleFValLower() const; virtual doubleFValMinimum() const; virtual doubleFValUpper() const; ROOT::Math::GSLMinimizer1DGSLMinimizer1D(ROOT::Math::Minim1D::Type type = Minim1D::kBRENT); intIterate(); virtual intIterations() const; virtual boolMinimize(int maxIter, double absTol, double relTol); virtual const char*Name() const; voidSetFunction(ROOT::Math::GSLFuncPointer f, void* params, double xmin, double xlow, double xup); virtual intStatus() const; static intTestInterval(double xlow, double xup, double epsAbs, double epsRel); virtual doubleXLower() const; virtual doubleXMinimum() const; virtual doubleXUpper() const. private:. ROOT::Math::GSLMinimizer1DGSLMinimizer1D(const ROOT::Math::GSLMinimizer1D&); ROOT::Math::GSLMinimizer1D&operator=(const ROOT::Math::GSLMinimizer1D&). Data Members; private:. ROOT::Math::GSLFunctionWrapper*fFunction; boolfIsSet; intfIter; doublefLow; doublefMin; ROOT::Math::GSL1DMinimizerWrapper*fMinimizer; intfStatusstatus of last minimization (==0 ok =1 failed); doublefUp",MatchSource.WIKI,root/html530/ROOT__Math__GSLMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLMinimizer1D.html
Availability,avail,available,". ROOT::Math::GSLMultiRootFinder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLMultiRootFinder. class ROOT::Math::GSLMultiRootFinder. Class for Multidimensional root finding algorithms bassed on GSL. This class is used to solve a; non-linear system of equations:. f1(x1,....xn) = 0; f2(x1,....xn) = 0; ..................; fn(x1,....xn) = 0. See the GSL <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Multidimensional-Root_002dFinding.html""> online manual</A> for; information on the GSL MultiRoot finding algorithms. The available GSL algorithms require the derivatives of the supplied functions or not (they are; computed internally by GSL). In the first case the user needs to provide a list of multidimensional functions implementing the; gradient interface (ROOT::Math::IMultiGradFunction) while in the second case it is enough to supply a list of; functions impelmenting the ROOT::Math::IMultiGenFunction interface.; The available algorithms requiring derivatives (see also the GSL; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Algorithms-using-Derivatives.html"">documentation</A> ); are the followings:; <ul>; <li><tt>ROOT::Math::GSLMultiRootFinder::kHybridSJ</tt> with name <it>""HybridSJ""</it>: modified Powell's hybrid; method as implemented in HYBRJ in MINPACK; <li><tt>ROOT::Math::GSLMultiRootFinder::kHybridJ</tt> with name <it>""HybridJ""</it>: unscaled version of the; previous algorithm</li>; <li><tt>ROOT::Math::GSLMultiRootFinder::kNewton</tt> with name <it>""Newton""</it>: Newton method </li>; <li><tt>ROOT::Math::GSLMultiRootFinder::kGNewton</tt> with name <it>""GNewton""</it>: modified Newton method </li>; </ul>; The algorithms without derivatives (see also the GSL; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Algorithms-without-Derivatives.html"">documentation</A> ",MatchSource.WIKI,root/html530/ROOT__Math__GSLMultiRootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLMultiRootFinder.html
Deployability,configurat,configurations,"he number of sunctions set in the class.; The number must be equal to the dimension of the functions. { return fFunctions.size(); }. void Clear(); clear list of functions. const double * X() const; return the root X values solving the system. const double * FVal() const; return the function values f(X) solving the system; i.e. they must be close to zero at the solution. const double * Dx() const; return the last step size. bool Solve(const double* x, int maxIter = 0, double absTol = 0, double relTol = 0). Find the root starting from the point X;; Use the number of iteration and tolerance if given otherwise use; default parameter values which can be defined by; the static method SetDefault... int Iterations() const; Return number of iterations. int Status() const; Return the status of last root finding. { return fStatus; }. const char * Name() const; Return the algorithm name. void SetPrintLevel(int level). set print level; level = 0 quiet (no messages print); = 1 print only the result; = 3 max debug. Print result at each iteration. { fPrintLevel = level; }. int PrintLevel() const; return the print level. { return fPrintLevel; }. void SetDefaultTolerance(double abstol, double reltol = 0); -- static methods to set configurations; set tolerance (absolute and relative); relative tolerance is only use to verify the convergence; do it is a minor parameter. void SetDefaultMaxIterations(int maxiter); set maximum number of iterations. void PrintState(ostream& os = std::cout); print iteration state. std::pair<bool,int> GetType(const char* name); return type given a name. void ClearFunctions(); clear list of functions. » Author: L. Moneta 03/2011 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: GSLMultiRootFinder.h 38726 2011-04-04 14:05:51Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__GSLMultiRootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLMultiRootFinder.html
Integrability,interface,interface,". ROOT::Math::GSLMultiRootFinder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLMultiRootFinder. class ROOT::Math::GSLMultiRootFinder. Class for Multidimensional root finding algorithms bassed on GSL. This class is used to solve a; non-linear system of equations:. f1(x1,....xn) = 0; f2(x1,....xn) = 0; ..................; fn(x1,....xn) = 0. See the GSL <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Multidimensional-Root_002dFinding.html""> online manual</A> for; information on the GSL MultiRoot finding algorithms. The available GSL algorithms require the derivatives of the supplied functions or not (they are; computed internally by GSL). In the first case the user needs to provide a list of multidimensional functions implementing the; gradient interface (ROOT::Math::IMultiGradFunction) while in the second case it is enough to supply a list of; functions impelmenting the ROOT::Math::IMultiGenFunction interface.; The available algorithms requiring derivatives (see also the GSL; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Algorithms-using-Derivatives.html"">documentation</A> ); are the followings:; <ul>; <li><tt>ROOT::Math::GSLMultiRootFinder::kHybridSJ</tt> with name <it>""HybridSJ""</it>: modified Powell's hybrid; method as implemented in HYBRJ in MINPACK; <li><tt>ROOT::Math::GSLMultiRootFinder::kHybridJ</tt> with name <it>""HybridJ""</it>: unscaled version of the; previous algorithm</li>; <li><tt>ROOT::Math::GSLMultiRootFinder::kNewton</tt> with name <it>""Newton""</it>: Newton method </li>; <li><tt>ROOT::Math::GSLMultiRootFinder::kGNewton</tt> with name <it>""GNewton""</it>: modified Newton method </li>; </ul>; The algorithms without derivatives (see also the GSL; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Algorithms-without-Derivatives.html"">documentation</A> ",MatchSource.WIKI,root/html530/ROOT__Math__GSLMultiRootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLMultiRootFinder.html
Modifiability,config,configurations,"he number of sunctions set in the class.; The number must be equal to the dimension of the functions. { return fFunctions.size(); }. void Clear(); clear list of functions. const double * X() const; return the root X values solving the system. const double * FVal() const; return the function values f(X) solving the system; i.e. they must be close to zero at the solution. const double * Dx() const; return the last step size. bool Solve(const double* x, int maxIter = 0, double absTol = 0, double relTol = 0). Find the root starting from the point X;; Use the number of iteration and tolerance if given otherwise use; default parameter values which can be defined by; the static method SetDefault... int Iterations() const; Return number of iterations. int Status() const; Return the status of last root finding. { return fStatus; }. const char * Name() const; Return the algorithm name. void SetPrintLevel(int level). set print level; level = 0 quiet (no messages print); = 1 print only the result; = 3 max debug. Print result at each iteration. { fPrintLevel = level; }. int PrintLevel() const; return the print level. { return fPrintLevel; }. void SetDefaultTolerance(double abstol, double reltol = 0); -- static methods to set configurations; set tolerance (absolute and relative); relative tolerance is only use to verify the convergence; do it is a minor parameter. void SetDefaultMaxIterations(int maxiter); set maximum number of iterations. void PrintState(ostream& os = std::cout); print iteration state. std::pair<bool,int> GetType(const char* name); return type given a name. void ClearFunctions(); clear list of functions. » Author: L. Moneta 03/2011 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: GSLMultiRootFinder.h 38726 2011-04-04 14:05:51Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__GSLMultiRootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLMultiRootFinder.html
Usability,clear,clear,"oot_fsolver).; Default algorithm is ""hybrids"" (without derivative). virtual ~GSLMultiRootFinder(); destructor. GSLMultiRootFinder(const GSLMultiRootFinder &); usually copying is non trivial, so we make this unaccessible. void SetType(EType type); set the type for an algorithm without derivatives. void SetType(EDerivType type); set the type of algorithm using derivatives. void SetType(const char* name); set the type using a string. int AddFunction(const ROOT::Math::IMultiGenFunction& func). add (set) a single function fi(x1,...xn) which is part of the system of; specifying the begin and end of the iterator.; If using a derivative type algorithm the function must implement the; ROOOT::Math::IMultiGradFunction interface; Return the current number of function in the list and 0 if failed to add the function. unsigned int Dim() const. return the number of sunctions set in the class.; The number must be equal to the dimension of the functions. { return fFunctions.size(); }. void Clear(); clear list of functions. const double * X() const; return the root X values solving the system. const double * FVal() const; return the function values f(X) solving the system; i.e. they must be close to zero at the solution. const double * Dx() const; return the last step size. bool Solve(const double* x, int maxIter = 0, double absTol = 0, double relTol = 0). Find the root starting from the point X;; Use the number of iteration and tolerance if given otherwise use; default parameter values which can be defined by; the static method SetDefault... int Iterations() const; Return number of iterations. int Status() const; Return the status of last root finding. { return fStatus; }. const char * Name() const; Return the algorithm name. void SetPrintLevel(int level). set print level; level = 0 quiet (no messages print); = 1 print only the result; = 3 max debug. Print result at each iteration. { fPrintLevel = level; }. int PrintLevel() const; return the print level. { return fPrintLevel; }. void ",MatchSource.WIKI,root/html530/ROOT__Math__GSLMultiRootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLMultiRootFinder.html
Availability,error,errors,"n); virtual boolSetVariable(unsigned int ivar, const string& name, double val, double step); virtual boolSetVariableValue(unsigned int ivar, double val); virtual boolSetVariableValues(const double* x); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string&) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int) const; virtual const double*X() const. private:. ROOT::Math::GSLNLSMinimizerGSLNLSMinimizer(const ROOT::Math::GSLNLSMinimizer&); ROOT::Math::GSLNLSMinimizer&operator=(const ROOT::Math::GSLNLSMinimizer& rhs). Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; doubleROOT::Math::Minimizer::fPrecprecision; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. map<unsigned int,std::pair<double,double> >fBoundsmap specifying the bound using as key the parameter index; vector<double>fCovMatrixcov matrix (stored as cov[ i * dim + j] ; unsigned intfDimdimension of the function to be minimized ; doublefEdmedm value; vector<double>fErrors; ROOT::Math::GSLMultiFit*fGSLMultiFitpointer to GSL multi fit solver ; doublefLSToleranceLine Search Tolerance; doublefMinValminimum function value; unsigned intfNFreedimension of the internal function to be minimized ; vector<std::string>fNames; const ROOT::Math::FitMethodFunction*fObjFuncpointer to Least square function; vector<LSResidualFunc>fResiduals! transient Vector of the residual functions; unsigned in",MatchSource.WIKI,root/html530/ROOT__Math__GSLNLSMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLNLSMinimizer.html
Integrability,wrap,wraps,". ROOT::Math::GSLNLSMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLNLSMinimizer. class ROOT::Math::GSLNLSMinimizer: public ROOT::Math::Minimizer. LSResidualFunc class description.; Internal class used for accessing the residuals of the Least Square function; and their derivates which are estimated numerically using GSL numerical derivation.; The class contains a pointer to the fit method function and an index specifying; the i-th residual and wraps it in a multi-dim gradient function interface; ROOT::Math::IGradientFunctionMultiDim.; The class is used by ROOT::Math::GSLNLSMinimizer (GSL non linear least square fitter). @ingroup MultiMin. Function Members (Methods); public:. virtual~GSLNLSMinimizer(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int, unsigned int, unsigned int&, double*, double*); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int, unsigned int) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::GetCovMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int, double& errLow, double& errUp, int = 0); virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int) const; ROOT::Math::GSLNLSMinimizerGSLNLSMinimizer(int type = 0); virtual boolROOT::Math::Minimizer::Hesse(); boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); virtual doubleMinVa",MatchSource.WIKI,root/html530/ROOT__Math__GSLNLSMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLNLSMinimizer.html
Modifiability,variab,variables,"nt level; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; doubleROOT::Math::Minimizer::fPrecprecision; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. map<unsigned int,std::pair<double,double> >fBoundsmap specifying the bound using as key the parameter index; vector<double>fCovMatrixcov matrix (stored as cov[ i * dim + j] ; unsigned intfDimdimension of the function to be minimized ; doublefEdmedm value; vector<double>fErrors; ROOT::Math::GSLMultiFit*fGSLMultiFitpointer to GSL multi fit solver ; doublefLSToleranceLine Search Tolerance; doublefMinValminimum function value; unsigned intfNFreedimension of the internal function to be minimized ; vector<std::string>fNames; const ROOT::Math::FitMethodFunction*fObjFuncpointer to Least square function; vector<LSResidualFunc>fResiduals! transient Vector of the residual functions; unsigned intfSizenumber of fit points (residuals); vector<double>fSteps; vector<double>fValues; vector<ROOT::Math::EMinimVariableType>fVarTypesvector specifyng the type of variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; operator=(const ROOT::Math::GSLNLSMinimizer& rhs). unsigned int NDim() const; { return fChi2->NDim(); }. GSLNLSMinimizer(int type = 0). Default constructor. ~GSLNLSMinimizer(). Destructor (no operations). GSLNLSMinimizer(const ROOT::Math::GSLNLSMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiG",MatchSource.WIKI,root/html530/ROOT__Math__GSLNLSMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLNLSMinimizer.html
Performance,perform,perform,"ion to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set gradient the function to minimize. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limited variable. bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limited variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower, double upper); set upper/lower limited variable. bool SetFixedVariable(unsigned int ivar, const string& name, double val); set fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the value of an existing variable. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of existing parameters). bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. const double * X() const; return pointer to X values at the minimum. { return &fValues.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. { return (fObjFunc) ? fObjFunc->NCalls() : 0; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.size() > 0) ? &fErrors.front() : 0; }. double CovMatrix(unsigned int , unsigned int ) const; {; static std::vector<double> err;; err.resize(fDim);; return &err.front();; }; return covariance m",MatchSource.WIKI,root/html530/ROOT__Math__GSLNLSMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLNLSMinimizer.html
Security,access,accessing,". ROOT::Math::GSLNLSMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLNLSMinimizer. class ROOT::Math::GSLNLSMinimizer: public ROOT::Math::Minimizer. LSResidualFunc class description.; Internal class used for accessing the residuals of the Least Square function; and their derivates which are estimated numerically using GSL numerical derivation.; The class contains a pointer to the fit method function and an index specifying; the i-th residual and wraps it in a multi-dim gradient function interface; ROOT::Math::IGradientFunctionMultiDim.; The class is used by ROOT::Math::GSLNLSMinimizer (GSL non linear least square fitter). @ingroup MultiMin. Function Members (Methods); public:. virtual~GSLNLSMinimizer(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int, unsigned int, unsigned int&, double*, double*); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int, unsigned int) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::GetCovMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int, double& errLow, double& errUp, int = 0); virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int) const; ROOT::Math::GSLNLSMinimizerGSLNLSMinimizer(int type = 0); virtual boolROOT::Math::Minimizer::Hesse(); boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); virtual doubleMinVa",MatchSource.WIKI,root/html530/ROOT__Math__GSLNLSMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLNLSMinimizer.html
Availability,avail,available,". ROOT::Math::GSLRandomEngine. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLRandomEngine. class ROOT::Math::GSLRandomEngine. GSLRandomEngine; Base class for all GSL random engines,; normally user instantiate the derived classes; which creates internally the generator. The main GSL generators (see; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-number-generator-algorithms.html"">; here</A>) are available as derived classes; In addition to generate uniform numbers it provides method for; generating numbers according to pre-defined distributions; using the GSL functions from; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-Number-Distributions.html"">; GSL random number distributions</A>. @ingroup Random. Function Members (Methods); public:. virtual~GSLRandomEngine(); unsigned intBinomial(double p, unsigned int n) const; doubleCauchy(double a) const; doubleChiSquare(double nu) const; voidDir2D(double& x, double& y) const; voidDir3D(double& x, double& y, double& z) const; doubleExponential(double mu) const; doubleFDist(double nu1, double nu2) const; doubleGamma(double a, double b) const; doubleGaussian(double sigma) const; voidGaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y) const; doubleGaussianRatio(double sigma) const; doubleGaussianTail(double a, double sigma) const; doubleGaussianZig(double sigma) const; ROOT::Math::GSLRandomEngineGSLRandomEngine(); ROOT::Math::GSLRandomEngineGSLRandomEngine(ROOT::Math::GSLRngWrapper* rng); ROOT::Math::GSLRandomEngineGSLRandomEngine(const ROOT::Math::GSLRandomEngine&); voidInitialize(); doubleLandau() const; doubleLogNormal(double zeta, double sigma) const; vector<unsigned int>Multinomial(unsigned int ntot, const vector<double>& p) const; stringName() const; unsigned intNegativeBinomial(double p, ",MatchSource.WIKI,root/html530/ROOT__Math__GSLRandomEngine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLRandomEngine.html
Integrability,wrap,wrapper,"gma) const; doubleGaussianZig(double sigma) const; ROOT::Math::GSLRandomEngineGSLRandomEngine(); ROOT::Math::GSLRandomEngineGSLRandomEngine(ROOT::Math::GSLRngWrapper* rng); ROOT::Math::GSLRandomEngineGSLRandomEngine(const ROOT::Math::GSLRandomEngine&); voidInitialize(); doubleLandau() const; doubleLogNormal(double zeta, double sigma) const; vector<unsigned int>Multinomial(unsigned int ntot, const vector<double>& p) const; stringName() const; unsigned intNegativeBinomial(double p, double n) const; doubleoperator()() const; ROOT::Math::GSLRandomEngine&operator=(const ROOT::Math::GSLRandomEngine&); unsigned intPoisson(double mu) const; voidRandomArray(double* begin, double* end) const; unsigned intRndmInt(unsigned int max) const; voidSetSeed(unsigned int seed) const; unsigned intSize() const; doubletDist(double nu) const; voidTerminate(). protected:. voidSetType(ROOT::Math::GSLRngWrapper* r). Data Members; private:. unsigned intfCurTimecurrent time used to seed the generator; ROOT::Math::GSLRngWrapper*fRngpointer to GSL generator wrapper (managed by the class). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLRandomEngine(). default constructor. No creation of rng is done.; If then Initialize() is called an engine is created; based on default GSL type (MT). GSLRandomEngine( GSLRngWrapper * rng). create from an existing rng.; User manage the rng pointer which is then deleted olny by calling Terminate(). void Initialize(). initialize the generator; If no rng is present the default one based on Mersenne and Twister is created. void Terminate(). delete pointer to contained rng. virtual ~GSLRandomEngine(). call Terminate(). double operator()() const. Generate a random number between ]0,1]; 0 is excluded and 1 is included. unsigned int RndmInt(unsigned int max) const. Generate an integer number between [0,max-1] (including 0 and max-1); if max is larger than available range of algorithm; an error message is printed and zero is ret",MatchSource.WIKI,root/html530/ROOT__Math__GSLRandomEngine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLRandomEngine.html
Availability,avail,available,". ROOT::Math::GSLRngGFSR4. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLRngGFSR4. class ROOT::Math::GSLRngGFSR4: public ROOT::Math::GSLRandomEngine. GSLRandomEngine; Base class for all GSL random engines,; normally user instantiate the derived classes; which creates internally the generator. The main GSL generators (see; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-number-generator-algorithms.html"">; here</A>) are available as derived classes; In addition to generate uniform numbers it provides method for; generating numbers according to pre-defined distributions; using the GSL functions from; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-Number-Distributions.html"">; GSL random number distributions</A>. @ingroup Random. Function Members (Methods); public:. ~GSLRngGFSR4(); unsigned intROOT::Math::GSLRandomEngine::Binomial(double p, unsigned int n) const; doubleROOT::Math::GSLRandomEngine::Cauchy(double a) const; doubleROOT::Math::GSLRandomEngine::ChiSquare(double nu) const; voidROOT::Math::GSLRandomEngine::Dir2D(double& x, double& y) const; voidROOT::Math::GSLRandomEngine::Dir3D(double& x, double& y, double& z) const; doubleROOT::Math::GSLRandomEngine::Exponential(double mu) const; doubleROOT::Math::GSLRandomEngine::FDist(double nu1, double nu2) const; doubleROOT::Math::GSLRandomEngine::Gamma(double a, double b) const; doubleROOT::Math::GSLRandomEngine::Gaussian(double sigma) const; voidROOT::Math::GSLRandomEngine::Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y) const; doubleROOT::Math::GSLRandomEngine::GaussianRatio(double sigma) const; doubleROOT::Math::GSLRandomEngine::GaussianTail(double a, double sigma) const; doubleROOT::Math::GSLRandomEngine::GaussianZig(double sigma) const; ROOT::Math::GSLRandomEngineROOT::Math::GSLRa",MatchSource.WIKI,root/html530/ROOT__Math__GSLRngGFSR4.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLRngGFSR4.html
Availability,avail,available,". ROOT::Math::GSLRngMT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLRngMT. class ROOT::Math::GSLRngMT: public ROOT::Math::GSLRandomEngine. GSLRandomEngine; Base class for all GSL random engines,; normally user instantiate the derived classes; which creates internally the generator. The main GSL generators (see; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-number-generator-algorithms.html"">; here</A>) are available as derived classes; In addition to generate uniform numbers it provides method for; generating numbers according to pre-defined distributions; using the GSL functions from; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-Number-Distributions.html"">; GSL random number distributions</A>. @ingroup Random. Function Members (Methods); public:. ~GSLRngMT(); unsigned intROOT::Math::GSLRandomEngine::Binomial(double p, unsigned int n) const; doubleROOT::Math::GSLRandomEngine::Cauchy(double a) const; doubleROOT::Math::GSLRandomEngine::ChiSquare(double nu) const; voidROOT::Math::GSLRandomEngine::Dir2D(double& x, double& y) const; voidROOT::Math::GSLRandomEngine::Dir3D(double& x, double& y, double& z) const; doubleROOT::Math::GSLRandomEngine::Exponential(double mu) const; doubleROOT::Math::GSLRandomEngine::FDist(double nu1, double nu2) const; doubleROOT::Math::GSLRandomEngine::Gamma(double a, double b) const; doubleROOT::Math::GSLRandomEngine::Gaussian(double sigma) const; voidROOT::Math::GSLRandomEngine::Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y) const; doubleROOT::Math::GSLRandomEngine::GaussianRatio(double sigma) const; doubleROOT::Math::GSLRandomEngine::GaussianTail(double a, double sigma) const; doubleROOT::Math::GSLRandomEngine::GaussianZig(double sigma) const; ROOT::Math::GSLRandomEngineROOT::Math::GSLRandomEngine::",MatchSource.WIKI,root/html530/ROOT__Math__GSLRngMT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLRngMT.html
Availability,avail,available,". ROOT::Math::GSLRngRanLux. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLRngRanLux. class ROOT::Math::GSLRngRanLux: public ROOT::Math::GSLRandomEngine. GSLRandomEngine; Base class for all GSL random engines,; normally user instantiate the derived classes; which creates internally the generator. The main GSL generators (see; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-number-generator-algorithms.html"">; here</A>) are available as derived classes; In addition to generate uniform numbers it provides method for; generating numbers according to pre-defined distributions; using the GSL functions from; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-Number-Distributions.html"">; GSL random number distributions</A>. @ingroup Random. Function Members (Methods); public:. ~GSLRngRanLux(); unsigned intROOT::Math::GSLRandomEngine::Binomial(double p, unsigned int n) const; doubleROOT::Math::GSLRandomEngine::Cauchy(double a) const; doubleROOT::Math::GSLRandomEngine::ChiSquare(double nu) const; voidROOT::Math::GSLRandomEngine::Dir2D(double& x, double& y) const; voidROOT::Math::GSLRandomEngine::Dir3D(double& x, double& y, double& z) const; doubleROOT::Math::GSLRandomEngine::Exponential(double mu) const; doubleROOT::Math::GSLRandomEngine::FDist(double nu1, double nu2) const; doubleROOT::Math::GSLRandomEngine::Gamma(double a, double b) const; doubleROOT::Math::GSLRandomEngine::Gaussian(double sigma) const; voidROOT::Math::GSLRandomEngine::Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y) const; doubleROOT::Math::GSLRandomEngine::GaussianRatio(double sigma) const; doubleROOT::Math::GSLRandomEngine::GaussianTail(double a, double sigma) const; doubleROOT::Math::GSLRandomEngine::GaussianZig(double sigma) const; ROOT::Math::GSLRandomEngineROOT::Math::G",MatchSource.WIKI,root/html530/ROOT__Math__GSLRngRanLux.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLRngRanLux.html
Availability,avail,available,". ROOT::Math::GSLRngRanLuxD1. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLRngRanLuxD1. class ROOT::Math::GSLRngRanLuxD1: public ROOT::Math::GSLRandomEngine. GSLRandomEngine; Base class for all GSL random engines,; normally user instantiate the derived classes; which creates internally the generator. The main GSL generators (see; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-number-generator-algorithms.html"">; here</A>) are available as derived classes; In addition to generate uniform numbers it provides method for; generating numbers according to pre-defined distributions; using the GSL functions from; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-Number-Distributions.html"">; GSL random number distributions</A>. @ingroup Random. Function Members (Methods); public:. ~GSLRngRanLuxD1(); unsigned intROOT::Math::GSLRandomEngine::Binomial(double p, unsigned int n) const; doubleROOT::Math::GSLRandomEngine::Cauchy(double a) const; doubleROOT::Math::GSLRandomEngine::ChiSquare(double nu) const; voidROOT::Math::GSLRandomEngine::Dir2D(double& x, double& y) const; voidROOT::Math::GSLRandomEngine::Dir3D(double& x, double& y, double& z) const; doubleROOT::Math::GSLRandomEngine::Exponential(double mu) const; doubleROOT::Math::GSLRandomEngine::FDist(double nu1, double nu2) const; doubleROOT::Math::GSLRandomEngine::Gamma(double a, double b) const; doubleROOT::Math::GSLRandomEngine::Gaussian(double sigma) const; voidROOT::Math::GSLRandomEngine::Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y) const; doubleROOT::Math::GSLRandomEngine::GaussianRatio(double sigma) const; doubleROOT::Math::GSLRandomEngine::GaussianTail(double a, double sigma) const; doubleROOT::Math::GSLRandomEngine::GaussianZig(double sigma) const; ROOT::Math::GSLRandomEngineROOT:",MatchSource.WIKI,root/html530/ROOT__Math__GSLRngRanLuxD1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLRngRanLuxD1.html
Availability,avail,available,". ROOT::Math::GSLRngRanLuxD2. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLRngRanLuxD2. class ROOT::Math::GSLRngRanLuxD2: public ROOT::Math::GSLRandomEngine. GSLRandomEngine; Base class for all GSL random engines,; normally user instantiate the derived classes; which creates internally the generator. The main GSL generators (see; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-number-generator-algorithms.html"">; here</A>) are available as derived classes; In addition to generate uniform numbers it provides method for; generating numbers according to pre-defined distributions; using the GSL functions from; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-Number-Distributions.html"">; GSL random number distributions</A>. @ingroup Random. This class is also known as (typedefs to this class)ROOT::Math::GSLRngRanLux48. Function Members (Methods); public:. ~GSLRngRanLuxD2(); unsigned intROOT::Math::GSLRandomEngine::Binomial(double p, unsigned int n) const; doubleROOT::Math::GSLRandomEngine::Cauchy(double a) const; doubleROOT::Math::GSLRandomEngine::ChiSquare(double nu) const; voidROOT::Math::GSLRandomEngine::Dir2D(double& x, double& y) const; voidROOT::Math::GSLRandomEngine::Dir3D(double& x, double& y, double& z) const; doubleROOT::Math::GSLRandomEngine::Exponential(double mu) const; doubleROOT::Math::GSLRandomEngine::FDist(double nu1, double nu2) const; doubleROOT::Math::GSLRandomEngine::Gamma(double a, double b) const; doubleROOT::Math::GSLRandomEngine::Gaussian(double sigma) const; voidROOT::Math::GSLRandomEngine::Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y) const; doubleROOT::Math::GSLRandomEngine::GaussianRatio(double sigma) const; doubleROOT::Math::GSLRandomEngine::GaussianTail(double a, double sigma) const; doubleROOT::Math::GS",MatchSource.WIKI,root/html530/ROOT__Math__GSLRngRanLuxD2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLRngRanLuxD2.html
Availability,avail,available,". ROOT::Math::GSLRngRanLuxS1. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLRngRanLuxS1. class ROOT::Math::GSLRngRanLuxS1: public ROOT::Math::GSLRandomEngine. GSLRandomEngine; Base class for all GSL random engines,; normally user instantiate the derived classes; which creates internally the generator. The main GSL generators (see; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-number-generator-algorithms.html"">; here</A>) are available as derived classes; In addition to generate uniform numbers it provides method for; generating numbers according to pre-defined distributions; using the GSL functions from; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-Number-Distributions.html"">; GSL random number distributions</A>. @ingroup Random. This class is also known as (typedefs to this class)ROOT::Math::GSLRngRanLux1. Function Members (Methods); public:. ~GSLRngRanLuxS1(); unsigned intROOT::Math::GSLRandomEngine::Binomial(double p, unsigned int n) const; doubleROOT::Math::GSLRandomEngine::Cauchy(double a) const; doubleROOT::Math::GSLRandomEngine::ChiSquare(double nu) const; voidROOT::Math::GSLRandomEngine::Dir2D(double& x, double& y) const; voidROOT::Math::GSLRandomEngine::Dir3D(double& x, double& y, double& z) const; doubleROOT::Math::GSLRandomEngine::Exponential(double mu) const; doubleROOT::Math::GSLRandomEngine::FDist(double nu1, double nu2) const; doubleROOT::Math::GSLRandomEngine::Gamma(double a, double b) const; doubleROOT::Math::GSLRandomEngine::Gaussian(double sigma) const; voidROOT::Math::GSLRandomEngine::Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y) const; doubleROOT::Math::GSLRandomEngine::GaussianRatio(double sigma) const; doubleROOT::Math::GSLRandomEngine::GaussianTail(double a, double sigma) const; doubleROOT::Math::GSL",MatchSource.WIKI,root/html530/ROOT__Math__GSLRngRanLuxS1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLRngRanLuxS1.html
Availability,avail,available,". ROOT::Math::GSLRngRanLuxS2. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLRngRanLuxS2. class ROOT::Math::GSLRngRanLuxS2: public ROOT::Math::GSLRandomEngine. GSLRandomEngine; Base class for all GSL random engines,; normally user instantiate the derived classes; which creates internally the generator. The main GSL generators (see; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-number-generator-algorithms.html"">; here</A>) are available as derived classes; In addition to generate uniform numbers it provides method for; generating numbers according to pre-defined distributions; using the GSL functions from; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-Number-Distributions.html"">; GSL random number distributions</A>. @ingroup Random. This class is also known as (typedefs to this class)ROOT::Math::GSLRngRanLux2. Function Members (Methods); public:. ~GSLRngRanLuxS2(); unsigned intROOT::Math::GSLRandomEngine::Binomial(double p, unsigned int n) const; doubleROOT::Math::GSLRandomEngine::Cauchy(double a) const; doubleROOT::Math::GSLRandomEngine::ChiSquare(double nu) const; voidROOT::Math::GSLRandomEngine::Dir2D(double& x, double& y) const; voidROOT::Math::GSLRandomEngine::Dir3D(double& x, double& y, double& z) const; doubleROOT::Math::GSLRandomEngine::Exponential(double mu) const; doubleROOT::Math::GSLRandomEngine::FDist(double nu1, double nu2) const; doubleROOT::Math::GSLRandomEngine::Gamma(double a, double b) const; doubleROOT::Math::GSLRandomEngine::Gaussian(double sigma) const; voidROOT::Math::GSLRandomEngine::Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y) const; doubleROOT::Math::GSLRandomEngine::GaussianRatio(double sigma) const; doubleROOT::Math::GSLRandomEngine::GaussianTail(double a, double sigma) const; doubleROOT::Math::GSL",MatchSource.WIKI,root/html530/ROOT__Math__GSLRngRanLuxS2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLRngRanLuxS2.html
Availability,avail,available,". ROOT::Math::GSLRngTaus. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLRngTaus. class ROOT::Math::GSLRngTaus: public ROOT::Math::GSLRandomEngine. GSLRandomEngine; Base class for all GSL random engines,; normally user instantiate the derived classes; which creates internally the generator. The main GSL generators (see; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-number-generator-algorithms.html"">; here</A>) are available as derived classes; In addition to generate uniform numbers it provides method for; generating numbers according to pre-defined distributions; using the GSL functions from; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-Number-Distributions.html"">; GSL random number distributions</A>. @ingroup Random. Function Members (Methods); public:. ~GSLRngTaus(); unsigned intROOT::Math::GSLRandomEngine::Binomial(double p, unsigned int n) const; doubleROOT::Math::GSLRandomEngine::Cauchy(double a) const; doubleROOT::Math::GSLRandomEngine::ChiSquare(double nu) const; voidROOT::Math::GSLRandomEngine::Dir2D(double& x, double& y) const; voidROOT::Math::GSLRandomEngine::Dir3D(double& x, double& y, double& z) const; doubleROOT::Math::GSLRandomEngine::Exponential(double mu) const; doubleROOT::Math::GSLRandomEngine::FDist(double nu1, double nu2) const; doubleROOT::Math::GSLRandomEngine::Gamma(double a, double b) const; doubleROOT::Math::GSLRandomEngine::Gaussian(double sigma) const; voidROOT::Math::GSLRandomEngine::Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y) const; doubleROOT::Math::GSLRandomEngine::GaussianRatio(double sigma) const; doubleROOT::Math::GSLRandomEngine::GaussianTail(double a, double sigma) const; doubleROOT::Math::GSLRandomEngine::GaussianZig(double sigma) const; ROOT::Math::GSLRandomEngineROOT::Math::GSLRandom",MatchSource.WIKI,root/html530/ROOT__Math__GSLRngTaus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLRngTaus.html
Availability,error,error,"on& f, double xlow, double xup); boolSetFunction(ROOT::Math::GSLRootFinder::GSLFuncPointer f, void* params, double xlow, double xup); virtual boolSolve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); virtual intStatus() const. protected:. voidFreeSolver(); voidSetSolver(ROOT::Math::GSLRootFSolver* s). private:. ROOT::Math::GSLRootFinderGSLRootFinder(const ROOT::Math::GSLRootFinder&); ROOT::Math::GSLRootFinder&operator=(const ROOT::Math::GSLRootFinder&). Data Members; private:. ROOT::Math::GSLFunctionWrapper*fFunction; intfIter; doublefRoot; ROOT::Math::GSLRootFSolver*fS; intfStatus; boolfValidInterval; doublefXlow; doublefXup. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLRootFinder(). virtual ~GSLRootFinder(). GSLRootFinder(const ROOT::Math::GSLRootFinder& ); usually copying is non trivial, so we make this unaccessible. bool SetFunction(const ROOT::Math::IGradFunction& , double ). bool SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). bool SetFunction(ROOT::Math::GSLRootFinder::GSLFuncPointer f, void* params, double xlow, double xup). int Iterate(); iterate to find ROOTS return GSL_CONTINUE if iteration was succesfull or another error. double Root() const. bool Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); double XLower() const;; double XUpper() const;; Find the root. int Iterations() const; Return number of iterations. int Status() const; Return the status of last root finding. { return fStatus; }. const char * Name() const. void SetSolver(ROOT::Math::GSLRootFSolver* s). void FreeSolver(). » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: GSLRootFinder.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__GSLRootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLRootFinder.html
Deployability,configurat,configuration,". derived classes might need to re-define completly the class. {}. virtual ~GSLSimAnFunc(); virtual distructor (no operations). { }. GSLSimAnFunc & FastCopy(const ROOT::Math::GSLSimAnFunc& f). fast copy method called by GSL simuated annealing internally; copy only the things which have been changed; must be re-implemented by derived classes if needed. GSLSimAnFunc * Clone() const. clone method. Needs to be re-implemented by the derived classes for deep copying. return new GSLSimAnFunc(const ROOT::Math::GSLSimAnFunc& ). double Energy() const. evaluate the energy ( objective function value); re-implement by derived classes if needed to be modified. void Step(const ROOT::Math::GSLRandomEngine& r, double maxstep). change the x[i] value using a random value urndm generated between [0,1]; up to a maximum value maxstep; re-implement by derived classes if needed to be modified. double Distance(const ROOT::Math::GSLSimAnFunc& func) const. calculate the distance (metric) between this one and another configuration; Presently a cartesian metric is used.; re-implement by derived classes if needed to be modified. void Print(). print the position in the standard output ostream; GSL prints in addition n iteration, n function calls, temperature and energy; re-implement by derived classes if necessary. void SetX(const double* x). change the x values (used by sim annealing to take a step). void SetX(unsigned int i, double x). unsigned int NDim() const; { return fX.size(); }. double X(unsigned int i) const; { return fX[i]; }. const std::vector<double> & X() const; { return fX; }. double Scale(unsigned int i) const; { return fScale[i]; }. » Author: L. Moneta Thu Jan 25 11:13:48 2007 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: GSLSimAnnealing.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please se",MatchSource.WIKI,root/html530/ROOT__Math__GSLSimAnFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLSimAnFunc.html
Energy Efficiency,energy,energy,"nst double* x). construct from an interface of a multi-dimensional function. GSLSimAnFunc(const ROOT::Math::IMultiGenFunction& func, const double* x, const double* scale). construct from an interface of a multi-dimensional function; Use optionally a scale factor (for each coordinate) which can be used to scale the step sizes; (this is used for example by the minimization algorithm). GSLSimAnFunc(). derived classes might need to re-define completly the class. {}. virtual ~GSLSimAnFunc(); virtual distructor (no operations). { }. GSLSimAnFunc & FastCopy(const ROOT::Math::GSLSimAnFunc& f). fast copy method called by GSL simuated annealing internally; copy only the things which have been changed; must be re-implemented by derived classes if needed. GSLSimAnFunc * Clone() const. clone method. Needs to be re-implemented by the derived classes for deep copying. return new GSLSimAnFunc(const ROOT::Math::GSLSimAnFunc& ). double Energy() const. evaluate the energy ( objective function value); re-implement by derived classes if needed to be modified. void Step(const ROOT::Math::GSLRandomEngine& r, double maxstep). change the x[i] value using a random value urndm generated between [0,1]; up to a maximum value maxstep; re-implement by derived classes if needed to be modified. double Distance(const ROOT::Math::GSLSimAnFunc& func) const. calculate the distance (metric) between this one and another configuration; Presently a cartesian metric is used.; re-implement by derived classes if needed to be modified. void Print(). print the position in the standard output ostream; GSL prints in addition n iteration, n function calls, temperature and energy; re-implement by derived classes if necessary. void SetX(const double* x). change the x values (used by sim annealing to take a step). void SetX(unsigned int i, double x). unsigned int NDim() const; { return fX.size(); }. double X(unsigned int i) const; { return fX[i]; }. const std::vector<double> & X() const; { return fX; }. double Scale(u",MatchSource.WIKI,root/html530/ROOT__Math__GSLSimAnFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLSimAnFunc.html
Integrability,interface,interface," virtual ROOT::Math::GSLSimAnFunc&FastCopy(const ROOT::Math::GSLSimAnFunc& f); ROOT::Math::GSLSimAnFuncGSLSimAnFunc(const ROOT::Math::GSLSimAnFunc&); ROOT::Math::GSLSimAnFuncGSLSimAnFunc(const ROOT::Math::IMultiGenFunction& func, const double* x); ROOT::Math::GSLSimAnFuncGSLSimAnFunc(const ROOT::Math::IMultiGenFunction& func, const double* x, const double* scale); unsigned intNDim() const; virtual voidPrint(); doubleScale(unsigned int i) const; voidSetX(const double* x); voidSetX(unsigned int i, double x); virtual voidStep(const ROOT::Math::GSLRandomEngine& r, double maxstep); const vector<double>&X() const; doubleX(unsigned int i) const. protected:. ROOT::Math::GSLSimAnFuncGSLSimAnFunc(). Data Members; private:. const ROOT::Math::IMultiGenFunction*fFunc; vector<double>fScale; vector<double>fX. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLSimAnFunc(const ROOT::Math::IMultiGenFunction& func, const double* x). construct from an interface of a multi-dimensional function. GSLSimAnFunc(const ROOT::Math::IMultiGenFunction& func, const double* x, const double* scale). construct from an interface of a multi-dimensional function; Use optionally a scale factor (for each coordinate) which can be used to scale the step sizes; (this is used for example by the minimization algorithm). GSLSimAnFunc(). derived classes might need to re-define completly the class. {}. virtual ~GSLSimAnFunc(); virtual distructor (no operations). { }. GSLSimAnFunc & FastCopy(const ROOT::Math::GSLSimAnFunc& f). fast copy method called by GSL simuated annealing internally; copy only the things which have been changed; must be re-implemented by derived classes if needed. GSLSimAnFunc * Clone() const. clone method. Needs to be re-implemented by the derived classes for deep copying. return new GSLSimAnFunc(const ROOT::Math::GSLSimAnFunc& ). double Energy() const. evaluate the energy ( objective function value); re-implement by derived classes if needed to be m",MatchSource.WIKI,root/html530/ROOT__Math__GSLSimAnFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLSimAnFunc.html
Modifiability,config,configuration,". derived classes might need to re-define completly the class. {}. virtual ~GSLSimAnFunc(); virtual distructor (no operations). { }. GSLSimAnFunc & FastCopy(const ROOT::Math::GSLSimAnFunc& f). fast copy method called by GSL simuated annealing internally; copy only the things which have been changed; must be re-implemented by derived classes if needed. GSLSimAnFunc * Clone() const. clone method. Needs to be re-implemented by the derived classes for deep copying. return new GSLSimAnFunc(const ROOT::Math::GSLSimAnFunc& ). double Energy() const. evaluate the energy ( objective function value); re-implement by derived classes if needed to be modified. void Step(const ROOT::Math::GSLRandomEngine& r, double maxstep). change the x[i] value using a random value urndm generated between [0,1]; up to a maximum value maxstep; re-implement by derived classes if needed to be modified. double Distance(const ROOT::Math::GSLSimAnFunc& func) const. calculate the distance (metric) between this one and another configuration; Presently a cartesian metric is used.; re-implement by derived classes if needed to be modified. void Print(). print the position in the standard output ostream; GSL prints in addition n iteration, n function calls, temperature and energy; re-implement by derived classes if necessary. void SetX(const double* x). change the x values (used by sim annealing to take a step). void SetX(unsigned int i, double x). unsigned int NDim() const; { return fX.size(); }. double X(unsigned int i) const; { return fX[i]; }. const std::vector<double> & X() const; { return fX; }. double Scale(unsigned int i) const; { return fScale[i]; }. » Author: L. Moneta Thu Jan 25 11:13:48 2007 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: GSLSimAnnealing.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please se",MatchSource.WIKI,root/html530/ROOT__Math__GSLSimAnFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLSimAnFunc.html
Availability,error,errors,"l boolSetVariable(unsigned int ivar, const string& name, double val, double step); virtual boolSetVariableValue(unsigned int ivar, double val); virtual boolSetVariableValues(const double* x); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string&) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int) const; virtual const double*X() const. private:. ROOT::Math::GSLSimAnMinimizerGSLSimAnMinimizer(const ROOT::Math::GSLSimAnMinimizer&); ROOT::Math::GSLSimAnMinimizer&operator=(const ROOT::Math::GSLSimAnMinimizer& rhs). Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; doubleROOT::Math::Minimizer::fPrecprecision; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. map<unsigned int,std::pair<double,double> >fBoundsmap specifying the bound using as key the parameter index; unsigned intfDimdimension of the function to be minimized ; doublefMinValminimum values ; vector<std::string>fNames; const ROOT::Math::IMultiGenFunction*fObjFunc; boolfOwnFuncflag to indicate if objective function is managed ; ROOT::Math::GSLSimAnnealingfSolver; vector<double>fSteps; vector<double>fValues; vector<ROOT::Math::EMinimVariableType>fVarTypesvector specifyng the type of variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLSimAnMinimizer(int type = 0). Default constructor. ~GSLSimAnMinimizer(). Destructor (no operat",MatchSource.WIKI,root/html530/ROOT__Math__GSLSimAnMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLSimAnMinimizer.html
Integrability,interface,interface,". ROOT::Math::GSLSimAnMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLSimAnMinimizer. class ROOT::Math::GSLSimAnMinimizer: public ROOT::Math::Minimizer. GSLSimAnMinimizer class for minimization using simulated annealing; using the algorithm from; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Simulated-Annealing.html"">; GSL</A>.; It implements the ROOT::Minimizer interface and; a plug-in (name ""GSLSimAn"") exists to instantiate this class via the plug-in manager. @ingroup MultiMin. Function Members (Methods); public:. virtual~GSLSimAnMinimizer(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int, unsigned int, unsigned int&, double*, double*); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int, unsigned int) const; virtual intROOT::Math::Minimizer::CovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::GetCovMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int, double& errLow, double& errUp, int = 0); virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int) const; ROOT::Math::GSLSimAnMinimizerGSLSimAnMinimizer(int type = 0); virtual boolROOT::Math::Minimizer::Hesse(); boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); virtual doubleMinValue() const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNFree() const; vir",MatchSource.WIKI,root/html530/ROOT__Math__GSLSimAnMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLSimAnMinimizer.html
Modifiability,plug-in,plug-in,". ROOT::Math::GSLSimAnMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLSimAnMinimizer. class ROOT::Math::GSLSimAnMinimizer: public ROOT::Math::Minimizer. GSLSimAnMinimizer class for minimization using simulated annealing; using the algorithm from; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Simulated-Annealing.html"">; GSL</A>.; It implements the ROOT::Minimizer interface and; a plug-in (name ""GSLSimAn"") exists to instantiate this class via the plug-in manager. @ingroup MultiMin. Function Members (Methods); public:. virtual~GSLSimAnMinimizer(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int, unsigned int, unsigned int&, double*, double*); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int, unsigned int) const; virtual intROOT::Math::Minimizer::CovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::GetCovMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int, double& errLow, double& errUp, int = 0); virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int) const; ROOT::Math::GSLSimAnMinimizerGSLSimAnMinimizer(int type = 0); virtual boolROOT::Math::Minimizer::Hesse(); boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); virtual doubleMinValue() const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNFree() const; vir",MatchSource.WIKI,root/html530/ROOT__Math__GSLSimAnMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLSimAnMinimizer.html
Performance,perform,perform,"unsigned int ivar, const string& name, double val, double step); set free variable. bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set upper/lower limited variable (override if minimizer supports them ). bool SetVariableValue(unsigned int ivar, double val); set the value of an existing variable. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of the existing parameters). bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. const double * X() const; return pointer to X values at the minimum. { return &fValues.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fDim; }. bool ProvidesError() const; minimizer provides error and error matrix. { return false; }. const double * Errors() const; return errors at the minimum. { return 0; }. double CovMatrix(unsigned int , unsigned int ) const; return covariance mat",MatchSource.WIKI,root/html530/ROOT__Math__GSLSimAnMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLSimAnMinimizer.html
Security,validat,validated,"l boolSetVariable(unsigned int ivar, const string& name, double val, double step); virtual boolSetVariableValue(unsigned int ivar, double val); virtual boolSetVariableValues(const double* x); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string&) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int) const; virtual const double*X() const. private:. ROOT::Math::GSLSimAnMinimizerGSLSimAnMinimizer(const ROOT::Math::GSLSimAnMinimizer&); ROOT::Math::GSLSimAnMinimizer&operator=(const ROOT::Math::GSLSimAnMinimizer& rhs). Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; doubleROOT::Math::Minimizer::fPrecprecision; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. map<unsigned int,std::pair<double,double> >fBoundsmap specifying the bound using as key the parameter index; unsigned intfDimdimension of the function to be minimized ; doublefMinValminimum values ; vector<std::string>fNames; const ROOT::Math::IMultiGenFunction*fObjFunc; boolfOwnFuncflag to indicate if objective function is managed ; ROOT::Math::GSLSimAnnealingfSolver; vector<double>fSteps; vector<double>fValues; vector<ROOT::Math::EMinimVariableType>fVarTypesvector specifyng the type of variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLSimAnMinimizer(int type = 0). Default constructor. ~GSLSimAnMinimizer(). Destructor (no operat",MatchSource.WIKI,root/html530/ROOT__Math__GSLSimAnMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLSimAnMinimizer.html
Availability,avail,available,"ROOT::Fit::Fitter::BaseFunc, ROOT::Math::IBaseFunctionMultiDim::BaseFunc, ROOT::Math::IMultiGenFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction, ROOT::Math::IGradientFunctionMultiDim::BaseFunc, ROOT::Math::Functor::Impl, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction, ROOT::Math::WrappedMultiTF1::BaseFunc, ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction, ROOT::Math::IParametricFunctionMultiDim::BaseFunc, ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction, ROOT::Math::IParametricGradFunctionMultiDim::BaseFunc, ROOT::Math::GradFunctor::ImplBase, ROOT::Math::Functor::ImplBase. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IBaseFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*Clone() const; virtual unsigned intNDim() const; doubleoperator()(const double* x) const; ROOT::Math::IBaseFunctionMultiDim&operator=(const ROOT::Math::IBaseFunctionMultiDim&). private:. virtual doubleDoEval(const double* x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseFunctionMultiDim(). virtual destructor. {}. IBaseFunctionMultiDim * Clone() const. Clone a function.; Each derived class must implement his version of the Clone method. unsigned int NDim() const. Retrieve the dimension of the function. double operator()(const double* x) const. Evaluate the function at a point x[].; Use the pure virtual private method DoEval which must be implemented by the sub-classes. return DoEval(x). » Last changed: root/mathcore:$Id: IFunction.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2011-07-04 15:19; This",MatchSource.WIKI,root/html530/ROOT__Math__IBaseFunctionMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IBaseFunctionMultiDim.html
Integrability,interface,interface,". ROOT::Math::IBaseFunctionMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IBaseFunctionMultiDim. class ROOT::Math::IBaseFunctionMultiDim. Documentation for the abstract class IBaseFunctionMultiDim.; Interface (abstract class) for generic functions objects of multi-dimension; Provides a method to evaluate the function given a vector of coordinate values,; by implementing operator() (const double *).; In addition it defines the interface for copying functions via the pure virtual method Clone(); and the interface for getting the function dimension via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction, ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction, ROOT::Fit::Fitter::BaseFunc, ROOT::Math::IBaseFunctionMultiDim::BaseFunc, ROOT::Math::IMultiGenFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction, ROOT::Math::IGradientFunctionMultiDim::BaseFunc, ROOT::Math::Functor::Impl, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction, ROOT::Math::WrappedMultiTF1::BaseFunc, ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction, ROOT::Math::IParametricFunctionMultiDim::BaseFunc, ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction, ROOT::Math::IParametricGradFunctionMultiDim::BaseFunc, ROOT::Math::GradFunctor::ImplBase, ROOT::Math::Fu",MatchSource.WIKI,root/html530/ROOT__Math__IBaseFunctionMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IBaseFunctionMultiDim.html
Availability,avail,available,"s,; by implementing operator() (const double *).; In addition it defines the interface for copying functions via the pure virtual method Clone(); and the interface for getting the function dimension via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::WrappedTF1::BaseFunc, ROOT::Math::IGradientFunctionOneDim::BaseFunc, ROOT::Math::Functor1D::Impl, ROOT::Math::Functor1D::ImplBase, ROOT::Math::IParametricFunctionOneDim::BaseFunc, ROOT::Math::IGenFunction, ROOT::Math::IBaseFunctionOneDim::BaseFunc, ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>::BaseFunc, ROOT::Math::IParametricGradFunctionOneDim::BaseFunc, ROOT::Math::GradFunctor1D::ImplBase. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IBaseFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*Clone() const; doubleoperator()(double x) const; doubleoperator()(const double* x) const; ROOT::Math::IBaseFunctionOneDim&operator=(const ROOT::Math::IBaseFunctionOneDim&). private:. virtual doubleDoEval(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IBaseFunctionMultiDim * Clone() const. Clone a function.; Each derived class must implement his version of the Clone method. double operator()(const double* x) const. Evaluate the function at a point x[].; Use the pure virtual private method DoEval which must be implemented by the sub-classes. return DoEval(x). double operator()(double x) const. Template method to eveluate the function using the begin of an iterator; User is responsible to provide correct size for the iterator. virtual ~IBaseFunctionOneDim(). virtual destructor. {}. » Last changed: root/mathcore:$Id: IF",MatchSource.WIKI,root/html530/ROOT__Math__IBaseFunctionOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IBaseFunctionOneDim.html
Integrability,interface,interface,". ROOT::Math::IBaseFunctionOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IBaseFunctionOneDim. class ROOT::Math::IBaseFunctionOneDim. Documentation for the abstract class IBaseFunctionMultiDim.; Interface (abstract class) for generic functions objects of multi-dimension; Provides a method to evaluate the function given a vector of coordinate values,; by implementing operator() (const double *).; In addition it defines the interface for copying functions via the pure virtual method Clone(); and the interface for getting the function dimension via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::WrappedTF1::BaseFunc, ROOT::Math::IGradientFunctionOneDim::BaseFunc, ROOT::Math::Functor1D::Impl, ROOT::Math::Functor1D::ImplBase, ROOT::Math::IParametricFunctionOneDim::BaseFunc, ROOT::Math::IGenFunction, ROOT::Math::IBaseFunctionOneDim::BaseFunc, ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>::BaseFunc, ROOT::Math::IParametricGradFunctionOneDim::BaseFunc, ROOT::Math::GradFunctor1D::ImplBase. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IBaseFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*Clone() const; doubleoperator()(double x) const; doubleoperator()(const double* x) const; ROOT::Math::IBaseFunctionOneDim&operator=(const ROOT::Math::IBaseFunctionOneDim&). private:. virtual doubleDoEval(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IBaseFunctionMultiDim * Clone() const. Clon",MatchSource.WIKI,root/html530/ROOT__Math__IBaseFunctionOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IBaseFunctionOneDim.html
Availability,avail,available,". ROOT::Math::IBaseParam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IBaseParam. class ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IBaseParam(); virtual unsigned intNPar() const; ROOT::Math::IBaseParam&operator=(const ROOT::Math::IBaseParam&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseParam(). Virtual Destructor (no operations). {}. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. to be defined: can user change number of params ? At the moment no. unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggest",MatchSource.WIKI,root/html530/ROOT__Math__IBaseParam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IBaseParam.html
Integrability,interface,interface,". ROOT::Math::IBaseParam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IBaseParam. class ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IBaseParam(); virtual unsigned intNPar() const; ROOT::Math::IBaseParam&operator=(const ROOT::Math::IBaseParam&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseParam(). Virtual Destructor (no operations). {}. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. to be defined: can user change number of params ? At the moment no. unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggest",MatchSource.WIKI,root/html530/ROOT__Math__IBaseParam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IBaseParam.html
Safety,avoid,avoid,". ROOT::Math::IBaseParam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IBaseParam. class ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IBaseParam(); virtual unsigned intNPar() const; ROOT::Math::IBaseParam&operator=(const ROOT::Math::IBaseParam&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseParam(). Virtual Destructor (no operations). {}. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. to be defined: can user change number of params ? At the moment no. unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggest",MatchSource.WIKI,root/html530/ROOT__Math__IBaseParam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IBaseParam.html
Availability,avail,available,"IBaseFunctionMultiDim, public ROOT::Math::IGradientMultiDim. Documentation for the abstract class IBaseFunctionMultiDim.; Interface (abstract class) for generic functions objects of multi-dimension; Provides a method to evaluate the function given a vector of coordinate values,; by implementing operator() (const double *).; In addition it defines the interface for copying functions via the pure virtual method Clone(); and the interface for getting the function dimension via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IParametricGradFunctionMultiDim::BaseGradFunc, ROOT::Fit::Fitter::BaseGradFunc, ROOT::Math::IMultiGradFunction, ROOT::Math::GradFunctor::Impl. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionMultiDim&operator=(const ROOT::Math::IGradientFunctionMultiDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. void FdF(const double* x, double& f, double* df) const. Optimized ",MatchSource.WIKI,root/html530/ROOT__Math__IGradientFunctionMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IGradientFunctionMultiDim.html
Energy Efficiency,efficient,efficient,"fs to this class)ROOT::Math::IParametricGradFunctionMultiDim::BaseGradFunc, ROOT::Fit::Fitter::BaseGradFunc, ROOT::Math::IMultiGradFunction, ROOT::Math::GradFunctor::Impl. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionMultiDim&operator=(const ROOT::Math::IGradientFunctionMultiDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientFunctionMultiDim(). Virtual Destructor (no operations). {}. » Last changed: root/mathcore:$Id: IFunction.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__IGradientFunctionMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IGradientFunctionMultiDim.html
Integrability,interface,interface,". ROOT::Math::IGradientFunctionMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IGradientFunctionMultiDim. class ROOT::Math::IGradientFunctionMultiDim: public ROOT::Math::IBaseFunctionMultiDim, public ROOT::Math::IGradientMultiDim. Documentation for the abstract class IBaseFunctionMultiDim.; Interface (abstract class) for generic functions objects of multi-dimension; Provides a method to evaluate the function given a vector of coordinate values,; by implementing operator() (const double *).; In addition it defines the interface for copying functions via the pure virtual method Clone(); and the interface for getting the function dimension via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IParametricGradFunctionMultiDim::BaseGradFunc, ROOT::Fit::Fitter::BaseGradFunc, ROOT::Math::IMultiGradFunction, ROOT::Math::GradFunctor::Impl. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionMultiDim&operator=(const ROOT::Math::IGradientFunctionMultiDim&). Class Charts. In",MatchSource.WIKI,root/html530/ROOT__Math__IGradientFunctionMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IGradientFunctionMultiDim.html
Performance,perform,performances,"fs to this class)ROOT::Math::IParametricGradFunctionMultiDim::BaseGradFunc, ROOT::Fit::Fitter::BaseGradFunc, ROOT::Math::IMultiGradFunction, ROOT::Math::GradFunctor::Impl. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionMultiDim&operator=(const ROOT::Math::IGradientFunctionMultiDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientFunctionMultiDim(). Virtual Destructor (no operations). {}. » Last changed: root/mathcore:$Id: IFunction.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__IGradientFunctionMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IGradientFunctionMultiDim.html
Availability,avail,available,"radientFunctionOneDim: public ROOT::Math::IBaseFunctionOneDim, public ROOT::Math::IGradientOneDim. Documentation for the abstract class IBaseFunctionMultiDim.; Interface (abstract class) for generic functions objects of multi-dimension; Provides a method to evaluate the function given a vector of coordinate values,; by implementing operator() (const double *).; In addition it defines the interface for copying functions via the pure virtual method Clone(); and the interface for getting the function dimension via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::GradFunctor1D::Impl, ROOT::Math::IGradFunction, ROOT::Math::IParametricGradFunctionOneDim::BaseGradFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; doubleROOT::Math::IGradientOneDim::Derivative(double x) const; doubleROOT::Math::IGradientOneDim::Derivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidROOT::Math::IGradientOneDim::Gradient(const double* x, double* g) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionOneDim&operator=(const ROOT::Math::IGradientFunctionOneDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same ",MatchSource.WIKI,root/html530/ROOT__Math__IGradientFunctionOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IGradientFunctionOneDim.html
Energy Efficiency,efficient,efficient," via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::GradFunctor1D::Impl, ROOT::Math::IGradFunction, ROOT::Math::IParametricGradFunctionOneDim::BaseGradFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; doubleROOT::Math::IGradientOneDim::Derivative(double x) const; doubleROOT::Math::IGradientOneDim::Derivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidROOT::Math::IGradientOneDim::Gradient(const double* x, double* g) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionOneDim&operator=(const ROOT::Math::IGradientFunctionOneDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientFunctionOneDim(). Virtual Destructor (no operations). {}. » Last changed: root/mathcore:$Id: IFunction.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__IGradientFunctionOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IGradientFunctionOneDim.html
Integrability,interface,interface,". ROOT::Math::IGradientFunctionOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IGradientFunctionOneDim. class ROOT::Math::IGradientFunctionOneDim: public ROOT::Math::IBaseFunctionOneDim, public ROOT::Math::IGradientOneDim. Documentation for the abstract class IBaseFunctionMultiDim.; Interface (abstract class) for generic functions objects of multi-dimension; Provides a method to evaluate the function given a vector of coordinate values,; by implementing operator() (const double *).; In addition it defines the interface for copying functions via the pure virtual method Clone(); and the interface for getting the function dimension via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::GradFunctor1D::Impl, ROOT::Math::IGradFunction, ROOT::Math::IParametricGradFunctionOneDim::BaseGradFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; doubleROOT::Math::IGradientOneDim::Derivative(double x) const; doubleROOT::Math::IGradientOneDim::Derivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidROOT::Math::IGradientOneDim::Gradient(const double* x, double* g) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionOneDim&operator=(const ROOT::Math::IGradientFunctionOneDim&). Class Charts. Inheritance; Inhe",MatchSource.WIKI,root/html530/ROOT__Math__IGradientFunctionOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IGradientFunctionOneDim.html
Performance,perform,performances," via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::GradFunctor1D::Impl, ROOT::Math::IGradFunction, ROOT::Math::IParametricGradFunctionOneDim::BaseGradFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; doubleROOT::Math::IGradientOneDim::Derivative(double x) const; doubleROOT::Math::IGradientOneDim::Derivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidROOT::Math::IGradientOneDim::Gradient(const double* x, double* g) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionOneDim&operator=(const ROOT::Math::IGradientFunctionOneDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientFunctionOneDim(). Virtual Destructor (no operations). {}. » Last changed: root/mathcore:$Id: IFunction.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__IGradientFunctionOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IGradientFunctionOneDim.html
Availability,avail,available,"ons:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IGradientMultiDim. class ROOT::Math::IGradientMultiDim. Documentation for the abstract class IBaseFunctionMultiDim.; Interface (abstract class) for generic functions objects of multi-dimension; Provides a method to evaluate the function given a vector of coordinate values,; by implementing operator() (const double *).; In addition it defines the interface for copying functions via the pure virtual method Clone(); and the interface for getting the function dimension via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IGradientFunctionMultiDim::BaseGrad. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientMultiDim(); doubleDerivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; ROOT::Math::IGradientMultiDim&operator=(const ROOT::Math::IGradientMultiDim&). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IGradientMultiDim(); virual destructor. {}. void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double* x, unsigned int icoord = 0) const. Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const.",MatchSource.WIKI,root/html530/ROOT__Math__IGradientMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IGradientMultiDim.html
Energy Efficiency,efficient,efficient," the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IGradientFunctionMultiDim::BaseGrad. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientMultiDim(); doubleDerivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; ROOT::Math::IGradientMultiDim&operator=(const ROOT::Math::IGradientMultiDim&). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IGradientMultiDim(); virual destructor. {}. void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double* x, unsigned int icoord = 0) const. Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. » Last changed: root/mathcore:$Id: IFunction.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__IGradientMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IGradientMultiDim.html
Integrability,interface,interface,". ROOT::Math::IGradientMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IGradientMultiDim. class ROOT::Math::IGradientMultiDim. Documentation for the abstract class IBaseFunctionMultiDim.; Interface (abstract class) for generic functions objects of multi-dimension; Provides a method to evaluate the function given a vector of coordinate values,; by implementing operator() (const double *).; In addition it defines the interface for copying functions via the pure virtual method Clone(); and the interface for getting the function dimension via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IGradientFunctionMultiDim::BaseGrad. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientMultiDim(); doubleDerivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; ROOT::Math::IGradientMultiDim&operator=(const ROOT::Math::IGradientMultiDim&). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IGradientMultiDim(); virual destructor. {}. void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double* x, unsigned int icoord = 0) const. Return the ",MatchSource.WIKI,root/html530/ROOT__Math__IGradientMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IGradientMultiDim.html
Performance,perform,performances," the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IGradientFunctionMultiDim::BaseGrad. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientMultiDim(); doubleDerivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; ROOT::Math::IGradientMultiDim&operator=(const ROOT::Math::IGradientMultiDim&). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IGradientMultiDim(); virual destructor. {}. void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double* x, unsigned int icoord = 0) const. Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. » Last changed: root/mathcore:$Id: IFunction.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__IGradientMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IGradientMultiDim.html
Availability,avail,available,"function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IGradientOneDim. class ROOT::Math::IGradientOneDim. Documentation for the abstract class IBaseFunctionMultiDim.; Interface (abstract class) for generic functions objects of multi-dimension; Provides a method to evaluate the function given a vector of coordinate values,; by implementing operator() (const double *).; In addition it defines the interface for copying functions via the pure virtual method Clone(); and the interface for getting the function dimension via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::WrappedTF1::IGrad, ROOT::Math::IGradientFunctionOneDim::BaseGrad. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientOneDim(); doubleDerivative(double x) const; doubleDerivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidFdF(const double* x, double& f, double* df) const; voidGradient(const double* x, double* g) const; ROOT::Math::IGradientOneDim&operator=(const ROOT::Math::IGradientOneDim&). private:. virtual doubleDoDerivative(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* g) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double * x, unsigned int icoord = 0). Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time th",MatchSource.WIKI,root/html530/ROOT__Math__IGradientOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IGradientOneDim.html
Energy Efficiency,efficient,efficient,"on in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::WrappedTF1::IGrad, ROOT::Math::IGradientFunctionOneDim::BaseGrad. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientOneDim(); doubleDerivative(double x) const; doubleDerivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidFdF(const double* x, double& f, double* df) const; voidGradient(const double* x, double* g) const; ROOT::Math::IGradientOneDim&operator=(const ROOT::Math::IGradientOneDim&). private:. virtual doubleDoDerivative(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* g) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double * x, unsigned int icoord = 0). Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientOneDim(); virtual destructor. {}. double Derivative(double x) const. Return the derivative of the function at a point x; Use the private method DoDerivative. void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is oft",MatchSource.WIKI,root/html530/ROOT__Math__IGradientOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IGradientOneDim.html
Integrability,interface,interface,". ROOT::Math::IGradientOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IGradientOneDim. class ROOT::Math::IGradientOneDim. Documentation for the abstract class IBaseFunctionMultiDim.; Interface (abstract class) for generic functions objects of multi-dimension; Provides a method to evaluate the function given a vector of coordinate values,; by implementing operator() (const double *).; In addition it defines the interface for copying functions via the pure virtual method Clone(); and the interface for getting the function dimension via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::WrappedTF1::IGrad, ROOT::Math::IGradientFunctionOneDim::BaseGrad. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientOneDim(); doubleDerivative(double x) const; doubleDerivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidFdF(const double* x, double& f, double* df) const; voidGradient(const double* x, double* g) const; ROOT::Math::IGradientOneDim&operator=(const ROOT::Math::IGradientOneDim&). private:. virtual doubleDoDerivative(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* g) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double * x, unsigned int icoord = 0). Return the partial derivative with re",MatchSource.WIKI,root/html530/ROOT__Math__IGradientOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IGradientOneDim.html
Performance,perform,performances,"double& f, double& df) const; voidFdF(const double* x, double& f, double* df) const; voidGradient(const double* x, double* g) const; ROOT::Math::IGradientOneDim&operator=(const ROOT::Math::IGradientOneDim&). private:. virtual doubleDoDerivative(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* g) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double * x, unsigned int icoord = 0). Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientOneDim(); virtual destructor. {}. double Derivative(double x) const. Return the derivative of the function at a point x; Use the private method DoDerivative. void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. » Last changed: root/mathcore:$Id: IFunction.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__IGradientOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IGradientOneDim.html
Availability,avail,available,". ROOT::Math::IMinimizer1D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IMinimizer1D. class ROOT::Math::IMinimizer1D. Interface class for numerical methods for one-dimensional minimization. @ingroup Min1D. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IMinimizer1D(); virtual doubleFValLower() const; virtual doubleFValMinimum() const; virtual doubleFValUpper() const; virtual intIterations() const; virtual boolMinimize(int maxIter, double absTol, double relTol); virtual const char*Name() const; ROOT::Math::IMinimizer1D&operator=(const ROOT::Math::IMinimizer1D&); virtual intStatus() const; virtual doubleXLower() const; virtual doubleXMinimum() const; virtual doubleXUpper() const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IMinimizer1D(); {}. double XMinimum() const. * Return current estimate of the position of the minimum. double XLower() const. * Return current lower bound of the minimization interval. double XUpper() const. * Return current upper bound of the minimization interval. double FValMinimum() const. * Return function value at current estimate of the minimum. double FValLower() const. * Return function value at current lower bound of the minimization interval. double FValUpper() const. * Return function value at current upper bound of the minimization interval. bool Minimize(int maxIter, double absTol, double relTol). * Find minimum position iterating until convergence specified by the absolute and relative tolerance or; * the maximum number of iteration is reached; * Return true if iterations converged successfully; * \@param maxIter maximum number of iteration; * \@param absTol desired absolute err",MatchSource.WIKI,root/html530/ROOT__Math__IMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IMinimizer1D.html
Availability,error,error,"y only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000) {; fIntegrator = CreateIntegrator(type, absTol, relTol, ncall);; SetFunction(f, dim);; }; destructor. IntegratorMultiDim(const ROOT::Math::IntegratorMultiDim& ); disable copy constructur and assignment operator. {}. IntegratorMultiDim & operator=(const ROOT::Math::IntegratorMultiDim& ); { return *this; }. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. double Result() const; return result of last integration. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const; return integration error. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const; return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. void SetRelTolerance(double relTol); return number of function evaluations in calculating the integral; unsigned int NEval() const { return fNEval; }; set the relative tolerance. { if (fIntegrator) fIntegrator->SetRelTolerance(relTol); }. void SetAbsTolerance(double absTol); set absolute tolerance. { if (fIntegrator) fIntegrator->SetAbsTolerance(absTol); }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options. { if (fIntegrator) fIntegrator->SetOptions(opt); }. VirtualIntegratorMultiDim * GetIntegrator(); return a pointer to integrator object. { return fIntegrator; }. std::string Name() const; return name of integrator. { return (fIntegrator) ? Options().Integrator() : std::string(""""); }. IntegrationMultiDim::Type GetType(const char* name); ",MatchSource.WIKI,root/html530/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IntegratorMultiDim.html
Deployability,integrat,integration,". ROOT::Math::IntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IntegratorMultiDim. class ROOT::Math::IntegratorMultiDim. User class for performing multidimensional integration. By default uses adaptive multi-dimensional integration using the algorithm from Genz Mallik; implemented in the class ROOT::Math::AdaptiveIntegratorMultiDim otherwise it can uses via the; plug-in manager the MC integration class (ROOT::Math::GSLMCIntegration) from MathMore. @ingroup Integration. Function Members (Methods); public:. virtual~IntegratorMultiDim(); doubleError() const; ROOT::Math::VirtualIntegratorMultiDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationMultiDim::Type); static ROOT::Math::IntegrationMultiDim::TypeGetType(const char* name); doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); stringName() const; ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleResult() const; voidSetAbsTolerance(double absTol); voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); voidSetRelTolerance(double relTol); intStatus() const. protected:. ROOT::Math::VirtualIntegratorMultiDim*CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall). private:. ROOT::Ma",MatchSource.WIKI,root/html530/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IntegratorMultiDim.html
Energy Efficiency,adapt,adaptive,". ROOT::Math::IntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IntegratorMultiDim. class ROOT::Math::IntegratorMultiDim. User class for performing multidimensional integration. By default uses adaptive multi-dimensional integration using the algorithm from Genz Mallik; implemented in the class ROOT::Math::AdaptiveIntegratorMultiDim otherwise it can uses via the; plug-in manager the MC integration class (ROOT::Math::GSLMCIntegration) from MathMore. @ingroup Integration. Function Members (Methods); public:. virtual~IntegratorMultiDim(); doubleError() const; ROOT::Math::VirtualIntegratorMultiDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationMultiDim::Type); static ROOT::Math::IntegrationMultiDim::TypeGetType(const char* name); doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); stringName() const; ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleResult() const; voidSetAbsTolerance(double absTol); voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); voidSetRelTolerance(double relTol); intStatus() const. protected:. ROOT::Math::VirtualIntegratorMultiDim*CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall). private:. ROOT::Ma",MatchSource.WIKI,root/html530/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IntegratorMultiDim.html
Integrability,integrat,integration,". ROOT::Math::IntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IntegratorMultiDim. class ROOT::Math::IntegratorMultiDim. User class for performing multidimensional integration. By default uses adaptive multi-dimensional integration using the algorithm from Genz Mallik; implemented in the class ROOT::Math::AdaptiveIntegratorMultiDim otherwise it can uses via the; plug-in manager the MC integration class (ROOT::Math::GSLMCIntegration) from MathMore. @ingroup Integration. Function Members (Methods); public:. virtual~IntegratorMultiDim(); doubleError() const; ROOT::Math::VirtualIntegratorMultiDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationMultiDim::Type); static ROOT::Math::IntegrationMultiDim::TypeGetType(const char* name); doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); stringName() const; ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleResult() const; voidSetAbsTolerance(double absTol); voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); voidSetRelTolerance(double relTol); intStatus() const. protected:. ROOT::Math::VirtualIntegratorMultiDim*CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall). private:. ROOT::Ma",MatchSource.WIKI,root/html530/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IntegratorMultiDim.html
Modifiability,adapt,adaptive,". ROOT::Math::IntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IntegratorMultiDim. class ROOT::Math::IntegratorMultiDim. User class for performing multidimensional integration. By default uses adaptive multi-dimensional integration using the algorithm from Genz Mallik; implemented in the class ROOT::Math::AdaptiveIntegratorMultiDim otherwise it can uses via the; plug-in manager the MC integration class (ROOT::Math::GSLMCIntegration) from MathMore. @ingroup Integration. Function Members (Methods); public:. virtual~IntegratorMultiDim(); doubleError() const; ROOT::Math::VirtualIntegratorMultiDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationMultiDim::Type); static ROOT::Math::IntegrationMultiDim::TypeGetType(const char* name); doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); stringName() const; ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleResult() const; voidSetAbsTolerance(double absTol); voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); voidSetRelTolerance(double relTol); intStatus() const. protected:. ROOT::Math::VirtualIntegratorMultiDim*CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall). private:. ROOT::Ma",MatchSource.WIKI,root/html530/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IntegratorMultiDim.html
Performance,perform,performing,". ROOT::Math::IntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IntegratorMultiDim. class ROOT::Math::IntegratorMultiDim. User class for performing multidimensional integration. By default uses adaptive multi-dimensional integration using the algorithm from Genz Mallik; implemented in the class ROOT::Math::AdaptiveIntegratorMultiDim otherwise it can uses via the; plug-in manager the MC integration class (ROOT::Math::GSLMCIntegration) from MathMore. @ingroup Integration. Function Members (Methods); public:. virtual~IntegratorMultiDim(); doubleError() const; ROOT::Math::VirtualIntegratorMultiDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationMultiDim::Type); static ROOT::Math::IntegrationMultiDim::TypeGetType(const char* name); doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); stringName() const; ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleResult() const; voidSetAbsTolerance(double absTol); voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); voidSetRelTolerance(double relTol); intStatus() const. protected:. ROOT::Math::VirtualIntegratorMultiDim*CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall). private:. ROOT::Ma",MatchSource.WIKI,root/html530/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IntegratorMultiDim.html
Availability,toler,tolerance,; voidROOT::Math::BaseIntegratorOptions::SetAbsTolerance(double tol); static voidSetDefaultAbsTolerance(double tol); static voidSetDefaultIntegrator(const char* name); static voidSetDefaultNCalls(unsigned int ncall); static voidSetDefaultRelTolerance(double tol); static voidSetDefaultWKSize(unsigned int size); voidROOT::Math::BaseIntegratorOptions::SetExtraOptions(const ROOT::Math::IOptions& opt); voidSetIntegrator(const char* name); voidSetNCalls(unsigned int calls); voidROOT::Math::BaseIntegratorOptions::SetRelTolerance(double tol); voidROOT::Math::BaseIntegratorOptions::SetWKSize(unsigned int size); unsigned intROOT::Math::BaseIntegratorOptions::WKSize() const. protected:. voidROOT::Math::BaseIntegratorOptions::ClearExtra(). Data Members; protected:. doubleROOT::Math::BaseIntegratorOptions::fAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*ROOT::Math::BaseIntegratorOptions::fExtraOptionsextra options ; intROOT::Math::BaseIntegratorOptions::fIntegTypeIntegrator type (value converted from enum); unsigned intROOT::Math::BaseIntegratorOptions::fNCalls(max) funxtion calls; doubleROOT::Math::BaseIntegratorOptions::fRelTolerancerelative tolerance ; unsigned intROOT::Math::BaseIntegratorOptions::fWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::IntegratorMultiDimOptions& rhs); assignment operators. std::string Integrator() const; name of 1D integrator. IntegrationOneDim::Type IntegratorType() const; type of the integrator (return the enumeration type). { return (IntegrationOneDim::Type) fIntegType; }. void SetIntegrator(const char* name); set 1D integrator name. void Print(ostream& os = std::cout) const; print all the options. void SetDefaultIntegrator(const char* name); static methods for setting and retrieving the default options. void SetDefaultAbsTolerance(double tol). void SetDefaultRelTolerance(double tol). void SetDefaultWKSize(unsigned int size,MatchSource.WIKI,root/html530/ROOT__Math__IntegratorMultiDimOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IntegratorMultiDimOptions.html
Deployability,integrat,integration,". ROOT::Math::IntegratorMultiDimOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IntegratorMultiDimOptions. class ROOT::Math::IntegratorMultiDimOptions: public ROOT::Math::BaseIntegratorOptions. Base class for Numerical integration options; common in 1D and multi-dimension; This is an internal class and is not supposed to be instantiated by the user. @ingroup Integration. Function Members (Methods); public:. virtual~IntegratorMultiDimOptions(); doubleROOT::Math::BaseIntegratorOptions::AbsTolerance() const; static ROOT::Math::IOptions&Default(const char* name); static doubleDefaultAbsTolerance(); static stringDefaultIntegrator(); static ROOT::Math::IntegrationMultiDim::TypeDefaultIntegratorType(); static unsigned intDefaultNCalls(); static doubleDefaultRelTolerance(); static unsigned intDefaultWKSize(); ROOT::Math::IOptions*ROOT::Math::BaseIntegratorOptions::ExtraOptions() const; static ROOT::Math::IOptions*FindDefault(const char* name); virtual stringIntegrator() const; ROOT::Math::IntegratorMultiDimOptionsIntegratorMultiDimOptions(ROOT::Math::IOptions* extraOpts = 0); ROOT::Math::IntegratorMultiDimOptionsIntegratorMultiDimOptions(const ROOT::Math::IntegratorMultiDimOptions& rhs); ROOT::Math::IntegrationMultiDim::TypeIntegratorType() const; unsigned intNCalls() const; ROOT::Math::IntegratorMultiDimOptions&operator=(const ROOT::Math::IntegratorMultiDimOptions& rhs); voidPrint(ostream& os = std::cout) const; static voidPrintDefault(const char* name = 0, ostream& os = std::cout); doubleROOT::Math::BaseIntegratorOptions::RelTolerance() const; voidROOT::Math::BaseIntegratorOptions::SetAbsTolerance(double tol); static voidSetDefaultAbsTolerance(double tol); static voidSetDefaultIntegrator(const char* name); static voidSetDefaultNCalls(unsigned int ncall); static voidSetDefaultRelTolerance(doub",MatchSource.WIKI,root/html530/ROOT__Math__IntegratorMultiDimOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IntegratorMultiDimOptions.html
Integrability,integrat,integration,". ROOT::Math::IntegratorMultiDimOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IntegratorMultiDimOptions. class ROOT::Math::IntegratorMultiDimOptions: public ROOT::Math::BaseIntegratorOptions. Base class for Numerical integration options; common in 1D and multi-dimension; This is an internal class and is not supposed to be instantiated by the user. @ingroup Integration. Function Members (Methods); public:. virtual~IntegratorMultiDimOptions(); doubleROOT::Math::BaseIntegratorOptions::AbsTolerance() const; static ROOT::Math::IOptions&Default(const char* name); static doubleDefaultAbsTolerance(); static stringDefaultIntegrator(); static ROOT::Math::IntegrationMultiDim::TypeDefaultIntegratorType(); static unsigned intDefaultNCalls(); static doubleDefaultRelTolerance(); static unsigned intDefaultWKSize(); ROOT::Math::IOptions*ROOT::Math::BaseIntegratorOptions::ExtraOptions() const; static ROOT::Math::IOptions*FindDefault(const char* name); virtual stringIntegrator() const; ROOT::Math::IntegratorMultiDimOptionsIntegratorMultiDimOptions(ROOT::Math::IOptions* extraOpts = 0); ROOT::Math::IntegratorMultiDimOptionsIntegratorMultiDimOptions(const ROOT::Math::IntegratorMultiDimOptions& rhs); ROOT::Math::IntegrationMultiDim::TypeIntegratorType() const; unsigned intNCalls() const; ROOT::Math::IntegratorMultiDimOptions&operator=(const ROOT::Math::IntegratorMultiDimOptions& rhs); voidPrint(ostream& os = std::cout) const; static voidPrintDefault(const char* name = 0, ostream& os = std::cout); doubleROOT::Math::BaseIntegratorOptions::RelTolerance() const; voidROOT::Math::BaseIntegratorOptions::SetAbsTolerance(double tol); static voidSetDefaultAbsTolerance(double tol); static voidSetDefaultIntegrator(const char* name); static voidSetDefaultNCalls(unsigned int ncall); static voidSetDefaultRelTolerance(doub",MatchSource.WIKI,root/html530/ROOT__Math__IntegratorMultiDimOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IntegratorMultiDimOptions.html
Deployability,integrat,integration,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Ma",MatchSource.WIKI,root/html530/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IntegratorOneDim.html
Energy Efficiency,adapt,adaptive,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Ma",MatchSource.WIKI,root/html530/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IntegratorOneDim.html
Integrability,integrat,integration,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Ma",MatchSource.WIKI,root/html530/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IntegratorOneDim.html
Modifiability,plug-in,plug-in,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Ma",MatchSource.WIKI,root/html530/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IntegratorOneDim.html
Performance,perform,performing,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Ma",MatchSource.WIKI,root/html530/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IntegratorOneDim.html
Usability,simpl,simple,"e; Inherited Members; Includes; Libraries. Function documentation; void SetFunction( Function & f). double Integral(const ROOT::Math::IGenFunction& f, double a, double b). double Integral(double a, double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). IntegratorOneDim(ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, unsigned int rule = 0); constructors. Constructor of one dimensional Integrator, default type is adaptive. @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the defa",MatchSource.WIKI,root/html530/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IntegratorOneDim.html
Availability,toler,tolerance," const; voidROOT::Math::BaseIntegratorOptions::SetAbsTolerance(double tol); static voidSetDefaultAbsTolerance(double tol); static voidSetDefaultIntegrator(const char* name); static voidSetDefaultNPoints(unsigned int n); static voidSetDefaultRelTolerance(double tol); static voidSetDefaultWKSize(unsigned int size); voidROOT::Math::BaseIntegratorOptions::SetExtraOptions(const ROOT::Math::IOptions& opt); voidSetIntegrator(const char* name); voidSetNPoints(unsigned int n); voidROOT::Math::BaseIntegratorOptions::SetRelTolerance(double tol); voidROOT::Math::BaseIntegratorOptions::SetWKSize(unsigned int size); unsigned intROOT::Math::BaseIntegratorOptions::WKSize() const. protected:. voidROOT::Math::BaseIntegratorOptions::ClearExtra(). Data Members; protected:. doubleROOT::Math::BaseIntegratorOptions::fAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*ROOT::Math::BaseIntegratorOptions::fExtraOptionsextra options ; intROOT::Math::BaseIntegratorOptions::fIntegTypeIntegrator type (value converted from enum); unsigned intROOT::Math::BaseIntegratorOptions::fNCalls(max) funxtion calls; doubleROOT::Math::BaseIntegratorOptions::fRelTolerancerelative tolerance ; unsigned intROOT::Math::BaseIntegratorOptions::fWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::IntegratorOneDimOptions& rhs); assignment operators. std::string Integrator() const; name of 1D integrator. IntegratorOneDimOptions(IOptions * extraOpts = 0); constructor using the default options; can pass a pointer to extra options (N.B. pointer will be managed by the class). virtual ~IntegratorOneDimOptions(); {}. IntegratorOneDimOptions(const IntegratorOneDimOptions & rhs); copy constructor. {}. void SetNPoints(unsigned int n); specific method for one-dim; set number of points rule; values of 1,2,3,4,5,6 corresponds to 15,21,31,41,51,61 and they are used in GSL adaptive; values > 6 corresponds to the actual ",MatchSource.WIKI,root/html530/ROOT__Math__IntegratorOneDimOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IntegratorOneDimOptions.html
Deployability,integrat,integration,". ROOT::Math::IntegratorOneDimOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IntegratorOneDimOptions. class ROOT::Math::IntegratorOneDimOptions: public ROOT::Math::BaseIntegratorOptions. Base class for Numerical integration options; common in 1D and multi-dimension; This is an internal class and is not supposed to be instantiated by the user. @ingroup Integration. Function Members (Methods); public:. virtual~IntegratorOneDimOptions(); doubleROOT::Math::BaseIntegratorOptions::AbsTolerance() const; static ROOT::Math::IOptions&Default(const char* name); static doubleDefaultAbsTolerance(); static stringDefaultIntegrator(); static ROOT::Math::IntegrationOneDim::TypeDefaultIntegratorType(); static unsigned intDefaultNPoints(); static doubleDefaultRelTolerance(); static unsigned intDefaultWKSize(); ROOT::Math::IOptions*ROOT::Math::BaseIntegratorOptions::ExtraOptions() const; static ROOT::Math::IOptions*FindDefault(const char* name); virtual stringIntegrator() const; ROOT::Math::IntegratorOneDimOptionsIntegratorOneDimOptions(ROOT::Math::IOptions* extraOpts = 0); ROOT::Math::IntegratorOneDimOptionsIntegratorOneDimOptions(const ROOT::Math::IntegratorOneDimOptions& rhs); ROOT::Math::IntegrationOneDim::TypeIntegratorType() const; unsigned intNPoints() const; ROOT::Math::IntegratorOneDimOptions&operator=(const ROOT::Math::IntegratorOneDimOptions& rhs); voidPrint(ostream& os = std::cout) const; static voidPrintDefault(const char* name = 0, ostream& os = std::cout); doubleROOT::Math::BaseIntegratorOptions::RelTolerance() const; voidROOT::Math::BaseIntegratorOptions::SetAbsTolerance(double tol); static voidSetDefaultAbsTolerance(double tol); static voidSetDefaultIntegrator(const char* name); static voidSetDefaultNPoints(unsigned int n); static voidSetDefaultRelTolerance(double tol); static voidSetDefa",MatchSource.WIKI,root/html530/ROOT__Math__IntegratorOneDimOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IntegratorOneDimOptions.html
Energy Efficiency,adapt,adaptive,"s ; intROOT::Math::BaseIntegratorOptions::fIntegTypeIntegrator type (value converted from enum); unsigned intROOT::Math::BaseIntegratorOptions::fNCalls(max) funxtion calls; doubleROOT::Math::BaseIntegratorOptions::fRelTolerancerelative tolerance ; unsigned intROOT::Math::BaseIntegratorOptions::fWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::IntegratorOneDimOptions& rhs); assignment operators. std::string Integrator() const; name of 1D integrator. IntegratorOneDimOptions(IOptions * extraOpts = 0); constructor using the default options; can pass a pointer to extra options (N.B. pointer will be managed by the class). virtual ~IntegratorOneDimOptions(); {}. IntegratorOneDimOptions(const IntegratorOneDimOptions & rhs); copy constructor. {}. void SetNPoints(unsigned int n); specific method for one-dim; set number of points rule; values of 1,2,3,4,5,6 corresponds to 15,21,31,41,51,61 and they are used in GSL adaptive; values > 6 corresponds to the actual points and they are used by teh GaussLegendre integrator. { fNCalls = n; }. unsigned int NPoints() const; maximum number of function calls. { return fNCalls; }. IntegrationOneDim::Type IntegratorType() const; type of the integrator (return the enumeration type). { return (IntegrationOneDim::Type) fIntegType; }. void SetIntegrator(const char* name); set 1D integrator name. void Print(ostream& os = std::cout) const; print all the options. void SetDefaultIntegrator(const char* name); static methods for setting and retrieving the default options. void SetDefaultAbsTolerance(double tol). void SetDefaultRelTolerance(double tol). void SetDefaultWKSize(unsigned int size). void SetDefaultNPoints(unsigned int n). std::string DefaultIntegrator(). IntegrationOneDim::Type DefaultIntegratorType(). double DefaultAbsTolerance(). double DefaultRelTolerance(). unsigned int DefaultWKSize(). unsigned int DefaultNPoints(). ROOT",MatchSource.WIKI,root/html530/ROOT__Math__IntegratorOneDimOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IntegratorOneDimOptions.html
Integrability,integrat,integration,". ROOT::Math::IntegratorOneDimOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IntegratorOneDimOptions. class ROOT::Math::IntegratorOneDimOptions: public ROOT::Math::BaseIntegratorOptions. Base class for Numerical integration options; common in 1D and multi-dimension; This is an internal class and is not supposed to be instantiated by the user. @ingroup Integration. Function Members (Methods); public:. virtual~IntegratorOneDimOptions(); doubleROOT::Math::BaseIntegratorOptions::AbsTolerance() const; static ROOT::Math::IOptions&Default(const char* name); static doubleDefaultAbsTolerance(); static stringDefaultIntegrator(); static ROOT::Math::IntegrationOneDim::TypeDefaultIntegratorType(); static unsigned intDefaultNPoints(); static doubleDefaultRelTolerance(); static unsigned intDefaultWKSize(); ROOT::Math::IOptions*ROOT::Math::BaseIntegratorOptions::ExtraOptions() const; static ROOT::Math::IOptions*FindDefault(const char* name); virtual stringIntegrator() const; ROOT::Math::IntegratorOneDimOptionsIntegratorOneDimOptions(ROOT::Math::IOptions* extraOpts = 0); ROOT::Math::IntegratorOneDimOptionsIntegratorOneDimOptions(const ROOT::Math::IntegratorOneDimOptions& rhs); ROOT::Math::IntegrationOneDim::TypeIntegratorType() const; unsigned intNPoints() const; ROOT::Math::IntegratorOneDimOptions&operator=(const ROOT::Math::IntegratorOneDimOptions& rhs); voidPrint(ostream& os = std::cout) const; static voidPrintDefault(const char* name = 0, ostream& os = std::cout); doubleROOT::Math::BaseIntegratorOptions::RelTolerance() const; voidROOT::Math::BaseIntegratorOptions::SetAbsTolerance(double tol); static voidSetDefaultAbsTolerance(double tol); static voidSetDefaultIntegrator(const char* name); static voidSetDefaultNPoints(unsigned int n); static voidSetDefaultRelTolerance(double tol); static voidSetDefa",MatchSource.WIKI,root/html530/ROOT__Math__IntegratorOneDimOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IntegratorOneDimOptions.html
Modifiability,adapt,adaptive,"s ; intROOT::Math::BaseIntegratorOptions::fIntegTypeIntegrator type (value converted from enum); unsigned intROOT::Math::BaseIntegratorOptions::fNCalls(max) funxtion calls; doubleROOT::Math::BaseIntegratorOptions::fRelTolerancerelative tolerance ; unsigned intROOT::Math::BaseIntegratorOptions::fWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::IntegratorOneDimOptions& rhs); assignment operators. std::string Integrator() const; name of 1D integrator. IntegratorOneDimOptions(IOptions * extraOpts = 0); constructor using the default options; can pass a pointer to extra options (N.B. pointer will be managed by the class). virtual ~IntegratorOneDimOptions(); {}. IntegratorOneDimOptions(const IntegratorOneDimOptions & rhs); copy constructor. {}. void SetNPoints(unsigned int n); specific method for one-dim; set number of points rule; values of 1,2,3,4,5,6 corresponds to 15,21,31,41,51,61 and they are used in GSL adaptive; values > 6 corresponds to the actual points and they are used by teh GaussLegendre integrator. { fNCalls = n; }. unsigned int NPoints() const; maximum number of function calls. { return fNCalls; }. IntegrationOneDim::Type IntegratorType() const; type of the integrator (return the enumeration type). { return (IntegrationOneDim::Type) fIntegType; }. void SetIntegrator(const char* name); set 1D integrator name. void Print(ostream& os = std::cout) const; print all the options. void SetDefaultIntegrator(const char* name); static methods for setting and retrieving the default options. void SetDefaultAbsTolerance(double tol). void SetDefaultRelTolerance(double tol). void SetDefaultWKSize(unsigned int size). void SetDefaultNPoints(unsigned int n). std::string DefaultIntegrator(). IntegrationOneDim::Type DefaultIntegratorType(). double DefaultAbsTolerance(). double DefaultRelTolerance(). unsigned int DefaultWKSize(). unsigned int DefaultNPoints(). ROOT",MatchSource.WIKI,root/html530/ROOT__Math__IntegratorOneDimOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IntegratorOneDimOptions.html
Availability,avail,available,". ROOT::Math::Interpolator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::Interpolator. class ROOT::Math::Interpolator. Class for performing function interpolation of points.; The class is instantiated with an interpolation methods, passed as an enumeration in the constructor.; See Interpolation::Type for the available interpolation algorithms, which are implemented using GSL.; See also the <A HREF=http://www.gnu.org/software/gsl/manual/html_node/Interpolation.html"">GSL manual</A> for more information.; The class provides additional methods for computing derivatives and integrals of interpolating functions. This class does not support copying.; @ingroup Interpolation. Function Members (Methods); public:. virtual~Interpolator(); doubleDeriv(double x) const; doubleDeriv2(double x) const; doubleEval(double x) const; doubleInteg(double a, double b) const; ROOT::Math::InterpolatorInterpolator(unsigned int ndata = 0, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE); ROOT::Math::InterpolatorInterpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE); boolSetData(const vector<double>& x, const vector<double>& y); boolSetData(unsigned int ndata, const double* x, const double* y); stringType() const; stringTypeGet() const. private:. ROOT::Math::InterpolatorInterpolator(const ROOT::Math::Interpolator&); ROOT::Math::Interpolator&operator=(const ROOT::Math::Interpolator&). Data Members; private:. ROOT::Math::GSLInterpolator*fInterppointer to GSL interpolator class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Interpolator(unsigned int ndata = 0, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from number of data points and with Int",MatchSource.WIKI,root/html530/ROOT__Math__Interpolator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Interpolator.html
Energy Efficiency,efficient,efficient,"ts an interpolator class from number of data points and with Interpolation::Type type.; The data can be set later on with the SetData method.; In case the data size is not known, better using the default of zero or the next constructor later on.; The defult interpolation type is Cubic spline. Interpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from vector of data points \f$ (x_i, y_i )\f$ and with Interpolation::Type type.; The method will compute a continous interpolating function \f$ y(x) \f$ such that \f$ y_i = y ( x_i )\f$.; The defult interpolation type is Cubic spline. virtual ~Interpolator(). Interpolator(const ROOT::Math::Interpolator& ); usually copying is non trivial, so we make this unaccessible. bool SetData(const vector<double>& x, const vector<double>& y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size. bool SetData(unsigned int ndata, const double* x, const double* y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size. double Eval(double x) const. Return the interpolated value at point x. double Deriv(double x) const. Return the derivative of the interpolated function at point x. double Deriv2(double x) const. Return the second derivative of the interpolated function at point x. double Integ(double a, double b) const. Return the Integral of the interpolated function over the range [a,b]. std::string Type() const. Return the type of interpolation method. std::string TypeGet() const. » Last changed: root/mathmore:$Id: Interpolator.h 24403 2008-06-20 08:31:10Z moneta $ » Last generated: 2011-07-04 1",MatchSource.WIKI,root/html530/ROOT__Math__Interpolator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Interpolator.html
Performance,perform,performing,". ROOT::Math::Interpolator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::Interpolator. class ROOT::Math::Interpolator. Class for performing function interpolation of points.; The class is instantiated with an interpolation methods, passed as an enumeration in the constructor.; See Interpolation::Type for the available interpolation algorithms, which are implemented using GSL.; See also the <A HREF=http://www.gnu.org/software/gsl/manual/html_node/Interpolation.html"">GSL manual</A> for more information.; The class provides additional methods for computing derivatives and integrals of interpolating functions. This class does not support copying.; @ingroup Interpolation. Function Members (Methods); public:. virtual~Interpolator(); doubleDeriv(double x) const; doubleDeriv2(double x) const; doubleEval(double x) const; doubleInteg(double a, double b) const; ROOT::Math::InterpolatorInterpolator(unsigned int ndata = 0, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE); ROOT::Math::InterpolatorInterpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE); boolSetData(const vector<double>& x, const vector<double>& y); boolSetData(unsigned int ndata, const double* x, const double* y); stringType() const; stringTypeGet() const. private:. ROOT::Math::InterpolatorInterpolator(const ROOT::Math::Interpolator&); ROOT::Math::Interpolator&operator=(const ROOT::Math::Interpolator&). Data Members; private:. ROOT::Math::GSLInterpolator*fInterppointer to GSL interpolator class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Interpolator(unsigned int ndata = 0, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from number of data points and with Int",MatchSource.WIKI,root/html530/ROOT__Math__Interpolator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Interpolator.html
Availability,avail,available,". ROOT::Math::IOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IOptions. class ROOT::Math::IOptions. Generic interface for defining configuration options of a numerical algorithm. @ingroup NumAlgo. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IOptions(); virtual ROOT::Math::IOptions*Clone() const; virtual boolGetIntValue(const char*, int&) const; virtual boolGetNamedValue(const char*, string&) const; virtual boolGetRealValue(const char*, double&) const; intIValue(const char* name) const; stringNamedValue(const char* name) const; ROOT::Math::IOptions&operator=(const ROOT::Math::IOptions&); virtual voidPrint(ostream& = std::cout) const; doubleRValue(const char* name) const; virtual voidSetIntValue(const char*, int); virtual voidSetNamedValue(const char*, const char*); virtual voidSetRealValue(const char*, double); voidSetValue(const char* name, double val); voidSetValue(const char* name, int val); voidSetValue(const char* name, const char* val). private:. boolDoGetValue(const char* name, double& val) const; boolDoGetValue(const char* name, int& val) const; boolDoGetValue(const char* name, string& val) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IOptions(). IOptions * Clone() const; copy the options. void SetValue(const char* name, double val); generic methods for retrivieng options ; set option value. { SetRealValue(name,val);}. void SetValue(const char* name, int val); { SetIntValue(name,val);}. void SetValue(const char* name, const char* val); { SetNamedValue(name,val);}. double RValue(const char* name) const. int IValue(const char* name) const. std::string NamedValue(const char* name) const. boo",MatchSource.WIKI,root/html530/ROOT__Math__IOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IOptions.html
Deployability,configurat,configuration,". ROOT::Math::IOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IOptions. class ROOT::Math::IOptions. Generic interface for defining configuration options of a numerical algorithm. @ingroup NumAlgo. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IOptions(); virtual ROOT::Math::IOptions*Clone() const; virtual boolGetIntValue(const char*, int&) const; virtual boolGetNamedValue(const char*, string&) const; virtual boolGetRealValue(const char*, double&) const; intIValue(const char* name) const; stringNamedValue(const char* name) const; ROOT::Math::IOptions&operator=(const ROOT::Math::IOptions&); virtual voidPrint(ostream& = std::cout) const; doubleRValue(const char* name) const; virtual voidSetIntValue(const char*, int); virtual voidSetNamedValue(const char*, const char*); virtual voidSetRealValue(const char*, double); voidSetValue(const char* name, double val); voidSetValue(const char* name, int val); voidSetValue(const char* name, const char* val). private:. boolDoGetValue(const char* name, double& val) const; boolDoGetValue(const char* name, int& val) const; boolDoGetValue(const char* name, string& val) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IOptions(). IOptions * Clone() const; copy the options. void SetValue(const char* name, double val); generic methods for retrivieng options ; set option value. { SetRealValue(name,val);}. void SetValue(const char* name, int val); { SetIntValue(name,val);}. void SetValue(const char* name, const char* val); { SetNamedValue(name,val);}. double RValue(const char* name) const. int IValue(const char* name) const. std::string NamedValue(const char* name) const. boo",MatchSource.WIKI,root/html530/ROOT__Math__IOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IOptions.html
Integrability,interface,interface,". ROOT::Math::IOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IOptions. class ROOT::Math::IOptions. Generic interface for defining configuration options of a numerical algorithm. @ingroup NumAlgo. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IOptions(); virtual ROOT::Math::IOptions*Clone() const; virtual boolGetIntValue(const char*, int&) const; virtual boolGetNamedValue(const char*, string&) const; virtual boolGetRealValue(const char*, double&) const; intIValue(const char* name) const; stringNamedValue(const char* name) const; ROOT::Math::IOptions&operator=(const ROOT::Math::IOptions&); virtual voidPrint(ostream& = std::cout) const; doubleRValue(const char* name) const; virtual voidSetIntValue(const char*, int); virtual voidSetNamedValue(const char*, const char*); virtual voidSetRealValue(const char*, double); voidSetValue(const char* name, double val); voidSetValue(const char* name, int val); voidSetValue(const char* name, const char* val). private:. boolDoGetValue(const char* name, double& val) const; boolDoGetValue(const char* name, int& val) const; boolDoGetValue(const char* name, string& val) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IOptions(). IOptions * Clone() const; copy the options. void SetValue(const char* name, double val); generic methods for retrivieng options ; set option value. { SetRealValue(name,val);}. void SetValue(const char* name, int val); { SetIntValue(name,val);}. void SetValue(const char* name, const char* val); { SetNamedValue(name,val);}. double RValue(const char* name) const. int IValue(const char* name) const. std::string NamedValue(const char* name) const. boo",MatchSource.WIKI,root/html530/ROOT__Math__IOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IOptions.html
Modifiability,config,configuration,". ROOT::Math::IOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IOptions. class ROOT::Math::IOptions. Generic interface for defining configuration options of a numerical algorithm. @ingroup NumAlgo. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IOptions(); virtual ROOT::Math::IOptions*Clone() const; virtual boolGetIntValue(const char*, int&) const; virtual boolGetNamedValue(const char*, string&) const; virtual boolGetRealValue(const char*, double&) const; intIValue(const char* name) const; stringNamedValue(const char* name) const; ROOT::Math::IOptions&operator=(const ROOT::Math::IOptions&); virtual voidPrint(ostream& = std::cout) const; doubleRValue(const char* name) const; virtual voidSetIntValue(const char*, int); virtual voidSetNamedValue(const char*, const char*); virtual voidSetRealValue(const char*, double); voidSetValue(const char* name, double val); voidSetValue(const char* name, int val); voidSetValue(const char* name, const char* val). private:. boolDoGetValue(const char* name, double& val) const; boolDoGetValue(const char* name, int& val) const; boolDoGetValue(const char* name, string& val) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IOptions(). IOptions * Clone() const; copy the options. void SetValue(const char* name, double val); generic methods for retrivieng options ; set option value. { SetRealValue(name,val);}. void SetValue(const char* name, int val); { SetIntValue(name,val);}. void SetValue(const char* name, const char* val); { SetNamedValue(name,val);}. double RValue(const char* name) const. int IValue(const char* name) const. std::string NamedValue(const char* name) const. boo",MatchSource.WIKI,root/html530/ROOT__Math__IOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IOptions.html
Availability,avail,available,"fining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Math::IParamMultiFunction, ROOT::Fit::Fitter::IModelFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Math::IParametricGradFunctionMultiDim::BaseParamFunc, ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::FitResult::IModelFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~IParametricFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionMultiDim&operator=(const ROOT::Math::IParametricFunctionMultiDim&); virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoEval(const double* x) const; virtual doubleDoEvalPar(const double* x, const double* p) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(const double* x, const double* p) const. Evaluate function at a point x and for given parameters p.; This method d",MatchSource.WIKI,root/html530/ROOT__Math__IParametricFunctionMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IParametricFunctionMultiDim.html
Integrability,interface,interface,". ROOT::Math::IParametricFunctionMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricFunctionMultiDim. class ROOT::Math::IParametricFunctionMultiDim: public ROOT::Math::IBaseFunctionMultiDim, public ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Math::IParamMultiFunction, ROOT::Fit::Fitter::IModelFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Math::IParametricGradFunctionMultiDim::BaseParamFunc, ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::FitResult::IModelFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~IParametricFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionMultiDim&operator=(const ROOT:",MatchSource.WIKI,root/html530/ROOT__Math__IParametricFunctionMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IParametricFunctionMultiDim.html
Performance,cache,cached,"tionMultiDim>::IModelFunction, ROOT::Fit::FitResult::IModelFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~IParametricFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionMultiDim&operator=(const ROOT::Math::IParametricFunctionMultiDim&); virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoEval(const double* x) const; virtual doubleDoEvalPar(const double* x, const double* p) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(const double* x, const double* p) const. Evaluate function at a point x and for given parameters p.; This method does not change the internal status of the function (internal parameter values).; If for some reason one prefers caching the parameter values, SetParameters(p) and then operator()(x) should be; called.; Use the pure virtual function DoEvalPar to implement it. return DoEvalPar(x, p). double DoEval(const double* x) const. Implement the ROOT::Math::IBaseFunctionMultiDim interface DoEval(x) using the cached parameter values. » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__IParametricFunctionMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IParametricFunctionMultiDim.html
Safety,avoid,avoid,". ROOT::Math::IParametricFunctionMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricFunctionMultiDim. class ROOT::Math::IParametricFunctionMultiDim: public ROOT::Math::IBaseFunctionMultiDim, public ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Math::IParamMultiFunction, ROOT::Fit::Fitter::IModelFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Math::IParametricGradFunctionMultiDim::BaseParamFunc, ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::FitResult::IModelFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~IParametricFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionMultiDim&operator=(const ROOT:",MatchSource.WIKI,root/html530/ROOT__Math__IParametricFunctionMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IParametricFunctionMultiDim.html
Availability,avail,available,"OOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricFunctionOneDim. class ROOT::Math::IParametricFunctionOneDim: public ROOT::Math::IBaseFunctionOneDim, public ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Fit::Fitter::IModel1DFunction, ROOT::Math::IParametricGradFunctionOneDim::BaseParamFunc, ROOT::Math::IParamFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~IParametricFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(double x, const double* p) const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionOneDim&operator=(const ROOT::Math::IParametricFunctionOneDim&); virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoEval(double x) const; virtual doubleDoEvalPar(double x, const double* p) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(const double* x, const double* p) const. Evaluate function at a point x and for given parameters p.; This method does not change the internal status of the ",MatchSource.WIKI,root/html530/ROOT__Math__IParametricFunctionOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IParametricFunctionOneDim.html
Integrability,interface,interface,". ROOT::Math::IParametricFunctionOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricFunctionOneDim. class ROOT::Math::IParametricFunctionOneDim: public ROOT::Math::IBaseFunctionOneDim, public ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Fit::Fitter::IModel1DFunction, ROOT::Math::IParametricGradFunctionOneDim::BaseParamFunc, ROOT::Math::IParamFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~IParametricFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(double x, const double* p) const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionOneDim&operator=(const ROOT::Math::IParametricFunctionOneDim&); virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoEval(double x) const; virtual doubleDoEvalPar(double x, const double* p) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(const double* x, const double* p) const. Evaluate function at a point x and for given parameters p.;",MatchSource.WIKI,root/html530/ROOT__Math__IParametricFunctionOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IParametricFunctionOneDim.html
Performance,cache,cached,"Dim::Clone() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(double x, const double* p) const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionOneDim&operator=(const ROOT::Math::IParametricFunctionOneDim&); virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoEval(double x) const; virtual doubleDoEvalPar(double x, const double* p) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(const double* x, const double* p) const. Evaluate function at a point x and for given parameters p.; This method does not change the internal status of the function (internal parameter values).; If for some reason one prefers caching the parameter values, SetParameters(p) and then operator()(x) should be; called.; Use the pure virtual function DoEvalPar to implement it. return DoEvalPar(x, p). double DoEval(double x) const. Implement the ROOT::Math::IBaseFunctionMultiDim interface DoEval(x) using the cached parameter values. double operator()(double x, const double* p) const. Evaluate function at a point x and for given parameters p.; This method does not change the internal status of the function (internal parameter values).; If for some reason one prefers caching the parameter values, SetParameters(p) and then operator()(x) should be; called.; Use the pure virtual function DoEvalPar to implement it. » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__IParametricFunctionOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IParametricFunctionOneDim.html
Safety,avoid,avoid,". ROOT::Math::IParametricFunctionOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricFunctionOneDim. class ROOT::Math::IParametricFunctionOneDim: public ROOT::Math::IBaseFunctionOneDim, public ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Fit::Fitter::IModel1DFunction, ROOT::Math::IParametricGradFunctionOneDim::BaseParamFunc, ROOT::Math::IParamFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~IParametricFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(double x, const double* p) const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionOneDim&operator=(const ROOT::Math::IParametricFunctionOneDim&); virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoEval(double x) const; virtual doubleDoEvalPar(double x, const double* p) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(const double* x, const double* p) const. Evaluate function at a point x and for given parameters p.;",MatchSource.WIKI,root/html530/ROOT__Math__IParametricFunctionOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IParametricFunctionOneDim.html
Availability,avail,available,"uick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricGradFunctionMultiDim. class ROOT::Math::IParametricGradFunctionMultiDim: public ROOT::Math::IParametricFunctionMultiDim. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Fit::Fitter::IGradModelFunction, ROOT::Math::IParamMultiGradFunction, ROOT::Math::WrappedMultiTF1::BaseParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IParametricGradFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleROOT::Math::IParametricFunctionMultiDim::operator()(const double* x, const double* p) const; ROOT::Math::IParametricGradFunctionMultiDim&operator=(const ROOT::Math::IParametricGradFunctionMultiDim&); doubleParameterDerivative(const double* x, unsigned int ipar = 0) const; doubleParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const; voidParameterGradient(const double* x, double* grad) const; virtual voidParameterGradient(const double* x, const double* p, double* grad) const; virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetPara",MatchSource.WIKI,root/html530/ROOT__Math__IParametricGradFunctionMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IParametricGradFunctionMultiDim.html
Integrability,interface,interface,". ROOT::Math::IParametricGradFunctionMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricGradFunctionMultiDim. class ROOT::Math::IParametricGradFunctionMultiDim: public ROOT::Math::IParametricFunctionMultiDim. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Fit::Fitter::IGradModelFunction, ROOT::Math::IParamMultiGradFunction, ROOT::Math::WrappedMultiTF1::BaseParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IParametricGradFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleROOT::Math::IParametricFunctionMultiDim::operator()(const double* x, const double* p) const; ROOT::Math::IParametricGradFunctionMultiDim&operator=(const ROOT::Math::IParametricGradFunctionMultiDim&); doubleParameterDerivative(const double* x, unsigned int ipar = 0) const; doubleParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const; voidParameterGradient(const double* x, double* grad) const; virtual voidParameterGradient(const double* x, const double* p, double* grad) const; virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() co",MatchSource.WIKI,root/html530/ROOT__Math__IParametricGradFunctionMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IParametricGradFunctionMultiDim.html
Performance,cache,cached,"ricGradFunctionMultiDim&operator=(const ROOT::Math::IParametricGradFunctionMultiDim&); doubleParameterDerivative(const double* x, unsigned int ipar = 0) const; doubleParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const; voidParameterGradient(const double* x, double* grad) const; virtual voidParameterGradient(const double* x, const double* p, double* grad) const; virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoParameterDerivative(const double* x, const double* p, unsigned int ipar) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IParametricGradFunctionMultiDim(). Virtual Destructor (no operations). {}. void ParameterGradient(const double* x, const double* p, double* grad) const. Evaluate the all the derivatives (gradient vector) of the function with respect to the parameters at a point x.; It is optional to be implemented by the derived classes for better efficiency. double ParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const. Evaluate the partial derivative w.r.t a parameter ipar from values and parameters. return DoParameterDerivative(x, p, ipar). void ParameterGradient(const double* x, double* grad) const. Evaluate all derivatives using cached parameter values. double ParameterDerivative(const double* x, unsigned int ipar = 0) const. Evaluate partial derivative using cached parameter values. » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__IParametricGradFunctionMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IParametricGradFunctionMultiDim.html
Safety,avoid,avoid,". ROOT::Math::IParametricGradFunctionMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricGradFunctionMultiDim. class ROOT::Math::IParametricGradFunctionMultiDim: public ROOT::Math::IParametricFunctionMultiDim. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Fit::Fitter::IGradModelFunction, ROOT::Math::IParamMultiGradFunction, ROOT::Math::WrappedMultiTF1::BaseParamFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IParametricGradFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleROOT::Math::IParametricFunctionMultiDim::operator()(const double* x, const double* p) const; ROOT::Math::IParametricGradFunctionMultiDim&operator=(const ROOT::Math::IParametricGradFunctionMultiDim&); doubleParameterDerivative(const double* x, unsigned int ipar = 0) const; doubleParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const; voidParameterGradient(const double* x, double* grad) const; virtual voidParameterGradient(const double* x, const double* p, double* grad) const; virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() co",MatchSource.WIKI,root/html530/ROOT__Math__IParametricGradFunctionMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IParametricGradFunctionMultiDim.html
Availability,avail,available,"urce:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricGradFunctionOneDim. class ROOT::Math::IParametricGradFunctionOneDim: public ROOT::Math::IParametricFunctionOneDim. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>::BaseParFunc, ROOT::Math::IParamGradFunction, ROOT::Math::WrappedTF1::BaseGradFunc, ROOT::Fit::Fitter::IGradModel1DFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IParametricGradFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleROOT::Math::IParametricFunctionOneDim::operator()(double x, const double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double* x, const double* p) const; ROOT::Math::IParametricGradFunctionOneDim&operator=(const ROOT::Math::IParametricGradFunctionOneDim&); doubleParameterDerivative(double x, unsigned int ipar = 0) const; doubleParameterDerivative(const double* x, unsigned int ipar = 0) const; doubleParameterDerivative(double x, const double* p, unsigned int ipar = 0) const; doubleParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const; voidParameterGradient(double x, double* grad) const; voidParameterGradient(const double* x, double* grad) const; virtual voidParameterGradient(double x, const double* p, ",MatchSource.WIKI,root/html530/ROOT__Math__IParametricGradFunctionOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IParametricGradFunctionOneDim.html
Integrability,interface,interface,". ROOT::Math::IParametricGradFunctionOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricGradFunctionOneDim. class ROOT::Math::IParametricGradFunctionOneDim: public ROOT::Math::IParametricFunctionOneDim. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>::BaseParFunc, ROOT::Math::IParamGradFunction, ROOT::Math::WrappedTF1::BaseGradFunc, ROOT::Fit::Fitter::IGradModel1DFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IParametricGradFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleROOT::Math::IParametricFunctionOneDim::operator()(double x, const double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double* x, const double* p) const; ROOT::Math::IParametricGradFunctionOneDim&operator=(const ROOT::Math::IParametricGradFunctionOneDim&); doubleParameterDerivative(double x, unsigned int ipar = 0) const; doubleParameterDerivative(const double* x, unsigned int ipar = 0) const; doubleParameterDerivative(double x, const double* p, unsigned int ipar = 0) const; doubleParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const; voidParameterGradient(double x, double* grad) const; voi",MatchSource.WIKI,root/html530/ROOT__Math__IParametricGradFunctionOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IParametricGradFunctionOneDim.html
Performance,cache,cached,"le* p, double* grad) const; virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoParameterDerivative(double x, const double* p, unsigned int ipar) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ParameterGradient(const double* x, const double* p, double* grad) const. Evaluate the all the derivatives (gradient vector) of the function with respect to the parameters at a point x.; It is optional to be implemented by the derived classes for better efficiency. double ParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const. Evaluate the partial derivative w.r.t a parameter ipar from values and parameters. return DoParameterDerivative(x, p, ipar). void ParameterGradient(const double* x, double* grad) const. Evaluate all derivatives using cached parameter values. return ParameterGradient(x, Parameters(), grad). double ParameterDerivative(const double* x, unsigned int ipar = 0) const. Evaluate partial derivative using cached parameter values. virtual ~IParametricGradFunctionOneDim(). Virtual Destructor (no operations). {}. void ParameterGradient(double x, const double* p, double* grad) const. Evaluate the derivatives of the function with respect to the parameters at a point x.; It is optional to be implemented by the derived classes for better efficiency if needed. double ParameterDerivative(double x, const double* p, unsigned int ipar = 0) const. Partial derivative with respect a parameter. double ParameterDerivative(double x, unsigned int ipar = 0) const. Evaluate partial derivative using cached parameter values. » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated",MatchSource.WIKI,root/html530/ROOT__Math__IParametricGradFunctionOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IParametricGradFunctionOneDim.html
Safety,avoid,avoid,". ROOT::Math::IParametricGradFunctionOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IParametricGradFunctionOneDim. class ROOT::Math::IParametricGradFunctionOneDim: public ROOT::Math::IParametricFunctionOneDim. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>::BaseParFunc, ROOT::Math::IParamGradFunction, ROOT::Math::WrappedTF1::BaseGradFunc, ROOT::Fit::Fitter::IGradModel1DFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IParametricGradFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleROOT::Math::IParametricFunctionOneDim::operator()(double x, const double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double* x, const double* p) const; ROOT::Math::IParametricGradFunctionOneDim&operator=(const ROOT::Math::IParametricGradFunctionOneDim&); doubleParameterDerivative(double x, unsigned int ipar = 0) const; doubleParameterDerivative(const double* x, unsigned int ipar = 0) const; doubleParameterDerivative(double x, const double* p, unsigned int ipar = 0) const; doubleParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const; voidParameterGradient(double x, double* grad) const; voi",MatchSource.WIKI,root/html530/ROOT__Math__IParametricGradFunctionOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IParametricGradFunctionOneDim.html
Availability,avail,available,". ROOT::Math::IRootFinderMethod. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::IRootFinderMethod. class ROOT::Math::IRootFinderMethod. Interface for finding function roots of one-dimensional functions. @ingroup RootFinders. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IRootFinderMethod(); virtual intIterate(); virtual intIterations() const; virtual const char*Name() const; ROOT::Math::IRootFinderMethod&operator=(const ROOT::Math::IRootFinderMethod&); virtual doubleRoot() const; virtual boolSetFunction(const ROOT::Math::IGradFunction&, double); virtual boolSetFunction(const ROOT::Math::IGenFunction&, double, double); virtual boolSolve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); virtual intStatus() const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IRootFinderMethod(); Default Destructor. . {}. bool SetFunction(const ROOT::Math::IGradFunction& , double ); Common functionality; Sets the function for algorithms using derivatives. . bool SetFunction(const ROOT::Math::IGenFunction& , double , double ); Sets the function for the rest of the algorithms.; The parameters set the interval where the root has to be calculated. . double Root() const; Returns the previously calculated root. . int Status() const; Returns the status of the previous estimate . bool Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); Methods to be Implemented in the derived classes; Stimates the root for the function.; \@param maxIter maximum number of iterations.; \@param absTol desired absolute error in the minimum position.; \@param absTol desired relative error in the minimum position. const char* Name",MatchSource.WIKI,root/html530/ROOT__Math__IRootFinderMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__IRootFinderMethod.html
Performance,perform,performed,"( Boost const & b ). Construct from a pure boost. { b.GetLorentzRotation( fM+0 ); }. explicit LorentzRotation( BoostX const & bx ); { bx.GetLorentzRotation( fM+0 ); }. explicit LorentzRotation( BoostY const & by ); { by.GetLorentzRotation( fM+0 ); }. explicit LorentzRotation( BoostZ const & bz ); { bz.GetLorentzRotation( fM+0 ); }. explicit LorentzRotation( Rotation3D const & r ). Construct from a 3-D rotation (no space-time mixing). explicit LorentzRotation( AxisAngle const & a ). explicit LorentzRotation( EulerAngles const & e ). explicit LorentzRotation( Quaternion const & q ). explicit LorentzRotation( RotationX const & r ). explicit LorentzRotation( RotationY const & r ). explicit LorentzRotation( RotationZ const & r ). explicit LorentzRotation(const ForeignMatrix & m). Construct from a linear algebra matrix of size at least 4x4,; which must support operator()(i,j) to obtain elements (0,3) thru (3,3).; Precondition: The matrix is assumed to be orthosymplectic. NO checking; or re-adjusting is performed.; Note: (0,0) refers to the XX component; (3,3) refers to the TT component. { SetComponents(m); }. SetComponents(ROOT::Math::LorentzRotation::Scalar xx, ROOT::Math::LorentzRotation::Scalar xy, ROOT::Math::LorentzRotation::Scalar xz, ROOT::Math::LorentzRotation::Scalar xt, ROOT::Math::LorentzRotation::Scalar yx, ROOT::Math::LorentzRotation::Scalar yy, ROOT::Math::LorentzRotation::Scalar yz, ROOT::Math::LorentzRotation::Scalar yt, ROOT::Math::LorentzRotation::Scalar zx, ROOT::Math::LorentzRotation::Scalar zy, ROOT::Math::LorentzRotation::Scalar zz, ROOT::Math::LorentzRotation::Scalar zt, ROOT::Math::LorentzRotation::Scalar tx, ROOT::Math::LorentzRotation::Scalar ty, ROOT::Math::LorentzRotation::Scalar tz, ROOT::Math::LorentzRotation::Scalar tt). Assign from another LorentzRotation. SetComponents(ROOT::Math::LorentzRotation::Scalar xx, ROOT::Math::LorentzRotation::Scalar xy, ROOT::Math::LorentzRotation::Scalar xz, ROOT::Math::LorentzRotation::Scalar xt, ROOT::Math::Lo",MatchSource.WIKI,root/html530/ROOT__Math__LorentzRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzRotation.html
Availability,toler,tolerance,"::PtEtaPhiE4D<Double32_t> >::Scalarenergy() const; ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::ScalarEt() const; ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::ScalarEt2() const; ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::ScalarEta() const; ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalareta() const; ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::ScalarGamma() const; voidGetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar* dest) const; voidGetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar& d) const; boolisLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const; boolisSpacelike() const; boolisTimelike() const; ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >(); ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >&); ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar& a, const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar& b, const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar& c, const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar& d); ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::ScalarM() const; ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t>",MatchSource.WIKI,root/html530/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html
Energy Efficiency,energy,energy,">::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar ee). bool operator==(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >& rhs) const. Scalar Px() const; ------ Individual element access, in various coordinate systems ------; individual coordinate accessors in various coordinate systems. spatial X component. { return fCoordinates.Px(); }. Scalar X() const. spatial Y component. { return fCoordinates.Px(); }. Scalar Py() const; { return fCoordinates.Py(); }. Scalar Y() const. spatial Z component. { return fCoordinates.Py(); }. Scalar Pz() const; { return fCoordinates.Pz(); }. Scalar Z() const. return 4-th component (time, or energy for a 4-momentum vector). { return fCoordinates.Pz(); }. Scalar E() const; { return fCoordinates.E(); }. Scalar T() const. return magnitude (mass) squared M2 = T**2 - X**2 - Y**2 - Z**2; (we use -,-,-,+ metric). { return fCoordinates.E(); }. Scalar M2() const. return magnitude (mass) using the (-,-,-,+) metric.; If M2 is negative (space-like vector) a GenVector_exception; is suggested and if continuing, - sqrt( -M2) is returned. { return fCoordinates.M2(); }. Scalar M() const. return the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) ). { return fCoordinates.M();}. Scalar R() const; { return fCoordinates.R(); }. Scalar P() const. return the square of the spatial (3D) magnitude ( X**2 + Y**2 + Z**2 ). { return fCoordinates.R(); }. Scalar P2() const. return the square of the transverse spatial component ( X**2 + Y**2 ). { return P() * P(); }. Scalar Perp2() const; { return fCoordinates.Perp2();}. Scalar Pt() const. return the transverse spatial component sqrt ( X**2 + Y**2 ). {",MatchSource.WIKI,root/html530/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html
Security,access,access,"inatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LorentzVector & operator=(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >& ); ------ assignment ------. Assignment operator from a lorentz vector of arbitrary type. SetXYZT(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar tt). fCoordinates. SetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar d). const CoordSystem & Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a const reference to the coordinates object. LorentzVector<CoordSystem>& SetCoordinates(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar& d) const. get internal data into 4 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c, d); }. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. fCoordinates. SetPxPyPzE(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar ",MatchSource.WIKI,root/html530/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html
Testability,log,log,"(); }. Scalar Mt2() const. return the transverse mass squared; \f[ m_t^2 = E^2 - p{_z}^2 \f]. { return fCoordinates.Mt2(); }. Scalar Mt() const. return the transverse mass; \f[ \sqrt{ m_t^2 = E^2 - p{_z}^2} X sign(E^ - p{_z}^2) \f]. { return fCoordinates.Mt(); }. Scalar Et2() const. return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(",MatchSource.WIKI,root/html530/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_Double32_t___.html
Availability,toler,tolerance,"re() const; ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalarenergy() const; ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::ScalarEt() const; ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::ScalarEt2() const; ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::ScalarEta() const; ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalareta() const; ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::ScalarGamma() const; voidGetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar* dest) const; voidGetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar& d) const; boolisLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const; boolisSpacelike() const; boolisTimelike() const; ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >(); ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >&); ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar& a, const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar& b, const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar& c, const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar& d); ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::ScalarM() const; ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::ScalarM2() const; ROOT::Math::LorentzVector<ROOT",MatchSource.WIKI,root/html530/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html
Energy Efficiency,energy,energy,"PtEtaPhiE4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar ee). bool operator==(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >& rhs) const. Scalar Px() const; ------ Individual element access, in various coordinate systems ------; individual coordinate accessors in various coordinate systems. spatial X component. { return fCoordinates.Px(); }. Scalar X() const. spatial Y component. { return fCoordinates.Px(); }. Scalar Py() const; { return fCoordinates.Py(); }. Scalar Y() const. spatial Z component. { return fCoordinates.Py(); }. Scalar Pz() const; { return fCoordinates.Pz(); }. Scalar Z() const. return 4-th component (time, or energy for a 4-momentum vector). { return fCoordinates.Pz(); }. Scalar E() const; { return fCoordinates.E(); }. Scalar T() const. return magnitude (mass) squared M2 = T**2 - X**2 - Y**2 - Z**2; (we use -,-,-,+ metric). { return fCoordinates.E(); }. Scalar M2() const. return magnitude (mass) using the (-,-,-,+) metric.; If M2 is negative (space-like vector) a GenVector_exception; is suggested and if continuing, - sqrt( -M2) is returned. { return fCoordinates.M2(); }. Scalar M() const. return the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) ). { return fCoordinates.M();}. Scalar R() const; { return fCoordinates.R(); }. Scalar P() const. return the square of the spatial (3D) magnitude ( X**2 + Y**2 + Z**2 ). { return fCoordinates.R(); }. Scalar P2() const. return the square of the transverse spatial component ( X**2 + Y**2 ). { return P() * P(); }. Scalar Perp2() const; { return fCoordinates.Perp2();}. Scalar Pt() const. return the transverse spatial component sqrt ( X**2 + Y**2 ). {",MatchSource.WIKI,root/html530/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html
Security,access,access,"nst. Data Members; private:. ROOT::Math::PtEtaPhiE4D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LorentzVector & operator=( const LorentzVector<OtherCoords> & v); ------ assignment ------. Assignment operator from a lorentz vector of arbitrary type. SetXYZT(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar tt). fCoordinates. SetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar d). const CoordSystem & Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a const reference to the coordinates object. LorentzVector<CoordSystem>& SetCoordinates(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar& d) const. get internal data into 4 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c, d); }. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. fCoordinates. SetPxPyPzE(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar xx, ROOT::Math::LorentzVecto",MatchSource.WIKI,root/html530/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html
Testability,log,log,"verse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. Scalar Dot(const OtherLorentzVector & q); ------ Operations combining two Lorentz vectors ------. scalar (Dot) product of two LorentzVector vectors (metric is -,-,-,+); Enable the product using any other LorentzVector implementing; the x(), y() , y() and t() member functions; \param q any LorentzVector implementing the x(), y() , z() and t(); member functions; \return the result of v.q of type according to the base scalar type of v. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }",MatchSource.WIKI,root/html530/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html
Availability,toler,tolerance,"::PtEtaPhiM4D<Double32_t> >::Scalarenergy() const; ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::ScalarEt() const; ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::ScalarEt2() const; ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::ScalarEta() const; ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalareta() const; ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::ScalarGamma() const; voidGetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar* dest) const; voidGetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar& d) const; boolisLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const; boolisSpacelike() const; boolisTimelike() const; ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >(); ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >&); ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar& a, const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar& b, const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar& c, const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar& d); ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::ScalarM() const; ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t>",MatchSource.WIKI,root/html530/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html
Energy Efficiency,energy,energy,">::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar ee). bool operator==(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >& rhs) const. Scalar Px() const; ------ Individual element access, in various coordinate systems ------; individual coordinate accessors in various coordinate systems. spatial X component. { return fCoordinates.Px(); }. Scalar X() const. spatial Y component. { return fCoordinates.Px(); }. Scalar Py() const; { return fCoordinates.Py(); }. Scalar Y() const. spatial Z component. { return fCoordinates.Py(); }. Scalar Pz() const; { return fCoordinates.Pz(); }. Scalar Z() const. return 4-th component (time, or energy for a 4-momentum vector). { return fCoordinates.Pz(); }. Scalar E() const; { return fCoordinates.E(); }. Scalar T() const. return magnitude (mass) squared M2 = T**2 - X**2 - Y**2 - Z**2; (we use -,-,-,+ metric). { return fCoordinates.E(); }. Scalar M2() const. return magnitude (mass) using the (-,-,-,+) metric.; If M2 is negative (space-like vector) a GenVector_exception; is suggested and if continuing, - sqrt( -M2) is returned. { return fCoordinates.M2(); }. Scalar M() const. return the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) ). { return fCoordinates.M();}. Scalar R() const; { return fCoordinates.R(); }. Scalar P() const. return the square of the spatial (3D) magnitude ( X**2 + Y**2 + Z**2 ). { return fCoordinates.R(); }. Scalar P2() const. return the square of the transverse spatial component ( X**2 + Y**2 ). { return P() * P(); }. Scalar Perp2() const; { return fCoordinates.Perp2();}. Scalar Pt() const. return the transverse spatial component sqrt ( X**2 + Y**2 ). {",MatchSource.WIKI,root/html530/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html
Security,access,access,"inatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LorentzVector & operator=(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >& ); ------ assignment ------. Assignment operator from a lorentz vector of arbitrary type. SetXYZT(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar tt). fCoordinates. SetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar d). const CoordSystem & Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a const reference to the coordinates object. LorentzVector<CoordSystem>& SetCoordinates(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar& d) const. get internal data into 4 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c, d); }. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. fCoordinates. SetPxPyPzE(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar ",MatchSource.WIKI,root/html530/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html
Testability,log,log,"(); }. Scalar Mt2() const. return the transverse mass squared; \f[ m_t^2 = E^2 - p{_z}^2 \f]. { return fCoordinates.Mt2(); }. Scalar Mt() const. return the transverse mass; \f[ \sqrt{ m_t^2 = E^2 - p{_z}^2} X sign(E^ - p{_z}^2) \f]. { return fCoordinates.Mt(); }. Scalar Et2() const. return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(",MatchSource.WIKI,root/html530/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_Double32_t___.html
Availability,toler,tolerance,"re() const; ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalarenergy() const; ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::ScalarEt() const; ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::ScalarEt2() const; ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::ScalarEta() const; ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalareta() const; ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::ScalarGamma() const; voidGetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar* dest) const; voidGetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar& d) const; boolisLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const; boolisSpacelike() const; boolisTimelike() const; ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >(); ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >&); ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar& a, const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar& b, const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar& c, const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar& d); ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::ScalarM() const; ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::ScalarM2() const; ROOT::Math::LorentzVector<ROOT",MatchSource.WIKI,root/html530/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html
Energy Efficiency,energy,energy,"PtEtaPhiM4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar ee). bool operator==(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >& rhs) const. Scalar Px() const; ------ Individual element access, in various coordinate systems ------; individual coordinate accessors in various coordinate systems. spatial X component. { return fCoordinates.Px(); }. Scalar X() const. spatial Y component. { return fCoordinates.Px(); }. Scalar Py() const; { return fCoordinates.Py(); }. Scalar Y() const. spatial Z component. { return fCoordinates.Py(); }. Scalar Pz() const; { return fCoordinates.Pz(); }. Scalar Z() const. return 4-th component (time, or energy for a 4-momentum vector). { return fCoordinates.Pz(); }. Scalar E() const; { return fCoordinates.E(); }. Scalar T() const. return magnitude (mass) squared M2 = T**2 - X**2 - Y**2 - Z**2; (we use -,-,-,+ metric). { return fCoordinates.E(); }. Scalar M2() const. return magnitude (mass) using the (-,-,-,+) metric.; If M2 is negative (space-like vector) a GenVector_exception; is suggested and if continuing, - sqrt( -M2) is returned. { return fCoordinates.M2(); }. Scalar M() const. return the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) ). { return fCoordinates.M();}. Scalar R() const; { return fCoordinates.R(); }. Scalar P() const. return the square of the spatial (3D) magnitude ( X**2 + Y**2 + Z**2 ). { return fCoordinates.R(); }. Scalar P2() const. return the square of the transverse spatial component ( X**2 + Y**2 ). { return P() * P(); }. Scalar Perp2() const; { return fCoordinates.Perp2();}. Scalar Pt() const. return the transverse spatial component sqrt ( X**2 + Y**2 ). {",MatchSource.WIKI,root/html530/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html
Security,access,access,"nst. Data Members; private:. ROOT::Math::PtEtaPhiM4D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LorentzVector & operator=( const LorentzVector<OtherCoords> & v); ------ assignment ------. Assignment operator from a lorentz vector of arbitrary type. SetXYZT(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar tt). fCoordinates. SetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar d). const CoordSystem & Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a const reference to the coordinates object. LorentzVector<CoordSystem>& SetCoordinates(const ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar& d) const. get internal data into 4 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c, d); }. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. fCoordinates. SetPxPyPzE(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar xx, ROOT::Math::LorentzVecto",MatchSource.WIKI,root/html530/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html
Testability,log,log,"verse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. Scalar Dot(const OtherLorentzVector & q); ------ Operations combining two Lorentz vectors ------. scalar (Dot) product of two LorentzVector vectors (metric is -,-,-,+); Enable the product using any other LorentzVector implementing; the x(), y() , y() and t() member functions; \param q any LorentzVector implementing the x(), y() , z() and t(); member functions; \return the result of v.q of type according to the base scalar type of v. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }",MatchSource.WIKI,root/html530/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html
Availability,toler,tolerance,"LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalarenergy() const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::ScalarEt() const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::ScalarEt2() const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::ScalarEta() const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalareta() const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::ScalarGamma() const; voidGetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar* dest) const; voidGetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar& d) const; boolisLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const; boolisSpacelike() const; boolisTimelike() const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >(); ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >&); ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar& a, const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar& b, const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar& c, const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar& d); ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::ScalarM() const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::ScalarM2() const; ROOT",MatchSource.WIKI,root/html530/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html
Energy Efficiency,energy,energy,"uble32_t> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar ee). bool operator==(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >& rhs) const. Scalar Px() const; ------ Individual element access, in various coordinate systems ------; individual coordinate accessors in various coordinate systems. spatial X component. { return fCoordinates.Px(); }. Scalar X() const. spatial Y component. { return fCoordinates.Px(); }. Scalar Py() const; { return fCoordinates.Py(); }. Scalar Y() const. spatial Z component. { return fCoordinates.Py(); }. Scalar Pz() const; { return fCoordinates.Pz(); }. Scalar Z() const. return 4-th component (time, or energy for a 4-momentum vector). { return fCoordinates.Pz(); }. Scalar E() const; { return fCoordinates.E(); }. Scalar T() const. return magnitude (mass) squared M2 = T**2 - X**2 - Y**2 - Z**2; (we use -,-,-,+ metric). { return fCoordinates.E(); }. Scalar M2() const. return magnitude (mass) using the (-,-,-,+) metric.; If M2 is negative (space-like vector) a GenVector_exception; is suggested and if continuing, - sqrt( -M2) is returned. { return fCoordinates.M2(); }. Scalar M() const. return the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) ). { return fCoordinates.M();}. Scalar R() const; { return fCoordinates.R(); }. Scalar P() const. return the square of the spatial (3D) magnitude ( X**2 + Y**2 + Z**2 ). { return fCoordinates.R(); }. Scalar P2() const. return the square of the transverse spatial component ( X**2 + Y**2 ). { return P() * P(); }. Scalar Perp2() const; { return fCoordinates.Perp2();}. Scalar Pt() const. return the transverse spatial component sqrt ( X**2 + Y**2 ). {",MatchSource.WIKI,root/html530/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html
Security,access,access,"<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LorentzVector & operator=(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >& ); ------ assignment ------. Assignment operator from a lorentz vector of arbitrary type. SetXYZT(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar tt). fCoordinates. SetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar a, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar b, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar c, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar d). const CoordSystem & Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a const reference to the coordinates object. LorentzVector<CoordSystem>& SetCoordinates(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar& d) const. get internal data into 4 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c, d); }. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. fCoordinates. SetPxPyPzE(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar xx, ROOT::Math",MatchSource.WIKI,root/html530/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html
Testability,log,log,"(); }. Scalar Mt2() const. return the transverse mass squared; \f[ m_t^2 = E^2 - p{_z}^2 \f]. { return fCoordinates.Mt2(); }. Scalar Mt() const. return the transverse mass; \f[ \sqrt{ m_t^2 = E^2 - p{_z}^2} X sign(E^ - p{_z}^2) \f]. { return fCoordinates.Mt(); }. Scalar Et2() const. return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px();",MatchSource.WIKI,root/html530/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html
Availability,toler,tolerance,"PyPzE4D<double> >::Scalare() const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalarenergy() const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::ScalarEt() const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::ScalarEt2() const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::ScalarEta() const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalareta() const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::ScalarGamma() const; voidGetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar* dest) const; voidGetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar& d) const; boolisLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const; boolisSpacelike() const; boolisTimelike() const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >LorentzVector<ROOT::Math::PxPyPzE4D<double> >(); ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >LorentzVector<ROOT::Math::PxPyPzE4D<double> >(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >&); ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >LorentzVector<ROOT::Math::PxPyPzE4D<double> >(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar& a, const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar& b, const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar& c, const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar& d); ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::ScalarM() const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::ScalarM2() const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> ",MatchSource.WIKI,root/html530/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html
Energy Efficiency,energy,energy,"ROOT::Math::PxPyPzE4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar ee). bool operator==(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >& rhs) const. Scalar Px() const; ------ Individual element access, in various coordinate systems ------; individual coordinate accessors in various coordinate systems. spatial X component. { return fCoordinates.Px(); }. Scalar X() const. spatial Y component. { return fCoordinates.Px(); }. Scalar Py() const; { return fCoordinates.Py(); }. Scalar Y() const. spatial Z component. { return fCoordinates.Py(); }. Scalar Pz() const; { return fCoordinates.Pz(); }. Scalar Z() const. return 4-th component (time, or energy for a 4-momentum vector). { return fCoordinates.Pz(); }. Scalar E() const; { return fCoordinates.E(); }. Scalar T() const. return magnitude (mass) squared M2 = T**2 - X**2 - Y**2 - Z**2; (we use -,-,-,+ metric). { return fCoordinates.E(); }. Scalar M2() const. return magnitude (mass) using the (-,-,-,+) metric.; If M2 is negative (space-like vector) a GenVector_exception; is suggested and if continuing, - sqrt( -M2) is returned. { return fCoordinates.M2(); }. Scalar M() const. return the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) ). { return fCoordinates.M();}. Scalar R() const; { return fCoordinates.R(); }. Scalar P() const. return the square of the spatial (3D) magnitude ( X**2 + Y**2 + Z**2 ). { return fCoordinates.R(); }. Scalar P2() const. return the square of the transverse spatial component ( X**2 + Y**2 ). { return P() * P(); }. Scalar Perp2() const; { return fCoordinates.Perp2();}. Scalar Pt() const. return the transverse spatial component sqrt ( X**2 + Y**2 ). {",MatchSource.WIKI,root/html530/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html
Security,access,access,"e> >::Scalarz() const. Data Members; private:. ROOT::Math::PxPyPzE4D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LorentzVector & operator=( const LorentzVector<OtherCoords> & v); ------ assignment ------. Assignment operator from a lorentz vector of arbitrary type. SetXYZT(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar tt). fCoordinates. SetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar a, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar b, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar c, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar d). const CoordSystem & Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a const reference to the coordinates object. LorentzVector<CoordSystem>& SetCoordinates(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar& d) const. get internal data into 4 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c, d); }. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. fCoordinates. SetPxPyPzE(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::",MatchSource.WIKI,root/html530/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html
Testability,log,log,"verse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. Scalar Dot(const OtherLorentzVector & q); ------ Operations combining two Lorentz vectors ------. scalar (Dot) product of two LorentzVector vectors (metric is -,-,-,+); Enable the product using any other LorentzVector implementing; the x(), y() , y() and t() member functions; \param q any LorentzVector implementing the x(), y() , z() and t(); member functions; \return the result of v.q of type according to the base scalar type of v. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. ",MatchSource.WIKI,root/html530/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html
Availability,toler,tolerance,"LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalarenergy() const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::ScalarEt() const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::ScalarEt2() const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::ScalarEta() const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalareta() const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::ScalarGamma() const; voidGetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar* dest) const; voidGetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar& d) const; boolisLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const; boolisSpacelike() const; boolisTimelike() const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >(); ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >&); ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar& a, const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar& b, const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar& c, const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar& d); ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::ScalarM() const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::ScalarM2() const; ROOT",MatchSource.WIKI,root/html530/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html
Energy Efficiency,energy,energy,"uble32_t> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar ee). bool operator==(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >& rhs) const. Scalar Px() const; ------ Individual element access, in various coordinate systems ------; individual coordinate accessors in various coordinate systems. spatial X component. { return fCoordinates.Px(); }. Scalar X() const. spatial Y component. { return fCoordinates.Px(); }. Scalar Py() const; { return fCoordinates.Py(); }. Scalar Y() const. spatial Z component. { return fCoordinates.Py(); }. Scalar Pz() const; { return fCoordinates.Pz(); }. Scalar Z() const. return 4-th component (time, or energy for a 4-momentum vector). { return fCoordinates.Pz(); }. Scalar E() const; { return fCoordinates.E(); }. Scalar T() const. return magnitude (mass) squared M2 = T**2 - X**2 - Y**2 - Z**2; (we use -,-,-,+ metric). { return fCoordinates.E(); }. Scalar M2() const. return magnitude (mass) using the (-,-,-,+) metric.; If M2 is negative (space-like vector) a GenVector_exception; is suggested and if continuing, - sqrt( -M2) is returned. { return fCoordinates.M2(); }. Scalar M() const. return the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) ). { return fCoordinates.M();}. Scalar R() const; { return fCoordinates.R(); }. Scalar P() const. return the square of the spatial (3D) magnitude ( X**2 + Y**2 + Z**2 ). { return fCoordinates.R(); }. Scalar P2() const. return the square of the transverse spatial component ( X**2 + Y**2 ). { return P() * P(); }. Scalar Perp2() const; { return fCoordinates.Perp2();}. Scalar Pt() const. return the transverse spatial component sqrt ( X**2 + Y**2 ). {",MatchSource.WIKI,root/html530/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html
Security,access,access,"<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LorentzVector & operator=(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >& ); ------ assignment ------. Assignment operator from a lorentz vector of arbitrary type. SetXYZT(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar tt). fCoordinates. SetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar a, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar b, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar c, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar d). const CoordSystem & Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a const reference to the coordinates object. LorentzVector<CoordSystem>& SetCoordinates(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar& d) const. get internal data into 4 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c, d); }. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. fCoordinates. SetPxPyPzE(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar xx, ROOT::Math",MatchSource.WIKI,root/html530/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html
Testability,log,log,"(); }. Scalar Mt2() const. return the transverse mass squared; \f[ m_t^2 = E^2 - p{_z}^2 \f]. { return fCoordinates.Mt2(); }. Scalar Mt() const. return the transverse mass; \f[ \sqrt{ m_t^2 = E^2 - p{_z}^2} X sign(E^ - p{_z}^2) \f]. { return fCoordinates.Mt(); }. Scalar Et2() const. return the transverse energy squared; \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px();",MatchSource.WIKI,root/html530/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html
Availability,toler,tolerance,"PyPzM4D<double> >::Scalare() const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalarenergy() const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::ScalarEt() const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::ScalarEt2() const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::ScalarEta() const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalareta() const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::ScalarGamma() const; voidGetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar* dest) const; voidGetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar& d) const; boolisLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const; boolisSpacelike() const; boolisTimelike() const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >LorentzVector<ROOT::Math::PxPyPzM4D<double> >(); ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >LorentzVector<ROOT::Math::PxPyPzM4D<double> >(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >&); ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >LorentzVector<ROOT::Math::PxPyPzM4D<double> >(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar& a, const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar& b, const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar& c, const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar& d); ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::ScalarM() const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::ScalarM2() const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> ",MatchSource.WIKI,root/html530/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html
Energy Efficiency,energy,energy,"ROOT::Math::PxPyPzM4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar ee). bool operator==(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >& rhs) const. Scalar Px() const; ------ Individual element access, in various coordinate systems ------; individual coordinate accessors in various coordinate systems. spatial X component. { return fCoordinates.Px(); }. Scalar X() const. spatial Y component. { return fCoordinates.Px(); }. Scalar Py() const; { return fCoordinates.Py(); }. Scalar Y() const. spatial Z component. { return fCoordinates.Py(); }. Scalar Pz() const; { return fCoordinates.Pz(); }. Scalar Z() const. return 4-th component (time, or energy for a 4-momentum vector). { return fCoordinates.Pz(); }. Scalar E() const; { return fCoordinates.E(); }. Scalar T() const. return magnitude (mass) squared M2 = T**2 - X**2 - Y**2 - Z**2; (we use -,-,-,+ metric). { return fCoordinates.E(); }. Scalar M2() const. return magnitude (mass) using the (-,-,-,+) metric.; If M2 is negative (space-like vector) a GenVector_exception; is suggested and if continuing, - sqrt( -M2) is returned. { return fCoordinates.M2(); }. Scalar M() const. return the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) ). { return fCoordinates.M();}. Scalar R() const; { return fCoordinates.R(); }. Scalar P() const. return the square of the spatial (3D) magnitude ( X**2 + Y**2 + Z**2 ). { return fCoordinates.R(); }. Scalar P2() const. return the square of the transverse spatial component ( X**2 + Y**2 ). { return P() * P(); }. Scalar Perp2() const; { return fCoordinates.Perp2();}. Scalar Pt() const. return the transverse spatial component sqrt ( X**2 + Y**2 ). {",MatchSource.WIKI,root/html530/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html
Security,access,access,"e> >::Scalarz() const. Data Members; private:. ROOT::Math::PxPyPzM4D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LorentzVector & operator=( const LorentzVector<OtherCoords> & v); ------ assignment ------. Assignment operator from a lorentz vector of arbitrary type. SetXYZT(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar tt). fCoordinates. SetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar a, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar b, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar c, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar d). const CoordSystem & Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a const reference to the coordinates object. LorentzVector<CoordSystem>& SetCoordinates(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar& d) const. get internal data into 4 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c, d); }. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. fCoordinates. SetPxPyPzE(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::",MatchSource.WIKI,root/html530/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html
Testability,log,log,"verse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. Scalar Dot(const OtherLorentzVector & q); ------ Operations combining two Lorentz vectors ------. scalar (Dot) product of two LorentzVector vectors (metric is -,-,-,+); Enable the product using any other LorentzVector implementing; the x(), y() , y() and t() member functions; \param q any LorentzVector implementing the x(), y() , z() and t(); member functions; \return the result of v.q of type according to the base scalar type of v. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. ",MatchSource.WIKI,root/html530/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html
Integrability,wrap,wraps,". ROOT::Math::LSResidualFunc. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::LSResidualFunc. class ROOT::Math::LSResidualFunc: public ROOT::Math::IGradientFunctionMultiDim. LSResidualFunc class description.; Internal class used for accessing the residuals of the Least Square function; and their derivates which are estimated numerically using GSL numerical derivation.; The class contains a pointer to the fit method function and an index specifying; the i-th residual and wraps it in a multi-dim gradient function interface; ROOT::Math::IGradientFunctionMultiDim.; The class is used by ROOT::Math::GSLNLSMinimizer (GSL non linear least square fitter). @ingroup MultiMin. Function Members (Methods); public:. ~LSResidualFunc(); virtual ROOT::Math::IMultiGenFunction*Clone() const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* g) const; virtual voidGradient(const double* x, double* g) const; ROOT::Math::LSResidualFuncLSResidualFunc(); ROOT::Math::LSResidualFuncLSResidualFunc(const ROOT::Math::LSResidualFunc& rhs); ROOT::Math::LSResidualFuncLSResidualFunc(const ROOT::Math::FitMethodFunction& func, unsigned int i); virtual unsigned intNDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::LSResidualFunc&operator=(const ROOT::Math::LSResidualFunc& rhs). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const. Data Members; private:. const ROOT::Math::FitMethodFunction*fChi2; unsigned intfIndex; vector<double>fX2cached vector. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LSResidualFunc(); default ctor (required by CINT). {}. LSResidualFunc(const RO",MatchSource.WIKI,root/html530/ROOT__Math__LSResidualFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LSResidualFunc.html
Security,access,accessing,". ROOT::Math::LSResidualFunc. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::LSResidualFunc. class ROOT::Math::LSResidualFunc: public ROOT::Math::IGradientFunctionMultiDim. LSResidualFunc class description.; Internal class used for accessing the residuals of the Least Square function; and their derivates which are estimated numerically using GSL numerical derivation.; The class contains a pointer to the fit method function and an index specifying; the i-th residual and wraps it in a multi-dim gradient function interface; ROOT::Math::IGradientFunctionMultiDim.; The class is used by ROOT::Math::GSLNLSMinimizer (GSL non linear least square fitter). @ingroup MultiMin. Function Members (Methods); public:. ~LSResidualFunc(); virtual ROOT::Math::IMultiGenFunction*Clone() const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* g) const; virtual voidGradient(const double* x, double* g) const; ROOT::Math::LSResidualFuncLSResidualFunc(); ROOT::Math::LSResidualFuncLSResidualFunc(const ROOT::Math::LSResidualFunc& rhs); ROOT::Math::LSResidualFuncLSResidualFunc(const ROOT::Math::FitMethodFunction& func, unsigned int i); virtual unsigned intNDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::LSResidualFunc&operator=(const ROOT::Math::LSResidualFunc& rhs). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const. Data Members; private:. const ROOT::Math::FitMethodFunction*fChi2; unsigned intfIndex; vector<double>fX2cached vector. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LSResidualFunc(); default ctor (required by CINT). {}. LSResidualFunc(const RO",MatchSource.WIKI,root/html530/ROOT__Math__LSResidualFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__LSResidualFunc.html
Usability,simpl,simplest,". ROOT::Math::Minim1D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; namespace description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::Minim1D. namespace ROOT::Math::Minim1D. Minimizer for arbitrary one dimensional functions. Implemented using GSL, for detailed description see:; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/One-dimensional-Minimization.html"">GSL online doc</A>. The algorithms uspported are only bracketing algorithm which do not use derivatives information.; The algorithms which can be choosen at construction time are GOLDENSECTION, whic is the simplest method; but the slowest and BRENT (the default one) which combines the golden section with a parabolic interpolation. This class does not support copying; @ingroup Min1D. Function Members (Methods). Data Members. Class Charts; Function documentation. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 moneta, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: GSLMinimizer1D.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__Minim1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Minim1D.html
Availability,error,error,"tract Minimizer class, defining the interface for the various minimizer; (like Minuit2, Minuit, GSL, etc..); Plug-in's exist in ROOT to be able to instantiate the derived classes like; ROOT::Math::GSLMinimizer or ROOT::Math::Minuit2Minimizer via the; plug-in manager. Provides interface for setting the function to be minimized.; The function must implemente the multi-dimensional generic interface; ROOT::Math::IBaseFunctionMultiDim.; If the function provides gradient calculation; (implements the ROOT::Math::IGradientFunctionMultiDim interface) this will be; used by the Minimizer. It Defines also interface for setting the initial values for the function variables (which are the parameters in; of the model function in case of solving for fitting) and especifying their limits. It defines the interface to set and retrieve basic minimization parameters; (for specific Minimizer parameters one must use the derived classes). Then it defines the interface to retrieve the result of minimization ( minimum X values, function value,; gradient, error on the mimnimum, etc...). @ingroup MultiMin. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~Minimizer(); virtual voidClear(); virtual boolContour(unsigned int, unsigned int, unsigned int&, double*, double*); virtual doubleCorrelation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleErrorDef() const; virtual const double*Errors() const; virtual boolGetCovMatrix(double*) const; virtual boolGetHessianMatrix(double*) const; virtual boolGetMinosError(unsigned int, double& errLow, double& errUp, int = 0); virtual doubleGlobalCC(unsigned int) const; virtual boolHesse(); boolIsValidError() const; unsigned intMaxFunctionCalls() const; unsigned intMaxIterations() const; virtual const double*MinGradi",MatchSource.WIKI,root/html530/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Minimizer.html
Deployability,configurat,configuration," i. Variable and function must be set before using Scan; Return false if an error or if minimizer does not support this functionality. bool Contour(unsigned int , unsigned int , unsigned int& , double* , double* ). find the contour points (xi,xj) of the function for parameter i and j around the minimum; The contour will be find for value of the function = Min + ErrorUp();. void PrintResults(); return reference to the objective function; virtual const ROOT::Math::IGenFunction & Function() const = 0;; print the result according to set level (implemented for TMinuit for mantaining Minuit-style printing). {}. std::string VariableName(unsigned int ) const; get name of variables (override if minimizer support storing of variable names); return an empty string if variable is not found. { return std::string();}. int VariableIndex(const string& ) const; get index of variable given a variable given a name; return -1 if variable is not found. { return -1; }. int PrintLevel() const; minimizer configuration parameters ; set print level. { return fDebug; }. unsigned int MaxFunctionCalls() const; max number of function calls. { return fMaxCalls; }. unsigned int MaxIterations() const; max iterations. { return fMaxIter; }. double Tolerance() const; absolute tolerance. { return fTol; }. double Precision() const; precision of minimizer in the evaluation of the objective function; ( a value <=0 corresponds to the let the minimizer choose its default one). { return fPrec; }. int Strategy() const; strategy. { return fStrategy; }. int Status() const; status code of minimizer. { return fStatus; }. double ErrorDef() const; return the statistical scale used for calculate the error; is typically 1 for Chi2 and 0.5 for likelihood minimization. { return fUp; }. bool IsValidError() const; return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit). { return fValidError; }. opt. SetPrintLevel(int level). opt. SetStrategy(int strategyLevel). opt. SetMaxFunctionCa",MatchSource.WIKI,root/html530/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Minimizer.html
Integrability,interface,interface,". ROOT::Math::Minimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::Minimizer. class ROOT::Math::Minimizer. Abstract Minimizer class, defining the interface for the various minimizer; (like Minuit2, Minuit, GSL, etc..); Plug-in's exist in ROOT to be able to instantiate the derived classes like; ROOT::Math::GSLMinimizer or ROOT::Math::Minuit2Minimizer via the; plug-in manager. Provides interface for setting the function to be minimized.; The function must implemente the multi-dimensional generic interface; ROOT::Math::IBaseFunctionMultiDim.; If the function provides gradient calculation; (implements the ROOT::Math::IGradientFunctionMultiDim interface) this will be; used by the Minimizer. It Defines also interface for setting the initial values for the function variables (which are the parameters in; of the model function in case of solving for fitting) and especifying their limits. It defines the interface to set and retrieve basic minimization parameters; (for specific Minimizer parameters one must use the derived classes). Then it defines the interface to retrieve the result of minimization ( minimum X values, function value,; gradient, error on the mimnimum, etc...). @ingroup MultiMin. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~Minimizer(); virtual voidClear(); virtual boolContour(unsigned int, unsigned int, unsigned int&, double*, double*); virtual doubleCorrelation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleErrorDef() const; virtual const double*Errors() const; virtual boolGetCovMatrix(double*) const; virtual boolGetHessianMatrix(",MatchSource.WIKI,root/html530/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Minimizer.html
Modifiability,plug-in,plug-in,". ROOT::Math::Minimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::Minimizer. class ROOT::Math::Minimizer. Abstract Minimizer class, defining the interface for the various minimizer; (like Minuit2, Minuit, GSL, etc..); Plug-in's exist in ROOT to be able to instantiate the derived classes like; ROOT::Math::GSLMinimizer or ROOT::Math::Minuit2Minimizer via the; plug-in manager. Provides interface for setting the function to be minimized.; The function must implemente the multi-dimensional generic interface; ROOT::Math::IBaseFunctionMultiDim.; If the function provides gradient calculation; (implements the ROOT::Math::IGradientFunctionMultiDim interface) this will be; used by the Minimizer. It Defines also interface for setting the initial values for the function variables (which are the parameters in; of the model function in case of solving for fitting) and especifying their limits. It defines the interface to set and retrieve basic minimization parameters; (for specific Minimizer parameters one must use the derived classes). Then it defines the interface to retrieve the result of minimization ( minimum X values, function value,; gradient, error on the mimnimum, etc...). @ingroup MultiMin. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~Minimizer(); virtual voidClear(); virtual boolContour(unsigned int, unsigned int, unsigned int&, double*, double*); virtual doubleCorrelation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleErrorDef() const; virtual const double*Errors() const; virtual boolGetCovMatrix(double*) const; virtual boolGetHessianMatrix(",MatchSource.WIKI,root/html530/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Minimizer.html
Performance,perform,perform,"ction& func); set a function to minimize using gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). return SetLimitedVariable(unsigned int , const string& , double , double , double , double ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int , double ); set the value of an existing variable. { return false; }. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of the existing parameters). bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. double Edm() const; return expected distance reached from the minimum. const double * X() const; return pointer to X values at the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. bool ProvidesError() const; minimizer provides error and error matrix. const double * Errors() const; return errors at the minimum. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. bool GetCovMatrix(double* ) cons",MatchSource.WIKI,root/html530/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Minimizer.html
Security,validat,validated,"dSetOptions(const ROOT::Math::MinimizerOptions& opt); voidSetPrecision(double prec); voidSetPrintLevel(int level); voidSetStrategy(int strategyLevel); voidSetTolerance(double tol); virtual boolSetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); voidSetValidError(bool on); virtual boolSetVariable(unsigned int ivar, const string& name, double val, double step); virtual boolSetVariableValue(unsigned int, double); virtual boolSetVariableValues(const double* x); intStatus() const; intStrategy() const; doubleTolerance() const; virtual intVariableIndex(const string&) const; virtual stringVariableName(unsigned int) const; virtual const double*X() const. private:. ROOT::Math::Minimizer&operator=(const ROOT::Math::Minimizer& rhs). Data Members; protected:. intfDebugprint level; unsigned intfMaxCallsmax number of function calls ; unsigned intfMaxItermax number or iterations used to find the minimum; doublefPrecprecision; intfStatusstatus of minimizer ; intfStrategyminimizer strategy; doublefToltolerance (absolute); doublefUperror scale ; boolfValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~Minimizer(). Destructor (no operations). {}. void Clear(); reset for consecutive minimizations - implement if needed. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set a function to minimize using gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). return SetLimitedVariable(unsigned int , const string& , double , double , double , double ). bool SetUpperLimited",MatchSource.WIKI,root/html530/ROOT__Math__Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Minimizer.html
Availability,error,error,"(int maxcall); static voidSetDefaultMaxIterations(int maxiter); static voidSetDefaultMinimizer(const char* type, const char* algo = 0); static voidSetDefaultPrecision(double prec); static voidSetDefaultPrintLevel(int level); static voidSetDefaultStrategy(int strat); static voidSetDefaultTolerance(double tol); voidSetErrorDef(double err); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetMaxFunctionCalls(unsigned int maxfcn); voidSetMaxIterations(unsigned int maxiter); voidSetMinimizerAlgorithm(const char* type); voidSetMinimizerType(const char* type); voidSetPrecision(double prec); voidSetPrintLevel(int level); voidSetStrategy(int stra); voidSetTolerance(double tol); intStrategy() const; doubleTolerance() const. Data Members; private:. stringfAlgoTypeMinimizer algorithmic specification (Migrad, Minimize, ...); doublefErrorDeferror definition (=1. for getting 1 sigma error for chi2 fits); ROOT::Math::IOptions*fExtraOptionsextra options ; intfLeveldebug print level ; intfMaxCallsmaximum number of function calls; intfMaxItermaximum number of iterations; stringfMinimTypeMinimizer type (Minuit, Minuit2, etc..; doublefPrecisionprecision of the objective function evaluation (value <=0 means left to default); intfStrategyminimizer strategy (used by Minuit); doublefToleranceminimize tolerance to reach solution. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetDefaultMinimizer(const char* type, const char* algo = 0); static methods for setting and retrieving the default options. void SetDefaultErrorDef(double up). void SetDefaultTolerance(double tol). void SetDefaultPrecision(double prec). void SetDefaultMaxFunctionCalls(int maxcall). void SetDefaultMaxIterations(int maxiter). void SetDefaultStrategy(int strat). void SetDefaultPrintLevel(int level). const std::string & DefaultMinimizerType(). const std::string & DefaultMinimizerAlgo(). double DefaultErrorDef(). double DefaultTolerance(). double DefaultPrecision(). i",MatchSource.WIKI,root/html530/ROOT__Math__MinimizerOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__MinimizerOptions.html
Availability,avail,available,"ng like; Parameteric 1D, Multi-Dim or gradient parametric. A parameteric function is a Generic Function with parameters, so; it is a function object which carries a state, the parameters.; The parameters are described with a standard vector of doubles. This class contains the default implementations for the methods defined in the; IParamFunction interface for dealing with parameters; Specific parameteric function classes should derive from this class if they want to profit from; default implementations for the abstract methods.; The derived classes need to implement only the DoEvalPar( x, p) and Clone() methods for non-gradient; parameteric functions or DoParameterDerivative(x,p,ipar) for gradient par functions. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Math::Polynomial::ParFunc, ROOT::Math::ParamFunction<IParamGradFunction>. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; virtual unsigned intNPar() const; doubleROOT::Math::IParametricFunctionOneDim::operator()(double x, const double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double* x, const double* p) const; ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>&operator=(const ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>&); doubleROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(double x, unsigned int ipar = 0) const; doubleROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(const double* x, unsigned int ipar = 0) const; doubleROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(double x, const double* p, unsigned int ipar = 0) const; doubleROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(const",MatchSource.WIKI,root/html530/ROOT__Math__ParamFunction_-p1IParametricGradFunctionOneDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__ParamFunction_-p1IParametricGradFunctionOneDim_.html
Integrability,interface,interface,". ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>. class ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>: public ROOT::Math::IParametricGradFunctionOneDim. Base template class for all Parametric Functions.; The template argument is the type of parameteric function interface is implementing like; Parameteric 1D, Multi-Dim or gradient parametric. A parameteric function is a Generic Function with parameters, so; it is a function object which carries a state, the parameters.; The parameters are described with a standard vector of doubles. This class contains the default implementations for the methods defined in the; IParamFunction interface for dealing with parameters; Specific parameteric function classes should derive from this class if they want to profit from; default implementations for the abstract methods.; The derived classes need to implement only the DoEvalPar( x, p) and Clone() methods for non-gradient; parameteric functions or DoParameterDerivative(x,p,ipar) for gradient par functions. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Math::Polynomial::ParFunc, ROOT::Math::ParamFunction<IParamGradFunction>. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; virtual unsigned intNPar() const; doubleROOT::Math::IParametricFunctionOneDim::operator()(double x, const double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double",MatchSource.WIKI,root/html530/ROOT__Math__ParamFunction_-p1IParametricGradFunctionOneDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__ParamFunction_-p1IParametricGradFunctionOneDim_.html
Availability,avail,available,". ROOT::Math::Plane3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » GENVECTOR; » ROOT::Math::Plane3D. class ROOT::Math::Plane3D. Class describing a geometrical plane in 3 dimensions.; A Plane3D is a 2 dimensional surface spanned by two linearly independent vectors.; The plane is described by the equation; \f$ a*x + b*y + c*z + d = 0 \f$ where (a,b,c) are the components of the; normal vector to the plane \f$ n = (a,b,c) \f$ and \f$ d = - n \dot x \f$, where x is any point; belonging to plane.; More information on the mathematics describing a plane in 3D is available on; <A HREF=http://mathworld.wolfram.com/Plane.html>MathWord</A>.; The Plane3D class contains the 4 scalar values in double which represent the; four coefficients, fA, fB, fC, fD. fA, fB, fC are the normal components normalized to 1,; i.e. fA**2 + fB**2 + fC**2 = 1. @ingroup GenVector. Function Members (Methods); public:. ~Plane3D(); ROOT::Math::Plane3D::ScalarA(); ROOT::Math::Plane3D::ScalarB(); ROOT::Math::Plane3D::ScalarC(); ROOT::Math::Plane3D::ScalarD(); ROOT::Math::Plane3D::ScalarDistance(const ROOT::Math::Plane3D::Point& p) const; ROOT::Math::Plane3D::ScalarHesseDistance() const; ROOT::Math::Plane3D::VectorNormal() const; booloperator!=(const ROOT::Math::Plane3D& rhs) const; ROOT::Math::Plane3D&operator=(const ROOT::Math::Plane3D& plane); booloperator==(const ROOT::Math::Plane3D& rhs) const; ROOT::Math::Plane3DPlane3D(); ROOT::Math::Plane3DPlane3D(const ROOT::Math::Plane3D&); ROOT::Math::Plane3DPlane3D(const ROOT::Math::Plane3D::Vector& n, const ROOT::Math::Plane3D::Point& p); ROOT::Math::Plane3DPlane3D(const ROOT::Math::Plane3D::Point& p1, const ROOT::Math::Plane3D::Point& p2, const ROOT::Math::Plane3D::Point& p3); ROOT::Math::Plane3DPlane3D(const ROOT::Math::Plane3D::Scalar& a, const ROOT::Math::Plane3D::Scalar& b, const ROOT::Math::Plane3D::Scal",MatchSource.WIKI,root/html530/ROOT__Math__Plane3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Plane3D.html
Integrability,interface,interface,". ROOT::Math::Polynomial. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::Polynomial. class ROOT::Math::Polynomial: public ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>, public ROOT::Math::IGradientOneDim. Parametric Function class describing polynomials of order n. <em>P(x) = p[0] + p[1]*x + p[2]*x**2 + ....... + p[n]*x**n</em>. The class implements also the derivatives, \a dP(x)/dx and the \a dP(x)/dp[i]. The class provides also the method to find the roots of the polynomial.; It uses analytical methods up to quartic polynomials. Implements both the Parameteric function interface and the gradient interface; since it provides the analytical gradient with respect to x. @ingroup ParamFunc. Function Members (Methods); public:. virtual~Polynomial(); virtual ROOT::Math::IGenFunction*Clone() const; doubleROOT::Math::IGradientOneDim::Derivative(double x) const; doubleROOT::Math::IGradientOneDim::Derivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; const vector<std::complex<double> >&FindNumRoots(); vector<double>FindRealRoots(); const vector<std::complex<double> >&FindRoots(); voidROOT::Math::IGradientOneDim::Gradient(const double* x, double* g) const; virtual unsigned intROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>::NPar() const; doubleROOT::Math::IParametricFunctionOneDim::operator()(double x, const double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double* x, const double* p) const; ROOT::Math::Polynomial&operator=(const ROOT::Math::Polynomial&); unsigned intOrder() const; doubleROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(double x, unsigned int ipar = 0) const; doubleROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(const double* x, unsigned int ipar = 0)",MatchSource.WIKI,root/html530/ROOT__Math__Polynomial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Polynomial.html
Security,access,access,"h::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Mag2() const. Magnitute squared ( r^2 in spherical coordinate). { return fCoordinates.Mag2();}. PositionVector2D<CoordSystem, Tag>& SetX(ROOT::Math::PositionVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a); It is physically meaningless to speak of the unit vector corresponding; to a point.; ------ Setting individual elements present in coordinate system ------. Change X - Cartesian2D coordinates only. PositionVector2D<CoordSystem, Tag>& SetY(ROOT::",MatchSource.WIKI,root/html530/ROOT__Math__PositionVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PositionVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html
Security,access,access,"onVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Mag2() const. Magnitute squared ( r^2 in spherical coordinate). { return fCoordinates.Mag2();}. PositionVector2D<CoordSystem, Tag>& SetX(ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a); It is physically meaningless to speak of the unit vector corresponding; to a point.; ------ Setting individual elements present in coordinate system ------. Change X - Cartesian2D coordinates only. PositionVector2D<CoordSystem, Tag>& SetY(ROOT::Math",MatchSource.WIKI,root/html530/ROOT__Math__PositionVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PositionVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html
Security,access,access,"DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html530/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
Security,access,access,"Math::GlobalCoordinateSystemTag>::Scalar& a, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar& b, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html530/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html
Security,access,access,"ROOT::Math::LocalCoordinateSystemTag>::Scalar& a, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar& b, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html530/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PositionVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html
Security,access,access,"double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html530/ROOT__Math__PositionVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PositionVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html
Security,access,access,"rdinateSystemTag>::Scalar& a, ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html530/ROOT__Math__PositionVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PositionVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
Security,access,access,"OT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html530/ROOT__Math__PositionVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PositionVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html
Security,access,access,"g>::Scalar& a, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html530/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
Security,access,access,"temTag>::Scalar& a, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar& b, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html530/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html
Security,access,access,"teSystemTag>::Scalar& a, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar& b, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html530/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html
Security,access,access,"ltCoordinateSystemTag>::Scalar& a, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html530/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PositionVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html
Security,access,access,"le32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html530/ROOT__Math__PositionVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PositionVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
Security,access,access,"ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html530/ROOT__Math__PositionVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PositionVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html
Energy Efficiency,energy,energy,"}. Scalar Rho() const; { return Pt(); }. Scalar T() const; { return E(); }. Scalar Px() const; other coordinate representation. { return fPt*cos(fPhi);}. Scalar X() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar M2() const. vector magnitude squared (or mass squared). { Scalar p = P(); return fE*fE - p*p; }. Scalar Mag2() const; { return M2(); }. Scalar M() const. invariant mass. Scalar Mag() const; { return M(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { Scalar pz = Pz(); return fE*fE - pz*pz; }. Scalar Mt() const. transverse mass. Scalar Et() const. transverse energy. transverse energy. Scalar Et2() const. transverse energy squared. { Scalar et = Et(); return et*et; }. Scalar pi(); { return M_PI; }. void Restrict(). Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar phi). set phi value. void SetE(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar e). set E value. void SetPxPyPzE(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar px, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar py, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar pz, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector. void Scale(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() con",MatchSource.WIKI,root/html530/ROOT__Math__PtEtaPhiE4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PtEtaPhiE4D_Double32_t_.html
Security,access,accessors,"ternal data based on an array of 4 Scalar numbers. { fPt=src[0]; fEta=src[1]; fPhi=src[2]; fE=src[3]; Restrict(); }. void GetCoordinates(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fPt; dest[1] = fEta; dest[2] = fPhi; dest[3] = fE; }. void SetCoordinates(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar pt, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar eta, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar phi, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar e). Set internal data based on 4 Scalar numbers. { fPt=pt; fEta = eta; fPhi = phi; fE = e; Restrict(); }. GetCoordinates(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar& pt, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar& eta, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar& phi, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar& e) const. get internal data into 4 Scalar numbers. { pt=fPt; eta=fEta; phi = fPhi; e = fE; }. Scalar Pt() const; --------- Coordinates and Coordinate-like Scalar properties -------------; 4-D Cylindrical eta coordinate accessors. { return fPt; }. Scalar Eta() const; { return fEta; }. Scalar Phi() const; { return fPhi; }. Scalar E() const; { return fE; }. Scalar Perp() const; { return Pt(); }. Scalar Rho() const; { return Pt(); }. Scalar T() const; { return E(); }. Scalar Px() const; other coordinate representation. { return fPt*cos(fPhi);}. Scalar X() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar M2() const. vector magnitude squared (or mass squared). { Scalar p = P(); return fE*fE - p*p; }. Scalar Mag2() const; { return M2(); }. Scalar M() const. invariant mass. Scalar Mag() const; { return M(); }. Scalar Pt2() const. transverse spatial c",MatchSource.WIKI,root/html530/ROOT__Math__PtEtaPhiE4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PtEtaPhiE4D_Double32_t_.html
Energy Efficiency,energy,energy,"}. Scalar Rho() const; { return Pt(); }. Scalar T() const; { return E(); }. Scalar Px() const; other coordinate representation. { return fPt*cos(fPhi);}. Scalar X() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar M2() const. vector magnitude squared (or mass squared). { Scalar p = P(); return fE*fE - p*p; }. Scalar Mag2() const; { return M2(); }. Scalar M() const. invariant mass. Scalar Mag() const; { return M(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { Scalar pz = Pz(); return fE*fE - pz*pz; }. Scalar Mt() const. transverse mass. Scalar Et() const. transverse energy. transverse energy. Scalar Et2() const. transverse energy squared. { Scalar et = Et(); return et*et; }. Scalar pi(); { return M_PI; }. void Restrict(). Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiE4D<double>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiE4D<double>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiE4D<double>::Scalar phi). set phi value. void SetE(ROOT::Math::PtEtaPhiE4D<double>::Scalar e). set E value. void SetPxPyPzE(ROOT::Math::PtEtaPhiE4D<double>::Scalar px, ROOT::Math::PtEtaPhiE4D<double>::Scalar py, ROOT::Math::PtEtaPhiE4D<double>::Scalar pz, ROOT::Math::PtEtaPhiE4D<double>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector. void Scale(ROOT::Math::PtEtaPhiE4D<double>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility seci",MatchSource.WIKI,root/html530/ROOT__Math__PtEtaPhiE4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PtEtaPhiE4D_double_.html
Security,access,accessors,"PhiE4D<double>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. { fPt=src[0]; fEta=src[1]; fPhi=src[2]; fE=src[3]; Restrict(); }. void GetCoordinates(ROOT::Math::PtEtaPhiE4D<double>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fPt; dest[1] = fEta; dest[2] = fPhi; dest[3] = fE; }. void SetCoordinates(ROOT::Math::PtEtaPhiE4D<double>::Scalar pt, ROOT::Math::PtEtaPhiE4D<double>::Scalar eta, ROOT::Math::PtEtaPhiE4D<double>::Scalar phi, ROOT::Math::PtEtaPhiE4D<double>::Scalar e). Set internal data based on 4 Scalar numbers. { fPt=pt; fEta = eta; fPhi = phi; fE = e; Restrict(); }. GetCoordinates(ROOT::Math::PtEtaPhiE4D<double>::Scalar& pt, ROOT::Math::PtEtaPhiE4D<double>::Scalar& eta, ROOT::Math::PtEtaPhiE4D<double>::Scalar& phi, ROOT::Math::PtEtaPhiE4D<double>::Scalar& e) const. get internal data into 4 Scalar numbers. { pt=fPt; eta=fEta; phi = fPhi; e = fE; }. Scalar Pt() const; --------- Coordinates and Coordinate-like Scalar properties -------------; 4-D Cylindrical eta coordinate accessors. { return fPt; }. Scalar Eta() const; { return fEta; }. Scalar Phi() const; { return fPhi; }. Scalar E() const; { return fE; }. Scalar Perp() const; { return Pt(); }. Scalar Rho() const; { return Pt(); }. Scalar T() const; { return E(); }. Scalar Px() const; other coordinate representation. { return fPt*cos(fPhi);}. Scalar X() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar M2() const. vector magnitude squared (or mass squared). { Scalar p = P(); return fE*fE - p*p; }. Scalar Mag2() const; { return M2(); }. Scalar M() const. invariant mass. Scalar Mag() const; { return M(); }. Scalar Pt2() const. transverse spatial c",MatchSource.WIKI,root/html530/ROOT__Math__PtEtaPhiE4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PtEtaPhiE4D_double_.html
Energy Efficiency,energy,energy,"M4D<Double32_t>(const ROOT::Math::PtEtaPhiM4D<Double32_t>& v); ROOT::Math::PtEtaPhiM4D<Double32_t>PtEtaPhiM4D<Double32_t>(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar eta, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar phi, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar mass); ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarPx() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarPy() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarPz() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarR() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarRho() const; voidScale(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar a); voidSetCoordinates(const ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar* src); voidSetCoordinates(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar eta, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar phi, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar mass); voidSetE(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar energy); voidSetEta(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar eta); voidSetM(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar mass); voidSetPhi(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar phi); voidSetPt(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt); voidSetPx(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar px); voidSetPxPyPzE(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar px, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar e); voidSetPy(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py); voidSetPz(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz); ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarT() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalart() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarTheta() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarX() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalarx() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::ScalarY() const; ROOT::Math::PtEtaPhiM4D<Double32_t>::Scala",MatchSource.WIKI,root/html530/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PtEtaPhiM4D_Double32_t_.html
Safety,avoid,avoid,"const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar E2() const. energy squared. Scalar E() const. Energy (timelike component of momentum-energy 4-vector). { return std::sqrt(E2() ); }. Scalar T() const; { return E(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { return M2() + fPt*fPt; }. Scalar Mt() const. transverse mass - will be negative if Mt2() is negative. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar pi(); { return M_PI; }. void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar px, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar py, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pz, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components; One would need to use negate only with vectors ",MatchSource.WIKI,root/html530/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PtEtaPhiM4D_Double32_t_.html
Security,access,accessors," documentation; RestrictPhi(). void SetCoordinates(const ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fPt; dest[1] = fEta; dest[2] = fPhi; dest[3] = fM; }. void SetCoordinates(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar eta, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar phi, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar mass). Set internal data based on 4 Scalar numbers. GetCoordinates(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar& pt, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar& eta, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar& phi, ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar& mass) const. get internal data into 4 Scalar numbers. { pt=fPt; eta=fEta; phi = fPhi; mass = fM; }. Scalar Pt() const; --------- Coordinates and Coordinate-like Scalar properties -------------; 4-D Cylindrical eta coordinate accessors. { return fPt; }. Scalar Eta() const; { return fEta; }. Scalar Phi() const. M() is the invariant mass;; in this coordinate system it can be negagative if set that way. { return fPhi; }. Scalar M() const; { return fM; }. Scalar Mag() const; { return M(); }. Scalar Perp() const; { return Pt(); }. Scalar Rho() const; { return Pt(); }. Scalar Px() const; other coordinate representation. { return fPt*cos(fPhi);}. Scalar X() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar E2() const. energy squared. Scalar E() const. Energy (timelike component of momentum-energy 4-vector). { return std::sqrt(E2() ); }. Scalar T() const; { ",MatchSource.WIKI,root/html530/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PtEtaPhiM4D_Double32_t_.html
Energy Efficiency,energy,energy,"tEtaPhiM4D<double>PtEtaPhiM4D<double>(); ROOT::Math::PtEtaPhiM4D<double>PtEtaPhiM4D<double>(const ROOT::Math::PtEtaPhiM4D<double>& v); ROOT::Math::PtEtaPhiM4D<double>PtEtaPhiM4D<double>(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt, ROOT::Math::PtEtaPhiM4D<double>::Scalar eta, ROOT::Math::PtEtaPhiM4D<double>::Scalar phi, ROOT::Math::PtEtaPhiM4D<double>::Scalar mass); ROOT::Math::PtEtaPhiM4D<double>::ScalarPx() const; ROOT::Math::PtEtaPhiM4D<double>::ScalarPy() const; ROOT::Math::PtEtaPhiM4D<double>::ScalarPz() const; ROOT::Math::PtEtaPhiM4D<double>::ScalarR() const; ROOT::Math::PtEtaPhiM4D<double>::ScalarRho() const; voidScale(ROOT::Math::PtEtaPhiM4D<double>::Scalar a); voidSetCoordinates(const ROOT::Math::PtEtaPhiM4D<double>::Scalar* src); voidSetCoordinates(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt, ROOT::Math::PtEtaPhiM4D<double>::Scalar eta, ROOT::Math::PtEtaPhiM4D<double>::Scalar phi, ROOT::Math::PtEtaPhiM4D<double>::Scalar mass); voidSetE(ROOT::Math::PtEtaPhiM4D<double>::Scalar energy); voidSetEta(ROOT::Math::PtEtaPhiM4D<double>::Scalar eta); voidSetM(ROOT::Math::PtEtaPhiM4D<double>::Scalar mass); voidSetPhi(ROOT::Math::PtEtaPhiM4D<double>::Scalar phi); voidSetPt(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt); voidSetPx(ROOT::Math::PtEtaPhiM4D<double>::Scalar px); voidSetPxPyPzE(ROOT::Math::PtEtaPhiM4D<double>::Scalar px, ROOT::Math::PtEtaPhiM4D<double>::Scalar py, ROOT::Math::PtEtaPhiM4D<double>::Scalar pz, ROOT::Math::PtEtaPhiM4D<double>::Scalar e); voidSetPy(ROOT::Math::PtEtaPhiM4D<double>::Scalar py); voidSetPz(ROOT::Math::PtEtaPhiM4D<double>::Scalar pz); ROOT::Math::PtEtaPhiM4D<double>::ScalarT() const; ROOT::Math::PtEtaPhiM4D<double>::Scalart() const; ROOT::Math::PtEtaPhiM4D<double>::ScalarTheta() const; ROOT::Math::PtEtaPhiM4D<double>::ScalarX() const; ROOT::Math::PtEtaPhiM4D<double>::Scalarx() const; ROOT::Math::PtEtaPhiM4D<double>::ScalarY() const; ROOT::Math::PtEtaPhiM4D<double>::Scalary() const; ROOT::Math::PtEtaPhiM4D<double>::ScalarZ() const; ROOT::Math",MatchSource.WIKI,root/html530/ROOT__Math__PtEtaPhiM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PtEtaPhiM4D_double_.html
Safety,avoid,avoid,"const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar E2() const. energy squared. Scalar E() const. Energy (timelike component of momentum-energy 4-vector). { return std::sqrt(E2() ); }. Scalar T() const; { return E(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { return M2() + fPt*fPt; }. Scalar Mt() const. transverse mass - will be negative if Mt2() is negative. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar pi(); { return M_PI; }. void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<double>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<double>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<double>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<double>::Scalar px, ROOT::Math::PtEtaPhiM4D<double>::Scalar py, ROOT::Math::PtEtaPhiM4D<double>::Scalar pz, ROOT::Math::PtEtaPhiM4D<double>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components; One would need to use negate only with vectors having the energy as data member",MatchSource.WIKI,root/html530/ROOT__Math__PtEtaPhiM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PtEtaPhiM4D_double_.html
Security,access,accessors,"d Members; Includes; Libraries. Function documentation; RestrictPhi(). void SetCoordinates(const ROOT::Math::PtEtaPhiM4D<double>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::PtEtaPhiM4D<double>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fPt; dest[1] = fEta; dest[2] = fPhi; dest[3] = fM; }. void SetCoordinates(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt, ROOT::Math::PtEtaPhiM4D<double>::Scalar eta, ROOT::Math::PtEtaPhiM4D<double>::Scalar phi, ROOT::Math::PtEtaPhiM4D<double>::Scalar mass). Set internal data based on 4 Scalar numbers. GetCoordinates(ROOT::Math::PtEtaPhiM4D<double>::Scalar& pt, ROOT::Math::PtEtaPhiM4D<double>::Scalar& eta, ROOT::Math::PtEtaPhiM4D<double>::Scalar& phi, ROOT::Math::PtEtaPhiM4D<double>::Scalar& mass) const. get internal data into 4 Scalar numbers. { pt=fPt; eta=fEta; phi = fPhi; mass = fM; }. Scalar Pt() const; --------- Coordinates and Coordinate-like Scalar properties -------------; 4-D Cylindrical eta coordinate accessors. { return fPt; }. Scalar Eta() const; { return fEta; }. Scalar Phi() const. M() is the invariant mass;; in this coordinate system it can be negagative if set that way. { return fPhi; }. Scalar M() const; { return fM; }. Scalar Mag() const; { return M(); }. Scalar Perp() const; { return Pt(); }. Scalar Rho() const; { return Pt(); }. Scalar Px() const; other coordinate representation. { return fPt*cos(fPhi);}. Scalar X() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar E2() const. energy squared. Scalar E() const. Energy (timelike component of momentum-energy 4-vector). { return std::sqrt(E2() ); }. Scalar T() const; { ",MatchSource.WIKI,root/html530/ROOT__Math__PtEtaPhiM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PtEtaPhiM4D_double_.html
Energy Efficiency,energy,energy,". ROOT::Math::PxPyPzE4D<Double32_t>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » GENVECTOR; » ROOT::Math::PxPyPzE4D<Double32_t>. class ROOT::Math::PxPyPzE4D<Double32_t>. Class describing a 4D cartesian coordinate system (x, y, z, t coordinates); or momentum-energy vectors stored as (Px, Py, Pz, E).; The metric used is (-,-,-,+). @ingroup GenVector. This class is also known as (typedefs to this class)ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::CoordinateType. Function Members (Methods); public:. ~PxPyPzE4D<Double32_t>(); ROOT::Math::PxPyPzE4D<Double32_t>::ScalarE() const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarEt() const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarEt2() const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarEta() const; voidGetCoordinates(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar* dest) const; voidGetCoordinates(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar& px, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar& py, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar& pz, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar& e) const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarM() const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarM2() const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarMag() const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarMag2() const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarMt() const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarMt2() const; voidNegate(); booloperator!=(const ROOT::Math::PxPyPzE4D<Double32_t>& rhs) const; ROOT::Math::PxPyPzE4D<Double32_t>&operator=(const ROOT::Math::PxPyPzE4D<Double32_t>& v); booloperator==(const ROOT::Math::PxPyPzE4D<Double32_t>& rhs) const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarP() const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarP2() const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarPerp() const; ROOT::Math::PxPyPzE4D<Double32_t>::ScalarPerp2() const; ROOT::Math::PxPyPzE4D<Do",MatchSource.WIKI,root/html530/ROOT__Math__PxPyPzE4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PxPyPzE4D_Double32_t_.html
Security,access,accessors," SetCoordinates(const ROOT::Math::PxPyPzE4D<Double32_t>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. { fX=src[0]; fY=src[1]; fZ=src[2]; fT=src[3]; }. void GetCoordinates(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fX; dest[1] = fY; dest[2] = fZ; dest[3] = fT; }. void SetCoordinates(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar e). Set internal data based on 4 Scalar numbers. { fX=px; fY=py; fZ=pz; fT=e;}. void GetCoordinates(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar& px, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar& py, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar& pz, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar& e) const. get internal data into 4 Scalar numbers. { px=fX; py=fY; pz=fZ; e=fT;}. Scalar Px() const; --------- Coordinates and Coordinate-like Scalar properties -------------; cartesian (Minkowski)coordinate accessors. { return fX;}. Scalar Py() const; { return fY;}. Scalar Pz() const; { return fZ;}. Scalar E() const; { return fT;}. Scalar X() const; { return fX;}. Scalar Y() const; { return fY;}. Scalar Z() const; { return fZ;}. Scalar T() const; { return fT;}. Scalar P2() const; other coordinate representation. squared magnitude of spatial components. { return fX*fX + fY*fY + fZ*fZ; }. Scalar P() const. magnitude of spatial components (magnitude of 3-momentum). { return std::sqrt(P2()); }. Scalar R() const; { return P(); }. Scalar M2() const. vector magnitude squared (or mass squared). { return fT*fT - fX*fX - fY*fY - fZ*fZ;}. Scalar Mag2() const; { return M2(); }. Scalar M() const. invariant mass. Scalar Mag() const; { return M(); }. Scalar Pt2() const. transverse spatial component squared. { return fX*fX + fY*fY;}. Scalar Perp2() const; { return Pt2();}. Scalar Pt() const. Transverse spatial component (P_perp or rho). { return s",MatchSource.WIKI,root/html530/ROOT__Math__PxPyPzE4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PxPyPzE4D_Double32_t_.html
Energy Efficiency,energy,energy,". ROOT::Math::PxPyPzE4D<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » GENVECTOR; » ROOT::Math::PxPyPzE4D<double>. class ROOT::Math::PxPyPzE4D<double>. Class describing a 4D cartesian coordinate system (x, y, z, t coordinates); or momentum-energy vectors stored as (Px, Py, Pz, E).; The metric used is (-,-,-,+). @ingroup GenVector. This class is also known as (typedefs to this class)ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::CoordinateType. Function Members (Methods); public:. ~PxPyPzE4D<double>(); ROOT::Math::PxPyPzE4D<double>::ScalarE() const; ROOT::Math::PxPyPzE4D<double>::ScalarEt() const; ROOT::Math::PxPyPzE4D<double>::ScalarEt2() const; ROOT::Math::PxPyPzE4D<double>::ScalarEta() const; voidGetCoordinates(ROOT::Math::PxPyPzE4D<double>::Scalar* dest) const; voidGetCoordinates(ROOT::Math::PxPyPzE4D<double>::Scalar& px, ROOT::Math::PxPyPzE4D<double>::Scalar& py, ROOT::Math::PxPyPzE4D<double>::Scalar& pz, ROOT::Math::PxPyPzE4D<double>::Scalar& e) const; ROOT::Math::PxPyPzE4D<double>::ScalarM() const; ROOT::Math::PxPyPzE4D<double>::ScalarM2() const; ROOT::Math::PxPyPzE4D<double>::ScalarMag() const; ROOT::Math::PxPyPzE4D<double>::ScalarMag2() const; ROOT::Math::PxPyPzE4D<double>::ScalarMt() const; ROOT::Math::PxPyPzE4D<double>::ScalarMt2() const; voidNegate(); booloperator!=(const ROOT::Math::PxPyPzE4D<double>& rhs) const; ROOT::Math::PxPyPzE4D<double>&operator=(const ROOT::Math::PxPyPzE4D<double>& v); booloperator==(const ROOT::Math::PxPyPzE4D<double>& rhs) const; ROOT::Math::PxPyPzE4D<double>::ScalarP() const; ROOT::Math::PxPyPzE4D<double>::ScalarP2() const; ROOT::Math::PxPyPzE4D<double>::ScalarPerp() const; ROOT::Math::PxPyPzE4D<double>::ScalarPerp2() const; ROOT::Math::PxPyPzE4D<double>::ScalarPhi() const; ROOT::Math::PxPyPzE4D<double>::ScalarPt() const; ROOT::Math::PxPyPzE4D<double>::Scalar",MatchSource.WIKI,root/html530/ROOT__Math__PxPyPzE4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PxPyPzE4D_double_.html
Security,access,accessors," Libraries. Function documentation; void SetCoordinates(const ROOT::Math::PxPyPzE4D<double>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. { fX=src[0]; fY=src[1]; fZ=src[2]; fT=src[3]; }. void GetCoordinates(ROOT::Math::PxPyPzE4D<double>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fX; dest[1] = fY; dest[2] = fZ; dest[3] = fT; }. void SetCoordinates(ROOT::Math::PxPyPzE4D<double>::Scalar px, ROOT::Math::PxPyPzE4D<double>::Scalar py, ROOT::Math::PxPyPzE4D<double>::Scalar pz, ROOT::Math::PxPyPzE4D<double>::Scalar e). Set internal data based on 4 Scalar numbers. { fX=px; fY=py; fZ=pz; fT=e;}. void GetCoordinates(ROOT::Math::PxPyPzE4D<double>::Scalar& px, ROOT::Math::PxPyPzE4D<double>::Scalar& py, ROOT::Math::PxPyPzE4D<double>::Scalar& pz, ROOT::Math::PxPyPzE4D<double>::Scalar& e) const. get internal data into 4 Scalar numbers. { px=fX; py=fY; pz=fZ; e=fT;}. Scalar Px() const; --------- Coordinates and Coordinate-like Scalar properties -------------; cartesian (Minkowski)coordinate accessors. { return fX;}. Scalar Py() const; { return fY;}. Scalar Pz() const; { return fZ;}. Scalar E() const; { return fT;}. Scalar X() const; { return fX;}. Scalar Y() const; { return fY;}. Scalar Z() const; { return fZ;}. Scalar T() const; { return fT;}. Scalar P2() const; other coordinate representation. squared magnitude of spatial components. { return fX*fX + fY*fY + fZ*fZ; }. Scalar P() const. magnitude of spatial components (magnitude of 3-momentum). { return std::sqrt(P2()); }. Scalar R() const; { return P(); }. Scalar M2() const. vector magnitude squared (or mass squared). { return fT*fT - fX*fX - fY*fY - fZ*fZ;}. Scalar Mag2() const; { return M2(); }. Scalar M() const. invariant mass. Scalar Mag() const; { return M(); }. Scalar Pt2() const. transverse spatial component squared. { return fX*fX + fY*fY;}. Scalar Perp2() const; { return Pt2();}. Scalar Pt() const. Transverse spatial component (P_perp or rho). { return s",MatchSource.WIKI,root/html530/ROOT__Math__PxPyPzE4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PxPyPzE4D_double_.html
Availability,error,errors,". ROOT::Math::PxPyPzM4D<Double32_t>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » GENVECTOR; » ROOT::Math::PxPyPzM4D<Double32_t>. class ROOT::Math::PxPyPzM4D<Double32_t>. Class describing a 4D coordinate system; or momentum-energy vectors stored as (Px, Py, Pz, M).; This system is useful to describe ultra-relativistic particles; (like electrons at LHC) to avoid numerical errors evaluating the mass; when E >>> m; The metric used is (-,-,-,+); Spacelike particles (M2 < 0) are described with negative mass values,; but in this case m2 must alwasy be less than P2 to preserve a positive value of E2. @ingroup GenVector. This class is also known as (typedefs to this class)ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::CoordinateType. Function Members (Methods); public:. ~PxPyPzM4D<Double32_t>(); ROOT::Math::PxPyPzM4D<Double32_t>::ScalarE() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarE2() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarEt() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarEt2() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarEta() const; voidGetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar* dest) const; voidGetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& m) const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarM() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarM2() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarMag() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarMag2() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarMt() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarMt2() const; voidNegate(); booloperator!=(const ROOT::Math::PxPyPzM4D<Double32_t>& rhs) const; ROOT::Math::PxPyPzM4D<Double32_t>&operator=(const ROOT::Math::PxPyPzM4D<Dou",MatchSource.WIKI,root/html530/ROOT__Math__PxPyPzM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PxPyPzM4D_Double32_t_.html
Energy Efficiency,energy,energy,". ROOT::Math::PxPyPzM4D<Double32_t>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » GENVECTOR; » ROOT::Math::PxPyPzM4D<Double32_t>. class ROOT::Math::PxPyPzM4D<Double32_t>. Class describing a 4D coordinate system; or momentum-energy vectors stored as (Px, Py, Pz, M).; This system is useful to describe ultra-relativistic particles; (like electrons at LHC) to avoid numerical errors evaluating the mass; when E >>> m; The metric used is (-,-,-,+); Spacelike particles (M2 < 0) are described with negative mass values,; but in this case m2 must alwasy be less than P2 to preserve a positive value of E2. @ingroup GenVector. This class is also known as (typedefs to this class)ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::CoordinateType. Function Members (Methods); public:. ~PxPyPzM4D<Double32_t>(); ROOT::Math::PxPyPzM4D<Double32_t>::ScalarE() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarE2() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarEt() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarEt2() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarEta() const; voidGetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar* dest) const; voidGetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& m) const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarM() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarM2() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarMag() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarMag2() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarMt() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarMt2() const; voidNegate(); booloperator!=(const ROOT::Math::PxPyPzM4D<Double32_t>& rhs) const; ROOT::Math::PxPyPzM4D<Double32_t>&operator=(const ROOT::Math::PxPyPzM4D<Dou",MatchSource.WIKI,root/html530/ROOT__Math__PxPyPzM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PxPyPzM4D_Double32_t_.html
Safety,avoid,avoid,". ROOT::Math::PxPyPzM4D<Double32_t>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » GENVECTOR; » ROOT::Math::PxPyPzM4D<Double32_t>. class ROOT::Math::PxPyPzM4D<Double32_t>. Class describing a 4D coordinate system; or momentum-energy vectors stored as (Px, Py, Pz, M).; This system is useful to describe ultra-relativistic particles; (like electrons at LHC) to avoid numerical errors evaluating the mass; when E >>> m; The metric used is (-,-,-,+); Spacelike particles (M2 < 0) are described with negative mass values,; but in this case m2 must alwasy be less than P2 to preserve a positive value of E2. @ingroup GenVector. This class is also known as (typedefs to this class)ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::CoordinateType. Function Members (Methods); public:. ~PxPyPzM4D<Double32_t>(); ROOT::Math::PxPyPzM4D<Double32_t>::ScalarE() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarE2() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarEt() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarEt2() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarEta() const; voidGetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar* dest) const; voidGetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& m) const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarM() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarM2() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarMag() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarMag2() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarMt() const; ROOT::Math::PxPyPzM4D<Double32_t>::ScalarMt2() const; voidNegate(); booloperator!=(const ROOT::Math::PxPyPzM4D<Double32_t>& rhs) const; ROOT::Math::PxPyPzM4D<Double32_t>&operator=(const ROOT::Math::PxPyPzM4D<Dou",MatchSource.WIKI,root/html530/ROOT__Math__PxPyPzM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PxPyPzM4D_Double32_t_.html
Security,access,accessors,"nheritance; Inherited Members; Includes; Libraries. Function documentation; void SetCoordinates(const ROOT::Math::PxPyPzM4D<Double32_t>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fX; dest[1] = fY; dest[2] = fZ; dest[3] = fM; }. void SetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m). Set internal data based on 4 Scalar numbers. void GetCoordinates(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& px, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& py, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& pz, ROOT::Math::PxPyPzM4D<Double32_t>::Scalar& m) const. get internal data into 4 Scalar numbers. { px=fX; py=fY; pz=fZ; m=fM;}. Scalar Px() const; --------- Coordinates and Coordinate-like Scalar properties -------------; cartesian (Minkowski)coordinate accessors. { return fX;}. Scalar Py() const; { return fY;}. Scalar Pz() const; { return fZ;}. Scalar M() const; { return fM; }. Scalar X() const; { return fX;}. Scalar Y() const; { return fY;}. Scalar Z() const; { return fZ;}. Scalar E() const; other coordinate representation. Energy. { return std::sqrt(E2() ); }. Scalar T() const; { return E();}. Scalar P2() const. squared magnitude of spatial components. { return fX*fX + fY*fY + fZ*fZ; }. Scalar P() const. magnitude of spatial components (magnitude of 3-momentum). { return std::sqrt(P2()); }. Scalar R() const; { return P(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Mag() const; { return M(); }. Scalar E2() const. energy squared. Scalar Pt2() const. transverse spatial component squared. { return fX*fX + fY*fY;}. Scalar Perp2() const; { ret",MatchSource.WIKI,root/html530/ROOT__Math__PxPyPzM4D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PxPyPzM4D_Double32_t_.html
Availability,error,errors,". ROOT::Math::PxPyPzM4D<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » GENVECTOR; » ROOT::Math::PxPyPzM4D<double>. class ROOT::Math::PxPyPzM4D<double>. Class describing a 4D coordinate system; or momentum-energy vectors stored as (Px, Py, Pz, M).; This system is useful to describe ultra-relativistic particles; (like electrons at LHC) to avoid numerical errors evaluating the mass; when E >>> m; The metric used is (-,-,-,+); Spacelike particles (M2 < 0) are described with negative mass values,; but in this case m2 must alwasy be less than P2 to preserve a positive value of E2. @ingroup GenVector. This class is also known as (typedefs to this class)ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::CoordinateType. Function Members (Methods); public:. ~PxPyPzM4D<double>(); ROOT::Math::PxPyPzM4D<double>::ScalarE() const; ROOT::Math::PxPyPzM4D<double>::ScalarE2() const; ROOT::Math::PxPyPzM4D<double>::ScalarEt() const; ROOT::Math::PxPyPzM4D<double>::ScalarEt2() const; ROOT::Math::PxPyPzM4D<double>::ScalarEta() const; voidGetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar* dest) const; voidGetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar& px, ROOT::Math::PxPyPzM4D<double>::Scalar& py, ROOT::Math::PxPyPzM4D<double>::Scalar& pz, ROOT::Math::PxPyPzM4D<double>::Scalar& m) const; ROOT::Math::PxPyPzM4D<double>::ScalarM() const; ROOT::Math::PxPyPzM4D<double>::ScalarM2() const; ROOT::Math::PxPyPzM4D<double>::ScalarMag() const; ROOT::Math::PxPyPzM4D<double>::ScalarMag2() const; ROOT::Math::PxPyPzM4D<double>::ScalarMt() const; ROOT::Math::PxPyPzM4D<double>::ScalarMt2() const; voidNegate(); booloperator!=(const ROOT::Math::PxPyPzM4D<double>& rhs) const; ROOT::Math::PxPyPzM4D<double>&operator=(const ROOT::Math::PxPyPzM4D<double>& v); booloperator==(const ROOT::Math::PxPyPzM4D<double>& rhs) const; ROOT::Math::PxPyPz",MatchSource.WIKI,root/html530/ROOT__Math__PxPyPzM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PxPyPzM4D_double_.html
Energy Efficiency,energy,energy,". ROOT::Math::PxPyPzM4D<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » GENVECTOR; » ROOT::Math::PxPyPzM4D<double>. class ROOT::Math::PxPyPzM4D<double>. Class describing a 4D coordinate system; or momentum-energy vectors stored as (Px, Py, Pz, M).; This system is useful to describe ultra-relativistic particles; (like electrons at LHC) to avoid numerical errors evaluating the mass; when E >>> m; The metric used is (-,-,-,+); Spacelike particles (M2 < 0) are described with negative mass values,; but in this case m2 must alwasy be less than P2 to preserve a positive value of E2. @ingroup GenVector. This class is also known as (typedefs to this class)ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::CoordinateType. Function Members (Methods); public:. ~PxPyPzM4D<double>(); ROOT::Math::PxPyPzM4D<double>::ScalarE() const; ROOT::Math::PxPyPzM4D<double>::ScalarE2() const; ROOT::Math::PxPyPzM4D<double>::ScalarEt() const; ROOT::Math::PxPyPzM4D<double>::ScalarEt2() const; ROOT::Math::PxPyPzM4D<double>::ScalarEta() const; voidGetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar* dest) const; voidGetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar& px, ROOT::Math::PxPyPzM4D<double>::Scalar& py, ROOT::Math::PxPyPzM4D<double>::Scalar& pz, ROOT::Math::PxPyPzM4D<double>::Scalar& m) const; ROOT::Math::PxPyPzM4D<double>::ScalarM() const; ROOT::Math::PxPyPzM4D<double>::ScalarM2() const; ROOT::Math::PxPyPzM4D<double>::ScalarMag() const; ROOT::Math::PxPyPzM4D<double>::ScalarMag2() const; ROOT::Math::PxPyPzM4D<double>::ScalarMt() const; ROOT::Math::PxPyPzM4D<double>::ScalarMt2() const; voidNegate(); booloperator!=(const ROOT::Math::PxPyPzM4D<double>& rhs) const; ROOT::Math::PxPyPzM4D<double>&operator=(const ROOT::Math::PxPyPzM4D<double>& v); booloperator==(const ROOT::Math::PxPyPzM4D<double>& rhs) const; ROOT::Math::PxPyPz",MatchSource.WIKI,root/html530/ROOT__Math__PxPyPzM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PxPyPzM4D_double_.html
Safety,avoid,avoid,". ROOT::Math::PxPyPzM4D<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » GENVECTOR; » ROOT::Math::PxPyPzM4D<double>. class ROOT::Math::PxPyPzM4D<double>. Class describing a 4D coordinate system; or momentum-energy vectors stored as (Px, Py, Pz, M).; This system is useful to describe ultra-relativistic particles; (like electrons at LHC) to avoid numerical errors evaluating the mass; when E >>> m; The metric used is (-,-,-,+); Spacelike particles (M2 < 0) are described with negative mass values,; but in this case m2 must alwasy be less than P2 to preserve a positive value of E2. @ingroup GenVector. This class is also known as (typedefs to this class)ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::CoordinateType. Function Members (Methods); public:. ~PxPyPzM4D<double>(); ROOT::Math::PxPyPzM4D<double>::ScalarE() const; ROOT::Math::PxPyPzM4D<double>::ScalarE2() const; ROOT::Math::PxPyPzM4D<double>::ScalarEt() const; ROOT::Math::PxPyPzM4D<double>::ScalarEt2() const; ROOT::Math::PxPyPzM4D<double>::ScalarEta() const; voidGetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar* dest) const; voidGetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar& px, ROOT::Math::PxPyPzM4D<double>::Scalar& py, ROOT::Math::PxPyPzM4D<double>::Scalar& pz, ROOT::Math::PxPyPzM4D<double>::Scalar& m) const; ROOT::Math::PxPyPzM4D<double>::ScalarM() const; ROOT::Math::PxPyPzM4D<double>::ScalarM2() const; ROOT::Math::PxPyPzM4D<double>::ScalarMag() const; ROOT::Math::PxPyPzM4D<double>::ScalarMag2() const; ROOT::Math::PxPyPzM4D<double>::ScalarMt() const; ROOT::Math::PxPyPzM4D<double>::ScalarMt2() const; voidNegate(); booloperator!=(const ROOT::Math::PxPyPzM4D<double>& rhs) const; ROOT::Math::PxPyPzM4D<double>&operator=(const ROOT::Math::PxPyPzM4D<double>& v); booloperator==(const ROOT::Math::PxPyPzM4D<double>& rhs) const; ROOT::Math::PxPyPz",MatchSource.WIKI,root/html530/ROOT__Math__PxPyPzM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PxPyPzM4D_double_.html
Security,access,accessors,"efX; doublefY; doublefZ. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetCoordinates(const ROOT::Math::PxPyPzM4D<double>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fX; dest[1] = fY; dest[2] = fZ; dest[3] = fM; }. void SetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::PxPyPzM4D<double>::Scalar py, ROOT::Math::PxPyPzM4D<double>::Scalar pz, ROOT::Math::PxPyPzM4D<double>::Scalar m). Set internal data based on 4 Scalar numbers. void GetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar& px, ROOT::Math::PxPyPzM4D<double>::Scalar& py, ROOT::Math::PxPyPzM4D<double>::Scalar& pz, ROOT::Math::PxPyPzM4D<double>::Scalar& m) const. get internal data into 4 Scalar numbers. { px=fX; py=fY; pz=fZ; m=fM;}. Scalar Px() const; --------- Coordinates and Coordinate-like Scalar properties -------------; cartesian (Minkowski)coordinate accessors. { return fX;}. Scalar Py() const; { return fY;}. Scalar Pz() const; { return fZ;}. Scalar M() const; { return fM; }. Scalar X() const; { return fX;}. Scalar Y() const; { return fY;}. Scalar Z() const; { return fZ;}. Scalar E() const; other coordinate representation. Energy. { return std::sqrt(E2() ); }. Scalar T() const; { return E();}. Scalar P2() const. squared magnitude of spatial components. { return fX*fX + fY*fY + fZ*fZ; }. Scalar P() const. magnitude of spatial components (magnitude of 3-momentum). { return std::sqrt(P2()); }. Scalar R() const; { return P(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Mag() const; { return M(); }. Scalar E2() const. energy squared. Scalar Pt2() const. transverse spatial component squared. { return fX*fX + fY*fY;}. Scalar Perp2() const; { ret",MatchSource.WIKI,root/html530/ROOT__Math__PxPyPzM4D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__PxPyPzM4D_double_.html
Availability,error,error,". ROOT::Math::RichardsonDerivator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::RichardsonDerivator. class ROOT::Math::RichardsonDerivator. User class for calculating the derivatives of a function. It can calculate first (method Derivative1),; second (method Derivative2) and third (method Derivative3) of a function. It uses the Richardson extrapolation method for function derivation in a given interval.; The method use 2 derivative estimates (one computed with step h and one computed with step h/2); to compute a third, more accurate estimation. It is equivalent to the; <a href = http://en.wikipedia.org/wiki/Five-point_stencil>5-point method</a>,; which can be obtained with a Taylor expansion.; A step size should be given, depending on x and f(x).; An optimal step size value minimizes the truncation error of the expansion and the rounding; error in evaluating x+h and f(x+h). A too small h will yield a too large rounding error while a too large; h will give a large truncation error in the derivative approximation.; A good discussion can be found in discussed in; <a href=http://www.nrbook.com/a/bookcpdf/c5-7.pdf>Chapter 5.7</a> of Numerical Recipes in C.; By default a value of 0.001 is uses, acceptable in many cases. This class is implemented using code previosuly in TF1::Derivate{,2,3}(). Now TF1 uses this class. @ingroup Deriv. Function Members (Methods); public:. ~RichardsonDerivator(); doubleDerivative1(double x); doubleDerivative1(const ROOT::Math::IGenFunction& f, double x, double h); doubleDerivative2(double x); doubleDerivative2(const ROOT::Math::IGenFunction& f, double x, double h); doubleDerivative3(double x); doubleDerivative3(const ROOT::Math::IGenFunction& f, double x, double h); doubleError() const; doubleoperator()(double x); ROOT::Math::RichardsonDerivator&operator=(const ROOT::M",MatchSource.WIKI,root/html530/ROOT__Math__RichardsonDerivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__RichardsonDerivator.html
Integrability,depend,depending,". ROOT::Math::RichardsonDerivator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::RichardsonDerivator. class ROOT::Math::RichardsonDerivator. User class for calculating the derivatives of a function. It can calculate first (method Derivative1),; second (method Derivative2) and third (method Derivative3) of a function. It uses the Richardson extrapolation method for function derivation in a given interval.; The method use 2 derivative estimates (one computed with step h and one computed with step h/2); to compute a third, more accurate estimation. It is equivalent to the; <a href = http://en.wikipedia.org/wiki/Five-point_stencil>5-point method</a>,; which can be obtained with a Taylor expansion.; A step size should be given, depending on x and f(x).; An optimal step size value minimizes the truncation error of the expansion and the rounding; error in evaluating x+h and f(x+h). A too small h will yield a too large rounding error while a too large; h will give a large truncation error in the derivative approximation.; A good discussion can be found in discussed in; <a href=http://www.nrbook.com/a/bookcpdf/c5-7.pdf>Chapter 5.7</a> of Numerical Recipes in C.; By default a value of 0.001 is uses, acceptable in many cases. This class is implemented using code previosuly in TF1::Derivate{,2,3}(). Now TF1 uses this class. @ingroup Deriv. Function Members (Methods); public:. ~RichardsonDerivator(); doubleDerivative1(double x); doubleDerivative1(const ROOT::Math::IGenFunction& f, double x, double h); doubleDerivative2(double x); doubleDerivative2(const ROOT::Math::IGenFunction& f, double x, double h); doubleDerivative3(double x); doubleDerivative3(const ROOT::Math::IGenFunction& f, double x, double h); doubleError() const; doubleoperator()(double x); ROOT::Math::RichardsonDerivator&operator=(const ROOT::M",MatchSource.WIKI,root/html530/ROOT__Math__RichardsonDerivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__RichardsonDerivator.html
Availability,failure,failure,"d . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool Solve(Function &f, Derivative &d, double start, int maxIter, double absTol, double relTol). RootFinder(RootFinder::EType type = RootFinder::kBRENT). Construct a Root-Finder algorithm. virtual ~RootFinder(). RootFinder(const RootFinder & ); usually copying is non trivial, so we make this unaccessible. {}. bool SetMethod(ROOT::Math::RootFinder::EType type = RootFinder::kBRENT). bool SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). Provide to the solver the function and the initial search interval [xlow, xup]; for algorithms not using derivatives (bracketing algorithms); The templated function f must be of a type implementing the \a operator() method,; <em> double operator() ( double x ) </em>; Returns non zero if interval is not valid (i.e. does not contains a root). return fSolver-> SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). int Iterations() const. Return the number of iteration performed to find the Root. int Iterate(). Perform a single iteration and return the Status. double Root() const. Return the current and latest estimate of the Root. int Status() const. Return the status of the last estimate of the Root; = 0 OK, not zero failure. const char * Name() const. Return the current and latest estimate of the lower value of the Root-finding interval (for bracketing algorithms). double XLower() const {; return fSolver->XLower();; }. Return the current and latest estimate of the upper value of the Root-finding interval (for bracketing algorithms). double XUpper() const {; return fSolver->XUpper();; }. Get Name of the Root-finding solver algorithm. » Last changed: root/mathmore:$Id: RootFinder.h 33942 2010-06-16 13:12:17Z moneta $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__RootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__RootFinder.html
Modifiability,plug-in,plug-in,". ROOT::Math::RootFinder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::RootFinder. class ROOT::Math::RootFinder. User Class to find the Root of one dimensional functions.; The GSL Methods are implemented in MathMore and they are loaded automatically; via the plug-in manager. The possible types of Root-finding algorithms are:; <ul>; <li>Root Bracketing Algorithms which do not require function derivatives; <ol>; <li>RootFinder::kBRENT (default method implemented in MathCore); <li>RootFinder::kGSL_BISECTION; <li>RootFinder::kGSL_FALSE_POS; <li>RootFinder::kGSL_BRENT; </ol>; <li>Root Finding Algorithms using Derivatives; <ol>; <li>RootFinder::kGSL_NEWTON; <li>RootFinder::kGSL_SECANT; <li>RootFinder::kGSL_STEFFENSON; </ol>; </ul>. This class does not cupport copying. @ingroup RootFinders. Function Members (Methods); public:. virtual~RootFinder(); intIterate(); intIterations() const; const char*Name() const; doubleRoot() const; ROOT::Math::RootFinderRootFinder(ROOT::Math::RootFinder::EType type = RootFinder::kBRENT); boolSetFunction(const ROOT::Math::IGradFunction& f, double xstart); boolSetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); boolSetMethod(ROOT::Math::RootFinder::EType type = RootFinder::kBRENT); boolSolve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); intStatus() const. private:. ROOT::Math::RootFinder&operator=(const ROOT::Math::RootFinder& rhs); ROOT::Math::RootFinderRootFinder(const ROOT::Math::RootFinder&). Data Members; public:. enum EType { kBRENT; kGSL_BISECTION; kGSL_FALSE_POS; kGSL_BRENT; kGSL_NEWTON; kGSL_SECANT; kGSL_STEFFENSON; };. private:. ROOT::Math::IRootFinderMethod*fSolvertype of algorithm to be used . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool Solve(Function &f, Derivative &d",MatchSource.WIKI,root/html530/ROOT__Math__RootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__RootFinder.html
Performance,load,loaded,". ROOT::Math::RootFinder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::RootFinder. class ROOT::Math::RootFinder. User Class to find the Root of one dimensional functions.; The GSL Methods are implemented in MathMore and they are loaded automatically; via the plug-in manager. The possible types of Root-finding algorithms are:; <ul>; <li>Root Bracketing Algorithms which do not require function derivatives; <ol>; <li>RootFinder::kBRENT (default method implemented in MathCore); <li>RootFinder::kGSL_BISECTION; <li>RootFinder::kGSL_FALSE_POS; <li>RootFinder::kGSL_BRENT; </ol>; <li>Root Finding Algorithms using Derivatives; <ol>; <li>RootFinder::kGSL_NEWTON; <li>RootFinder::kGSL_SECANT; <li>RootFinder::kGSL_STEFFENSON; </ol>; </ul>. This class does not cupport copying. @ingroup RootFinders. Function Members (Methods); public:. virtual~RootFinder(); intIterate(); intIterations() const; const char*Name() const; doubleRoot() const; ROOT::Math::RootFinderRootFinder(ROOT::Math::RootFinder::EType type = RootFinder::kBRENT); boolSetFunction(const ROOT::Math::IGradFunction& f, double xstart); boolSetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); boolSetMethod(ROOT::Math::RootFinder::EType type = RootFinder::kBRENT); boolSolve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); intStatus() const. private:. ROOT::Math::RootFinder&operator=(const ROOT::Math::RootFinder& rhs); ROOT::Math::RootFinderRootFinder(const ROOT::Math::RootFinder&). Data Members; public:. enum EType { kBRENT; kGSL_BISECTION; kGSL_FALSE_POS; kGSL_BRENT; kGSL_NEWTON; kGSL_SECANT; kGSL_STEFFENSON; };. private:. ROOT::Math::IRootFinderMethod*fSolvertype of algorithm to be used . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool Solve(Function &f, Derivative &d",MatchSource.WIKI,root/html530/ROOT__Math__RootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__RootFinder.html
Usability,simpl,simplest,". ROOT::Math::Roots. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; namespace description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::Roots. namespace ROOT::Math::Roots. Roots::Bisection; 	Bisection algorithm, simplest algorithm for bracketing the roots of a function, but slowest one.; 	See the <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Root-Bracketing-Algorithms.html"">GSL manual</A> for more information; 	@ingroup RootFinders. Function Members (Methods). Class Charts; Function documentation. » Author: L. Moneta, A. Zsenei 08/2005 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: RootFinderAlgorithms.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__Roots.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Roots.html
Usability,simpl,simplest,". ROOT::Math::Roots::Bisection. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::Roots::Bisection. class ROOT::Math::Roots::Bisection: public ROOT::Math::GSLRootFinder. Roots::Bisection; 	Bisection algorithm, simplest algorithm for bracketing the roots of a function, but slowest one.; 	See the <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Root-Bracketing-Algorithms.html"">GSL manual</A> for more information; 	@ingroup RootFinders. Function Members (Methods); public:. virtual~Bisection(); ROOT::Math::Roots::BisectionBisection(); ROOT::Math::GSLRootFinderROOT::Math::GSLRootFinder::GSLRootFinder(); virtual intROOT::Math::GSLRootFinder::Iterate(); virtual intROOT::Math::GSLRootFinder::Iterations() const; virtual const char*ROOT::Math::GSLRootFinder::Name() const; virtual doubleROOT::Math::GSLRootFinder::Root() const; virtual boolROOT::Math::GSLRootFinder::SetFunction(const ROOT::Math::IGradFunction&, double); virtual boolROOT::Math::GSLRootFinder::SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); boolROOT::Math::GSLRootFinder::SetFunction(ROOT::Math::GSLRootFinder::GSLFuncPointer f, void* params, double xlow, double xup); virtual boolROOT::Math::GSLRootFinder::Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); virtual intROOT::Math::GSLRootFinder::Status() const. protected:. voidROOT::Math::GSLRootFinder::FreeSolver(); voidROOT::Math::GSLRootFinder::SetSolver(ROOT::Math::GSLRootFSolver* s). private:. ROOT::Math::Roots::BisectionBisection(const ROOT::Math::Roots::Bisection&); ROOT::Math::Roots::Bisection&operator=(const ROOT::Math::Roots::Bisection&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bisection(). virtual ~Bisection(). Bisection(const ROOT::Math::Roots::Bisection& ); usually copying is non tr",MatchSource.WIKI,root/html530/ROOT__Math__Roots__Bisection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Roots__Bisection.html
Usability,simpl,simplest,". ROOT::Math::Roots::Brent. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::Roots::Brent. class ROOT::Math::Roots::Brent: public ROOT::Math::GSLRootFinder. Roots::Bisection; 	Bisection algorithm, simplest algorithm for bracketing the roots of a function, but slowest one.; 	See the <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Root-Bracketing-Algorithms.html"">GSL manual</A> for more information; 	@ingroup RootFinders. Function Members (Methods); public:. virtual~Brent(); ROOT::Math::Roots::BrentBrent(); ROOT::Math::GSLRootFinderROOT::Math::GSLRootFinder::GSLRootFinder(); virtual intROOT::Math::GSLRootFinder::Iterate(); virtual intROOT::Math::GSLRootFinder::Iterations() const; virtual const char*ROOT::Math::GSLRootFinder::Name() const; virtual doubleROOT::Math::GSLRootFinder::Root() const; virtual boolROOT::Math::GSLRootFinder::SetFunction(const ROOT::Math::IGradFunction&, double); virtual boolROOT::Math::GSLRootFinder::SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); boolROOT::Math::GSLRootFinder::SetFunction(ROOT::Math::GSLRootFinder::GSLFuncPointer f, void* params, double xlow, double xup); virtual boolROOT::Math::GSLRootFinder::Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); virtual intROOT::Math::GSLRootFinder::Status() const. protected:. voidROOT::Math::GSLRootFinder::FreeSolver(); voidROOT::Math::GSLRootFinder::SetSolver(ROOT::Math::GSLRootFSolver* s). private:. ROOT::Math::Roots::BrentBrent(const ROOT::Math::Roots::Brent&); ROOT::Math::Roots::Brent&operator=(const ROOT::Math::Roots::Brent&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Brent(). virtual ~Brent(). Brent(const ROOT::Math::Roots::Brent& ); usually copying is non trivial, so we make this unaccessible. » Author: L. Moneta, A.",MatchSource.WIKI,root/html530/ROOT__Math__Roots__Brent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Roots__Brent.html
Usability,simpl,simplest,". ROOT::Math::Roots::FalsePos. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::Roots::FalsePos. class ROOT::Math::Roots::FalsePos: public ROOT::Math::GSLRootFinder. Roots::Bisection; 	Bisection algorithm, simplest algorithm for bracketing the roots of a function, but slowest one.; 	See the <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Root-Bracketing-Algorithms.html"">GSL manual</A> for more information; 	@ingroup RootFinders. Function Members (Methods); public:. virtual~FalsePos(); ROOT::Math::Roots::FalsePosFalsePos(); ROOT::Math::GSLRootFinderROOT::Math::GSLRootFinder::GSLRootFinder(); virtual intROOT::Math::GSLRootFinder::Iterate(); virtual intROOT::Math::GSLRootFinder::Iterations() const; virtual const char*ROOT::Math::GSLRootFinder::Name() const; virtual doubleROOT::Math::GSLRootFinder::Root() const; virtual boolROOT::Math::GSLRootFinder::SetFunction(const ROOT::Math::IGradFunction&, double); virtual boolROOT::Math::GSLRootFinder::SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); boolROOT::Math::GSLRootFinder::SetFunction(ROOT::Math::GSLRootFinder::GSLFuncPointer f, void* params, double xlow, double xup); virtual boolROOT::Math::GSLRootFinder::Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); virtual intROOT::Math::GSLRootFinder::Status() const. protected:. voidROOT::Math::GSLRootFinder::FreeSolver(); voidROOT::Math::GSLRootFinder::SetSolver(ROOT::Math::GSLRootFSolver* s). private:. ROOT::Math::Roots::FalsePosFalsePos(const ROOT::Math::Roots::FalsePos&); ROOT::Math::Roots::FalsePos&operator=(const ROOT::Math::Roots::FalsePos&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FalsePos(). virtual ~FalsePos(). FalsePos(const ROOT::Math::Roots::FalsePos& ); usually copying is non trivial, so we ma",MatchSource.WIKI,root/html530/ROOT__Math__Roots__FalsePos.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Roots__FalsePos.html
Usability,simpl,simplest,". ROOT::Math::Roots::Newton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::Roots::Newton. class ROOT::Math::Roots::Newton: public ROOT::Math::GSLRootFinderDeriv. Roots::Bisection; 	Bisection algorithm, simplest algorithm for bracketing the roots of a function, but slowest one.; 	See the <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Root-Bracketing-Algorithms.html"">GSL manual</A> for more information; 	@ingroup RootFinders. Function Members (Methods); public:. virtual~Newton(); ROOT::Math::GSLRootFinderDerivROOT::Math::GSLRootFinderDeriv::GSLRootFinderDeriv(); virtual intROOT::Math::GSLRootFinderDeriv::Iterate(); virtual intROOT::Math::GSLRootFinderDeriv::Iterations() const; virtual const char*ROOT::Math::GSLRootFinderDeriv::Name() const; ROOT::Math::Roots::NewtonNewton(); virtual doubleROOT::Math::GSLRootFinderDeriv::Root() const; virtual boolROOT::Math::GSLRootFinderDeriv::SetFunction(const ROOT::Math::IGradFunction& f, double xstart); virtual boolROOT::Math::GSLRootFinderDeriv::SetFunction(const ROOT::Math::IGenFunction&, double, double); boolROOT::Math::GSLRootFinderDeriv::SetFunction(ROOT::Math::GSLRootFinderDeriv::GSLFuncPointer f, ROOT::Math::GSLRootFinderDeriv::GSLFuncPointer df, ROOT::Math::GSLRootFinderDeriv::GSLFdFPointer fdf, void* p, double Root); virtual boolROOT::Math::GSLRootFinderDeriv::Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); virtual intROOT::Math::GSLRootFinderDeriv::Status() const. protected:. voidROOT::Math::GSLRootFinderDeriv::FreeSolver(); voidROOT::Math::GSLRootFinderDeriv::SetSolver(ROOT::Math::GSLRootFdFSolver* s). private:. ROOT::Math::Roots::NewtonNewton(const ROOT::Math::Roots::Newton&); ROOT::Math::Roots::Newton&operator=(const ROOT::Math::Roots::Newton&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. F",MatchSource.WIKI,root/html530/ROOT__Math__Roots__Newton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Roots__Newton.html
Usability,simpl,simplest,". ROOT::Math::Roots::Secant. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::Roots::Secant. class ROOT::Math::Roots::Secant: public ROOT::Math::GSLRootFinderDeriv. Roots::Bisection; 	Bisection algorithm, simplest algorithm for bracketing the roots of a function, but slowest one.; 	See the <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Root-Bracketing-Algorithms.html"">GSL manual</A> for more information; 	@ingroup RootFinders. Function Members (Methods); public:. virtual~Secant(); ROOT::Math::GSLRootFinderDerivROOT::Math::GSLRootFinderDeriv::GSLRootFinderDeriv(); virtual intROOT::Math::GSLRootFinderDeriv::Iterate(); virtual intROOT::Math::GSLRootFinderDeriv::Iterations() const; virtual const char*ROOT::Math::GSLRootFinderDeriv::Name() const; virtual doubleROOT::Math::GSLRootFinderDeriv::Root() const; ROOT::Math::Roots::SecantSecant(); virtual boolROOT::Math::GSLRootFinderDeriv::SetFunction(const ROOT::Math::IGradFunction& f, double xstart); virtual boolROOT::Math::GSLRootFinderDeriv::SetFunction(const ROOT::Math::IGenFunction&, double, double); boolROOT::Math::GSLRootFinderDeriv::SetFunction(ROOT::Math::GSLRootFinderDeriv::GSLFuncPointer f, ROOT::Math::GSLRootFinderDeriv::GSLFuncPointer df, ROOT::Math::GSLRootFinderDeriv::GSLFdFPointer fdf, void* p, double Root); virtual boolROOT::Math::GSLRootFinderDeriv::Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); virtual intROOT::Math::GSLRootFinderDeriv::Status() const. protected:. voidROOT::Math::GSLRootFinderDeriv::FreeSolver(); voidROOT::Math::GSLRootFinderDeriv::SetSolver(ROOT::Math::GSLRootFdFSolver* s). private:. ROOT::Math::Roots::Secant&operator=(const ROOT::Math::Roots::Secant&); ROOT::Math::Roots::SecantSecant(const ROOT::Math::Roots::Secant&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. F",MatchSource.WIKI,root/html530/ROOT__Math__Roots__Secant.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Roots__Secant.html
Usability,simpl,simplest,". ROOT::Math::Roots::Steffenson. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::Roots::Steffenson. class ROOT::Math::Roots::Steffenson: public ROOT::Math::GSLRootFinderDeriv. Roots::Bisection; 	Bisection algorithm, simplest algorithm for bracketing the roots of a function, but slowest one.; 	See the <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Root-Bracketing-Algorithms.html"">GSL manual</A> for more information; 	@ingroup RootFinders. Function Members (Methods); public:. virtual~Steffenson(); ROOT::Math::GSLRootFinderDerivROOT::Math::GSLRootFinderDeriv::GSLRootFinderDeriv(); virtual intROOT::Math::GSLRootFinderDeriv::Iterate(); virtual intROOT::Math::GSLRootFinderDeriv::Iterations() const; virtual const char*ROOT::Math::GSLRootFinderDeriv::Name() const; virtual doubleROOT::Math::GSLRootFinderDeriv::Root() const; virtual boolROOT::Math::GSLRootFinderDeriv::SetFunction(const ROOT::Math::IGradFunction& f, double xstart); virtual boolROOT::Math::GSLRootFinderDeriv::SetFunction(const ROOT::Math::IGenFunction&, double, double); boolROOT::Math::GSLRootFinderDeriv::SetFunction(ROOT::Math::GSLRootFinderDeriv::GSLFuncPointer f, ROOT::Math::GSLRootFinderDeriv::GSLFuncPointer df, ROOT::Math::GSLRootFinderDeriv::GSLFdFPointer fdf, void* p, double Root); virtual boolROOT::Math::GSLRootFinderDeriv::Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); virtual intROOT::Math::GSLRootFinderDeriv::Status() const; ROOT::Math::Roots::SteffensonSteffenson(). protected:. voidROOT::Math::GSLRootFinderDeriv::FreeSolver(); voidROOT::Math::GSLRootFinderDeriv::SetSolver(ROOT::Math::GSLRootFdFSolver* s). private:. ROOT::Math::Roots::Steffenson&operator=(const ROOT::Math::Roots::Steffenson&); ROOT::Math::Roots::SteffensonSteffenson(const ROOT::Math::Roots::Steffenson&). Class Charts. Inheritanc",MatchSource.WIKI,root/html530/ROOT__Math__Roots__Steffenson.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Roots__Steffenson.html
Performance,perform,performed,"tion3D const & r ). copy constructor. explicit Rotation3D( AxisAngle const & a ). Construct from an AxisAngle. { gv_detail::convert(a, *this); }. explicit Rotation3D( EulerAngles const & e ). Construct from EulerAngles. { gv_detail::convert(e, *this); }. explicit Rotation3D( RotationZYX const & e ). Construct from RotationZYX. { gv_detail::convert(e, *this); }. explicit Rotation3D( Quaternion const & q ). Construct from a Quaternion. { gv_detail::convert(q, *this); }. explicit Rotation3D( RotationZ const & r ). Construct from an axial rotation. { gv_detail::convert(r, *this); }. explicit Rotation3D( RotationY const & r ); { gv_detail::convert(r, *this); }. explicit Rotation3D( RotationX const & r ); { gv_detail::convert(r, *this); }. explicit Rotation3D(const ForeignMatrix & m). Construct from a linear algebra matrix of size at least 3x3,; which must support operator()(i,j) to obtain elements (0,0) thru (2,2).; Precondition: The matrix is assumed to be orthonormal. No checking; or re-adjusting is performed. { SetComponents(m); }. Rotation3D(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v1, const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v2, const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v3). Construct from three orthonormal vectors (which must have methods; x(), y() and z()) which will be used as the columns of the rotation; matrix. The orthonormality will be checked, and values adjusted; so that the result will always be a good rotation matrix. SetComponents(ROOT::Math::Rotation3D::Scalar xx, ROOT::Math::Rotation3D::Scalar xy, ROOT::Math::Rotation3D::Scalar xz, ROOT::Math::Rotation3D::Scalar yx, ROOT::Math::Rotation3D::Scalar yy, ROOT::Math::Rotation3D::Scalar yz, ROOT::Math::Rotation3D::Scalar zx, ROOT::Math::Rotation3D::Scalar zy, ROOT::Math::Rotation3D::Scalar zz); compil",MatchSource.WIKI,root/html530/ROOT__Math__Rotation3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Rotation3D.html
Safety,avoid,avoid,"ateSystemTag>& v1, const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v2, const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v3). Construct from three orthonormal vectors (which must have methods; x(), y() and z()) which will be used as the columns of the rotation; matrix. The orthonormality will be checked, and values adjusted; so that the result will always be a good rotation matrix. SetComponents(ROOT::Math::Rotation3D::Scalar xx, ROOT::Math::Rotation3D::Scalar xy, ROOT::Math::Rotation3D::Scalar xz, ROOT::Math::Rotation3D::Scalar yx, ROOT::Math::Rotation3D::Scalar yy, ROOT::Math::Rotation3D::Scalar yz, ROOT::Math::Rotation3D::Scalar zx, ROOT::Math::Rotation3D::Scalar zy, ROOT::Math::Rotation3D::Scalar zz); compiler generated destruuctor is ok. Raw constructor from nine Scalar components (without any checking). operator=( Rotation3D const & rhs ); need to implement assignment operator to avoid using the templated one. Assignment operator. SetComponents(ROOT::Math::Rotation3D::Scalar xx, ROOT::Math::Rotation3D::Scalar xy, ROOT::Math::Rotation3D::Scalar xz, ROOT::Math::Rotation3D::Scalar yx, ROOT::Math::Rotation3D::Scalar yy, ROOT::Math::Rotation3D::Scalar yz, ROOT::Math::Rotation3D::Scalar zx, ROOT::Math::Rotation3D::Scalar zy, ROOT::Math::Rotation3D::Scalar zz). operator=( AxisAngle const & a ). Assign from an AxisAngle. { return operator=(Rotation3D(a)); }. operator=( EulerAngles const & e ). Assign from EulerAngles. { return operator=(Rotation3D(e)); }. operator=( RotationZYX const & r ). Assign from RotationZYX. { return operator=(Rotation3D(r)); }. operator=( Quaternion const & q ). Assign from a Quaternion. {return operator=(Rotation3D(q)); }. operator=( RotationZ const & r ). Assign from an axial rotation. { return operator=(Rotation3D(r)); }. operator=( RotationY const & r ); { return operator=(Rotation3D(r)); }. operator=( RotationX cons",MatchSource.WIKI,root/html530/ROOT__Math__Rotation3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Rotation3D.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix vi",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html
Integrability,interface,interface,"r<Double32_t,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,3,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html
Safety,avoid,avoid,"inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const Double32_t* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html
Security,access,access,"trix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >SMatrix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >(const ROOT::Math::SVector<Double32_t,3*(3+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,3,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html
Testability,assert,assert,"2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of sym",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix vi",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html
Integrability,interface,interface,"Vector<Double32_t,3*(3+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html
Safety,avoid,avoid,"inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const Double32_t* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html
Security,access,access,"Sym<Double32_t,3> >& rhs); ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >SMatrix<Double32_t,3,3,ROOT::Math::MatRepSym<Double32_t,3> >(const ROOT::Math::SVector<Double32_t,3*(3+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html
Testability,assert,assert,"2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of sym",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix vi",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html
Integrability,interface,interface,"r<Double32_t,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,4,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html
Safety,avoid,avoid,"inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const Double32_t* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html
Security,access,access,"trix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >SMatrix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >(const ROOT::Math::SVector<Double32_t,4*(4+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,4,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html
Testability,assert,assert,"2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of sym",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix vi",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html
Integrability,interface,interface,"Vector<Double32_t,4*(4+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html
Safety,avoid,avoid,"inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const Double32_t* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html
Security,access,access,"Sym<Double32_t,4> >& rhs); ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >SMatrix<Double32_t,4,4,ROOT::Math::MatRepSym<Double32_t,4> >(const ROOT::Math::SVector<Double32_t,4*(4+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html
Testability,assert,assert,"2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of sym",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix vi",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html
Integrability,interface,interface,"r<Double32_t,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,5,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html
Safety,avoid,avoid,"inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const Double32_t* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html
Security,access,access,"trix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >SMatrix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >(const ROOT::Math::SVector<Double32_t,5*(5+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,5,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html
Testability,assert,assert,"2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of sym",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix vi",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html
Integrability,interface,interface,"Vector<Double32_t,5*(5+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html
Safety,avoid,avoid,"inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const Double32_t* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html
Security,access,access,"Sym<Double32_t,5> >& rhs); ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >SMatrix<Double32_t,5,5,ROOT::Math::MatRepSym<Double32_t,5> >(const ROOT::Math::SVector<Double32_t,5*(5+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html
Testability,assert,assert,"2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of sym",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix vi",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html
Integrability,interface,interface,"r<Double32_t,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,6,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html
Safety,avoid,avoid,"inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const Double32_t* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html
Security,access,access,"trix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >SMatrix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >(const ROOT::Math::SVector<Double32_t,6*(6+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,6,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html
Testability,assert,assert,"2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of sym",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix vi",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html
Integrability,interface,interface,"Vector<Double32_t,6*(6+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html
Safety,avoid,avoid,"inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const Double32_t* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html
Security,access,access,"Sym<Double32_t,6> >& rhs); ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >(const ROOT::Math::SVector<Double32_t,6*(6+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html
Testability,assert,assert,"2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of sym",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
Integrability,interface,interface,"::SVector<double,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,2,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
Safety,avoid,avoid,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
Security,access,access,"e,2,2,ROOT::Math::MatRepStd<double,2,2> >SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >(const double& rhs); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >(const ROOT::Math::SVector<double,2*(2+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,2,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
Testability,assert,assert,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
Integrability,interface,interface,"st ROOT::Math::SVector<double,2*(2+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
Safety,avoid,avoid,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
Security,access,access,"(const ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >& rhs); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >(const double& rhs); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >(const ROOT::Math::SVector<double,2*(2+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
Testability,assert,assert,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
Integrability,interface,interface,"::SVector<double,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,3,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
Safety,avoid,avoid,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
Security,access,access,"e,3,3,ROOT::Math::MatRepStd<double,3,3> >SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >(const double& rhs); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >(const ROOT::Math::SVector<double,3*(3+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,3,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
Testability,assert,assert,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
Integrability,interface,interface,"st ROOT::Math::SVector<double,3*(3+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
Safety,avoid,avoid,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
Security,access,access,"(const ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >& rhs); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >(const double& rhs); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >(const ROOT::Math::SVector<double,3*(3+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
Testability,assert,assert,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
Integrability,interface,interface,"::SVector<double,3*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,3,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
Safety,avoid,avoid,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
Security,access,access,"e,3,4,ROOT::Math::MatRepStd<double,3,4> >SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >(const double& rhs); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >(const ROOT::Math::SVector<double,3*(4+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,3,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
Testability,assert,assert,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
Integrability,interface,interface,"::SVector<double,4*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,4,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
Safety,avoid,avoid,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
Security,access,access,"e,4,3,ROOT::Math::MatRepStd<double,4,3> >SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >(const double& rhs); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >(const ROOT::Math::SVector<double,4*(3+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,4,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
Testability,assert,assert,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
Integrability,interface,interface,"::SVector<double,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,4,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
Safety,avoid,avoid,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
Security,access,access,"e,4,4,ROOT::Math::MatRepStd<double,4,4> >SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >(const double& rhs); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >(const ROOT::Math::SVector<double,4*(4+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,4,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
Testability,assert,assert,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
Integrability,interface,interface,"st ROOT::Math::SVector<double,4*(4+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
Safety,avoid,avoid,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
Security,access,access,"(const ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >& rhs); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >(const double& rhs); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >(const ROOT::Math::SVector<double,4*(4+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
Testability,assert,assert,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
Integrability,interface,interface,"::SVector<double,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,5,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
Safety,avoid,avoid,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
Security,access,access,"e,5,5,ROOT::Math::MatRepStd<double,5,5> >SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >(const double& rhs); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >(const ROOT::Math::SVector<double,5*(5+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,5,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
Testability,assert,assert,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
Integrability,interface,interface,"st ROOT::Math::SVector<double,5*(5+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
Safety,avoid,avoid,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
Security,access,access,"(const ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >& rhs); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >(const double& rhs); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >(const ROOT::Math::SVector<double,5*(5+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
Testability,assert,assert,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
Integrability,interface,interface,"::SVector<double,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,6,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
Safety,avoid,avoid,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
Security,access,access,"e,6,6,ROOT::Math::MatRepStd<double,6,6> >SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >(const double& rhs); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >(const ROOT::Math::SVector<double,6*(6+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,6,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
Testability,assert,assert,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
Integrability,interface,interface,"st ROOT::Math::SVector<double,6*(6+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
Safety,avoid,avoid,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
Security,access,access,"(const ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >& rhs); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >(const double& rhs); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >(const ROOT::Math::SVector<double,6*(6+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
Testability,assert,assert,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
Integrability,interface,interface,"::SVector<double,7*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,7,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
Safety,avoid,avoid,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
Security,access,access,"e,7,7,ROOT::Math::MatRepStd<double,7,7> >SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >(const double& rhs); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >(const ROOT::Math::SVector<double,7*(7+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,7*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,7,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
Testability,assert,assert,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
Integrability,interface,interface,"st ROOT::Math::SVector<double,7*(7+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,7*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
Safety,avoid,avoid,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
Security,access,access,"(const ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >& rhs); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >(const double& rhs); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >(const ROOT::Math::SVector<double,7*(7+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,7*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
Testability,assert,assert,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
Integrability,interface,interface,"::SVector<double,9*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,9,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
Safety,avoid,avoid,"In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const double* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
Security,access,access,"e,9,7,ROOT::Math::MatRepStd<double,9,7> >SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >(const double& rhs); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >(const ROOT::Math::SVector<double,9*(7+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,9*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,9,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
Testability,assert,assert,"\\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
Integrability,interface,interface,"th::SVector<float,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,2,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
Safety,avoid,avoid,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
Security,access,access,"SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >(const float& rhs); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >SMatrix<float,2,2,ROOT::Math::MatRepStd<float,2,2> >(const ROOT::Math::SVector<float,2*(2+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,2,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
Testability,assert,assert,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
Integrability,interface,interface,"(const ROOT::Math::SVector<float,2*(2+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
Safety,avoid,avoid,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
Security,access,access,"pSym<float,2> >(const ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >& rhs); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >(const float& rhs); ROOT::Math::SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >SMatrix<float,2,2,ROOT::Math::MatRepSym<float,2> >(const ROOT::Math::SVector<float,2*(2+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
Testability,assert,assert,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepSym_float_2___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
Integrability,interface,interface,"th::SVector<float,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,3,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
Safety,avoid,avoid,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
Security,access,access,"SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >(const float& rhs); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >SMatrix<float,3,3,ROOT::Math::MatRepStd<float,3,3> >(const ROOT::Math::SVector<float,3*(3+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,3,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
Testability,assert,assert,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_3_3_-p1MatRepStd_float_3_3___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
Integrability,interface,interface,"(const ROOT::Math::SVector<float,3*(3+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
Safety,avoid,avoid,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
Security,access,access,"pSym<float,3> >(const ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >& rhs); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >(const float& rhs); ROOT::Math::SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >SMatrix<float,3,3,ROOT::Math::MatRepSym<float,3> >(const ROOT::Math::SVector<float,3*(3+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
Testability,assert,assert,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_3_3_-p1MatRepSym_float_3___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
Integrability,interface,interface,"th::SVector<float,3*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,3,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
Safety,avoid,avoid,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
Security,access,access,"SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >(const float& rhs); ROOT::Math::SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >SMatrix<float,3,4,ROOT::Math::MatRepStd<float,3,4> >(const ROOT::Math::SVector<float,3*(4+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,3*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,3,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
Testability,assert,assert,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_3_4_-p1MatRepStd_float_3_4___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
Integrability,interface,interface,"th::SVector<float,4*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,4,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
Safety,avoid,avoid,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
Security,access,access,"SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >(const float& rhs); ROOT::Math::SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >SMatrix<float,4,3,ROOT::Math::MatRepStd<float,4,3> >(const ROOT::Math::SVector<float,4*(3+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,4,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
Testability,assert,assert,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_4_3_-p1MatRepStd_float_4_3___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
Integrability,interface,interface,"th::SVector<float,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,4,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
Safety,avoid,avoid,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
Security,access,access,"SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >(const float& rhs); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >SMatrix<float,4,4,ROOT::Math::MatRepStd<float,4,4> >(const ROOT::Math::SVector<float,4*(4+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,4,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
Testability,assert,assert,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_4_4_-p1MatRepStd_float_4_4___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
Integrability,interface,interface,"(const ROOT::Math::SVector<float,4*(4+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
Safety,avoid,avoid,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
Security,access,access,"pSym<float,4> >(const ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >& rhs); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >(const float& rhs); ROOT::Math::SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >SMatrix<float,4,4,ROOT::Math::MatRepSym<float,4> >(const ROOT::Math::SVector<float,4*(4+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
Testability,assert,assert,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_4_4_-p1MatRepSym_float_4___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
Integrability,interface,interface,"th::SVector<float,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,5,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
Safety,avoid,avoid,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
Security,access,access,"SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >(const float& rhs); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >SMatrix<float,5,5,ROOT::Math::MatRepStd<float,5,5> >(const ROOT::Math::SVector<float,5*(5+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,5,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
Testability,assert,assert,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_5_5_-p1MatRepStd_float_5_5___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html
Integrability,interface,interface,"(const ROOT::Math::SVector<float,5*(5+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html
Safety,avoid,avoid,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html
Security,access,access,"pSym<float,5> >(const ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >& rhs); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >(const float& rhs); ROOT::Math::SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >SMatrix<float,5,5,ROOT::Math::MatRepSym<float,5> >(const ROOT::Math::SVector<float,5*(5+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html
Testability,assert,assert,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_5_5_-p1MatRepSym_float_5___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html
Integrability,interface,interface,"th::SVector<float,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,6,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html
Safety,avoid,avoid,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html
Security,access,access,"SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >(const float& rhs); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >SMatrix<float,6,6,ROOT::Math::MatRepStd<float,6,6> >(const ROOT::Math::SVector<float,6*(6+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,6,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html
Testability,assert,assert,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_6_6_-p1MatRepStd_float_6_6___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html
Integrability,interface,interface,"(const ROOT::Math::SVector<float,6*(6+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html
Safety,avoid,avoid,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html
Security,access,access,"pSym<float,6> >(const ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >& rhs); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >(const float& rhs); ROOT::Math::SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >SMatrix<float,6,6,ROOT::Math::MatRepSym<float,6> >(const ROOT::Math::SVector<float,6*(6+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html
Testability,assert,assert,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_6_6_-p1MatRepSym_float_6___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html
Integrability,interface,interface,"th::SVector<float,7*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,7,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html
Safety,avoid,avoid,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html
Security,access,access,"SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >(const float& rhs); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >SMatrix<float,7,7,ROOT::Math::MatRepStd<float,7,7> >(const ROOT::Math::SVector<float,7*(7+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,7*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,7,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html
Testability,assert,assert,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_7_7_-p1MatRepStd_float_7_7___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html
Integrability,interface,interface,"(const ROOT::Math::SVector<float,7*(7+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,7*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html
Safety,avoid,avoid,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html
Security,access,access,"pSym<float,7> >(const ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >& rhs); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >(const float& rhs); ROOT::Math::SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >SMatrix<float,7,7,ROOT::Math::MatRepSym<float,7> >(const ROOT::Math::SVector<float,7*(7+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,7*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<float,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html
Testability,assert,assert,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_7_7_-p1MatRepSym_float_7___.html
Availability,error,error,"ion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html
Integrability,interface,interface,"th::SVector<float,9*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,9,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html
Performance,perform,performing,"is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html
Safety,avoid,avoid,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html
Security,access,access,"SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >(const float& rhs); ROOT::Math::SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >SMatrix<float,9,7,ROOT::Math::MatRepStd<float,9,7> >(const ROOT::Math::SVector<float,9*(7+1)/2>& v, bool lower = true); floatTrace() const; ROOT::Math::SVector<float,9*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<float,9,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html
Testability,assert,assert,"_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunc",MatchSource.WIKI,root/html530/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_9_7_-p1MatRepStd_float_9_7___.html
Integrability,interface,interface," const Double32_t& a8, const Double32_t& a9); ROOT::Math::SVector<Double32_t,3>SVector<Double32_t,3>(const Double32_t& a1, const Double32_t& a2, const Double32_t& a3, const Double32_t& a4, const Double32_t& a5, const Double32_t& a6, const Double32_t& a7, const Double32_t& a8, const Double32_t& a9, const Double32_t& a10); ROOT::Math::SVector<Double32_t,3>&Unit(). Data Members; public:. enum { kSize; };. private:. Double32_tfArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html530/ROOT__Math__SVector_Double32_t_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_Double32_t_3_.html
Security,access,access,"a8); ROOT::Math::SVector<Double32_t,3>SVector<Double32_t,3>(const Double32_t& a1, const Double32_t& a2, const Double32_t& a3, const Double32_t& a4, const Double32_t& a5, const Double32_t& a6, const Double32_t& a7, const Double32_t& a8, const Double32_t& a9); ROOT::Math::SVector<Double32_t,3>SVector<Double32_t,3>(const Double32_t& a1, const Double32_t& a2, const Double32_t& a3, const Double32_t& a4, const Double32_t& a5, const Double32_t& a6, const Double32_t& a7, const Double32_t& a8, const Double32_t& a9, const Double32_t& a10); ROOT::Math::SVector<Double32_t,3>&Unit(). Data Members; public:. enum { kSize; };. private:. Double32_tfArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root/html530/ROOT__Math__SVector_Double32_t_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_Double32_t_3_.html
Integrability,interface,interface," const Double32_t& a8, const Double32_t& a9); ROOT::Math::SVector<Double32_t,4>SVector<Double32_t,4>(const Double32_t& a1, const Double32_t& a2, const Double32_t& a3, const Double32_t& a4, const Double32_t& a5, const Double32_t& a6, const Double32_t& a7, const Double32_t& a8, const Double32_t& a9, const Double32_t& a10); ROOT::Math::SVector<Double32_t,4>&Unit(). Data Members; public:. enum { kSize; };. private:. Double32_tfArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html530/ROOT__Math__SVector_Double32_t_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_Double32_t_4_.html
Security,access,access,"a8); ROOT::Math::SVector<Double32_t,4>SVector<Double32_t,4>(const Double32_t& a1, const Double32_t& a2, const Double32_t& a3, const Double32_t& a4, const Double32_t& a5, const Double32_t& a6, const Double32_t& a7, const Double32_t& a8, const Double32_t& a9); ROOT::Math::SVector<Double32_t,4>SVector<Double32_t,4>(const Double32_t& a1, const Double32_t& a2, const Double32_t& a3, const Double32_t& a4, const Double32_t& a5, const Double32_t& a6, const Double32_t& a7, const Double32_t& a8, const Double32_t& a9, const Double32_t& a10); ROOT::Math::SVector<Double32_t,4>&Unit(). Data Members; public:. enum { kSize; };. private:. Double32_tfArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root/html530/ROOT__Math__SVector_Double32_t_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_Double32_t_4_.html
Integrability,interface,interface," const Double32_t& a8, const Double32_t& a9); ROOT::Math::SVector<Double32_t,5>SVector<Double32_t,5>(const Double32_t& a1, const Double32_t& a2, const Double32_t& a3, const Double32_t& a4, const Double32_t& a5, const Double32_t& a6, const Double32_t& a7, const Double32_t& a8, const Double32_t& a9, const Double32_t& a10); ROOT::Math::SVector<Double32_t,5>&Unit(). Data Members; public:. enum { kSize; };. private:. Double32_tfArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html530/ROOT__Math__SVector_Double32_t_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_Double32_t_5_.html
Security,access,access,"a8); ROOT::Math::SVector<Double32_t,5>SVector<Double32_t,5>(const Double32_t& a1, const Double32_t& a2, const Double32_t& a3, const Double32_t& a4, const Double32_t& a5, const Double32_t& a6, const Double32_t& a7, const Double32_t& a8, const Double32_t& a9); ROOT::Math::SVector<Double32_t,5>SVector<Double32_t,5>(const Double32_t& a1, const Double32_t& a2, const Double32_t& a3, const Double32_t& a4, const Double32_t& a5, const Double32_t& a6, const Double32_t& a7, const Double32_t& a8, const Double32_t& a9, const Double32_t& a10); ROOT::Math::SVector<Double32_t,5>&Unit(). Data Members; public:. enum { kSize; };. private:. Double32_tfArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root/html530/ROOT__Math__SVector_Double32_t_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_Double32_t_5_.html
Integrability,interface,interface," const Double32_t& a8, const Double32_t& a9); ROOT::Math::SVector<Double32_t,6>SVector<Double32_t,6>(const Double32_t& a1, const Double32_t& a2, const Double32_t& a3, const Double32_t& a4, const Double32_t& a5, const Double32_t& a6, const Double32_t& a7, const Double32_t& a8, const Double32_t& a9, const Double32_t& a10); ROOT::Math::SVector<Double32_t,6>&Unit(). Data Members; public:. enum { kSize; };. private:. Double32_tfArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html530/ROOT__Math__SVector_Double32_t_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_Double32_t_6_.html
Security,access,access,"a8); ROOT::Math::SVector<Double32_t,6>SVector<Double32_t,6>(const Double32_t& a1, const Double32_t& a2, const Double32_t& a3, const Double32_t& a4, const Double32_t& a5, const Double32_t& a6, const Double32_t& a7, const Double32_t& a8, const Double32_t& a9); ROOT::Math::SVector<Double32_t,6>SVector<Double32_t,6>(const Double32_t& a1, const Double32_t& a2, const Double32_t& a3, const Double32_t& a4, const Double32_t& a5, const Double32_t& a6, const Double32_t& a7, const Double32_t& a8, const Double32_t& a9, const Double32_t& a10); ROOT::Math::SVector<Double32_t,6>&Unit(). Data Members; public:. enum { kSize; };. private:. Double32_tfArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root/html530/ROOT__Math__SVector_Double32_t_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_Double32_t_6_.html
Integrability,interface,interface,"ouble& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,2>SVector<double,2>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,2>&Unit(). Data Members; public:. enum { kSize; };. private:. doublefArray[2]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html530/ROOT__Math__SVector_double_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_double_2_.html
Security,access,access,"t double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,2>SVector<double,2>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,2>SVector<double,2>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,2>&Unit(). Data Members; public:. enum { kSize; };. private:. doublefArray[2]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root/html530/ROOT__Math__SVector_double_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_double_2_.html
Integrability,interface,interface,"ouble& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,3>&Unit(). Data Members; public:. enum { kSize; };. private:. doublefArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html530/ROOT__Math__SVector_double_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_double_3_.html
Security,access,access,"t double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,3>&Unit(). Data Members; public:. enum { kSize; };. private:. doublefArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root/html530/ROOT__Math__SVector_double_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_double_3_.html
Integrability,interface,interface,"ouble& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,4>&Unit(). Data Members; public:. enum { kSize; };. private:. doublefArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html530/ROOT__Math__SVector_double_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_double_4_.html
Security,access,access,"t double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,4>&Unit(). Data Members; public:. enum { kSize; };. private:. doublefArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root/html530/ROOT__Math__SVector_double_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_double_4_.html
Integrability,interface,interface,"ouble& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,5>&Unit(). Data Members; public:. enum { kSize; };. private:. doublefArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html530/ROOT__Math__SVector_double_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_double_5_.html
Security,access,access,"t double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,5>&Unit(). Data Members; public:. enum { kSize; };. private:. doublefArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root/html530/ROOT__Math__SVector_double_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_double_5_.html
Integrability,interface,interface,"ouble& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,6>&Unit(). Data Members; public:. enum { kSize; };. private:. doublefArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html530/ROOT__Math__SVector_double_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_double_6_.html
Security,access,access,"t double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,6>&Unit(). Data Members; public:. enum { kSize; };. private:. doublefArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root/html530/ROOT__Math__SVector_double_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_double_6_.html
Integrability,interface,interface,"ouble& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,7>SVector<double,7>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,7>&Unit(). Data Members; public:. enum { kSize; };. private:. doublefArray[7]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html530/ROOT__Math__SVector_double_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_double_7_.html
Security,access,access,"t double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,7>SVector<double,7>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,7>SVector<double,7>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,7>&Unit(). Data Members; public:. enum { kSize; };. private:. doublefArray[7]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root/html530/ROOT__Math__SVector_double_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_double_7_.html
Integrability,interface,interface,"t float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,2>SVector<float,2>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,2>&Unit(). Data Members; public:. enum { kSize; };. private:. floatfArray[2]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html530/ROOT__Math__SVector_float_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_float_2_.html
Security,access,access,"loat& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,2>SVector<float,2>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,2>SVector<float,2>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,2>&Unit(). Data Members; public:. enum { kSize; };. private:. floatfArray[2]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root/html530/ROOT__Math__SVector_float_2_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_float_2_.html
Integrability,interface,interface,"t float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,3>SVector<float,3>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,3>&Unit(). Data Members; public:. enum { kSize; };. private:. floatfArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html530/ROOT__Math__SVector_float_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_float_3_.html
Security,access,access,"loat& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,3>SVector<float,3>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,3>SVector<float,3>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,3>&Unit(). Data Members; public:. enum { kSize; };. private:. floatfArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root/html530/ROOT__Math__SVector_float_3_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_float_3_.html
Integrability,interface,interface,"t float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,4>SVector<float,4>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,4>&Unit(). Data Members; public:. enum { kSize; };. private:. floatfArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html530/ROOT__Math__SVector_float_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_float_4_.html
Security,access,access,"loat& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,4>SVector<float,4>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,4>SVector<float,4>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,4>&Unit(). Data Members; public:. enum { kSize; };. private:. floatfArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root/html530/ROOT__Math__SVector_float_4_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_float_4_.html
Integrability,interface,interface,"t float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,5>SVector<float,5>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,5>&Unit(). Data Members; public:. enum { kSize; };. private:. floatfArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html530/ROOT__Math__SVector_float_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_float_5_.html
Security,access,access,"loat& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,5>SVector<float,5>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,5>SVector<float,5>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,5>&Unit(). Data Members; public:. enum { kSize; };. private:. floatfArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root/html530/ROOT__Math__SVector_float_5_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_float_5_.html
Integrability,interface,interface,"t float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,6>SVector<float,6>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,6>&Unit(). Data Members; public:. enum { kSize; };. private:. floatfArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html530/ROOT__Math__SVector_float_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_float_6_.html
Security,access,access,"loat& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,6>SVector<float,6>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,6>SVector<float,6>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,6>&Unit(). Data Members; public:. enum { kSize; };. private:. floatfArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root/html530/ROOT__Math__SVector_float_6_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_float_6_.html
Integrability,interface,interface,"t float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,7>SVector<float,7>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,7>&Unit(). Data Members; public:. enum { kSize; };. private:. floatfArray[7]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root/html530/ROOT__Math__SVector_float_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_float_7_.html
Security,access,access,"loat& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8); ROOT::Math::SVector<float,7>SVector<float,7>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9); ROOT::Math::SVector<float,7>SVector<float,7>(const float& a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,7>&Unit(). Data Members; public:. enum { kSize; };. private:. floatfArray[7]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root/html530/ROOT__Math__SVector_float_7_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__SVector_float_7_.html
Usability,simpl,simple,". ROOT::Math::Transform3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » GENVECTOR; » ROOT::Math::Transform3D. class ROOT::Math::Transform3D. Basic 3D Transformation class describing a rotation and then a translation; The internal data are a 3D rotation data (represented as a 3x3 matrix) and a 3D vector data.; They are represented and held in this class like a 3x4 matrix (a simple array of 12 numbers). The class can be constructed from any 3D rotation object; (ROOT::Math::Rotation3D, ROOT::Math::AxisAngle, ROOT::Math::Quaternion, etc...) and/or; a 3D Vector (ROOT::Math::DislacementVector3D or via ROOT::Math::Translation ) representing a Translation.; The Transformation is defined by applying first the rotation and then the translation.; A transformation defined by applying first a translation and then a rotation is equivalent to the; transformation obtained applying first the rotation and then a translation equivalent to the rotated vector.; The operator * can be used to obtain directly such transformations, in addition to combine various; transformations.; Keep in mind that the operator * (like in the case of rotations ) is not commutative.; The operator * is used (in addition to operator() ) to apply a transformations on the vector; (DisplacementVector3D and LorentzVector classes) and point (PositionVector3D) classes.; In the case of Vector objects the transformation only rotates them and does not translate them.; Only Point objects are able to be both rotated and translated. @ingroup GenVector. Function Members (Methods); public:. ~Transform3D(); voidGetComponents(double* begin) const; voidGetComponents(double& xx, double& xy, double& xz, double& dx, double& yx, double& yy, double& yz, double& dy, double& zx, double& zy, double& zz, double& dz) const; voidGetDecomposition(ROOT::Math::Rotation3D& r, ROOT::Math::Tra",MatchSource.WIKI,root/html530/ROOT__Math__Transform3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Transform3D.html
Performance,perform,performes,". ROOT::Math::Translation3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » GENVECTOR; » ROOT::Math::Translation3D. class ROOT::Math::Translation3D. Class describing a 3 dimensional translation. It can be combined (using the operator *); with the ROOT::Math::Rotation3D classes and ROOT::Math::Transform3D to obtained combined; transformations and to operate on points and vectors.; Note that a the translation applied to a Vector object (DisplacementVector3D and LorentzVector classes); performes a noop, i.e. it returns the same vector. A translation can be applied only to the Point objects; (PositionVector3D classes). @ingroup GenVector. Function Members (Methods); public:. ~Translation3D(); voidGetComponents(double& dx, double& dy, double& dz) const; ROOT::Math::Translation3DInverse() const; voidInvert(); booloperator!=(const ROOT::Math::Translation3D& rhs) const; ROOT::Math::Plane3Doperator()(const ROOT::Math::Plane3D& plane) const; ROOT::Math::Translation3Doperator*(const ROOT::Math::Translation3D& t) const; ROOT::Math::Translation3D&operator*=(const ROOT::Math::Translation3D& t); ROOT::Math::Translation3D&operator=(const ROOT::Math::Translation3D&); booloperator==(const ROOT::Math::Translation3D& rhs) const; voidSetComponents(double dx, double dy, double dz); voidSetXYZ(double dx, double dy, double dz); ROOT::Math::Translation3DTranslation3D(); ROOT::Math::Translation3DTranslation3D(const ROOT::Math::Translation3D&); ROOT::Math::Translation3DTranslation3D(double dx, double dy, double dz); const ROOT::Math::Translation3D::Vector&Vect() const. Data Members; private:. ROOT::Math::Translation3D::VectorfVectinternal 3D vector representing the translation . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Translation3D(). Default constructor ( zero translation ). {}. Translation3D(",MatchSource.WIKI,root/html530/ROOT__Math__Translation3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Translation3D.html
Availability,avail,available,"om numbers,; <A HREF=""http://dx.doi.org/10.1016/0010-4655(74)90091-5"">Computer Phys. Comm. 7 (1974) 215-224</A>,; which has been implemented in; <A HREF=""http://wwwasdoc.web.cern.ch/wwwasdoc/shortwrupsdir/g116/top.html"">; CERNLIB (G116)</A>. Both subclasses store coefficients needed to calculate \f$p(\lambda; \kappa, \beta^2)\f$; for fixed values of \f$\kappa\f$ and \f$\beta^2\f$.; Changing these values is computationally expensive. VavilovFast is about 5 times faster for the calculation of the Pdf than VavilovAccurate;; initialization takes about 100 times longer than calculation of the Pdf value.; For the quantile calculation, VavilovFast; is 30 times faster for the initialization, and 6 times faster for; subsequent calculations. Initialization for Quantile takes; 27 (11) times longer than subsequent calls for VavilovFast (VavilovAccurate). @ingroup StatFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~Vavilov(); virtual doubleCdf(double x) const; virtual doubleCdf(double x, double kappa, double beta2); virtual doubleCdf_c(double x) const; virtual doubleCdf_c(double x, double kappa, double beta2); virtual doubleGetBeta2() const; virtual doubleGetKappa() const; virtual doubleGetLambdaMax() const; virtual doubleGetLambdaMin() const; virtual doubleKurtosis() const; static doubleKurtosis(double kappa, double beta2); virtual doubleMean() const; static doubleMean(double kappa, double beta2); virtual doubleMode() const; virtual doubleMode(double kappa, double beta2); ROOT::Math::Vavilov&operator=(const ROOT::Math::Vavilov&); virtual doublePdf(double x) const; virtual doublePdf(double x, double kappa, double beta2); virtual doubleQuantile(double z) const; virtual doubleQuantile(double z, double kappa, double beta2); virtual doubleQuantile_c(double z) const; virtual doubleQuantile_c(double z, double kappa, double beta2); virtual voidSetKappaBet",MatchSource.WIKI,root/html530/ROOT__Math__Vavilov.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Vavilov.html
Energy Efficiency,energy,energy,". ROOT::Math::Vavilov. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::Vavilov. class ROOT::Math::Vavilov. Base class describing a Vavilov distribution. The Vavilov distribution is defined in; P.V. Vavilov: Ionization losses of high-energy heavy particles,; Sov. Phys. JETP 5 (1957) 749 [Zh. Eksp. Teor. Fiz. 32 (1957) 920]. The probability density function of the Vavilov distribution; as function of Landau's parameter is given by:; \f[ p(\lambda_L; \kappa, \beta^2) =; \frac{1}{2 \pi i}\int_{c-i\infty}^{c+i\infty} \phi(s) e^{\lambda_L s} ds\f]; where \f$\phi(s) = e^{C} e^{\psi(s)}\f$; with \f$ C = \kappa (1+\beta^2 \gamma )\f$; and \f$\psi(s)= s \ln \kappa + (s+\beta^2 \kappa); \cdot \left ( \int \limits_{0}^{1}; \frac{1 - e^{\frac{-st}{\kappa}}}{t} \,d t- \gamma \right ); - \kappa \, e^{\frac{-s}{\kappa}}\f$.; \f$ \gamma = 0.5772156649\dots\f$ is Euler's constant. For the class Vavilov,; Pdf returns the Vavilov distribution as function of Landau's parameter; \f$\lambda_L = \lambda_V/\kappa - \ln \kappa\f$,; which is the convention used in the CERNLIB routines, and in the tables; by S.M. Seltzer and M.J. Berger: Energy loss stragglin of protons and mesons:; Tabulation of the Vavilov distribution, pp 187-203; in: National Research Council (U.S.), Committee on Nuclear Science:; Studies in penetration of charged particles in matter,; Nat. Akad. Sci. Publication 1133,; Nucl. Sci. Series Report No. 39,; Washington (Nat. Akad. Sci.) 1964, 388 pp.; Available from; <A HREF=""http://books.google.de/books?id=kmMrAAAAYAAJ&lpg=PP9&pg=PA187#v=onepage&q&f=false"">Google books</A>. Therefore, for small values of \f$\kappa < 0.01\f$,; pdf approaches the Landau distribution. For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::Mean(kappa, beta2); and",MatchSource.WIKI,root/html530/ROOT__Math__Vavilov.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Vavilov.html
Integrability,rout,routines,"nction members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::Vavilov. class ROOT::Math::Vavilov. Base class describing a Vavilov distribution. The Vavilov distribution is defined in; P.V. Vavilov: Ionization losses of high-energy heavy particles,; Sov. Phys. JETP 5 (1957) 749 [Zh. Eksp. Teor. Fiz. 32 (1957) 920]. The probability density function of the Vavilov distribution; as function of Landau's parameter is given by:; \f[ p(\lambda_L; \kappa, \beta^2) =; \frac{1}{2 \pi i}\int_{c-i\infty}^{c+i\infty} \phi(s) e^{\lambda_L s} ds\f]; where \f$\phi(s) = e^{C} e^{\psi(s)}\f$; with \f$ C = \kappa (1+\beta^2 \gamma )\f$; and \f$\psi(s)= s \ln \kappa + (s+\beta^2 \kappa); \cdot \left ( \int \limits_{0}^{1}; \frac{1 - e^{\frac{-st}{\kappa}}}{t} \,d t- \gamma \right ); - \kappa \, e^{\frac{-s}{\kappa}}\f$.; \f$ \gamma = 0.5772156649\dots\f$ is Euler's constant. For the class Vavilov,; Pdf returns the Vavilov distribution as function of Landau's parameter; \f$\lambda_L = \lambda_V/\kappa - \ln \kappa\f$,; which is the convention used in the CERNLIB routines, and in the tables; by S.M. Seltzer and M.J. Berger: Energy loss stragglin of protons and mesons:; Tabulation of the Vavilov distribution, pp 187-203; in: National Research Council (U.S.), Committee on Nuclear Science:; Studies in penetration of charged particles in matter,; Nat. Akad. Sci. Publication 1133,; Nucl. Sci. Series Report No. 39,; Washington (Nat. Akad. Sci.) 1964, 388 pp.; Available from; <A HREF=""http://books.google.de/books?id=kmMrAAAAYAAJ&lpg=PP9&pg=PA187#v=onepage&q&f=false"">Google books</A>. Therefore, for small values of \f$\kappa < 0.01\f$,; pdf approaches the Landau distribution. For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::Mean(kappa, beta2); and sqrt(Vavilov::Variance(kappa, beta2). The original Vavilov pdf is obtained by; v.Pdf(lambdaV/kappa-log(kappa))/kappa. Two subclasses are provided:; - VavilovFast",MatchSource.WIKI,root/html530/ROOT__Math__Vavilov.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Vavilov.html
Testability,log,log,"stribution as function of Landau's parameter; \f$\lambda_L = \lambda_V/\kappa - \ln \kappa\f$,; which is the convention used in the CERNLIB routines, and in the tables; by S.M. Seltzer and M.J. Berger: Energy loss stragglin of protons and mesons:; Tabulation of the Vavilov distribution, pp 187-203; in: National Research Council (U.S.), Committee on Nuclear Science:; Studies in penetration of charged particles in matter,; Nat. Akad. Sci. Publication 1133,; Nucl. Sci. Series Report No. 39,; Washington (Nat. Akad. Sci.) 1964, 388 pp.; Available from; <A HREF=""http://books.google.de/books?id=kmMrAAAAYAAJ&lpg=PP9&pg=PA187#v=onepage&q&f=false"">Google books</A>. Therefore, for small values of \f$\kappa < 0.01\f$,; pdf approaches the Landau distribution. For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::Mean(kappa, beta2); and sqrt(Vavilov::Variance(kappa, beta2). The original Vavilov pdf is obtained by; v.Pdf(lambdaV/kappa-log(kappa))/kappa. Two subclasses are provided:; - VavilovFast uses the algorithm by; A. Rotondi and P. Montagna, Fast calculation of Vavilov distribution,; <A HREF=""http://dx.doi.org/10.1016/0168-583X(90)90749-K"">Nucl. Instr. and Meth. B47 (1990) 215-224</A>,; which has been implemented in; <A HREF=""http://wwwasdoc.web.cern.ch/wwwasdoc/shortwrupsdir/g115/top.html"">; CERNLIB (G115)</A>. - VavilovAccurate uses the algorithm by; B. Schorr, Programs for the Landau and the Vavilov distributions and the corresponding random numbers,; <A HREF=""http://dx.doi.org/10.1016/0010-4655(74)90091-5"">Computer Phys. Comm. 7 (1974) 215-224</A>,; which has been implemented in; <A HREF=""http://wwwasdoc.web.cern.ch/wwwasdoc/shortwrupsdir/g116/top.html"">; CERNLIB (G116)</A>. Both subclasses store coefficients needed to calculate \f$p(\lambda; \kappa, \beta^2)\f$; for fixed values of \f$\kappa\f$ and \f$\beta^2\f$.; Changing these values is computationally expensive. VavilovFast is about 5 times faster for t",MatchSource.WIKI,root/html530/ROOT__Math__Vavilov.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__Vavilov.html
Energy Efficiency,charge,charged,"ibution. The probability density function of the Vavilov distribution; as function of Landau's parameter is given by:; \f[ p(\lambda_L; \kappa, \beta^2) =; \frac{1}{2 \pi i}\int_{c-i\infty}^{c+i\infty} \phi(s) e^{\lambda_L s} ds\f]; where \f$\phi(s) = e^{C} e^{\psi(s)}\f$; with \f$ C = \kappa (1+\beta^2 \gamma )\f$; and \f$\psi(s)= s \ln \kappa + (s+\beta^2 \kappa); \cdot \left ( \int \limits_{0}^{1}; \frac{1 - e^{\frac{-st}{\kappa}}}{t} \,d t- \gamma \right ); - \kappa \, e^{\frac{-s}{\kappa}}\f$.; \f$ \gamma = 0.5772156649\dots\f$ is Euler's constant. For the class VavilovAccurate,; Pdf returns the Vavilov distribution as function of Landau's parameter; \f$\lambda_L = \lambda_V/\kappa - \ln \kappa\f$,; which is the convention used in the CERNLIB routines, and in the tables; by S.M. Seltzer and M.J. Berger: Energy loss stragglin of protons and mesons:; Tabulation of the Vavilov distribution, pp 187-203; in: National Research Council (U.S.), Committee on Nuclear Science:; Studies in penetration of charged particles in matter,; Nat. Akad. Sci. Publication 1133,; Nucl. Sci. Series Report No. 39,; Washington (Nat. Akad. Sci.) 1964, 388 pp.; Available from; <A HREF=""http://books.google.de/books?id=kmMrAAAAYAAJ&lpg=PP9&pg=PA187#v=onepage&q&f=false"">Google books</A>. Therefore, for small values of \f$\kappa < 0.01\f$,; pdf approaches the Landau distribution. For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::mean(kappa, beta2); and sqrt(Vavilov::variance(kappa, beta2). The original Vavilov pdf is obtained by; v.Pdf(lambdaV/kappa-log(kappa))/kappa. For detailed description see; B. Schorr, Programs for the Landau and the Vavilov distributions and the corresponding random numbers,; <A HREF=""http://dx.doi.org/10.1016/0010-4655(74)90091-5"">Computer Phys. Comm. 7 (1974) 215-224</A>,; which has been implemented in; <A HREF=""http://wwwasdoc.web.cern.ch/wwwasdoc/shortwrupsdir/g116/top.html"">; CERNLIB (G116)</A>. ",MatchSource.WIKI,root/html530/ROOT__Math__VavilovAccurate.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__VavilovAccurate.html
Integrability,rout,routines,"s:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::VavilovAccurate. class ROOT::Math::VavilovAccurate: public ROOT::Math::Vavilov. Class describing a Vavilov distribution. The probability density function of the Vavilov distribution; as function of Landau's parameter is given by:; \f[ p(\lambda_L; \kappa, \beta^2) =; \frac{1}{2 \pi i}\int_{c-i\infty}^{c+i\infty} \phi(s) e^{\lambda_L s} ds\f]; where \f$\phi(s) = e^{C} e^{\psi(s)}\f$; with \f$ C = \kappa (1+\beta^2 \gamma )\f$; and \f$\psi(s)= s \ln \kappa + (s+\beta^2 \kappa); \cdot \left ( \int \limits_{0}^{1}; \frac{1 - e^{\frac{-st}{\kappa}}}{t} \,d t- \gamma \right ); - \kappa \, e^{\frac{-s}{\kappa}}\f$.; \f$ \gamma = 0.5772156649\dots\f$ is Euler's constant. For the class VavilovAccurate,; Pdf returns the Vavilov distribution as function of Landau's parameter; \f$\lambda_L = \lambda_V/\kappa - \ln \kappa\f$,; which is the convention used in the CERNLIB routines, and in the tables; by S.M. Seltzer and M.J. Berger: Energy loss stragglin of protons and mesons:; Tabulation of the Vavilov distribution, pp 187-203; in: National Research Council (U.S.), Committee on Nuclear Science:; Studies in penetration of charged particles in matter,; Nat. Akad. Sci. Publication 1133,; Nucl. Sci. Series Report No. 39,; Washington (Nat. Akad. Sci.) 1964, 388 pp.; Available from; <A HREF=""http://books.google.de/books?id=kmMrAAAAYAAJ&lpg=PP9&pg=PA187#v=onepage&q&f=false"">Google books</A>. Therefore, for small values of \f$\kappa < 0.01\f$,; pdf approaches the Landau distribution. For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::mean(kappa, beta2); and sqrt(Vavilov::variance(kappa, beta2). The original Vavilov pdf is obtained by; v.Pdf(lambdaV/kappa-log(kappa))/kappa. For detailed description see; B. Schorr",MatchSource.WIKI,root/html530/ROOT__Math__VavilovAccurate.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__VavilovAccurate.html
Modifiability,extend,extended," for fixed values of \f$\kappa\f$ and \f$\beta^2\f$.; Changing these values is computationally expensive. The parameter \f$\kappa\f$ should be in the range \f$0.01 \le \kappa \le 10\f$.; In contrast to the CERNLIB implementation, all values of \f$\kappa \ge 0.001\f$ may be used,; but may result in slower running and/or inaccurate results. The parameter \f$\beta^2\f$ must be in the range \f$0 \le \beta^2 \le 1\f$. Two parameters which are fixed in the CERNLIB implementation may be set by the user:; - epsilonPM corresponds to \f$\epsilon^+ = \epsilon^-\f$ in Eqs. (2.1) and (2.2) of Schorr's paper.; epsilonPM gives an estimate on the integral of the cummulative distribution function; outside the range \f$\lambda_{min} \le \lambda \le \lambda_{max}\f$; where the approximation is valid.; Thus, it determines the support of the approximation used here (called $T_0 - T_1$ in the paper).; Schorr recommends \f$\epsilon^+ = \epsilon^- = 5\cdot 10^{-4}\f$.; The code from CERNLIB has been extended such that also smaller values are possible. - epsilon corresponds to \f$\epsilon\f$ in Eq. (4.10) of Schorr's paper.; It determines the accuracy of the series expansion.; Schorr recommends \f$\epsilon = 10^{-5}\f$. For the quantile calculation, the algorithm given by Schorr is not used,; because it turns out to be very slow and still inaccurate.; Instead, an initial estimate is calculated based on a precalculated table,; which is subsequently improved by Newton iterations. While the CERNLIB implementation calculates at most 156 terms in the series expansion; for the pdf and cdf calculation, this class calculates up to 500 terms, depending; on the values of epsilonPM and epsilon. Average times on a Pentium Core2 Duo P8400 2.26GHz:; - 38us per call to SetKappaBeta2 or constructor; - 0.49us per call to Pdf, Cdf; - 8.2us per first call to Quantile after SetKappaBeta2 or constructor; - 0.83us per subsequent call to Quantile. Benno List, June 2010. @ingroup StatFunc. Function Members (Methods",MatchSource.WIKI,root/html530/ROOT__Math__VavilovAccurate.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__VavilovAccurate.html
Testability,log,log,"stribution as function of Landau's parameter; \f$\lambda_L = \lambda_V/\kappa - \ln \kappa\f$,; which is the convention used in the CERNLIB routines, and in the tables; by S.M. Seltzer and M.J. Berger: Energy loss stragglin of protons and mesons:; Tabulation of the Vavilov distribution, pp 187-203; in: National Research Council (U.S.), Committee on Nuclear Science:; Studies in penetration of charged particles in matter,; Nat. Akad. Sci. Publication 1133,; Nucl. Sci. Series Report No. 39,; Washington (Nat. Akad. Sci.) 1964, 388 pp.; Available from; <A HREF=""http://books.google.de/books?id=kmMrAAAAYAAJ&lpg=PP9&pg=PA187#v=onepage&q&f=false"">Google books</A>. Therefore, for small values of \f$\kappa < 0.01\f$,; pdf approaches the Landau distribution. For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::mean(kappa, beta2); and sqrt(Vavilov::variance(kappa, beta2). The original Vavilov pdf is obtained by; v.Pdf(lambdaV/kappa-log(kappa))/kappa. For detailed description see; B. Schorr, Programs for the Landau and the Vavilov distributions and the corresponding random numbers,; <A HREF=""http://dx.doi.org/10.1016/0010-4655(74)90091-5"">Computer Phys. Comm. 7 (1974) 215-224</A>,; which has been implemented in; <A HREF=""http://wwwasdoc.web.cern.ch/wwwasdoc/shortwrupsdir/g116/top.html"">; CERNLIB (G116)</A>. The class stores coefficients needed to calculate \f$p(\lambda; \kappa, \beta^2)\f$; for fixed values of \f$\kappa\f$ and \f$\beta^2\f$.; Changing these values is computationally expensive. The parameter \f$\kappa\f$ should be in the range \f$0.01 \le \kappa \le 10\f$.; In contrast to the CERNLIB implementation, all values of \f$\kappa \ge 0.001\f$ may be used,; but may result in slower running and/or inaccurate results. The parameter \f$\beta^2\f$ must be in the range \f$0 \le \beta^2 \le 1\f$. Two parameters which are fixed in the CERNLIB implementation may be set by the user:; - epsilonPM corresponds to \f$\",MatchSource.WIKI,root/html530/ROOT__Math__VavilovAccurate.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__VavilovAccurate.html
Safety,avoid,avoid,"nOneDim::operator()(const double* x, const double* p) const; ROOT::Math::VavilovAccurateCdf&operator=(const ROOT::Math::VavilovAccurateCdf&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const double* p); ROOT::Math::VavilovAccurateCdfVavilovAccurateCdf(const ROOT::Math::VavilovAccurateCdf&). Data Members; private:. doublefP[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VavilovAccurateCdf(). Default constructor. VavilovAccurateCdf(const double* p). Constructor with parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). virtual ~VavilovAccurateCdf(). Destructor. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ...""). double DoEval(double x) const. Evaluate the function. @param x The Landau parameter \f$x = \lambda_L\f$. double DoEvalPar(double x, const double* p) const. Evaluate the function, using parameters p. @param x The Landau parameter \f$x = \lambda_L\f$; @param p vector of doubles containing the parameter values (Norm, x0, xi, kappa, beta2). IBaseFunctionOneDim * Clone() const. Return a clone of the object. » Last changed: root/mathmore:$Id: VavilovAccurateCdf.h 34195 2010-06-30 04:33:36Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Math__VavilovAccurateCdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__VavilovAccurateCdf.html
Energy Efficiency,charge,charged,"istribution. The probability density function of the Vavilov distribution; as function of Landau's parameter is given by:; \f[ p(\lambda_L; \kappa, \beta^2) =; \frac{1}{2 \pi i}\int_{c-i\infty}^{c+i\infty} \phi(s) e^{\lambda_L s} ds\f]; where \f$\phi(s) = e^{C} e^{\psi(s)}\f$; with \f$ C = \kappa (1+\beta^2 \gamma )\f$; and \f$\psi(s)= s \ln \kappa + (s+\beta^2 \kappa); \cdot \left ( \int \limits_{0}^{1}; \frac{1 - e^{\frac{-st}{\kappa}}}{t} \,d t- \gamma \right ); - \kappa \, e^{\frac{-s}{\kappa}}\f$.; \f$ \gamma = 0.5772156649\dots\f$ is Euler's constant. For the class VavilovFast,; Pdf returns the Vavilov distribution as function of Landau's parameter; \f$\lambda_L = \lambda_V/\kappa - \ln \kappa\f$,; which is the convention used in the CERNLIB routines, and in the tables; by S.M. Seltzer and M.J. Berger: Energy loss stragglin of protons and mesons:; Tabulation of the Vavilov distribution, pp 187-203; in: National Research Council (U.S.), Committee on Nuclear Science:; Studies in penetration of charged particles in matter,; Nat. Akad. Sci. Publication 1133,; Nucl. Sci. Series Report No. 39,; Washington (Nat. Akad. Sci.) 1964, 388 pp.; Available from; <A HREF=""http://books.google.de/books?id=kmMrAAAAYAAJ&lpg=PP9&pg=PA187#v=onepage&q&f=false"">Google books</A>. Therefore, for small values of \f$\kappa < 0.01\f$,; pdf approaches the Landau distribution. For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::mean(kappa, beta2); and sqrt(Vavilov::variance(kappa, beta2). For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::mean(kappa, beta2); and sqrt(Vavilov::variance(kappa, beta2). The original Vavilov pdf is obtained by; v.Pdf(lambdaV/kappa-log(kappa))/kappa. For detailed description see; A. Rotondi and P. Montagna, Fast calculation of Vavilov distribution,; <A HREF=""http://dx.doi.org/10.1016/0168-583X(90)90749-K"">Nucl. Instr. and Meth. ",MatchSource.WIKI,root/html530/ROOT__Math__VavilovFast.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__VavilovFast.html
Integrability,rout,routines,"Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::VavilovFast. class ROOT::Math::VavilovFast: public ROOT::Math::Vavilov. Class describing a Vavilov distribution. The probability density function of the Vavilov distribution; as function of Landau's parameter is given by:; \f[ p(\lambda_L; \kappa, \beta^2) =; \frac{1}{2 \pi i}\int_{c-i\infty}^{c+i\infty} \phi(s) e^{\lambda_L s} ds\f]; where \f$\phi(s) = e^{C} e^{\psi(s)}\f$; with \f$ C = \kappa (1+\beta^2 \gamma )\f$; and \f$\psi(s)= s \ln \kappa + (s+\beta^2 \kappa); \cdot \left ( \int \limits_{0}^{1}; \frac{1 - e^{\frac{-st}{\kappa}}}{t} \,d t- \gamma \right ); - \kappa \, e^{\frac{-s}{\kappa}}\f$.; \f$ \gamma = 0.5772156649\dots\f$ is Euler's constant. For the class VavilovFast,; Pdf returns the Vavilov distribution as function of Landau's parameter; \f$\lambda_L = \lambda_V/\kappa - \ln \kappa\f$,; which is the convention used in the CERNLIB routines, and in the tables; by S.M. Seltzer and M.J. Berger: Energy loss stragglin of protons and mesons:; Tabulation of the Vavilov distribution, pp 187-203; in: National Research Council (U.S.), Committee on Nuclear Science:; Studies in penetration of charged particles in matter,; Nat. Akad. Sci. Publication 1133,; Nucl. Sci. Series Report No. 39,; Washington (Nat. Akad. Sci.) 1964, 388 pp.; Available from; <A HREF=""http://books.google.de/books?id=kmMrAAAAYAAJ&lpg=PP9&pg=PA187#v=onepage&q&f=false"">Google books</A>. Therefore, for small values of \f$\kappa < 0.01\f$,; pdf approaches the Landau distribution. For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::mean(kappa, beta2); and sqrt(Vavilov::variance(kappa, beta2). For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::m",MatchSource.WIKI,root/html530/ROOT__Math__VavilovFast.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__VavilovFast.html
Testability,log,log,"er and M.J. Berger: Energy loss stragglin of protons and mesons:; Tabulation of the Vavilov distribution, pp 187-203; in: National Research Council (U.S.), Committee on Nuclear Science:; Studies in penetration of charged particles in matter,; Nat. Akad. Sci. Publication 1133,; Nucl. Sci. Series Report No. 39,; Washington (Nat. Akad. Sci.) 1964, 388 pp.; Available from; <A HREF=""http://books.google.de/books?id=kmMrAAAAYAAJ&lpg=PP9&pg=PA187#v=onepage&q&f=false"">Google books</A>. Therefore, for small values of \f$\kappa < 0.01\f$,; pdf approaches the Landau distribution. For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::mean(kappa, beta2); and sqrt(Vavilov::variance(kappa, beta2). For values \f$\kappa > 10\f$, the Gauss approximation should be used; with \f$\mu\f$ and \f$\sigma\f$ given by Vavilov::mean(kappa, beta2); and sqrt(Vavilov::variance(kappa, beta2). The original Vavilov pdf is obtained by; v.Pdf(lambdaV/kappa-log(kappa))/kappa. For detailed description see; A. Rotondi and P. Montagna, Fast calculation of Vavilov distribution,; <A HREF=""http://dx.doi.org/10.1016/0168-583X(90)90749-K"">Nucl. Instr. and Meth. B47 (1990) 215-224</A>,; which has been implemented in; <A HREF=""http://wwwasdoc.web.cern.ch/wwwasdoc/shortwrupsdir/g115/top.html"">; CERNLIB (G115)</A>. The class stores coefficients needed to calculate \f$p(\lambda; \kappa, \beta^2)\f$; for fixed values of \f$\kappa\f$ and \f$\beta^2\f$.; Changing these values is computationally expensive. The parameter \f$\kappa\f$ must be in the range \f$0.01 \le \kappa \le 12\f$. The parameter \f$\beta^2\f$ must be in the range \f$0 \le \beta^2 \le 1\f$. Average times on a Pentium Core2 Duo P8400 2.26GHz:; - 9.9us per call to SetKappaBeta2 or constructor; - 0.095us per call to Pdf, Cdf; - 3.7us per first call to Quantile after SetKappaBeta2 or constructor; - 0.137us per subsequent call to Quantile. Benno List, June 2010. @ingroup StatFunc. Function Mem",MatchSource.WIKI,root/html530/ROOT__Math__VavilovFast.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__VavilovFast.html
Availability,avail,available,"er file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegrator. class ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegrator(); virtual doubleError() const; virtual intNEval() const; ROOT::Math::VirtualIntegrator&operator=(const ROOT::Math::VirtualIntegrator&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetRelTolerance(double); virtual intStatus() const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~VirtualIntegrator(); destructor: no operation. {}. void SetRelTolerance(double ). set the desired relative Error. void SetAbsTolerance(double ). set the desired absolute Error. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function retur",MatchSource.WIKI,root/html530/ROOT__Math__VirtualIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__VirtualIntegrator.html
Deployability,integrat,integration,". ROOT::Math::VirtualIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegrator. class ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegrator(); virtual doubleError() const; virtual intNEval() const; ROOT::Math::VirtualIntegrator&operator=(const ROOT::Math::VirtualIntegrator&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetRelTolerance(double); virtual intStatus() const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~VirtualIntegrator(); destructor: no operation. {}. void SetRelTolerance(double ). set the desired relative Error. void SetAbsTolerance(double ). set the desired absolute Error. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. retur",MatchSource.WIKI,root/html530/ROOT__Math__VirtualIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__VirtualIntegrator.html
Integrability,integrat,integration,". ROOT::Math::VirtualIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegrator. class ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegrator(); virtual doubleError() const; virtual intNEval() const; ROOT::Math::VirtualIntegrator&operator=(const ROOT::Math::VirtualIntegrator&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetRelTolerance(double); virtual intStatus() const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~VirtualIntegrator(); destructor: no operation. {}. void SetRelTolerance(double ). set the desired relative Error. void SetAbsTolerance(double ). set the desired absolute Error. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. retur",MatchSource.WIKI,root/html530/ROOT__Math__VirtualIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__VirtualIntegrator.html
Modifiability,plug-in,plug-in,". ROOT::Math::VirtualIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegrator. class ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegrator(); virtual doubleError() const; virtual intNEval() const; ROOT::Math::VirtualIntegrator&operator=(const ROOT::Math::VirtualIntegrator&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetRelTolerance(double); virtual intStatus() const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~VirtualIntegrator(); destructor: no operation. {}. void SetRelTolerance(double ). set the desired relative Error. void SetAbsTolerance(double ). set the desired absolute Error. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. retur",MatchSource.WIKI,root/html530/ROOT__Math__VirtualIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__VirtualIntegrator.html
Availability,avail,available,"n; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegratorMultiDim. class ROOT::Math::VirtualIntegratorMultiDim: public ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegratorMultiDim(); virtual doubleROOT::Math::VirtualIntegrator::Error() const; virtual doubleIntegral(const double*, const double*); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorMultiDim&operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleROOT::Math::VirtualIntegrator::Result() const; virtual voidROOT::Math::VirtualIntegrator::SetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidROOT::Math::VirtualIntegrator::SetRelTolerance(double); virtual intROOT::Math::VirtualIntegrator::Status() const; virtual ROOT::Math::IntegrationMultiDim::TypeType() const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double Integral(const double* , const double* ); eva",MatchSource.WIKI,root/html530/ROOT__Math__VirtualIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__VirtualIntegratorMultiDim.html
Deployability,integrat,integration,". ROOT::Math::VirtualIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegratorMultiDim. class ROOT::Math::VirtualIntegratorMultiDim: public ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegratorMultiDim(); virtual doubleROOT::Math::VirtualIntegrator::Error() const; virtual doubleIntegral(const double*, const double*); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorMultiDim&operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleROOT::Math::VirtualIntegrator::Result() const; virtual voidROOT::Math::VirtualIntegrator::SetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidROOT::Math::VirtualIntegrator::SetRelTolerance(double); virtual intROOT::Math::VirtualIntegrator::Status() const; virtual ROOT::Math::Integra",MatchSource.WIKI,root/html530/ROOT__Math__VirtualIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__VirtualIntegratorMultiDim.html
Integrability,integrat,integration,". ROOT::Math::VirtualIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegratorMultiDim. class ROOT::Math::VirtualIntegratorMultiDim: public ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegratorMultiDim(); virtual doubleROOT::Math::VirtualIntegrator::Error() const; virtual doubleIntegral(const double*, const double*); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorMultiDim&operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleROOT::Math::VirtualIntegrator::Result() const; virtual voidROOT::Math::VirtualIntegrator::SetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidROOT::Math::VirtualIntegrator::SetRelTolerance(double); virtual intROOT::Math::VirtualIntegrator::Status() const; virtual ROOT::Math::Integra",MatchSource.WIKI,root/html530/ROOT__Math__VirtualIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__VirtualIntegratorMultiDim.html
Modifiability,plug-in,plug-in,". ROOT::Math::VirtualIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegratorMultiDim. class ROOT::Math::VirtualIntegratorMultiDim: public ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegratorMultiDim(); virtual doubleROOT::Math::VirtualIntegrator::Error() const; virtual doubleIntegral(const double*, const double*); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorMultiDim&operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleROOT::Math::VirtualIntegrator::Result() const; virtual voidROOT::Math::VirtualIntegrator::SetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidROOT::Math::VirtualIntegrator::SetRelTolerance(double); virtual intROOT::Math::VirtualIntegrator::Status() const; virtual ROOT::Math::Integra",MatchSource.WIKI,root/html530/ROOT__Math__VirtualIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__VirtualIntegratorMultiDim.html
Availability,avail,available,"ption; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegratorOneDim. class ROOT::Math::VirtualIntegratorOneDim: public ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegratorOneDim(); virtual doubleROOT::Math::VirtualIntegrator::Error() const; virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorOneDim&operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::VirtualIntegrator::Result() const; virtual voidROOT::Math::VirtualIntegrator::SetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidROOT::Math::VirtualIntegrator::SetRelTolerance(double); virtual intROOT::Math::VirtualIntegrator::Status() const; virtual ROOT::Mat",MatchSource.WIKI,root/html530/ROOT__Math__VirtualIntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__VirtualIntegratorOneDim.html
Deployability,integrat,integration,". ROOT::Math::VirtualIntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegratorOneDim. class ROOT::Math::VirtualIntegratorOneDim: public ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegratorOneDim(); virtual doubleROOT::Math::VirtualIntegrator::Error() const; virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorOneDim&operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::VirtualIntegrator::Result() const; virtual voidROOT::Math::VirtualIntegrator::SetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::Integ",MatchSource.WIKI,root/html530/ROOT__Math__VirtualIntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__VirtualIntegratorOneDim.html
Integrability,integrat,integration,". ROOT::Math::VirtualIntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegratorOneDim. class ROOT::Math::VirtualIntegratorOneDim: public ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegratorOneDim(); virtual doubleROOT::Math::VirtualIntegrator::Error() const; virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorOneDim&operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::VirtualIntegrator::Result() const; virtual voidROOT::Math::VirtualIntegrator::SetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::Integ",MatchSource.WIKI,root/html530/ROOT__Math__VirtualIntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__VirtualIntegratorOneDim.html
Modifiability,plug-in,plug-in,". ROOT::Math::VirtualIntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegratorOneDim. class ROOT::Math::VirtualIntegratorOneDim: public ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegratorOneDim(); virtual doubleROOT::Math::VirtualIntegrator::Error() const; virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorOneDim&operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::VirtualIntegrator::Result() const; virtual voidROOT::Math::VirtualIntegrator::SetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::Integ",MatchSource.WIKI,root/html530/ROOT__Math__VirtualIntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__VirtualIntegratorOneDim.html
Integrability,interface,interface,"erivative(const double* x, const double* p, unsigned int ipar) const. Data Members; private:. unsigned intfDimcached value of dimension; TF1*fFuncpointer to ROOT function; boolfLinearflag for linear functions ; vector<double>fParamscached vector with parameter values; boolfPolynomialflag for polynomial functions; static doublefgEpsepsilon used in derivative calculation h ~ eps |p|. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; WrappedMultiTF1(TF1& f, unsigned int dim = 0). constructor from a function pointer to a TF1; If dim = 0 dimension is taken from TF1::GetNdim().; IN case of multi-dimensional function created using directly TF1 object the dimension; returned by TF1::GetNdim is always 1. The user must then pass the correct value of dim. virtual ~WrappedMultiTF1(). Destructor (no operations). Function pointer is not owned. {}. WrappedMultiTF1(const ROOT::Math::WrappedMultiTF1& rhs). Copy constructor. IMultiGenFunction * Clone() const; @name interface inherited from IFunction . Clone the wrapper but not the original function. unsigned int NDim() const; function dimension. const double * Parameters() const; @name interface inherited from IParamFunction ; get the parameter values (return values cached inside, those inside TF1 might be different). void SetParameters(const double* p); set parameter values (only the cached one in this class,leave unchanges those of TF1). unsigned int NPar() const; return number of parameters. std::string ParameterName(unsigned int i) const; return parameter name (from TF1). void ParameterGradient(const double* x, const double* par, double* grad) const; evaluate the derivative of the function with respect to the parameters. void SetDerivPrecision(double eps); precision value used for calculating the derivative step-size; h = eps * |x|. The default is 0.001, give a smaller in case function changes rapidly. double GetDerivPrecision(); get precision value used for calculating the derivative step",MatchSource.WIKI,root/html530/ROOT__Math__WrappedMultiTF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__WrappedMultiTF1.html
Modifiability,inherit,inherited,"erivative(const double* x, const double* p, unsigned int ipar) const. Data Members; private:. unsigned intfDimcached value of dimension; TF1*fFuncpointer to ROOT function; boolfLinearflag for linear functions ; vector<double>fParamscached vector with parameter values; boolfPolynomialflag for polynomial functions; static doublefgEpsepsilon used in derivative calculation h ~ eps |p|. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; WrappedMultiTF1(TF1& f, unsigned int dim = 0). constructor from a function pointer to a TF1; If dim = 0 dimension is taken from TF1::GetNdim().; IN case of multi-dimensional function created using directly TF1 object the dimension; returned by TF1::GetNdim is always 1. The user must then pass the correct value of dim. virtual ~WrappedMultiTF1(). Destructor (no operations). Function pointer is not owned. {}. WrappedMultiTF1(const ROOT::Math::WrappedMultiTF1& rhs). Copy constructor. IMultiGenFunction * Clone() const; @name interface inherited from IFunction . Clone the wrapper but not the original function. unsigned int NDim() const; function dimension. const double * Parameters() const; @name interface inherited from IParamFunction ; get the parameter values (return values cached inside, those inside TF1 might be different). void SetParameters(const double* p); set parameter values (only the cached one in this class,leave unchanges those of TF1). unsigned int NPar() const; return number of parameters. std::string ParameterName(unsigned int i) const; return parameter name (from TF1). void ParameterGradient(const double* x, const double* par, double* grad) const; evaluate the derivative of the function with respect to the parameters. void SetDerivPrecision(double eps); precision value used for calculating the derivative step-size; h = eps * |x|. The default is 0.001, give a smaller in case function changes rapidly. double GetDerivPrecision(); get precision value used for calculating the derivative step",MatchSource.WIKI,root/html530/ROOT__Math__WrappedMultiTF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__WrappedMultiTF1.html
Performance,cache,cached,"e>fParamscached vector with parameter values; boolfPolynomialflag for polynomial functions; static doublefgEpsepsilon used in derivative calculation h ~ eps |p|. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; WrappedMultiTF1(TF1& f, unsigned int dim = 0). constructor from a function pointer to a TF1; If dim = 0 dimension is taken from TF1::GetNdim().; IN case of multi-dimensional function created using directly TF1 object the dimension; returned by TF1::GetNdim is always 1. The user must then pass the correct value of dim. virtual ~WrappedMultiTF1(). Destructor (no operations). Function pointer is not owned. {}. WrappedMultiTF1(const ROOT::Math::WrappedMultiTF1& rhs). Copy constructor. IMultiGenFunction * Clone() const; @name interface inherited from IFunction . Clone the wrapper but not the original function. unsigned int NDim() const; function dimension. const double * Parameters() const; @name interface inherited from IParamFunction ; get the parameter values (return values cached inside, those inside TF1 might be different). void SetParameters(const double* p); set parameter values (only the cached one in this class,leave unchanges those of TF1). unsigned int NPar() const; return number of parameters. std::string ParameterName(unsigned int i) const; return parameter name (from TF1). void ParameterGradient(const double* x, const double* par, double* grad) const; evaluate the derivative of the function with respect to the parameters. void SetDerivPrecision(double eps); precision value used for calculating the derivative step-size; h = eps * |x|. The default is 0.001, give a smaller in case function changes rapidly. double GetDerivPrecision(); get precision value used for calculating the derivative step-size. double DoEvalPar(const double* x, const double* p) const; evaluate function passing coordinates x and vector of parameters. double DoParameterDerivative(const double* x, const double* p, unsigned int ipar) const; eva",MatchSource.WIKI,root/html530/ROOT__Math__WrappedMultiTF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__WrappedMultiTF1.html
Integrability,interface,interface,"1WrappedTF1(TF1& f); ROOT::Math::WrappedTF1WrappedTF1(const ROOT::Math::WrappedTF1& rhs). private:. virtual doubleDoDerivative(double x) const; virtual doubleDoEval(double x) const; virtual doubleDoEvalPar(double x, const double* p) const; virtual doubleDoParameterDerivative(double x, const double* p, unsigned int ipar) const. Data Members; private:. TF1*fFuncpointer to ROOT function; boolfLinearflag for linear functions ; vector<double>fParamscached vector with parameter values; boolfPolynomialflag for polynomial functions ; doublefX[1]! cached vector for x value (needed for TF1::EvalPar signature) ; static doublefgEpsepsilon used in derivative calculation h ~ eps |x|. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; WrappedTF1(TF1& f). constructor from a TF1 function pointer. virtual ~WrappedTF1(). Destructor (no operations). TF1 Function pointer is not owned. {}. WrappedTF1(TF1& f). Copy constructor. ROOT::Math::IGenFunction * Clone() const; @name interface inherited from IFunction . Clone the wrapper but not the original function. const double * Parameters() const; @name interface inherited from IParamFunction ; get the parameter values (return values cachen inside, those inside TF1 might be different). void SetParameters(const double* p); set parameter values (only the cached one in this class,leave unchanges those of TF1). unsigned int NPar() const; return number of parameters. std::string ParameterName(unsigned int i) const; return parameter name (this is stored in TF1). void ParameterGradient(double x, const double* par, double* grad) const; evaluate the derivative of the function with respect to the parameters. void FdF(double x, double& f, double& deriv) const; calculate function and derivative at same time (required by IGradient interface). void SetDerivPrecision(double eps); precision value used for calculating the derivative step-size; h = eps * |x|. The default is 0.001, give a smaller in case function changes r",MatchSource.WIKI,root/html530/ROOT__Math__WrappedTF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__WrappedTF1.html
Modifiability,inherit,inherited,"1WrappedTF1(TF1& f); ROOT::Math::WrappedTF1WrappedTF1(const ROOT::Math::WrappedTF1& rhs). private:. virtual doubleDoDerivative(double x) const; virtual doubleDoEval(double x) const; virtual doubleDoEvalPar(double x, const double* p) const; virtual doubleDoParameterDerivative(double x, const double* p, unsigned int ipar) const. Data Members; private:. TF1*fFuncpointer to ROOT function; boolfLinearflag for linear functions ; vector<double>fParamscached vector with parameter values; boolfPolynomialflag for polynomial functions ; doublefX[1]! cached vector for x value (needed for TF1::EvalPar signature) ; static doublefgEpsepsilon used in derivative calculation h ~ eps |x|. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; WrappedTF1(TF1& f). constructor from a TF1 function pointer. virtual ~WrappedTF1(). Destructor (no operations). TF1 Function pointer is not owned. {}. WrappedTF1(TF1& f). Copy constructor. ROOT::Math::IGenFunction * Clone() const; @name interface inherited from IFunction . Clone the wrapper but not the original function. const double * Parameters() const; @name interface inherited from IParamFunction ; get the parameter values (return values cachen inside, those inside TF1 might be different). void SetParameters(const double* p); set parameter values (only the cached one in this class,leave unchanges those of TF1). unsigned int NPar() const; return number of parameters. std::string ParameterName(unsigned int i) const; return parameter name (this is stored in TF1). void ParameterGradient(double x, const double* par, double* grad) const; evaluate the derivative of the function with respect to the parameters. void FdF(double x, double& f, double& deriv) const; calculate function and derivative at same time (required by IGradient interface). void SetDerivPrecision(double eps); precision value used for calculating the derivative step-size; h = eps * |x|. The default is 0.001, give a smaller in case function changes r",MatchSource.WIKI,root/html530/ROOT__Math__WrappedTF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__WrappedTF1.html
Performance,cache,cached,"meterDerivative(double x, const double* p, unsigned int ipar = 0) const; doubleROOT::Math::IParametricGradFunctionOneDim::ParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const; virtual voidParameterGradient(double x, const double* par, double* grad) const; virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; static voidSetDerivPrecision(double eps); virtual voidSetParameters(const double* p); ROOT::Math::WrappedTF1WrappedTF1(TF1& f); ROOT::Math::WrappedTF1WrappedTF1(const ROOT::Math::WrappedTF1& rhs). private:. virtual doubleDoDerivative(double x) const; virtual doubleDoEval(double x) const; virtual doubleDoEvalPar(double x, const double* p) const; virtual doubleDoParameterDerivative(double x, const double* p, unsigned int ipar) const. Data Members; private:. TF1*fFuncpointer to ROOT function; boolfLinearflag for linear functions ; vector<double>fParamscached vector with parameter values; boolfPolynomialflag for polynomial functions ; doublefX[1]! cached vector for x value (needed for TF1::EvalPar signature) ; static doublefgEpsepsilon used in derivative calculation h ~ eps |x|. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; WrappedTF1(TF1& f). constructor from a TF1 function pointer. virtual ~WrappedTF1(). Destructor (no operations). TF1 Function pointer is not owned. {}. WrappedTF1(TF1& f). Copy constructor. ROOT::Math::IGenFunction * Clone() const; @name interface inherited from IFunction . Clone the wrapper but not the original function. const double * Parameters() const; @name interface inherited from IParamFunction ; get the parameter values (return values cachen inside, those inside TF1 might be different). void SetParameters(const double* p); set parameter values (only the cached one in this class,leave unchanges those of TF1). unsigned int NPar() const; return number of parameters. std::string ParameterName(unsigned int i) const; return parameter ",MatchSource.WIKI,root/html530/ROOT__Math__WrappedTF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Math__WrappedTF1.html
Availability,toler,toler,". ROOT::Minuit2::CombinedMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::CombinedMinimizer. class ROOT::Minuit2::CombinedMinimizer: public ROOT::Minuit2::ModularFunctionMinimizer. Combined minimizer: combination of Migrad and Simplex. I; If the Migrad method fails at first attempt, a simplex; minimization is performed and then migrad is tried again. Function Members (Methods); public:. virtual~CombinedMinimizer(); virtual const ROOT::Minuit2::MinimumBuilder&Builder() const; ROOT::Minuit2::CombinedMinimizerCombinedMinimizer(); ROOT::Minuit2::CombinedMinimizerCombinedMinimizer(const ROOT::Minuit2::CombinedMinimizer&); virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNBase&, const ROOT::Minuit2::MnUserParameterState&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameterState&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNBase&, const vector<double>&, const vector<double>&, unsigned int stra = ",MatchSource.WIKI,root/html530/ROOT__Minuit2__CombinedMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__CombinedMinimizer.html
Performance,perform,performed,". ROOT::Minuit2::CombinedMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::CombinedMinimizer. class ROOT::Minuit2::CombinedMinimizer: public ROOT::Minuit2::ModularFunctionMinimizer. Combined minimizer: combination of Migrad and Simplex. I; If the Migrad method fails at first attempt, a simplex; minimization is performed and then migrad is tried again. Function Members (Methods); public:. virtual~CombinedMinimizer(); virtual const ROOT::Minuit2::MinimumBuilder&Builder() const; ROOT::Minuit2::CombinedMinimizerCombinedMinimizer(); ROOT::Minuit2::CombinedMinimizerCombinedMinimizer(const ROOT::Minuit2::CombinedMinimizer&); virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNBase&, const ROOT::Minuit2::MnUserParameterState&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameterState&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNBase&, const vector<double>&, const vector<double>&, unsigned int stra = ",MatchSource.WIKI,root/html530/ROOT__Minuit2__CombinedMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__CombinedMinimizer.html
Usability,simpl,simplex,". ROOT::Minuit2::CombinedMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::CombinedMinimizer. class ROOT::Minuit2::CombinedMinimizer: public ROOT::Minuit2::ModularFunctionMinimizer. Combined minimizer: combination of Migrad and Simplex. I; If the Migrad method fails at first attempt, a simplex; minimization is performed and then migrad is tried again. Function Members (Methods); public:. virtual~CombinedMinimizer(); virtual const ROOT::Minuit2::MinimumBuilder&Builder() const; ROOT::Minuit2::CombinedMinimizerCombinedMinimizer(); ROOT::Minuit2::CombinedMinimizerCombinedMinimizer(const ROOT::Minuit2::CombinedMinimizer&); virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNBase&, const ROOT::Minuit2::MnUserParameterState&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameterState&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNBase&, const vector<double>&, const vector<double>&, unsigned int stra = ",MatchSource.WIKI,root/html530/ROOT__Minuit2__CombinedMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__CombinedMinimizer.html
Availability,avail,available,". ROOT::Minuit2::FCNBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::FCNBase. class ROOT::Minuit2::FCNBase: public ROOT::Minuit2::GenericFunction. Interface (abstract class) defining the function to be minimized, which has to be implemented by the user. @author Fred James and Matthias Winkler; modified by Andras Zsenei and Lorenzo Moneta. @ingroup Minuit. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~FCNBase(); virtual doubleErrorDef() const; virtual doubleoperator()(const vector<double>& x) const; ROOT::Minuit2::FCNBase&operator=(const ROOT::Minuit2::FCNBase&); virtual voidSetErrorDef(double); virtual doubleUp() const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~FCNBase(); {}. double operator()(const vector<double>& x) const. The meaning of the vector of parameters is of course defined by the user,; who uses the values of those parameters to calculate his function Value.; The order and the position of these parameters is strictly the one specified; by the user when supplying the starting values for minimization. The starting; values must be specified by the user, either via an std::vector<double> or the; MnUserParameters supplied as input to the MINUIT minimizers such as; VariableMetricMinimizer or MnMigrad. Later values are determined by MINUIT; as it searches for the Minimum or performs whatever analysis is requested by; the user. @param par function parameters as defined by the user. @return the Value of the function. @see MnUserParameters; @see VariableMetricMinimizer; @see MnMigrad. double ErrorDef() const. Error definition of the function. MINUIT defines Parameter errors as the; change in Parameter ",MatchSource.WIKI,root/html530/ROOT__Minuit2__FCNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__FCNBase.html
Integrability,interface,interface,"ses the values of those parameters to calculate his function Value.; The order and the position of these parameters is strictly the one specified; by the user when supplying the starting values for minimization. The starting; values must be specified by the user, either via an std::vector<double> or the; MnUserParameters supplied as input to the MINUIT minimizers such as; VariableMetricMinimizer or MnMigrad. Later values are determined by MINUIT; as it searches for the Minimum or performs whatever analysis is requested by; the user. @param par function parameters as defined by the user. @return the Value of the function. @see MnUserParameters; @see VariableMetricMinimizer; @see MnMigrad. double ErrorDef() const. Error definition of the function. MINUIT defines Parameter errors as the; change in Parameter Value required to change the function Value by up. Normally,; for chisquared fits it is 1, and for negative log likelihood, its Value is 0.5.; If the user wants instead the 2-sigma errors for chisquared fits, it becomes 4,; as Chi2(x+n*sigma) = Chi2(x) + n*n. Comment a little bit better with links!!!!!!!!!!!!!!!!!. {return Up();}. double Up() const. Error definition of the function. MINUIT defines Parameter errors as the; change in Parameter Value required to change the function Value by up. Normally,; for chisquared fits it is 1, and for negative log likelihood, its Value is 0.5.; If the user wants instead the 2-sigma errors for chisquared fits, it becomes 4,; as Chi2(x+n*sigma) = Chi2(x) + n*n. \todo Comment a little bit better with links!!!!!!!!!!!!!!!!! Idem for ErrorDef(). void SetErrorDef(double ). add interface to set dynamically a new error definition; Re-implement this function if needed. {}. » Last changed: root/minuit2:$Id: FCNBase.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Minuit2__FCNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__FCNBase.html
Performance,perform,performs,"r to check for available constructors.; public:. virtual~FCNBase(); virtual doubleErrorDef() const; virtual doubleoperator()(const vector<double>& x) const; ROOT::Minuit2::FCNBase&operator=(const ROOT::Minuit2::FCNBase&); virtual voidSetErrorDef(double); virtual doubleUp() const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~FCNBase(); {}. double operator()(const vector<double>& x) const. The meaning of the vector of parameters is of course defined by the user,; who uses the values of those parameters to calculate his function Value.; The order and the position of these parameters is strictly the one specified; by the user when supplying the starting values for minimization. The starting; values must be specified by the user, either via an std::vector<double> or the; MnUserParameters supplied as input to the MINUIT minimizers such as; VariableMetricMinimizer or MnMigrad. Later values are determined by MINUIT; as it searches for the Minimum or performs whatever analysis is requested by; the user. @param par function parameters as defined by the user. @return the Value of the function. @see MnUserParameters; @see VariableMetricMinimizer; @see MnMigrad. double ErrorDef() const. Error definition of the function. MINUIT defines Parameter errors as the; change in Parameter Value required to change the function Value by up. Normally,; for chisquared fits it is 1, and for negative log likelihood, its Value is 0.5.; If the user wants instead the 2-sigma errors for chisquared fits, it becomes 4,; as Chi2(x+n*sigma) = Chi2(x) + n*n. Comment a little bit better with links!!!!!!!!!!!!!!!!!. {return Up();}. double Up() const. Error definition of the function. MINUIT defines Parameter errors as the; change in Parameter Value required to change the function Value by up. Normally,; for chisquared fits it is 1, and for negative log likelihood, its Value is 0.5.; If the user wants instead the 2-sigma errors for chisquared fits, it b",MatchSource.WIKI,root/html530/ROOT__Minuit2__FCNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__FCNBase.html
Testability,log,log,"x) const. The meaning of the vector of parameters is of course defined by the user,; who uses the values of those parameters to calculate his function Value.; The order and the position of these parameters is strictly the one specified; by the user when supplying the starting values for minimization. The starting; values must be specified by the user, either via an std::vector<double> or the; MnUserParameters supplied as input to the MINUIT minimizers such as; VariableMetricMinimizer or MnMigrad. Later values are determined by MINUIT; as it searches for the Minimum or performs whatever analysis is requested by; the user. @param par function parameters as defined by the user. @return the Value of the function. @see MnUserParameters; @see VariableMetricMinimizer; @see MnMigrad. double ErrorDef() const. Error definition of the function. MINUIT defines Parameter errors as the; change in Parameter Value required to change the function Value by up. Normally,; for chisquared fits it is 1, and for negative log likelihood, its Value is 0.5.; If the user wants instead the 2-sigma errors for chisquared fits, it becomes 4,; as Chi2(x+n*sigma) = Chi2(x) + n*n. Comment a little bit better with links!!!!!!!!!!!!!!!!!. {return Up();}. double Up() const. Error definition of the function. MINUIT defines Parameter errors as the; change in Parameter Value required to change the function Value by up. Normally,; for chisquared fits it is 1, and for negative log likelihood, its Value is 0.5.; If the user wants instead the 2-sigma errors for chisquared fits, it becomes 4,; as Chi2(x+n*sigma) = Chi2(x) + n*n. \todo Comment a little bit better with links!!!!!!!!!!!!!!!!! Idem for ErrorDef(). void SetErrorDef(double ). add interface to set dynamically a new error definition; Re-implement this function if needed. {}. » Last changed: root/minuit2:$Id: FCNBase.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or sugges",MatchSource.WIKI,root/html530/ROOT__Minuit2__FCNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__FCNBase.html
Availability,avail,available,"; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::FCNGradientBase. class ROOT::Minuit2::FCNGradientBase: public ROOT::Minuit2::FCNBase. Extension of the FCNBase for providing the analytical Gradient of the; function. The user-Gradient is checked at the beginning of the; minimization against the Minuit internal numerical Gradient in order to; spot problems in the analytical Gradient calculation. This can be turned; off by overriding CheckGradient() to make it return ""false"".; The size of the output Gradient vector must be equal to the size of the; input Parameter vector.; Minuit does a check of the user Gradient at the beginning, if this is not; wanted the method ""CheckGradient()"" has to be overridden to return; ""false"". Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~FCNGradientBase(); virtual boolCheckGradient() const; virtual doubleROOT::Minuit2::FCNBase::ErrorDef() const; virtual vector<double>Gradient(const vector<double>&) const; virtual doubleROOT::Minuit2::FCNBase::operator()(const vector<double>& x) const; ROOT::Minuit2::FCNGradientBase&operator=(const ROOT::Minuit2::FCNGradientBase&); virtual voidROOT::Minuit2::FCNBase::SetErrorDef(double); virtual doubleROOT::Minuit2::FCNBase::Up() const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~FCNGradientBase(); {}. std::vector<double> Gradient(const vector<double>& ) const. bool CheckGradient() const; {return true;}. » Last changed: root/minuit2:$Id: FCNGradientBase.h 21530 2007-12-20 11:14:35Z moneta $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Minuit2__FCNGradientBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__FCNGradientBase.html
Availability,avail,available,"; » MATH; » MINUIT2; » ROOT::Minuit2::FumiliFCNBase. class ROOT::Minuit2::FumiliFCNBase: public ROOT::Minuit2::FCNBase. Extension of the FCNBase for the Fumili method. Fumili applies only to; minimization problems used for fitting. The method is based on a; linearization of the model function negleting second derivatives.; User needs to provide the model function. The figure-of-merit describing; the difference between the model function and the actual measurements; has to be implemented by the user in a subclass of FumiliFCNBase.; For an example see the FumiliChi2FCN and FumiliStandardChi2FCN classes. @author Andras Zsenei and Lorenzo Moneta, Creation date: 23 Aug 2004. @see <A HREF=""http://www.cern.ch/winkler/minuit/tutorial/mntutorial.pdf"">MINUIT Tutorial</A> on function minimization, section 5. @see FumiliChi2FCN. @see FumiliStandardChi2FCN. @ingroup Minuit. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~FumiliFCNBase(); virtual unsigned intDimension(); virtual doubleROOT::Minuit2::FCNBase::ErrorDef() const; virtual voidEvaluateAll(const vector<double>& par); virtual const vector<double>&Gradient() const; virtual doubleHessian(unsigned int row, unsigned int col) const; virtual doubleROOT::Minuit2::FCNBase::operator()(const vector<double>& x) const; ROOT::Minuit2::FumiliFCNBase&operator=(const ROOT::Minuit2::FumiliFCNBase&); virtual voidROOT::Minuit2::FCNBase::SetErrorDef(double); virtual doubleROOT::Minuit2::FCNBase::Up() const; virtual doubleValue() const. protected:. vector<double>&Gradient(); vector<double>&Hessian(); virtual voidInitAndReset(unsigned int npar); voidSetFCNValue(double value). Data Members; private:. vector<double>fGradient; vector<double>fHessian; unsigned intfNumberOfParameters; doublefValue. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~FumiliFCNBase(); FumiliFCN",MatchSource.WIKI,root/html530/ROOT__Minuit2__FumiliFCNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__FumiliFCNBase.html
Modifiability,variab,variable,"t(unsigned int npar); voidSetFCNValue(double value). Data Members; private:. vector<double>fGradient; vector<double>fHessian; unsigned intfNumberOfParameters; doublefValue. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~FumiliFCNBase(); FumiliFCNBase(const ParametricFunction& modelFCN) { fModelFunction = &modelFCN; }. {}. void EvaluateAll(const vector<double>& par). Evaluate function Value, Gradient and Hessian using Fumili approximation, for values of parameters p; The resul is cached inside and is return from the FumiliFCNBase::Value , FumiliFCNBase::Gradient and; FumiliFCNBase::Hessian methods. @param par vector of parameters. double Value() const. Return cached Value of objective function estimated previously using the FumiliFCNBase::EvaluateAll method. { return fValue; }. const std::vector<double> & Gradient() const. Return cached Value of function Gradient estimated previously using the FumiliFCNBase::EvaluateAll method. { return fGradient; }. double Hessian(unsigned int row, unsigned int col) const. Return Value of the i-th j-th element of the Hessian matrix estimated previously using the FumiliFCNBase::EvaluateAll method; @param row row Index of the matrix; @param col col Index of the matrix. unsigned int Dimension(). return number of function variable (parameters) , i.e. function dimension. { return fNumberOfParameters; }. void InitAndReset(unsigned int npar). initialize and reset values of gradien and Hessian. void SetFCNValue(double value); methods to be used by the derived classes to set the values. { fValue = value; }. std::vector<double> & Gradient(); { return fGradient; }. std::vector<double> & Hessian(); { return fHessian; }. » Last changed: root/minuit2:$Id: FumiliFCNBase.h 34992 2010-08-25 10:36:11Z moneta $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Minuit2__FumiliFCNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__FumiliFCNBase.html
Performance,cache,cached,"ient() const; virtual doubleHessian(unsigned int row, unsigned int col) const; virtual doubleROOT::Minuit2::FCNBase::operator()(const vector<double>& x) const; ROOT::Minuit2::FumiliFCNBase&operator=(const ROOT::Minuit2::FumiliFCNBase&); virtual voidROOT::Minuit2::FCNBase::SetErrorDef(double); virtual doubleROOT::Minuit2::FCNBase::Up() const; virtual doubleValue() const. protected:. vector<double>&Gradient(); vector<double>&Hessian(); virtual voidInitAndReset(unsigned int npar); voidSetFCNValue(double value). Data Members; private:. vector<double>fGradient; vector<double>fHessian; unsigned intfNumberOfParameters; doublefValue. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~FumiliFCNBase(); FumiliFCNBase(const ParametricFunction& modelFCN) { fModelFunction = &modelFCN; }. {}. void EvaluateAll(const vector<double>& par). Evaluate function Value, Gradient and Hessian using Fumili approximation, for values of parameters p; The resul is cached inside and is return from the FumiliFCNBase::Value , FumiliFCNBase::Gradient and; FumiliFCNBase::Hessian methods. @param par vector of parameters. double Value() const. Return cached Value of objective function estimated previously using the FumiliFCNBase::EvaluateAll method. { return fValue; }. const std::vector<double> & Gradient() const. Return cached Value of function Gradient estimated previously using the FumiliFCNBase::EvaluateAll method. { return fGradient; }. double Hessian(unsigned int row, unsigned int col) const. Return Value of the i-th j-th element of the Hessian matrix estimated previously using the FumiliFCNBase::EvaluateAll method; @param row row Index of the matrix; @param col col Index of the matrix. unsigned int Dimension(). return number of function variable (parameters) , i.e. function dimension. { return fNumberOfParameters; }. void InitAndReset(unsigned int npar). initialize and reset values of gradien and Hessian. void SetFCNValue(double value); methods to",MatchSource.WIKI,root/html530/ROOT__Minuit2__FumiliFCNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__FumiliFCNBase.html
Availability,toler,toler,". ROOT::Minuit2::FumiliMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::FumiliMinimizer. class ROOT::Minuit2::FumiliMinimizer: public ROOT::Minuit2::ModularFunctionMinimizer. Instantiates the seed generator and Minimum builder for the; Fumili minimization method. Produces the Minimum via the; Minimize methods inherited from ModularFunctionMinimizer. @author Andras Zsenei and Lorenzo Moneta, Creation date: 28 Sep 2004. @ingroup Minuit. Function Members (Methods); public:. virtual~FumiliMinimizer(); virtual const ROOT::Minuit2::FumiliBuilder&Builder() const; ROOT::Minuit2::FumiliMinimizerFumiliMinimizer(); ROOT::Minuit2::FumiliMinimizerFumiliMinimizer(const ROOT::Minuit2::FumiliMinimizer&); virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNBase&, const ROOT::Minuit2::MnUserParameterState&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameterState&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNBase& fcn, const ROOT::Minuit2::MnUserParameters& par, const ROOT::Minuit2::MnStrategy& stra, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNGradientBase& fcn, const ROOT::Minuit2::MnUserParameters& par, const ROOT::Minuit2::MnStrategy& stra, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNBase& fcn, const vector<double>& par, const vector<double>& err, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumM",MatchSource.WIKI,root/html530/ROOT__Minuit2__FumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__FumiliMinimizer.html
Modifiability,inherit,inherited,". ROOT::Minuit2::FumiliMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::FumiliMinimizer. class ROOT::Minuit2::FumiliMinimizer: public ROOT::Minuit2::ModularFunctionMinimizer. Instantiates the seed generator and Minimum builder for the; Fumili minimization method. Produces the Minimum via the; Minimize methods inherited from ModularFunctionMinimizer. @author Andras Zsenei and Lorenzo Moneta, Creation date: 28 Sep 2004. @ingroup Minuit. Function Members (Methods); public:. virtual~FumiliMinimizer(); virtual const ROOT::Minuit2::FumiliBuilder&Builder() const; ROOT::Minuit2::FumiliMinimizerFumiliMinimizer(); ROOT::Minuit2::FumiliMinimizerFumiliMinimizer(const ROOT::Minuit2::FumiliMinimizer&); virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNBase&, const ROOT::Minuit2::MnUserParameterState&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameterState&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNBase& fcn, const ROOT::Minuit2::MnUserParameters& par, const ROOT::Minuit2::MnStrategy& stra, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNGradientBase& fcn, const ROOT::Minuit2::MnUserParameters& par, const ROOT::Minuit2::MnStrategy& stra, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNBase& fcn, const vector<double>& par, const vector<double>& err, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumM",MatchSource.WIKI,root/html530/ROOT__Minuit2__FumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__FumiliMinimizer.html
Availability,avail,available,". ROOT::Minuit2::FunctionMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::FunctionMinimizer. class ROOT::Minuit2::FunctionMinimizer. base class for function minimizers; user may give FCN or FCN with Gradient,; Parameter starting values and initial Error guess (sigma) (or ""step size""),; or Parameter starting values and initial covariance matrix;; covariance matrix is stored in Upper triangular packed storage format,; e.g. the Elements in the array are arranged like; {a(0,0), a(0,1), a(1,1), a(0,2), a(1,2), a(2,2), ...},; the size is nrow*(nrow+1)/2 (see also MnUserCovariance.h);. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~FunctionMinimizer(); virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNBase&, const vector<double>& par, const vector<double>& err, unsigned int strategy, unsigned int maxfcn, double toler) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNGradientBase&, const vector<double>& par, const vector<double>& err, unsigned int strategy, unsigned int maxfcn, double toler) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNBase&, const vector<double>& par, unsigned int nrow, const vector<double>& cov, unsigned int strategy, unsigned int maxfcn, double toler) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNGradientBase&, const vector<double>& par, unsigned int nrow, const vector<double>& cov, unsigned int strategy, unsigned int maxfcn, double toler) const; ROOT::Minuit2::FunctionMinimizer&operator=(const ROOT::Minuit2::FunctionMinimizer&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~Func",MatchSource.WIKI,root/html530/ROOT__Minuit2__FunctionMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__FunctionMinimizer.html
Availability,avail,available,". ROOT::Minuit2::FunctionMinimum. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::FunctionMinimum. class ROOT::Minuit2::FunctionMinimum. class holding the full result of the minimization;; both internal and external (MnUserParameterState) representation available; for the parameters at the Minimum. Function Members (Methods); public:. ~FunctionMinimum(); voidAdd(const ROOT::Minuit2::MinimumState& state); voidAdd(const ROOT::Minuit2::MinimumState& state, ROOT::Minuit2::FunctionMinimum::MnAboveMaxEdm); doubleEdm() const; const ROOT::Minuit2::MinimumError&Error() const; ROOT::Minuit2::FunctionMinimumFunctionMinimum(const ROOT::Minuit2::FunctionMinimum& min); ROOT::Minuit2::FunctionMinimumFunctionMinimum(const ROOT::Minuit2::MinimumSeed& seed, double up); ROOT::Minuit2::FunctionMinimumFunctionMinimum(const ROOT::Minuit2::MinimumSeed& seed, const vector<MinimumState>& states, double up); ROOT::Minuit2::FunctionMinimumFunctionMinimum(const ROOT::Minuit2::MinimumSeed& seed, const vector<MinimumState>& states, double up, ROOT::Minuit2::FunctionMinimum::MnReachedCallLimit); ROOT::Minuit2::FunctionMinimumFunctionMinimum(const ROOT::Minuit2::MinimumSeed& seed, const vector<MinimumState>& states, double up, ROOT::Minuit2::FunctionMinimum::MnAboveMaxEdm); doubleFval() const; const ROOT::Minuit2::FunctionGradient&Grad() const; boolHasAccurateCovar() const; boolHasCovariance() const; boolHasMadePosDefCovar() const; boolHasPosDefCovar() const; boolHasReachedCallLimit() const; boolHasValidCovariance() const; boolHasValidParameters() const; boolHesseFailed() const; boolIsAboveMaxEdm() const; boolIsValid() const; intNFcn() const; ROOT::Minuit2::FunctionMinimum&operator=(const ROOT::Minuit2::FunctionMinimum& min); const ROOT::Minuit2::MinimumParameters&Parameters() const; const ROOT::Minuit2::MinimumSeed&Seed() c",MatchSource.WIKI,root/html530/ROOT__Minuit2__FunctionMinimum.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__FunctionMinimum.html
Availability,avail,available,". ROOT::Minuit2::GenericFunction. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::GenericFunction. class ROOT::Minuit2::GenericFunction. Class from which all the other classes, representing functions,; inherit. That is why it defines only one method, the operator(),; which allows to call the function. @author Andras Zsenei and Lorenzo Moneta, Creation date: 23 Sep 2004. @ingroup Minuit. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~GenericFunction(); virtual doubleoperator()(const vector<double>& x) const; ROOT::Minuit2::GenericFunction&operator=(const ROOT::Minuit2::GenericFunction&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~GenericFunction(); {}. double operator()(const vector<double>& x) const. Evaluates the function using the vector containing the input values. @param x vector of the coordinates (for example the x coordinate for a; one-dimensional Gaussian). @return the result of the evaluation of the function. » Last changed: root/minuit2:$Id: GenericFunction.h 21530 2007-12-20 11:14:35Z moneta $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Minuit2__GenericFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__GenericFunction.html
Modifiability,inherit,inherit,". ROOT::Minuit2::GenericFunction. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::GenericFunction. class ROOT::Minuit2::GenericFunction. Class from which all the other classes, representing functions,; inherit. That is why it defines only one method, the operator(),; which allows to call the function. @author Andras Zsenei and Lorenzo Moneta, Creation date: 23 Sep 2004. @ingroup Minuit. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~GenericFunction(); virtual doubleoperator()(const vector<double>& x) const; ROOT::Minuit2::GenericFunction&operator=(const ROOT::Minuit2::GenericFunction&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~GenericFunction(); {}. double operator()(const vector<double>& x) const. Evaluates the function using the vector containing the input values. @param x vector of the coordinates (for example the x coordinate for a; one-dimensional Gaussian). @return the result of the evaluation of the function. » Last changed: root/minuit2:$Id: GenericFunction.h 21530 2007-12-20 11:14:35Z moneta $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Minuit2__GenericFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__GenericFunction.html
Availability,error,errors,er::Tolerance() const; virtual intVariableIndex(const string& name) const; virtual stringVariableName(unsigned int ivar) const; virtual const double*X() const. protected:. boolExamineMinimum(const ROOT::Minuit2::FunctionMinimum& min); virtual const ROOT::Minuit2::FCNBase*GetFCN() const; virtual const ROOT::Minuit2::ModularFunctionMinimizer*GetMinimizer() const; virtual voidSetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); voidSetMinimizerType(ROOT::Minuit2::EMinimizerType type). private:. ROOT::Minuit2::Minuit2MinimizerMinuit2Minimizer(const ROOT::Minuit2::Minuit2Minimizer&); ROOT::Minuit2::Minuit2Minimizer&operator=(const ROOT::Minuit2::Minuit2Minimizer& rhs). Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; doubleROOT::Math::Minimizer::fPrecprecision; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. unsigned intfDimdimension of the function to be minimized ; vector<double>fErrors; ROOT::Minuit2::ModularFunctionMinimizer*fMinimizer; ROOT::Minuit2::FunctionMinimum*fMinimum; ROOT::Minuit2::FCNBase*fMinuitFCN; ROOT::Minuit2::MnUserParameterStatefState; boolfUseFumili; vector<double>fValues. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Minuit2Minimizer(ROOT::Minuit2::EMinimizerType type = ROOT::Minuit2::kMigrad). Default constructor. Minuit2Minimizer(const char* type). Constructor with a char (used by PM). virtual ~Minuit2Minimizer(). Destructor (no operations). Minuit2Minimizer(const ROOT::Minuit2::Minuit2Minimizer& ); usually copying is,MatchSource.WIKI,root/html530/ROOT__Minuit2__Minuit2Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__Minuit2Minimizer.html
Deployability,update,updated," will be filled as h[i *ndim + j]. int CovMatrixStatus() const. return the status of the covariance matrix. double Correlation(unsigned int i, unsigned int j) const. return correlation coefficient between variable i and j.; If the variable is fixed or const the return value is zero. double GlobalCC(unsigned int i) const. get global correlation coefficient for the variable i. This is a number between zero and one which gives; the correlation between the i-th variable and that linear combination of all other variables which; is most strongly correlated with i.; If the variable is fixed or const the return value is zero. bool GetMinosError(unsigned int i, double& errLow, double& errUp, int = 0). get the minos error for parameter i, return false if Minos failed; A minimizaiton must be performed befre, return false if no minimization has been done; In case of Minos failed the status error is updated as following; status += 10 * minosStatus where the minos status is:; status = 1 : maximum number of function calls exceeded when running for lower error; status = 2 : maximum number of function calls exceeded when running for upper error; status = 3 : new minimum found when running for lower error; status = 4 : new minimum found when running for upper error; status = 5 : any other failure. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0). scan a parameter i around the minimum. A minimization must have been done before,; return false if it is not the case. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj). find the contour points (xi,xj) of the function for parameter i and j around the minimum; The contour will be find for value of the function = Min + ErrorUp();. bool Hesse(). perform a full calculation of the Hessian matrix for error calculation; If a valid minimum exists the calculation is done on the minimum point otherwise is performed; in the current set values of parameters; S",MatchSource.WIKI,root/html530/ROOT__Minuit2__Minuit2Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__Minuit2Minimizer.html
Integrability,interface,interface,". ROOT::Minuit2::Minuit2Minimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::Minuit2Minimizer. class ROOT::Minuit2::Minuit2Minimizer: public ROOT::Math::Minimizer. Minuit2Minimizer class implementing the ROOT::Math::Minimizer interface for; Minuit2 minimization algorithm.; In ROOT it can be instantiated using the plug-in manager (plug-in ""Minuit2""); Using a string (used by the plugin manager) or via an enumeration; an one can set all the possible minimization algorithms (Migrad, Simplex, Combined, Scan and Fumili). Function Members (Methods); public:. virtual~Minuit2Minimizer(); virtual voidClear(); virtual boolContour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); virtual doubleCorrelation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolGetCovMatrix(double* cov) const; virtual boolGetHessianMatrix(double* h) const; virtual boolGetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); virtual doubleGlobalCC(unsigned int i) const; virtual boolHesse(); boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); ROOT::Minuit2::Minuit2MinimizerMinuit2Minimizer(ROOT::Minuit2::EMinimizerType type = ROOT::Minuit2::kMigrad); ROOT::Minuit2::Minuit2MinimizerMinuit2Minimizer(const char* type); virtual doubleMinValue() const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNFree() const; virtual ROOT::Math::MinimizerOptionsROOT::Math",MatchSource.WIKI,root/html530/ROOT__Minuit2__Minuit2Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__Minuit2Minimizer.html
Modifiability,plug-in,plug-in,". ROOT::Minuit2::Minuit2Minimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::Minuit2Minimizer. class ROOT::Minuit2::Minuit2Minimizer: public ROOT::Math::Minimizer. Minuit2Minimizer class implementing the ROOT::Math::Minimizer interface for; Minuit2 minimization algorithm.; In ROOT it can be instantiated using the plug-in manager (plug-in ""Minuit2""); Using a string (used by the plugin manager) or via an enumeration; an one can set all the possible minimization algorithms (Migrad, Simplex, Combined, Scan and Fumili). Function Members (Methods); public:. virtual~Minuit2Minimizer(); virtual voidClear(); virtual boolContour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); virtual doubleCorrelation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolGetCovMatrix(double* cov) const; virtual boolGetHessianMatrix(double* h) const; virtual boolGetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); virtual doubleGlobalCC(unsigned int i) const; virtual boolHesse(); boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); ROOT::Minuit2::Minuit2MinimizerMinuit2Minimizer(ROOT::Minuit2::EMinimizerType type = ROOT::Minuit2::kMigrad); ROOT::Minuit2::Minuit2MinimizerMinuit2Minimizer(const char* type); virtual doubleMinValue() const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNFree() const; virtual ROOT::Math::MinimizerOptionsROOT::Math",MatchSource.WIKI,root/html530/ROOT__Minuit2__Minuit2Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__Minuit2Minimizer.html
Performance,perform,perform,"g& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set upper/lower limited variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int ivar, double val); set variable. bool SetVariableValues(const double* val). std::string VariableName(unsigned int ivar) const; get name of variables (override if minimizer support storing of variable names). int VariableIndex(const string& name) const; get index of variable given a variable given a name; return -1 if variable is not found. bool Minimize(). method to perform the minimization.; Return false in case the minimization did not converge. In this case a; status code different than zero is set; (retrieved by the derived method Minimizer::Status() )"" . status = 1 : Covariance was made pos defined; status = 2 : Hesse is invalid; status = 3 : Edm is above max; status = 4 : Reached call limit; status = 5 : Any other failure. double MinValue() const; return minimum function value. { return fState.Fval(); }. double Edm() const; return expected distance reached from the minimum. { return fState.Edm(); }. const double * X() const; return pointer to X values at the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return fState.NFcn(); }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free v",MatchSource.WIKI,root/html530/ROOT__Minuit2__Minuit2Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__Minuit2Minimizer.html
Security,validat,validated,er::Tolerance() const; virtual intVariableIndex(const string& name) const; virtual stringVariableName(unsigned int ivar) const; virtual const double*X() const. protected:. boolExamineMinimum(const ROOT::Minuit2::FunctionMinimum& min); virtual const ROOT::Minuit2::FCNBase*GetFCN() const; virtual const ROOT::Minuit2::ModularFunctionMinimizer*GetMinimizer() const; virtual voidSetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); voidSetMinimizerType(ROOT::Minuit2::EMinimizerType type). private:. ROOT::Minuit2::Minuit2MinimizerMinuit2Minimizer(const ROOT::Minuit2::Minuit2Minimizer&); ROOT::Minuit2::Minuit2Minimizer&operator=(const ROOT::Minuit2::Minuit2Minimizer& rhs). Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; doubleROOT::Math::Minimizer::fPrecprecision; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. unsigned intfDimdimension of the function to be minimized ; vector<double>fErrors; ROOT::Minuit2::ModularFunctionMinimizer*fMinimizer; ROOT::Minuit2::FunctionMinimum*fMinimum; ROOT::Minuit2::FCNBase*fMinuitFCN; ROOT::Minuit2::MnUserParameterStatefState; boolfUseFumili; vector<double>fValues. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Minuit2Minimizer(ROOT::Minuit2::EMinimizerType type = ROOT::Minuit2::kMigrad). Default constructor. Minuit2Minimizer(const char* type). Constructor with a char (used by PM). virtual ~Minuit2Minimizer(). Destructor (no operations). Minuit2Minimizer(const ROOT::Minuit2::Minuit2Minimizer& ); usually copying is,MatchSource.WIKI,root/html530/ROOT__Minuit2__Minuit2Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__Minuit2Minimizer.html
Usability,clear,clear,"er::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. unsigned intfDimdimension of the function to be minimized ; vector<double>fErrors; ROOT::Minuit2::ModularFunctionMinimizer*fMinimizer; ROOT::Minuit2::FunctionMinimum*fMinimum; ROOT::Minuit2::FCNBase*fMinuitFCN; ROOT::Minuit2::MnUserParameterStatefState; boolfUseFumili; vector<double>fValues. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Minuit2Minimizer(ROOT::Minuit2::EMinimizerType type = ROOT::Minuit2::kMigrad). Default constructor. Minuit2Minimizer(const char* type). Constructor with a char (used by PM). virtual ~Minuit2Minimizer(). Destructor (no operations). Minuit2Minimizer(const ROOT::Minuit2::Minuit2Minimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. void Clear(); clear resources (parameters) for consecutives minimizations. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set gradient the function to minimize. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set upper/lower limited variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue",MatchSource.WIKI,root/html530/ROOT__Minuit2__Minuit2Minimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__Minuit2Minimizer.html
Availability,error,error,". ROOT::Minuit2::MinuitParameter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::MinuitParameter. class ROOT::Minuit2::MinuitParameter. class for the individual Minuit Parameter with Name and number;; contains the input numbers for the minimization or the output result; from minimization;; possible interactions: Fix/release, set/remove limits, set Value/error;. From version 5.20: use string to store the name to avoid limitation of; name length of 20 characters. This class is also known as (typedefs to this class)vector<ROOT::Minuit2::MinuitParameter,allocator<ROOT::Minuit2::MinuitParameter> >::value_type. Function Members (Methods); public:. ~MinuitParameter(); doubleError() const; voidFix(); const string&GetName() const; boolHasLimits() const; boolHasLowerLimit() const; boolHasUpperLimit() const; boolIsConst() const; boolIsFixed() const; doubleLowerLimit() const; ROOT::Minuit2::MinuitParameterMinuitParameter(); ROOT::Minuit2::MinuitParameterMinuitParameter(const ROOT::Minuit2::MinuitParameter& par); ROOT::Minuit2::MinuitParameterMinuitParameter(unsigned int num, const string& name, double val); ROOT::Minuit2::MinuitParameterMinuitParameter(unsigned int num, const string& name, double val, double err); ROOT::Minuit2::MinuitParameterMinuitParameter(unsigned int num, const string& name, double val, double err, double min, double max); const char*Name() const; unsigned intNumber() const; ROOT::Minuit2::MinuitParameter&operator=(const ROOT::Minuit2::MinuitParameter& par); voidRelease(); voidRemoveLimits(); voidSetError(double err); voidSetLimits(double low, double up); voidSetLowerLimit(double low); voidSetUpperLimit(double up); voidSetValue(double val); doubleUpperLimit() const; doubleValue() const. Data Members; private:. boolfConst; doublefError; boolfFix; boolfLoLimValid; doublefLoLimit; stri",MatchSource.WIKI,root/html530/ROOT__Minuit2__MinuitParameter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__MinuitParameter.html
Deployability,release,release,". ROOT::Minuit2::MinuitParameter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::MinuitParameter. class ROOT::Minuit2::MinuitParameter. class for the individual Minuit Parameter with Name and number;; contains the input numbers for the minimization or the output result; from minimization;; possible interactions: Fix/release, set/remove limits, set Value/error;. From version 5.20: use string to store the name to avoid limitation of; name length of 20 characters. This class is also known as (typedefs to this class)vector<ROOT::Minuit2::MinuitParameter,allocator<ROOT::Minuit2::MinuitParameter> >::value_type. Function Members (Methods); public:. ~MinuitParameter(); doubleError() const; voidFix(); const string&GetName() const; boolHasLimits() const; boolHasLowerLimit() const; boolHasUpperLimit() const; boolIsConst() const; boolIsFixed() const; doubleLowerLimit() const; ROOT::Minuit2::MinuitParameterMinuitParameter(); ROOT::Minuit2::MinuitParameterMinuitParameter(const ROOT::Minuit2::MinuitParameter& par); ROOT::Minuit2::MinuitParameterMinuitParameter(unsigned int num, const string& name, double val); ROOT::Minuit2::MinuitParameterMinuitParameter(unsigned int num, const string& name, double val, double err); ROOT::Minuit2::MinuitParameterMinuitParameter(unsigned int num, const string& name, double val, double err, double min, double max); const char*Name() const; unsigned intNumber() const; ROOT::Minuit2::MinuitParameter&operator=(const ROOT::Minuit2::MinuitParameter& par); voidRelease(); voidRemoveLimits(); voidSetError(double err); voidSetLimits(double low, double up); voidSetLowerLimit(double low); voidSetUpperLimit(double up); voidSetValue(double val); doubleUpperLimit() const; doubleValue() const. Data Members; private:. boolfConst; doublefError; boolfFix; boolfLoLimValid; doublefLoLimit; stri",MatchSource.WIKI,root/html530/ROOT__Minuit2__MinuitParameter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__MinuitParameter.html
Safety,avoid,avoid,". ROOT::Minuit2::MinuitParameter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::MinuitParameter. class ROOT::Minuit2::MinuitParameter. class for the individual Minuit Parameter with Name and number;; contains the input numbers for the minimization or the output result; from minimization;; possible interactions: Fix/release, set/remove limits, set Value/error;. From version 5.20: use string to store the name to avoid limitation of; name length of 20 characters. This class is also known as (typedefs to this class)vector<ROOT::Minuit2::MinuitParameter,allocator<ROOT::Minuit2::MinuitParameter> >::value_type. Function Members (Methods); public:. ~MinuitParameter(); doubleError() const; voidFix(); const string&GetName() const; boolHasLimits() const; boolHasLowerLimit() const; boolHasUpperLimit() const; boolIsConst() const; boolIsFixed() const; doubleLowerLimit() const; ROOT::Minuit2::MinuitParameterMinuitParameter(); ROOT::Minuit2::MinuitParameterMinuitParameter(const ROOT::Minuit2::MinuitParameter& par); ROOT::Minuit2::MinuitParameterMinuitParameter(unsigned int num, const string& name, double val); ROOT::Minuit2::MinuitParameterMinuitParameter(unsigned int num, const string& name, double val, double err); ROOT::Minuit2::MinuitParameterMinuitParameter(unsigned int num, const string& name, double val, double err, double min, double max); const char*Name() const; unsigned intNumber() const; ROOT::Minuit2::MinuitParameter&operator=(const ROOT::Minuit2::MinuitParameter& par); voidRelease(); voidRemoveLimits(); voidSetError(double err); voidSetLimits(double low, double up); voidSetLowerLimit(double low); voidSetUpperLimit(double up); voidSetValue(double val); doubleUpperLimit() const; doubleValue() const. Data Members; private:. boolfConst; doublefError; boolfFix; boolfLoLimValid; doublefLoLimit; stri",MatchSource.WIKI,root/html530/ROOT__Minuit2__MinuitParameter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__MinuitParameter.html
Security,access,access,"mit(double low); voidSetUpperLimit(double up); voidSetValue(double val); doubleUpperLimit() const; doubleValue() const. Data Members; private:. boolfConst; doublefError; boolfFix; boolfLoLimValid; doublefLoLimit; stringfName; unsigned intfNum; boolfUpLimValid; doublefUpLimit; doublefValue. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MinuitParameter(); default constructor standard with value/error = 0. {}. MinuitParameter(unsigned int num, const string& name, double val); constructor for constant Parameter. {}. MinuitParameter(unsigned int num, const string& name, double val, double err); constructor for standard Parameter. {}. MinuitParameter(unsigned int num, const string& name, double val, double err, double min, double max); constructor for limited Parameter. ~MinuitParameter(); {}. MinuitParameter(const ROOT::Minuit2::MinuitParameter& par); {}. MinuitParameter& operator=(const ROOT::Minuit2::MinuitParameter& par). unsigned int Number() const; access methods. {return fNum;}. const std::string & GetName() const; new API returning a string. { return fName; }. const char * Name() const; return const char * for mantaining backward compatibility. {return fName.c_str();}. double Value() const; {return fValue;}. double Error() const; {return fError;}. void SetValue(double val); interaction. {fValue = val;}. void SetError(double err); {fError = err;}. void SetLimits(double low, double up). void SetUpperLimit(double up). void SetLowerLimit(double low). void RemoveLimits(). void Fix(); {fFix = true;}. void Release(); {fFix = false;}. bool IsConst() const; state of Parameter (fixed/const/limited). {return fConst;}. bool IsFixed() const; {return fFix;}. bool HasLimits() const; {return fLoLimValid || fUpLimValid; }. bool HasLowerLimit() const; {return fLoLimValid; }. bool HasUpperLimit() const; {return fUpLimValid; }. double LowerLimit() const; {return fLoLimit;}. double UpperLimit() const; {return fUpLimit;}. » Last changed: root",MatchSource.WIKI,root/html530/ROOT__Minuit2__MinuitParameter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__MinuitParameter.html
Availability,avail,available,". ROOT::Minuit2::MnApplication. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::MnApplication. class ROOT::Minuit2::MnApplication. application interface class for minimizers (migrad, simplex, Minimize,; Scan); User normally instantiates the derived class like ROOT::Minuit2::MnMigrad; for using Migrad for minimization. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MnApplication(); voidAdd(const char*, double); voidAdd(const char* Name, double val, double err); voidAdd(const char* Name, double val, double err, double, double); const ROOT::Minuit2::MnUserCovariance&Covariance() const; doubleError(unsigned int) const; doubleError(const char*) const; vector<double>Errors() const; doubleExt2int(unsigned int, double) const; unsigned intExtOfInt(unsigned int) const; virtual const ROOT::Minuit2::FCNBase&Fcnbase() const; voidFix(unsigned int); voidFix(const char*); unsigned intIndex(const char*) const; doubleInt2ext(unsigned int, double) const; unsigned intIntOfExt(unsigned int) const; virtual const ROOT::Minuit2::ModularFunctionMinimizer&Minimizer() const; const vector<ROOT::Minuit2::MinuitParameter>&MinuitParameters() const; const char*Name(unsigned int) const; unsigned intNumOfCalls() const; virtual ROOT::Minuit2::FunctionMinimumoperator()(unsigned int maxfcn = 0, double tolerance = 0.1); const ROOT::Minuit2::MinuitParameter&Parameter(unsigned int i) const; const ROOT::Minuit2::MnUserParameters&Parameters() const; vector<double>Params() const; const ROOT::Minuit2::MnMachinePrecision&Precision() const; voidRelease(unsigned int); voidRelease(const char*); voidRemoveLimits(unsigned int); voidRemoveLimits(const char*); voidSetError(unsigned int, double); voidSetError(const cha",MatchSource.WIKI,root/html530/ROOT__Minuit2__MnApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__MnApplication.html
Integrability,interface,interface,". ROOT::Minuit2::MnApplication. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::MnApplication. class ROOT::Minuit2::MnApplication. application interface class for minimizers (migrad, simplex, Minimize,; Scan); User normally instantiates the derived class like ROOT::Minuit2::MnMigrad; for using Migrad for minimization. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MnApplication(); voidAdd(const char*, double); voidAdd(const char* Name, double val, double err); voidAdd(const char* Name, double val, double err, double, double); const ROOT::Minuit2::MnUserCovariance&Covariance() const; doubleError(unsigned int) const; doubleError(const char*) const; vector<double>Errors() const; doubleExt2int(unsigned int, double) const; unsigned intExtOfInt(unsigned int) const; virtual const ROOT::Minuit2::FCNBase&Fcnbase() const; voidFix(unsigned int); voidFix(const char*); unsigned intIndex(const char*) const; doubleInt2ext(unsigned int, double) const; unsigned intIntOfExt(unsigned int) const; virtual const ROOT::Minuit2::ModularFunctionMinimizer&Minimizer() const; const vector<ROOT::Minuit2::MinuitParameter>&MinuitParameters() const; const char*Name(unsigned int) const; unsigned intNumOfCalls() const; virtual ROOT::Minuit2::FunctionMinimumoperator()(unsigned int maxfcn = 0, double tolerance = 0.1); const ROOT::Minuit2::MinuitParameter&Parameter(unsigned int i) const; const ROOT::Minuit2::MnUserParameters&Parameters() const; vector<double>Params() const; const ROOT::Minuit2::MnMachinePrecision&Precision() const; voidRelease(unsigned int); voidRelease(const char*); voidRemoveLimits(unsigned int); voidRemoveLimits(const char*); voidSetError(unsigned int, double); voidSetError(const cha",MatchSource.WIKI,root/html530/ROOT__Minuit2__MnApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__MnApplication.html
Security,access,access,"har*) const; unsigned intVariableParameters() const. Data Members; protected:. const ROOT::Minuit2::FCNBase&fFCN; unsigned intfNumCall; ROOT::Minuit2::MnUserParameterStatefState; ROOT::Minuit2::MnStrategyfStrategy; boolfUseGrad. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~MnApplication(); { }. FunctionMinimum operator()(unsigned int maxfcn = 0, double tolerance = 0.1). Minimize the function; @param maxfcn : max number of function calls (if = 0) default is used which is set to; 200 + 100 * npar + 5 * npar**2; @param tolerance : value used for terminating iteration procedure.; For example, MIGRAD will stop iterating when edm (expected distance from minimum) will be:; edm < tolerance * 10**-3; Default value of tolerance used is 0.1. const FCNBase& Fcnbase() const; {return fFCN;}. unsigned int NumOfCalls() const; {return fNumCall;}. const std::vector<ROOT::Minuit2::MinuitParameter>& MinuitParameters() const; facade: forward interface of MnUserParameters and MnUserTransformation; via MnUserParameterState; access to parameters (row-wise). std::vector<double> Params() const; access to parameters and errors in column-wise representation. std::vector<double> Errors() const. void Add(const char* Name, double val, double err); add free Parameter. void Add(const char* Name, double val, double err, double , double ); add limited Parameter. void Add(const char* , double ); add const Parameter. void Fix(unsigned int ); interaction via external number of Parameter. void Release(unsigned int ). void SetValue(unsigned int , double ). void SetError(unsigned int , double ). void SetLimits(unsigned int , double , double ). void RemoveLimits(unsigned int ). double Value(unsigned int ) const. double Error(unsigned int ) const. void Fix(const char* ); interaction via Name of Parameter. void Release(const char* ). void SetValue(const char* , double ). void SetError(const char* , double ). void SetLimits(const char* , double , double ).",MatchSource.WIKI,root/html530/ROOT__Minuit2__MnApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__MnApplication.html
Usability,simpl,simplex,". ROOT::Minuit2::MnApplication. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::MnApplication. class ROOT::Minuit2::MnApplication. application interface class for minimizers (migrad, simplex, Minimize,; Scan); User normally instantiates the derived class like ROOT::Minuit2::MnMigrad; for using Migrad for minimization. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MnApplication(); voidAdd(const char*, double); voidAdd(const char* Name, double val, double err); voidAdd(const char* Name, double val, double err, double, double); const ROOT::Minuit2::MnUserCovariance&Covariance() const; doubleError(unsigned int) const; doubleError(const char*) const; vector<double>Errors() const; doubleExt2int(unsigned int, double) const; unsigned intExtOfInt(unsigned int) const; virtual const ROOT::Minuit2::FCNBase&Fcnbase() const; voidFix(unsigned int); voidFix(const char*); unsigned intIndex(const char*) const; doubleInt2ext(unsigned int, double) const; unsigned intIntOfExt(unsigned int) const; virtual const ROOT::Minuit2::ModularFunctionMinimizer&Minimizer() const; const vector<ROOT::Minuit2::MinuitParameter>&MinuitParameters() const; const char*Name(unsigned int) const; unsigned intNumOfCalls() const; virtual ROOT::Minuit2::FunctionMinimumoperator()(unsigned int maxfcn = 0, double tolerance = 0.1); const ROOT::Minuit2::MinuitParameter&Parameter(unsigned int i) const; const ROOT::Minuit2::MnUserParameters&Parameters() const; vector<double>Params() const; const ROOT::Minuit2::MnMachinePrecision&Precision() const; voidRelease(unsigned int); voidRelease(const char*); voidRemoveLimits(unsigned int); voidRemoveLimits(const char*); voidSetError(unsigned int, double); voidSetError(const cha",MatchSource.WIKI,root/html530/ROOT__Minuit2__MnApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__MnApplication.html
Availability,error,errors,". ROOT::Minuit2::MnContours. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::MnContours. class ROOT::Minuit2::MnContours. API class for Contours Error analysis (2-dim errors);; minimization has to be done before and Minimum must be valid;; possibility to ask only for the points or the points and associated Minos; errors;. Function Members (Methods); public:. ~MnContours(); ROOT::Minuit2::ContoursErrorContour(unsigned int, unsigned int, unsigned int npoints = 20) const; ROOT::Minuit2::MnContoursMnContours(const ROOT::Minuit2::MnContours&); ROOT::Minuit2::MnContoursMnContours(const ROOT::Minuit2::FCNBase& fcn, const ROOT::Minuit2::FunctionMinimum& min); ROOT::Minuit2::MnContoursMnContours(const ROOT::Minuit2::FCNBase& fcn, const ROOT::Minuit2::FunctionMinimum& min, unsigned int stra); ROOT::Minuit2::MnContoursMnContours(const ROOT::Minuit2::FCNBase& fcn, const ROOT::Minuit2::FunctionMinimum& min, const ROOT::Minuit2::MnStrategy& stra); vector<std::pair<double,double> >operator()(unsigned int, unsigned int, unsigned int npoints = 20) const; const ROOT::Minuit2::MnStrategy&Strategy() const. Data Members; private:. const ROOT::Minuit2::FCNBase&fFCN; const ROOT::Minuit2::FunctionMinimum&fMinimum; ROOT::Minuit2::MnStrategyfStrategy. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MnContours(const ROOT::Minuit2::FCNBase& fcn, const ROOT::Minuit2::FunctionMinimum& min); construct from FCN + Minimum. {}. MnContours(const ROOT::Minuit2::FCNBase& fcn, const ROOT::Minuit2::FunctionMinimum& min, unsigned int stra); construct from FCN + Minimum + strategy. {}. MnContours(const ROOT::Minuit2::FCNBase& fcn, const ROOT::Minuit2::FunctionMinimum& min, const ROOT::Minuit2::MnStrategy& stra); construct from FCN + Minimum + strategy. {}. ~MnContours(); {}. std::vector<std:",MatchSource.WIKI,root/html530/ROOT__Minuit2__MnContours.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__MnContours.html
Availability,error,errors,"it2::MnApplication::State() const; const ROOT::Minuit2::MnStrategy&ROOT::Minuit2::MnApplication::Strategy() const; doubleROOT::Minuit2::MnApplication::Value(unsigned int) const; doubleROOT::Minuit2::MnApplication::Value(const char*) const; unsigned intROOT::Minuit2::MnApplication::VariableParameters() const. private:. ROOT::Minuit2::MnFumiliMinimize&operator=(const ROOT::Minuit2::MnFumiliMinimize&). Data Members; protected:. const ROOT::Minuit2::FCNBase&ROOT::Minuit2::MnApplication::fFCN; unsigned intROOT::Minuit2::MnApplication::fNumCall; ROOT::Minuit2::MnUserParameterStateROOT::Minuit2::MnApplication::fState; ROOT::Minuit2::MnStrategyROOT::Minuit2::MnApplication::fStrategy; boolROOT::Minuit2::MnApplication::fUseGrad. private:. const ROOT::Minuit2::FumiliFCNBase&fFCN; ROOT::Minuit2::FumiliMinimizerfMinimizer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MnFumiliMinimize(const FumiliFCNBase& fcn, const std::vector<double>& par, const std::vector<double>& err, unsigned int stra = 1); construct from FumiliFCNBase + std::vector for parameters and errors. {}. MnFumiliMinimize(const ROOT::Minuit2::FumiliFCNBase& fcn, const vector<double>& par, unsigned int nrow, const vector<double>& cov, unsigned int stra = 1); construct from FumiliFCNBase + std::vector for parameters and covariance. {}. MnFumiliMinimize(const FumiliFCNBase& fcn, const std::vector<double>& par, const MnUserCovariance& cov, unsigned int stra = 1); construct from FumiliFCNBase + std::vector for parameters and MnUserCovariance. {}. MnFumiliMinimize(const ROOT::Minuit2::FumiliFCNBase& fcn, const ROOT::Minuit2::MnUserParameters& par, unsigned int stra = 1); construct from FumiliFCNBase + MnUserParameters. {}. MnFumiliMinimize(const FumiliFCNBase& fcn, const MnUserParameters& par, const MnUserCovariance& cov, unsigned int stra = 1); construct from FumiliFCNBase + MnUserParameters + MnUserCovariance. {}. MnFumiliMinimize(const ROOT::Minuit2::FumiliFCNBase& fcn, cons",MatchSource.WIKI,root/html530/ROOT__Minuit2__MnFumiliMinimize.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__MnFumiliMinimize.html
Availability,error,errors,"OT::Minuit2::MinimumStateoperator()(const ROOT::Minuit2::MnFcn&, const ROOT::Minuit2::MinimumState&, const ROOT::Minuit2::MnUserTransformation&, unsigned int maxcalls = 0) const; ROOT::Minuit2::MnUserParameterStateoperator()(const ROOT::Minuit2::FCNBase&, const vector<double>&, unsigned int nrow, const vector<double>&, unsigned int maxcalls = 0) const; ROOT::Minuit2::MnHesse&operator=(const ROOT::Minuit2::MnHesse&); doubleTolerG2() const; doubleTolerstp() const. Data Members; private:. ROOT::Minuit2::MnStrategyfStrategy. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MnHesse(); default constructor with default strategy. {}. MnHesse(unsigned int stra); constructor with user-defined strategy level. {}. MnHesse(const MnStrategy& stra); conctructor with specific strategy. {}. ~MnHesse(); {}. MnUserParameterState operator()(const FCNBase&, const std::vector<double>&, const std::vector<double>&, unsigned int maxcalls=0). low-level API. FCN + parameters + errors. MnUserParameterState operator()(const ROOT::Minuit2::FCNBase& , const vector<double>& , unsigned int nrow, const vector<double>& , unsigned int maxcalls = 0) const; FCN + parameters + covariance. MnUserParameterState operator()(const FCNBase&, const std::vector<double>&, const MnUserCovariance&, unsigned int maxcalls=0); FCN + parameters + MnUserCovariance. MnUserParameterState operator()(const FCNBase&, const MnUserParameters&, unsigned int maxcalls=0). high-level API. FCN + MnUserParameters. MnUserParameterState operator()(const FCNBase&, const MnUserParameters&, const MnUserCovariance&, unsigned int maxcalls=0); FCN + MnUserParameters + MnUserCovariance. MnUserParameterState operator()(const FCNBase&, const MnUserParameterState&, unsigned int maxcalls=0); FCN + MnUserParameterState. void operator()(const ROOT::Minuit2::FCNBase& , ROOT::Minuit2::FunctionMinimum& , unsigned int maxcalls = 0) const. API to use MnHesse after minimization when function mimimum is avalilable",MatchSource.WIKI,root/html530/ROOT__Minuit2__MnHesse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__MnHesse.html
Deployability,update,updated,"se&, const std::vector<double>&, const std::vector<double>&, unsigned int maxcalls=0). low-level API. FCN + parameters + errors. MnUserParameterState operator()(const ROOT::Minuit2::FCNBase& , const vector<double>& , unsigned int nrow, const vector<double>& , unsigned int maxcalls = 0) const; FCN + parameters + covariance. MnUserParameterState operator()(const FCNBase&, const std::vector<double>&, const MnUserCovariance&, unsigned int maxcalls=0); FCN + parameters + MnUserCovariance. MnUserParameterState operator()(const FCNBase&, const MnUserParameters&, unsigned int maxcalls=0). high-level API. FCN + MnUserParameters. MnUserParameterState operator()(const FCNBase&, const MnUserParameters&, const MnUserCovariance&, unsigned int maxcalls=0); FCN + MnUserParameters + MnUserCovariance. MnUserParameterState operator()(const FCNBase&, const MnUserParameterState&, unsigned int maxcalls=0); FCN + MnUserParameterState. void operator()(const ROOT::Minuit2::FCNBase& , ROOT::Minuit2::FunctionMinimum& , unsigned int maxcalls = 0) const. API to use MnHesse after minimization when function mimimum is avalilable, otherwise information on the last state will be; lost. (It would be needed to re-call the gradient and spend extra useless function calls); The Function Minimum is updated (modified) by adding the Hesse results as last state of minimization. MinimumState operator()(const MnFcn&, const MinimumState&, const MnUserTransformation&, unsigned int maxcalls=0); internal interface. unsigned int Ncycles() const; forward interface of MnStrategy. {return fStrategy.HessianNCycles();}. double Tolerstp() const; {return fStrategy.HessianStepTolerance();}. double TolerG2() const; {return fStrategy.HessianG2Tolerance();}. » Last changed: root/minuit2:$Id: MnHesse.h 23654 2008-05-06 07:30:34Z moneta $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Minuit2__MnHesse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__MnHesse.html
Integrability,interface,interface,"se&, const std::vector<double>&, const std::vector<double>&, unsigned int maxcalls=0). low-level API. FCN + parameters + errors. MnUserParameterState operator()(const ROOT::Minuit2::FCNBase& , const vector<double>& , unsigned int nrow, const vector<double>& , unsigned int maxcalls = 0) const; FCN + parameters + covariance. MnUserParameterState operator()(const FCNBase&, const std::vector<double>&, const MnUserCovariance&, unsigned int maxcalls=0); FCN + parameters + MnUserCovariance. MnUserParameterState operator()(const FCNBase&, const MnUserParameters&, unsigned int maxcalls=0). high-level API. FCN + MnUserParameters. MnUserParameterState operator()(const FCNBase&, const MnUserParameters&, const MnUserCovariance&, unsigned int maxcalls=0); FCN + MnUserParameters + MnUserCovariance. MnUserParameterState operator()(const FCNBase&, const MnUserParameterState&, unsigned int maxcalls=0); FCN + MnUserParameterState. void operator()(const ROOT::Minuit2::FCNBase& , ROOT::Minuit2::FunctionMinimum& , unsigned int maxcalls = 0) const. API to use MnHesse after minimization when function mimimum is avalilable, otherwise information on the last state will be; lost. (It would be needed to re-call the gradient and spend extra useless function calls); The Function Minimum is updated (modified) by adding the Hesse results as last state of minimization. MinimumState operator()(const MnFcn&, const MinimumState&, const MnUserTransformation&, unsigned int maxcalls=0); internal interface. unsigned int Ncycles() const; forward interface of MnStrategy. {return fStrategy.HessianNCycles();}. double Tolerstp() const; {return fStrategy.HessianStepTolerance();}. double TolerG2() const; {return fStrategy.HessianG2Tolerance();}. » Last changed: root/minuit2:$Id: MnHesse.h 23654 2008-05-06 07:30:34Z moneta $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Minuit2__MnHesse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__MnHesse.html
Availability,toler,tolerance,"Minuit2::FCNBase& fcn, const ROOT::Minuit2::MnUserParameterState& par, const ROOT::Minuit2::MnStrategy& str); ROOT::Minuit2::MnMigradMnMigrad(const ROOT::Minuit2::FCNGradientBase& fcn, const ROOT::Minuit2::MnUserParameters& par, unsigned int stra = 1); ROOT::Minuit2::MnMigradMnMigrad(const ROOT::Minuit2::FCNGradientBase& fcn, const ROOT::Minuit2::MnUserParameterState& par, const ROOT::Minuit2::MnStrategy& str); ROOT::Minuit2::MnMigradMnMigrad(const ROOT::Minuit2::FCNBase& fcn, const vector<double>& par, const vector<double>& err, unsigned int stra = 1); ROOT::Minuit2::MnMigradMnMigrad(const ROOT::Minuit2::FCNBase& fcn, const vector<double>& par, const ROOT::Minuit2::MnUserCovariance& cov, unsigned int stra = 1); ROOT::Minuit2::MnMigradMnMigrad(const ROOT::Minuit2::FCNBase& fcn, const ROOT::Minuit2::MnUserParameters& par, const ROOT::Minuit2::MnUserCovariance& cov, unsigned int stra = 1); ROOT::Minuit2::MnMigradMnMigrad(const ROOT::Minuit2::FCNGradientBase& fcn, const vector<double>& par, const vector<double>& err, unsigned int stra = 1); ROOT::Minuit2::MnMigradMnMigrad(const ROOT::Minuit2::FCNGradientBase& fcn, const vector<double>& par, const ROOT::Minuit2::MnUserCovariance& cov, unsigned int stra = 1); ROOT::Minuit2::MnMigradMnMigrad(const ROOT::Minuit2::FCNGradientBase& fcn, const ROOT::Minuit2::MnUserParameters& par, const ROOT::Minuit2::MnUserCovariance& cov, unsigned int stra = 1); ROOT::Minuit2::MnMigradMnMigrad(const ROOT::Minuit2::FCNBase& fcn, const vector<double>& par, unsigned int nrow, const vector<double>& cov, unsigned int stra = 1); ROOT::Minuit2::MnMigradMnMigrad(const ROOT::Minuit2::FCNGradientBase& fcn, const vector<double>& par, unsigned int nrow, const vector<double>& cov, unsigned int stra = 1); const char*ROOT::Minuit2::MnApplication::Name(unsigned int) const; unsigned intROOT::Minuit2::MnApplication::NumOfCalls() const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::MnApplication::operator()(unsigned int maxfcn = 0, double tolerance = 0.",MatchSource.WIKI,root/html530/ROOT__Minuit2__MnMigrad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__MnMigrad.html
Availability,toler,tolerance,"t2::MnUserParameterState& par, const ROOT::Minuit2::MnStrategy& str); ROOT::Minuit2::MnMinimizeMnMinimize(const ROOT::Minuit2::FCNGradientBase& fcn, const ROOT::Minuit2::MnUserParameters& par, unsigned int stra = 1); ROOT::Minuit2::MnMinimizeMnMinimize(const ROOT::Minuit2::FCNGradientBase& fcn, const ROOT::Minuit2::MnUserParameterState& par, const ROOT::Minuit2::MnStrategy& str); ROOT::Minuit2::MnMinimizeMnMinimize(const ROOT::Minuit2::FCNBase& fcn, const vector<double>& par, const vector<double>& err, unsigned int stra = 1); ROOT::Minuit2::MnMinimizeMnMinimize(const ROOT::Minuit2::FCNBase& fcn, const vector<double>& par, const ROOT::Minuit2::MnUserCovariance& cov, unsigned int stra = 1); ROOT::Minuit2::MnMinimizeMnMinimize(const ROOT::Minuit2::FCNBase& fcn, const ROOT::Minuit2::MnUserParameters& par, const ROOT::Minuit2::MnUserCovariance& cov, unsigned int stra = 1); ROOT::Minuit2::MnMinimizeMnMinimize(const ROOT::Minuit2::FCNGradientBase& fcn, const vector<double>& par, const vector<double>& err, unsigned int stra = 1); ROOT::Minuit2::MnMinimizeMnMinimize(const ROOT::Minuit2::FCNGradientBase& fcn, const vector<double>& par, const ROOT::Minuit2::MnUserCovariance& cov, unsigned int stra = 1); ROOT::Minuit2::MnMinimizeMnMinimize(const ROOT::Minuit2::FCNGradientBase& fcn, const ROOT::Minuit2::MnUserParameters& par, const ROOT::Minuit2::MnUserCovariance& cov, unsigned int stra = 1); ROOT::Minuit2::MnMinimizeMnMinimize(const ROOT::Minuit2::FCNBase& fcn, const vector<double>& par, unsigned int nrow, const vector<double>& cov, unsigned int stra = 1); ROOT::Minuit2::MnMinimizeMnMinimize(const ROOT::Minuit2::FCNGradientBase& fcn, const vector<double>& par, unsigned int nrow, const vector<double>& cov, unsigned int stra = 1); const char*ROOT::Minuit2::MnApplication::Name(unsigned int) const; unsigned intROOT::Minuit2::MnApplication::NumOfCalls() const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::MnApplication::operator()(unsigned int maxfcn = 0, double tolerance = 0.",MatchSource.WIKI,root/html530/ROOT__Minuit2__MnMinimize.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__MnMinimize.html
Integrability,interface,interfaces,"rs and errors. {}. MnMinimize(const FCNBase& fcn, const std::vector<double>& par, unsigned int nrow, const std::vector<double>& cov, unsigned int stra = 1); construct from FCNBase + std::vector for parameters and covariance. {}. MnMinimize(const FCNBase& fcn, const std::vector<double>& par, const MnUserCovariance& cov, unsigned int stra = 1); construct from FCNBase + std::vector for parameters and MnUserCovariance. {}. MnMinimize(const FCNBase& fcn, const MnUserParameters& par, unsigned int stra = 1); construct from FCNBase + MnUserParameters. {}. MnMinimize(const FCNBase& fcn, const MnUserParameters& par, const MnUserCovariance& cov, unsigned int stra = 1); construct from FCNBase + MnUserParameters + MnUserCovariance. {}. MnMinimize(const FCNBase& fcn, const MnUserParameterState& par, const MnStrategy& str); construct from FCNBase + MnUserParameterState + MnStrategy. {}. MnMinimize(const FCNGradientBase& fcn, const std::vector<double>& par, const std::vector<double>& err, unsigned int stra = 1); interfaces using FCNGradientBase; construct from FCNGradientBase + std::vector for parameters and errors. {}. MnMinimize(const FCNGradientBase& fcn, const std::vector<double>& par, unsigned int nrow, const std::vector<double>& cov, unsigned int stra = 1); construct from FCNGradientBase + std::vector for parameters and covariance. {}. MnMinimize(const FCNGradientBase& fcn, const std::vector<double>& par, const MnUserCovariance& cov, unsigned int stra = 1); construct from FCNGradientBase + std::vector for parameters and MnUserCovariance. {}. MnMinimize(const FCNGradientBase& fcn, const MnUserParameters& par, unsigned int stra = 1); construct from FCNGradientBase + MnUserParameters. {}. MnMinimize(const FCNGradientBase& fcn, const MnUserParameters& par, const MnUserCovariance& cov, unsigned int stra = 1); construct from FCNGradientBase + MnUserParameters + MnUserCovariance. {}. MnMinimize(const FCNGradientBase& fcn, const MnUserParameterState& par, const MnStrategy& str); const",MatchSource.WIKI,root/html530/ROOT__Minuit2__MnMinimize.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__MnMinimize.html
Availability,error,errors,". ROOT::Minuit2::MnMinos. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::MnMinos. class ROOT::Minuit2::MnMinos. API class for Minos Error analysis (asymmetric errors);; minimization has to be done before and Minimum must be valid;; possibility to ask only for one side of the Minos Error;. Function Members (Methods); public:. ~MnMinos(); ROOT::Minuit2::MnCrossLoval(unsigned int, unsigned int maxcalls = 0, double toler = 0.1) const; doubleLower(unsigned int, unsigned int maxcalls = 0, double toler = 0.1) const; ROOT::Minuit2::MinosErrorMinos(unsigned int, unsigned int maxcalls = 0, double toler = 0.1) const; ROOT::Minuit2::MnMinosMnMinos(const ROOT::Minuit2::MnMinos&); ROOT::Minuit2::MnMinosMnMinos(const ROOT::Minuit2::FCNBase& fcn, const ROOT::Minuit2::FunctionMinimum& min, unsigned int stra = 1); ROOT::Minuit2::MnMinosMnMinos(const ROOT::Minuit2::FCNBase& fcn, const ROOT::Minuit2::FunctionMinimum& min, const ROOT::Minuit2::MnStrategy& stra); pair<double,double>operator()(unsigned int, unsigned int maxcalls = 0, double toler = 0.1) const; doubleUpper(unsigned int, unsigned int maxcalls = 0, double toler = 0.1) const; ROOT::Minuit2::MnCrossUpval(unsigned int, unsigned int maxcalls = 0, double toler = 0.1) const. protected:. ROOT::Minuit2::MnCrossFindCrossValue(int dir, unsigned int, unsigned int maxcalls, double toler) const. Data Members; private:. const ROOT::Minuit2::FCNBase&fFCN; const ROOT::Minuit2::FunctionMinimum&fMinimum; ROOT::Minuit2::MnStrategyfStrategy. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MnMinos(const ROOT::Minuit2::FCNBase& fcn, const ROOT::Minuit2::FunctionMinimum& min, unsigned int stra = 1); construct from FCN + Minimum + strategy. MnMinos(const ROOT::Minuit2::FCNBase& fcn, const ROOT::Minuit2::FunctionMinimum& min, const R",MatchSource.WIKI,root/html530/ROOT__Minuit2__MnMinos.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__MnMinos.html
Availability,toler,tolerance,">ROOT::Minuit2::MnApplication::Errors() const; doubleROOT::Minuit2::MnApplication::Ext2int(unsigned int, double) const; unsigned intROOT::Minuit2::MnApplication::ExtOfInt(unsigned int) const; virtual const ROOT::Minuit2::FCNBase&ROOT::Minuit2::MnApplication::Fcnbase() const; voidROOT::Minuit2::MnApplication::Fix(unsigned int); voidROOT::Minuit2::MnApplication::Fix(const char*); unsigned intROOT::Minuit2::MnApplication::Index(const char*) const; doubleROOT::Minuit2::MnApplication::Int2ext(unsigned int, double) const; unsigned intROOT::Minuit2::MnApplication::IntOfExt(unsigned int) const; virtual const ROOT::Minuit2::ModularFunctionMinimizer&Minimizer() const; const vector<ROOT::Minuit2::MinuitParameter>&ROOT::Minuit2::MnApplication::MinuitParameters() const; ROOT::Minuit2::MnScanMnScan(const ROOT::Minuit2::MnScan& migr); ROOT::Minuit2::MnScanMnScan(const ROOT::Minuit2::FCNBase& fcn, const ROOT::Minuit2::MnUserParameters& par, unsigned int stra = 1); ROOT::Minuit2::MnScanMnScan(const ROOT::Minuit2::FCNBase& fcn, const ROOT::Minuit2::MnUserParameterState& par, const ROOT::Minuit2::MnStrategy& str); ROOT::Minuit2::MnScanMnScan(const ROOT::Minuit2::FCNBase& fcn, const vector<double>& par, const vector<double>& err, unsigned int stra = 1); ROOT::Minuit2::MnScanMnScan(const ROOT::Minuit2::FCNBase& fcn, const vector<double>& par, const ROOT::Minuit2::MnUserCovariance& cov, unsigned int stra = 1); ROOT::Minuit2::MnScanMnScan(const ROOT::Minuit2::FCNBase& fcn, const ROOT::Minuit2::MnUserParameters& par, const ROOT::Minuit2::MnUserCovariance& cov, unsigned int stra = 1); ROOT::Minuit2::MnScanMnScan(const ROOT::Minuit2::FCNBase& fcn, const vector<double>& par, unsigned int nrow, const vector<double>& cov, unsigned int stra = 1); const char*ROOT::Minuit2::MnApplication::Name(unsigned int) const; unsigned intROOT::Minuit2::MnApplication::NumOfCalls() const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::MnApplication::operator()(unsigned int maxfcn = 0, double tolerance = 0.",MatchSource.WIKI,root/html530/ROOT__Minuit2__MnScan.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__MnScan.html
Availability,avail,available,". ROOT::Minuit2::MnSimplex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::MnSimplex. class ROOT::Minuit2::MnSimplex: public ROOT::Minuit2::MnApplication. API class for minimization using the Simplex method, which does not need and use; the derivatives of the function, but only function values.; More information on the minimization method is available; <A HREF=""http://seal.web.cern.ch/mathlibs/documents/minuit/mntutorial.pdf"">here</A>. It allows for user interaction: set/change parameters, do minimization,; change parameters, re-do minimization etc.;. Function Members (Methods); public:. virtual~MnSimplex(); voidROOT::Minuit2::MnApplication::Add(const char*, double); voidROOT::Minuit2::MnApplication::Add(const char* Name, double val, double err); voidROOT::Minuit2::MnApplication::Add(const char* Name, double val, double err, double, double); const ROOT::Minuit2::MnUserCovariance&ROOT::Minuit2::MnApplication::Covariance() const; doubleROOT::Minuit2::MnApplication::Error(unsigned int) const; doubleROOT::Minuit2::MnApplication::Error(const char*) const; vector<double>ROOT::Minuit2::MnApplication::Errors() const; doubleROOT::Minuit2::MnApplication::Ext2int(unsigned int, double) const; unsigned intROOT::Minuit2::MnApplication::ExtOfInt(unsigned int) const; virtual const ROOT::Minuit2::FCNBase&ROOT::Minuit2::MnApplication::Fcnbase() const; voidROOT::Minuit2::MnApplication::Fix(unsigned int); voidROOT::Minuit2::MnApplication::Fix(const char*); unsigned intROOT::Minuit2::MnApplication::Index(const char*) const; doubleROOT::Minuit2::MnApplication::Int2ext(unsigned int, double) const; unsigned intROOT::Minuit2::MnApplication::IntOfExt(unsigned int) const; virtual const ROOT::Minuit2::ModularFunctionMinimizer&Minimizer() const; const vector<ROOT::Minuit2::MinuitParameter>&ROOT::Minuit2::MnApplication::M",MatchSource.WIKI,root/html530/ROOT__Minuit2__MnSimplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__MnSimplex.html
Availability,toler,toler,"omepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::MnStrategy. class ROOT::Minuit2::MnStrategy. API class for defining three levels of strategies: low (0), medium (1),; high (>=2);; acts on: Migrad (behavioural),; Minos (lowers strategy by 1 for Minos-own minimization),; 	 Hesse (iterations),; 	 Numerical2PDerivative (iterations). Function Members (Methods); public:. ~MnStrategy(); unsigned intGradientNCycles() const; doubleGradientStepTolerance() const; doubleGradientTolerance() const; doubleHessianG2Tolerance() const; unsigned intHessianGradientNCycles() const; unsigned intHessianNCycles() const; doubleHessianStepTolerance() const; boolIsHigh() const; boolIsLow() const; boolIsMedium() const; ROOT::Minuit2::MnStrategyMnStrategy(); ROOT::Minuit2::MnStrategyMnStrategy(unsigned int); ROOT::Minuit2::MnStrategyMnStrategy(const ROOT::Minuit2::MnStrategy&); ROOT::Minuit2::MnStrategy&operator=(const ROOT::Minuit2::MnStrategy&); voidSetGradientNCycles(unsigned int n); voidSetGradientStepTolerance(double stp); voidSetGradientTolerance(double toler); voidSetHessianG2Tolerance(double toler); voidSetHessianGradientNCycles(unsigned int n); voidSetHessianNCycles(unsigned int n); voidSetHessianStepTolerance(double stp); voidSetHighStrategy(); voidSetLowStrategy(); voidSetMediumStrategy(); unsigned intStrategy() const. Data Members; private:. unsigned intfGradNCyc; doublefGradTlr; doublefGradTlrStp; unsigned intfHessGradNCyc; unsigned intfHessNCyc; doublefHessTlrG2; doublefHessTlrStp; unsigned intfStrategy. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MnStrategy(); default strategy. explicit MnStrategy(unsigned int ); user defined strategy (0, 1, >=2). ~MnStrategy(); {}. unsigned int Strategy() const; {return fStrategy;}. unsigned int GradientNCycles() const; {return fGradNCyc;}. double",MatchSource.WIKI,root/html530/ROOT__Minuit2__MnStrategy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__MnStrategy.html
Availability,error,errors,"SetUpperLimit(unsigned int, double); voidSetUpperLimit(const string&, double); voidSetValue(unsigned int, double); voidSetValue(const string&, double); const ROOT::Minuit2::MnUserTransformation&Trafo() const; doubleValue(unsigned int) const; doubleValue(const string&) const; unsigned intVariableParameters() const. Data Members; private:. ROOT::Minuit2::MnUserTransformationfTransformation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MnUserParameters(); {}. MnUserParameters(const vector<double>& , const vector<double>& ). ~MnUserParameters(); {}. MnUserParameters(const ROOT::Minuit2::MnUserParameters& par); {}. MnUserParameters& operator=(const ROOT::Minuit2::MnUserParameters& par). const MnUserTransformation& Trafo() const; {return fTransformation;}. unsigned int VariableParameters() const. const std::vector<ROOT::Minuit2::MinuitParameter>& Parameters() const; access to parameters (row-wise). std::vector<double> Params() const; access to parameters and errors in column-wise representation. std::vector<double> Errors() const. bool Add(const string& , double , double ); Add free Parameter Name, Value, Error. bool Add(const string& , double , double , double , double ); Add limited Parameter Name, Value, Lower bound, Upper bound. bool Add(const string& , double ); Add const Parameter Name, vale. void Fix(unsigned int ); interaction via external number of Parameter. void Release(unsigned int ). void SetValue(unsigned int , double ). void SetError(unsigned int , double ). void SetLimits(unsigned int , double , double ). void SetUpperLimit(unsigned int , double ). void SetLowerLimit(unsigned int , double ). void RemoveLimits(unsigned int ). double Value(unsigned int ) const. double Error(unsigned int ) const. void Fix(const string& ); interaction via Name of Parameter. void Release(const string& ). void SetValue(const string& , double ). void SetError(const string& , double ). void SetLimits(const string& , double , double ). v",MatchSource.WIKI,root/html530/ROOT__Minuit2__MnUserParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__MnUserParameters.html
Integrability,interface,interface,"s() const. const std::vector<ROOT::Minuit2::MinuitParameter>& Parameters() const; access to parameters (row-wise). std::vector<double> Params() const; access to parameters and errors in column-wise representation. std::vector<double> Errors() const. bool Add(const string& , double , double ); Add free Parameter Name, Value, Error. bool Add(const string& , double , double , double , double ); Add limited Parameter Name, Value, Lower bound, Upper bound. bool Add(const string& , double ); Add const Parameter Name, vale. void Fix(unsigned int ); interaction via external number of Parameter. void Release(unsigned int ). void SetValue(unsigned int , double ). void SetError(unsigned int , double ). void SetLimits(unsigned int , double , double ). void SetUpperLimit(unsigned int , double ). void SetLowerLimit(unsigned int , double ). void RemoveLimits(unsigned int ). double Value(unsigned int ) const. double Error(unsigned int ) const. void Fix(const string& ); interaction via Name of Parameter. void Release(const string& ). void SetValue(const string& , double ). void SetError(const string& , double ). void SetLimits(const string& , double , double ). void SetUpperLimit(const string& , double ). void SetLowerLimit(const string& , double ). void RemoveLimits(const string& ). double Value(const string& ) const. double Error(const string& ) const. unsigned int Index(const string& ) const; convert Name into external number of Parameter. const std::string & GetName(unsigned int ) const; convert external number into Name of Parameter. const char* Name(unsigned int ) const; mantain interface with const char * for backward compatibility. void SetPrecision(double eps); {fTransformation.SetPrecision(eps);}. » Last changed: root/minuit2:$Id: MnUserParameters.h 24400 2008-06-20 07:28:49Z moneta $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__Minuit2__MnUserParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__MnUserParameters.html
Security,access,access,"t(unsigned int, double); voidSetLowerLimit(const string&, double); voidSetPrecision(double eps); voidSetUpperLimit(unsigned int, double); voidSetUpperLimit(const string&, double); voidSetValue(unsigned int, double); voidSetValue(const string&, double); const ROOT::Minuit2::MnUserTransformation&Trafo() const; doubleValue(unsigned int) const; doubleValue(const string&) const; unsigned intVariableParameters() const. Data Members; private:. ROOT::Minuit2::MnUserTransformationfTransformation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MnUserParameters(); {}. MnUserParameters(const vector<double>& , const vector<double>& ). ~MnUserParameters(); {}. MnUserParameters(const ROOT::Minuit2::MnUserParameters& par); {}. MnUserParameters& operator=(const ROOT::Minuit2::MnUserParameters& par). const MnUserTransformation& Trafo() const; {return fTransformation;}. unsigned int VariableParameters() const. const std::vector<ROOT::Minuit2::MinuitParameter>& Parameters() const; access to parameters (row-wise). std::vector<double> Params() const; access to parameters and errors in column-wise representation. std::vector<double> Errors() const. bool Add(const string& , double , double ); Add free Parameter Name, Value, Error. bool Add(const string& , double , double , double , double ); Add limited Parameter Name, Value, Lower bound, Upper bound. bool Add(const string& , double ); Add const Parameter Name, vale. void Fix(unsigned int ); interaction via external number of Parameter. void Release(unsigned int ). void SetValue(unsigned int , double ). void SetError(unsigned int , double ). void SetLimits(unsigned int , double , double ). void SetUpperLimit(unsigned int , double ). void SetLowerLimit(unsigned int , double ). void RemoveLimits(unsigned int ). double Value(unsigned int ) const. double Error(unsigned int ) const. void Fix(const string& ); interaction via Name of Parameter. void Release(const string& ). void SetValue(const string& ,",MatchSource.WIKI,root/html530/ROOT__Minuit2__MnUserParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__MnUserParameters.html
Availability,error,errors,". ROOT::Minuit2::MnUserParameterState. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::MnUserParameterState. class ROOT::Minuit2::MnUserParameterState. class which holds the external user and/or internal Minuit representation; of the parameters and errors;; transformation internal <-> external on demand;. Function Members (Methods); public:. ~MnUserParameterState(); voidAdd(const string&, double); voidAdd(const string& name, double val, double err); voidAdd(const string& name, double val, double err, double, double); const ROOT::Minuit2::MnUserCovariance&Covariance() const; doubleEdm() const; doubleError(unsigned int) const; doubleError(const string&) const; vector<double>Errors() const; doubleExt2int(unsigned int, double) const; unsigned intExtOfInt(unsigned int) const; voidFix(unsigned int); voidFix(const string&); doubleFval() const; const string&GetName(unsigned int) const; const ROOT::Minuit2::MnGlobalCorrelationCoeff&GlobalCC() const; boolHasCovariance() const; boolHasGlobalCC() const; ROOT::Minuit2::MnUserCovarianceHessian() const; unsigned intIndex(const string&) const; doubleInt2ext(unsigned int, double) const; const ROOT::Minuit2::MnUserCovariance&IntCovariance() const; unsigned intIntOfExt(unsigned int) const; const vector<double>&IntParameters() const; boolIsValid() const; const vector<ROOT::Minuit2::MinuitParameter>&MinuitParameters() const; ROOT::Minuit2::MnUserParameterStateMnUserParameterState(); ROOT::Minuit2::MnUserParameterStateMnUserParameterState(const ROOT::Minuit2::MnUserParameters&); ROOT::Minuit2::MnUserParameterStateMnUserParameterState(const ROOT::Minuit2::MnUserParameterState& state); ROOT::Minuit2::MnUserParameterStateMnUserParameterState(const vector<double>&, const vector<double>&); ROOT::Minuit2::MnUserParameterStateMnUserParameterState(const vector<double>&, co",MatchSource.WIKI,root/html530/ROOT__Minuit2__MnUserParameterState.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__MnUserParameterState.html
Integrability,interface,interface,"rnal parameters (after minimization). ~MnUserParameterState(); {}. MnUserParameterState(const MnUserParameterState& state); {}. MnUserParameterState& operator=(const ROOT::Minuit2::MnUserParameterState& state). const MnGlobalCorrelationCoeff& GlobalCC() const; {return fGlobalCC;}. MnUserCovariance Hessian() const; hessian (inverse of covariance matrix). const std::vector<double>& IntParameters() const; Minuit internal representation. {return fIntParameters;}. const MnUserCovariance& IntCovariance() const; {return fIntCovariance;}. const MnUserTransformation& Trafo() const; transformation internal <-> external. {return fParameters.Trafo();}. bool IsValid() const; {return fValid;}. bool HasCovariance() const; {return fCovarianceValid;}. bool HasGlobalCC() const; {return fGCCValid;}. double Fval() const; {return fFVal;}. double Edm() const; {return fEDM;}. unsigned int NFcn() const; {return fNFcn;}. const std::vector<ROOT::Minuit2::MinuitParameter>& MinuitParameters() const; facade: forward interface of MnUserParameters and MnUserTransformation ; access to parameters (row-wise). std::vector<double> Params() const; access to parameters and errors in column-wise representation. std::vector<double> Errors() const. void Add(const string& name, double val, double err); add free Parameter. void Add(const string& name, double val, double err, double , double ); add limited Parameter. void Add(const string& , double ); add const Parameter. void Fix(unsigned int ); interaction via external number of Parameter. void Release(unsigned int ). void SetValue(unsigned int , double ). void SetError(unsigned int , double ). void SetLimits(unsigned int , double , double ). void SetUpperLimit(unsigned int , double ). void SetLowerLimit(unsigned int , double ). void RemoveLimits(unsigned int ). double Value(unsigned int ) const. double Error(unsigned int ) const. void Fix(const string& ); interaction via Name of Parameter. void Release(const string& ). void SetValue(const string& , double )",MatchSource.WIKI,root/html530/ROOT__Minuit2__MnUserParameterState.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__MnUserParameterState.html
Security,access,access,"rnal parameters (after minimization). ~MnUserParameterState(); {}. MnUserParameterState(const MnUserParameterState& state); {}. MnUserParameterState& operator=(const ROOT::Minuit2::MnUserParameterState& state). const MnGlobalCorrelationCoeff& GlobalCC() const; {return fGlobalCC;}. MnUserCovariance Hessian() const; hessian (inverse of covariance matrix). const std::vector<double>& IntParameters() const; Minuit internal representation. {return fIntParameters;}. const MnUserCovariance& IntCovariance() const; {return fIntCovariance;}. const MnUserTransformation& Trafo() const; transformation internal <-> external. {return fParameters.Trafo();}. bool IsValid() const; {return fValid;}. bool HasCovariance() const; {return fCovarianceValid;}. bool HasGlobalCC() const; {return fGCCValid;}. double Fval() const; {return fFVal;}. double Edm() const; {return fEDM;}. unsigned int NFcn() const; {return fNFcn;}. const std::vector<ROOT::Minuit2::MinuitParameter>& MinuitParameters() const; facade: forward interface of MnUserParameters and MnUserTransformation ; access to parameters (row-wise). std::vector<double> Params() const; access to parameters and errors in column-wise representation. std::vector<double> Errors() const. void Add(const string& name, double val, double err); add free Parameter. void Add(const string& name, double val, double err, double , double ); add limited Parameter. void Add(const string& , double ); add const Parameter. void Fix(unsigned int ); interaction via external number of Parameter. void Release(unsigned int ). void SetValue(unsigned int , double ). void SetError(unsigned int , double ). void SetLimits(unsigned int , double , double ). void SetUpperLimit(unsigned int , double ). void SetLowerLimit(unsigned int , double ). void RemoveLimits(unsigned int ). double Value(unsigned int ) const. double Error(unsigned int ) const. void Fix(const string& ); interaction via Name of Parameter. void Release(const string& ). void SetValue(const string& , double )",MatchSource.WIKI,root/html530/ROOT__Minuit2__MnUserParameterState.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__MnUserParameterState.html
Availability,avail,available,". ROOT::Minuit2::ModularFunctionMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::ModularFunctionMinimizer. class ROOT::Minuit2::ModularFunctionMinimizer: public ROOT::Minuit2::FunctionMinimizer. Base common class providing the API for all the minimizer; Various Minimize methods are provided varying on the type of; FCN function passesd and on the objects used for the parameters. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~ModularFunctionMinimizer(); virtual const ROOT::Minuit2::MinimumBuilder&Builder() const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNBase&, const ROOT::Minuit2::MnUserParameterState&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameterState&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNBase&, const vector<double>&, const vector<double>&, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNGradientBase&, const vector<double>&, const vector<double>",MatchSource.WIKI,root/html530/ROOT__Minuit2__ModularFunctionMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__ModularFunctionMinimizer.html
Integrability,interface,interface,"OT::Minuit2::MinimumSeed&, const ROOT::Minuit2::MnStrategy&, unsigned int, double) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNBase&, const vector<double>&, unsigned int, const vector<double>&, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNGradientBase&, const vector<double>&, unsigned int, const vector<double>&, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.1) const; ROOT::Minuit2::ModularFunctionMinimizer&operator=(const ROOT::Minuit2::ModularFunctionMinimizer&); virtual const ROOT::Minuit2::MinimumSeedGenerator&SeedGenerator() const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~ModularFunctionMinimizer(); {}. FunctionMinimum Minimize(const FCNBase&, const std::vector<double>&, const std::vector<double>&, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1); inherited interface. FunctionMinimum Minimize(const FCNGradientBase&, const std::vector<double>&, const std::vector<double>&, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNBase&, const std::vector<double>&, unsigned int, const std::vector<double>&, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNGradientBase&, const std::vector<double>&, unsigned int, const std::vector<double>&, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNBase&, const MnUserParameters&, const MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1); extension. FunctionMinimum Minimize(const FCNGradientBase&, const MnUserParameters&, const MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNBase&, const MnUserParameters&, const MnUserCovariance&, const MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimu",MatchSource.WIKI,root/html530/ROOT__Minuit2__ModularFunctionMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__ModularFunctionMinimizer.html
Modifiability,inherit,inherited,"OT::Minuit2::MinimumSeed&, const ROOT::Minuit2::MnStrategy&, unsigned int, double) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNBase&, const vector<double>&, unsigned int, const vector<double>&, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNGradientBase&, const vector<double>&, unsigned int, const vector<double>&, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.1) const; ROOT::Minuit2::ModularFunctionMinimizer&operator=(const ROOT::Minuit2::ModularFunctionMinimizer&); virtual const ROOT::Minuit2::MinimumSeedGenerator&SeedGenerator() const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~ModularFunctionMinimizer(); {}. FunctionMinimum Minimize(const FCNBase&, const std::vector<double>&, const std::vector<double>&, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1); inherited interface. FunctionMinimum Minimize(const FCNGradientBase&, const std::vector<double>&, const std::vector<double>&, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNBase&, const std::vector<double>&, unsigned int, const std::vector<double>&, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNGradientBase&, const std::vector<double>&, unsigned int, const std::vector<double>&, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNBase&, const MnUserParameters&, const MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1); extension. FunctionMinimum Minimize(const FCNGradientBase&, const MnUserParameters&, const MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNBase&, const MnUserParameters&, const MnUserCovariance&, const MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimu",MatchSource.WIKI,root/html530/ROOT__Minuit2__ModularFunctionMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__ModularFunctionMinimizer.html
Availability,toler,toler,". ROOT::Minuit2::ScanMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::ScanMinimizer. class ROOT::Minuit2::ScanMinimizer: public ROOT::Minuit2::ModularFunctionMinimizer. Class implementing the required methods for a minimization using SCAN; API is provided in the upper ROOT::Minuit2::ModularFunctionMinimizer class. Function Members (Methods); public:. virtual~ScanMinimizer(); virtual const ROOT::Minuit2::MinimumBuilder&Builder() const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNBase&, const ROOT::Minuit2::MnUserParameterState&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameterState&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNBase&, const vector<double>&, const vector<double>&, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNGradientBase&, cons",MatchSource.WIKI,root/html530/ROOT__Minuit2__ScanMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__ScanMinimizer.html
Availability,toler,toler,". ROOT::Minuit2::SimplexMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::SimplexMinimizer. class ROOT::Minuit2::SimplexMinimizer: public ROOT::Minuit2::ModularFunctionMinimizer. Class implementing the required methods for a minimization using Simplex.; API is provided in the upper ROOT::Minuit2::ModularFunctionMinimizer class. Function Members (Methods); public:. virtual~SimplexMinimizer(); virtual const ROOT::Minuit2::MinimumBuilder&Builder() const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNBase&, const ROOT::Minuit2::MnUserParameterState&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameterState&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNBase&, const vector<double>&, const vector<double>&, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNGra",MatchSource.WIKI,root/html530/ROOT__Minuit2__SimplexMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__SimplexMinimizer.html
Availability,toler,toler,". ROOT::Minuit2::VariableMetricMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::VariableMetricMinimizer. class ROOT::Minuit2::VariableMetricMinimizer: public ROOT::Minuit2::ModularFunctionMinimizer. Instantiates the SeedGenerator and MinimumBuilder for; Variable Metric Minimization method.; API is provided in the upper ROOT::Minuit2::ModularFunctionMinimizer class. Function Members (Methods); public:. virtual~VariableMetricMinimizer(); virtual const ROOT::Minuit2::MinimumBuilder&Builder() const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNBase&, const ROOT::Minuit2::MnUserParameterState&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameterState&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionMinimizer::Minimize(const ROOT::Minuit2::FCNBase&, const vector<double>&, const vector<double>&, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumROOT::Minuit2::ModularFunctionM",MatchSource.WIKI,root/html530/ROOT__Minuit2__VariableMetricMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__Minuit2__VariableMetricMinimizer.html
Integrability,rout,routine,". ROOT::TBranchProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » ROOT::TBranchProxy. class ROOT::TBranchProxy. TBranchProxy. Base class for all the proxy object. It includes the imeplemtation; of the autoloading of branches as well as all the generic setup; routine. Function Members (Methods); public:. virtual~TBranchProxy(); TClass*GetClass(); virtual void*GetClaStart(UInt_t i = 0); TVirtualCollectionProxy*GetCollection(); Int_tGetOffset(); ROOT::TBranchProxy*GetProxy(); virtual void*GetStart(UInt_t = 0); virtual void*GetStlStart(UInt_t i = 0); void*GetWhere() const; Bool_tIsaPointer() const; Bool_tIsInitialized(); virtual voidPrint(); Bool_tRead(); Bool_tReadEntries(); voidReset(); Bool_tSetup(); ROOT::TBranchProxyTBranchProxy(); ROOT::TBranchProxyTBranchProxy(const ROOT::TBranchProxy&); ROOT::TBranchProxyTBranchProxy(ROOT::TBranchProxyDirector* boss, const char* top, const char* name = 0); ROOT::TBranchProxyTBranchProxy(ROOT::TBranchProxyDirector* boss, const char* top, const char* name, const char* membername); ROOT::TBranchProxyTBranchProxy(ROOT::TBranchProxyDirector* boss, ROOT::TBranchProxy* parent, const char* membername, const char* top = 0, const char* name = 0). Data Members; protected:. TBranch*fBranchbranch to read; TBranch*fBranchCounteventual auxiliary branch (for example holding the size); const TStringfBranchNamename of the branch to read; TClass*fClassclass name of the object pointed to by the branch; TStringfClassNameclass name of the object pointed to by the branch; TVirtualCollectionProxy*fCollectionHandle to the collection containing the data chunk.; const TStringfDataMembername of the (eventual) data member being proxied; ROOT::TBranchProxyDirector*fDirectorcontain pointer to TTree and entry to be read; TStreamerElement*fElement; Bool_tfInitialized; Bool",MatchSource.WIKI,root/html530/ROOT__TBranchProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__TBranchProxy.html
Performance,cache,cache,"sMembertrue if we proxy an unsplit data member; Bool_tfIsaPointertrue if we proxy a data member of pointer type; TTree*fLastTreeTTree containing the last entry read; Int_tfMemberOffset; Int_tfOffsetOffset inside the object; ROOT::TBranchProxy*fParentProxy to a parent object; Long64_tfReadLast entry read; void*fWherememory location of the data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchProxy(); Constructor. TBranchProxy(ROOT::TBranchProxyDirector* boss, const char* top, const char* name = 0); Constructor. TBranchProxy(ROOT::TBranchProxyDirector* boss, const char* top, const char* name, const char* membername); Constructor. TBranchProxy(ROOT::TBranchProxyDirector* boss, ROOT::TBranchProxy* parent, const char* membername, const char* top = 0, const char* name = 0); Constructor. ~TBranchProxy(); Typical Destructor. void Reset(); Completely reset the object. void Print(); Display the content of the object. Bool_t Setup(); Initialize/cache the necessary information. TBranchProxy(). TBranchProxy* GetProxy(); { return this; }. Bool_t IsInitialized(). Bool_t IsaPointer() const. Bool_t Read(). Bool_t ReadEntries(). TClass * GetClass(). void* GetWhere() const; { return fWhere; }. TVirtualCollectionProxy * GetCollection(); { return fCollection; }. void * GetStart(UInt_t = 0); protected:. void * GetClaStart(UInt_t i = 0); return the address of the start of the object being proxied. Assumes; that Setup() has been called. Assumes the object containing this data; member is held in TClonesArray. void * GetStlStart(UInt_t i = 0); return the address of the start of the object being proxied. Assumes; that Setup() has been called. Assumes the object containing this data; member is held in STL Collection. Int_t GetOffset(); { return fOffset; }. » Author: Philippe Canal 01/06/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id: TBranchProxy.h 36449 2010-10-28 20:52:17Z pcanal $",MatchSource.WIKI,root/html530/ROOT__TBranchProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__TBranchProxy.html
Availability,error,error,"escriptor(); voidTObject::AbstractMethod(const char* method) const; voidAddDescriptor(ROOT::TBranchProxyDescriptor* desc, Bool_t isBase); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetBranchName() const; TStringGetContainerName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TVirtualStreamerInfo*GetInfo() const; ROOT::TBranchProxyClassDescriptor::ELocationGetIsClones() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetRawSymbol() const; UInt_tGetSplitLevel() const; const char*GetSubBranchPrefix() cons",MatchSource.WIKI,root/html530/ROOT__TBranchProxyClassDescriptor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__TBranchProxyClassDescriptor.html
Integrability,rout,routine,". ROOT::TBranchProxyClassDescriptor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » ROOT::TBranchProxyClassDescriptor. class ROOT::TBranchProxyClassDescriptor: public TNamed. TBranchProxyClassDescriptor. Hold the processed information about a TClass used in a TBranch while; TTreeProxyGenerator is parsing the TTree information.; Also contains the routine use to generate the appropriate code; fragment in the result of MakeProxy. Function Members (Methods); public:. ~TBranchProxyClassDescriptor(); voidTObject::AbstractMethod(const char* method) const; voidAddDescriptor(ROOT::TBranchProxyDescriptor* desc, Bool_t isBase); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const ",MatchSource.WIKI,root/html530/ROOT__TBranchProxyClassDescriptor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__TBranchProxyClassDescriptor.html
Performance,load,loaded,"hProxyClassDescriptor::ELocation isclones, UInt_t splitlevel, const TString& containerName); Constructor. TBranchProxyClassDescriptor(const char* branchname); Constructor for a branch constructed from a leaf list. TBranchProxyClassDescriptor(const char* type, TVirtualStreamerInfo* info, const char* branchname, const char* branchPrefix, ROOT::TBranchProxyClassDescriptor::ELocation isclones, UInt_t splitlevel, const TString& containerName); Constructor. const char* GetBranchName() const; Get the branch name. const char* GetSubBranchPrefix() const; Get the prefix from the branch name. const char* GetRawSymbol() const; Get the real symbol name. UInt_t GetSplitLevel() const; Return the split level of the branch. Bool_t IsEquivalent(const ROOT::TBranchProxyClassDescriptor* other); Return true if this description is the 'same' as the other decription. void AddDescriptor(ROOT::TBranchProxyDescriptor* desc, Bool_t isBase); Add a descriptor to this proxy. Bool_t IsLoaded() const; Return true if the class needed by the branch is loaded. Bool_t IsLoaded(const char* ); Return true if the class needed by the branch is loaded. Bool_t IsClones() const; Return true if this proxy is for a TClonesArray. Bool_t IsSTL() const; Return true if this proxy is for a TClonesArray. TString GetContainerName() const; Return the name of the container holding this class, if any. void OutputDecl(FILE* hf, int offset, UInt_t ); Output the declaration and implementation of this emulation class. TBranchProxyClassDescriptor(const ROOT::TBranchProxyClassDescriptor& b); {;}. TBranchProxyClassDescriptor& operator=(const ROOT::TBranchProxyClassDescriptor& ); {return *this;}. TVirtualStreamerInfo * GetInfo() const; { return fInfo; }. ELocation GetIsClones() const. » Author: Philippe Canal 06/06/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id: TBranchProxyClassDescriptor.h 36449 2010-10-28 20:52:17Z pcanal $ » Last generated: 2011-07-04 15:20; This",MatchSource.WIKI,root/html530/ROOT__TBranchProxyClassDescriptor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__TBranchProxyClassDescriptor.html
Availability,error,error," ~TBranchProxyDescriptor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetBranchName(); co",MatchSource.WIKI,root/html530/ROOT__TBranchProxyDescriptor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__TBranchProxyDescriptor.html
Integrability,rout,routine,". ROOT::TBranchProxyDescriptor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » ROOT::TBranchProxyDescriptor. class ROOT::TBranchProxyDescriptor: public TNamed. TBranchProxyDescriptor. Hold the processed information about a TBranch while; TTreeProxyGenerator is parsing the TTree information.; Also contains the routine use to generate the appropriate code; fragment in the result of MakeProxy. Function Members (Methods); public:. ~TBranchProxyDescriptor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetBranchName(); co",MatchSource.WIKI,root/html530/ROOT__TBranchProxyDescriptor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__TBranchProxyDescriptor.html
Security,access,access,". ROOT::TBranchProxyDirector. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » ROOT::TBranchProxyDirector. class ROOT::TBranchProxyDirector. TBranchProxyDirector. This class is used to 'drive' and hold a serie of TBranchProxy objects; which represent and give access to the content of TTree object.; This is intended to be used as part of a generate Selector class; which will hold the directory and its associate. Function Members (Methods); public:. ~TBranchProxyDirector(); voidAttach(ROOT::TBranchProxy* p); voidAttach(ROOT::TFriendProxy* f); TH1F*CreateHistogram(const char* options); Long64_tGetReadEntry() const; TTree*GetTree() const; voidSetReadEntry(Long64_t entry); TTree*SetTree(TTree* newtree); ROOT::TBranchProxyDirectorTBranchProxyDirector(TTree* tree, Long64_t i); ROOT::TBranchProxyDirectorTBranchProxyDirector(TTree* tree, Int_t i). private:. ROOT::TBranchProxyDirector&operator=(const ROOT::TBranchProxyDirector&); ROOT::TBranchProxyDirectorTBranchProxyDirector(const ROOT::TBranchProxyDirector&). Data Members; private:. list<TBranchProxy*>fDirected; Long64_tfEntryEntry currently being read.; list<TFriendProxy*>fFriends; TTree*fTreeTTree we are currently looking at. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchProxyDirector(TTree* tree, Long64_t i); Simple constructor. TBranchProxyDirector(TTree* tree, Int_t i); cint has a problem casting int to long long; Simple constructor. void Attach(TBranchProxy* p). void Attach(TFriendProxy* p). TH1F* CreateHistogram(const char* options); Create a temporary 1D histogram. void SetReadEntry(Long64_t entry). TTree* SetTree(TTree* newtree). TBranchProxyDirector(const ROOT::TBranchProxyDirector& ); {;}. TBranchProxyDirector& operator=(const ROOT::TBranchProxyDirector& ); {return *this;}. Long",MatchSource.WIKI,root/html530/ROOT__TBranchProxyDirector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__TBranchProxyDirector.html
Performance,cache,cached,". ROOT::TFriendProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » ROOT::TFriendProxy. class ROOT::TFriendProxy. TFriendProxy. Concrete implementation of the proxy around a Friend Tree. Function Members (Methods); public:. ~TFriendProxy(); Long64_tGetReadEntry() const; voidResetReadEntry(); ROOT::TFriendProxyTFriendProxy(); ROOT::TFriendProxyTFriendProxy(ROOT::TBranchProxyDirector* director, TTree* main, Int_t index); voidUpdate(TTree* newmain). Data Members; protected:. ROOT::TBranchProxyDirectorfDirectorcontain pointer to TTree and entry to be read; Int_tfIndexIndex of this tree in the list of friends. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFriendProxy(). TFriendProxy(ROOT::TBranchProxyDirector* director, TTree* main, Int_t index); Constructor. Long64_t GetReadEntry() const; Return the entry number currently being looked at. void ResetReadEntry(); Refresh the cached read entry number from the original tree. void Update(TTree* newmain); Update the address of the underlying tree. » Author: Philippe Canal 01/06/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id: TFriendProxy.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/ROOT__TFriendProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__TFriendProxy.html
Availability,error,error," ~TFriendProxyDescriptor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject:",MatchSource.WIKI,root/html530/ROOT__TFriendProxyDescriptor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__TFriendProxyDescriptor.html
Integrability,rout,routine,". ROOT::TFriendProxyDescriptor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » ROOT::TFriendProxyDescriptor. class ROOT::TFriendProxyDescriptor: public TNamed. TFriendProxyDescriptor. Hold the processed information about a Friend TTree while; TTreeProxyGenerator is parsing the TTree information.; Also contains the routine use to generate the appropriate code; fragment in the result of MakeProxy. Function Members (Methods); public:. ~TFriendProxyDescriptor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject:",MatchSource.WIKI,root/html530/ROOT__TFriendProxyDescriptor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__TFriendProxyDescriptor.html
Availability,error,error,"lection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObjArray::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; virtual voidTObjArray::Compress(); Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObjArray::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObjArray::Expand(Int_t newSize); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObjArray::FindObject(const char* name) const; virtual TObject*TObjArray::FindObject(const TObject* obj) const; virtual TObject*TObjArray::First() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTObjArray::GetEntries() const; Int_tTObjArray::GetEntriesFast() const; virtual const char*TObject::GetIconName() const; virtual Int_tTObjArray::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**TObjArray::GetObjectRef(const TObject* obj) const;",MatchSource.WIKI,root/html530/ROOT__TSchemaMatch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__TSchemaMatch.html
Availability,error,error,"tMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidAsString(TString& out, const char* options = """") const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tConflicts(const ROOT::TSchemaRule* rule) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetAttributes() const; const char*GetCode() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEmbed() const; virtual const char*TObject::GetIconName() const; const TObjArray*GetInclude() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; ROOT::TSchemaRule::ReadFuncPtr_tGetReadFunctionPointer() const; ROOT::TSchemaRule::ReadRawFuncPtr_tGetReadRawFunctionPointer() const; ROOT::TSchemaRule::RuleType_tGetRuleType() const; const TO",MatchSource.WIKI,root/html530/ROOT__TSchemaRule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__TSchemaRule.html
Security,checksum,checksum,"ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); ROOT::TSchemaRule&operator=(const ROOT::TSchemaRule& rhs); Bool_toperator==(const ROOT::TSchemaRule& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSetAttributes(const TString& attributes); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); Bool_tSetChecksum(const TString& checksum); voidSetCode(const TString& code); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEmbed(Bool_t embed); Bool_tSetFromRule(const char* rule); voidSetInclude(const TString& include); static voidTObject::SetObjectStat(Bool_t stat); voidSetReadFunctionPointer(ROOT::TSchemaRule::ReadFuncPtr_t ptr); voidSetReadRawFunctionPointer(ROOT::TSchemaRule::ReadRawFuncPtr_t ptr); voidSetRuleType(ROOT::TSchemaRule::RuleType_t type); voidSetSource(const TString& source); voidSetSourceClass(const TString& classname); voidSetTarget(const TString& target); voidSetTargetClass(const TString& classname); virtual voidTObject::SetUniqueID(UInt_t uid); Bool_tSetVersion(const TString& version); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::Test",MatchSource.WIKI,root/html530/ROOT__TSchemaRule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__TSchemaRule.html
Usability,simpl,simple,"n); Set the version string - returns kFALSE if the format is incorrect. const char * GetVersion() const; Get the version string. Bool_t TestVersion(Int_t version) const; Check if given version number is defined in this rule. Bool_t SetChecksum(const TString& checksum); Set the checksum string - returns kFALSE if the format is incorrect. Bool_t TestChecksum(UInt_t checksum) const; Check if given checksum is defined in this rule. void SetSourceClass(const TString& classname); Set the source class of this rule (i.e. the onfile class). const char * GetSourceClass() const; Get the source class of this rule (i.e. the onfile class). void SetTargetClass(const TString& classname); Set the target class of this rule (i.e. the in memory class). const char * GetTargetClass() const; Get the targte class of this rule (i.e. the in memory class). void SetTarget(const TString& target); Set the target member of this rule (i.e. the in memory data member). const char * GetTargetString() const; Get the target data members of this rule as a simple string (i.e. the in memory data member). const TObjArray* GetTarget() const; Get the target data members of this rule (i.e. the in memory data member). void SetSource(const TString& source); Set the list of source members. This should be in the form of a declaration:; Int_t fOldMember; TNamed fName;. const TObjArray* GetSource() const; Get the list of source members as a TObjArray of TNamed object,; with the name being the member name and the title being its type. void SetInclude(const TString& include); Set the comma separated list of header files to include to be able; to compile this rule. const TObjArray* GetInclude() const; Return the list of header files to include to be able to; compile this rule as a TObjArray of TObjString. void SetEmbed(Bool_t embed); Set whether this rule should be save in the ROOT file (if true). Bool_t GetEmbed() const; Return true if this rule should be saved in the ROOT File. Bool_t IsValid() const; Return kTRUE i",MatchSource.WIKI,root/html530/ROOT__TSchemaRule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__TSchemaRule.html
Availability,error,error,"leSet* rules, ROOT::TSchemaRuleSet::EConsistencyCheck checkConsistency = kCheckAll, TString* errmsg = 0); virtual voidTObject::AppendPad(Option_t* option = """"); voidAsString(TString& out) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TObjArray*FindRules(const TString& source) const; const ROOT::TSchemaMatch*FindRules(const TString& source, Int_t version) const; const ROOT::TSchemaMatch*FindRules(const TString& source, UInt_t checksum) const; const ROOT::TSchemaMatch*FindRules(const TString& source, Int_t version, UInt_t checksum) const; TClass*GetClass(); UInt_tGetClassCheckSum() const; TStringGetClassName() const; Int_tGetClassVersion() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(",MatchSource.WIKI,root/html530/ROOT__TSchemaRuleSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__TSchemaRuleSet.html
Security,checksum,checksum,"on = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TObjArray*FindRules(const TString& source) const; const ROOT::TSchemaMatch*FindRules(const TString& source, Int_t version) const; const ROOT::TSchemaMatch*FindRules(const TString& source, UInt_t checksum) const; const ROOT::TSchemaMatch*FindRules(const TString& source, Int_t version, UInt_t checksum) const; TClass*GetClass(); UInt_tGetClassCheckSum() const; TStringGetClassName() const; Int_tGetClassVersion() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TObjArray*GetPersistentRules() const; const TObjArray*GetRules() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; Bool_tHasRuleWithSourceClass(const TString& source) const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const;",MatchSource.WIKI,root/html530/ROOT__TSchemaRuleSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__TSchemaRuleSet.html
Availability,error,error," ~TSources(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetDimensions(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); vi",MatchSource.WIKI,root/html530/ROOT__TSchemaRule__TSources.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/ROOT__TSchemaRule__TSources.html
Availability,error,error,". RooUnblindCPAsymVar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFIT; » RooUnblindCPAsymVar. class RooUnblindCPAsymVar: public RooAbsHiddenReal. Implementation of BlindTools' CP asymmetry blinding method; A RooUnblindCPAsymVar object is a real valued function; object, constructed from a blind value holder and a ; set of unblinding parameters. When supplied to a PDF; in lieu of a regular parameter, the blind value holder; supplied to the unblinder objects will in a fit be minimized ; to blind value corresponding to the actual minimum of the; parameter. The transformation is chosen such that the; the error on the blind parameters is indentical to that; of the unblind parameter; . Function Members (Methods); public:. RooUnblindCPAsymVar(); RooUnblindCPAsymVar(const RooUnblindCPAsymVar& other, const char* name = 0); RooUnblindCPAsymVar(const char* name, const char* title, const char* blindString, RooAbsReal& cpasym); RooUnblindCPAsymVar(const char* name, const char* title, const char* blindString, RooAbsReal& cpasym, RooAbsCategory& blindState); virtual~RooUnblindCPAsymVar(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voi",MatchSource.WIKI,root/html530/RooUnblindCPAsymVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUnblindCPAsymVar.html
Deployability,integrat,integration,s of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; static RooCategory*RooAbsHiddenReal::_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::,MatchSource.WIKI,root/html530/RooUnblindCPAsymVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUnblindCPAsymVar.html
Integrability,depend,dependentVars,"const char* rangeName = 0) const; virtual RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt)",MatchSource.WIKI,root/html530/RooUnblindCPAsymVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUnblindCPAsymVar.html
Modifiability,config,config,"bject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNum",MatchSource.WIKI,root/html530/RooUnblindCPAsymVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUnblindCPAsymVar.html
Performance,cache,cacheUniqueSuffix,"ol_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root/html530/RooUnblindCPAsymVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUnblindCPAsymVar.html
Security,validat,validate,,MatchSource.WIKI,root/html530/RooUnblindCPAsymVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUnblindCPAsymVar.html
Testability,test,testArg,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooUnblindCPAsymVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUnblindCPAsymVar.html
Usability,clear,clearEvalErrorLog,", const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none()",MatchSource.WIKI,root/html530/RooUnblindCPAsymVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUnblindCPAsymVar.html
Availability,error,error,". RooUnblindOffset. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFIT; » RooUnblindOffset. class RooUnblindOffset: public RooAbsHiddenReal. Implementation of BlindTools' offset blinding method; A RooUnblindOffset object is a real valued function; object, constructed from a blind value holder and a ; set of unblinding parameters. When supplied to a PDF; in lieu of a regular parameter, the blind value holder; supplied to the unblinder objects will in a fit be minimized ; to blind value corresponding to the actual minimum of the; parameter. The transformation is chosen such that the; the error on the blind parameters is indentical to that; of the unblind parameter; . Function Members (Methods); public:. RooUnblindOffset(); RooUnblindOffset(const RooUnblindOffset& other, const char* name = 0); RooUnblindOffset(const char* name, const char* title, const char* blindString, Double_t scale, RooAbsReal& blindValue); RooUnblindOffset(const char* name, const char* title, const char* blindString, Double_t scale, RooAbsReal& blindValue, RooAbsCategory& blindState); virtual~RooUnblindOffset(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual",MatchSource.WIKI,root/html530/RooUnblindOffset.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUnblindOffset.html
Deployability,integrat,integration,s of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; static RooCategory*RooAbsHiddenReal::_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::,MatchSource.WIKI,root/html530/RooUnblindOffset.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUnblindOffset.html
Integrability,depend,dependentVars,"const char* rangeName = 0) const; virtual RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt)",MatchSource.WIKI,root/html530/RooUnblindOffset.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUnblindOffset.html
Modifiability,config,config,"bject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNum",MatchSource.WIKI,root/html530/RooUnblindOffset.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUnblindOffset.html
Performance,cache,cacheUniqueSuffix,"ol_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root/html530/RooUnblindOffset.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUnblindOffset.html
Security,validat,validate,,MatchSource.WIKI,root/html530/RooUnblindOffset.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUnblindOffset.html
Testability,test,testArg,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooUnblindOffset.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUnblindOffset.html
Usability,clear,clearEvalErrorLog,", const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none()",MatchSource.WIKI,root/html530/RooUnblindOffset.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUnblindOffset.html
Availability,error,error,". RooUnblindPrecision. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFIT; » RooUnblindPrecision. class RooUnblindPrecision: public RooAbsHiddenReal. Implementation of BlindTools' precision blinding method; A RooUnblindPrecision object is a real valued function; object, constructed from a blind value holder and a ; set of unblinding parameters. When supplied to a PDF; in lieu of a regular parameter, the blind value holder; supplied to the unblinder objects will in a fit be minimized ; to blind value corresponding to the actual minimum of the; parameter. The transformation is chosen such that the; the error on the blind parameters is indentical to that; of the unblind parameter; . Function Members (Methods); public:. RooUnblindPrecision(); RooUnblindPrecision(const RooUnblindPrecision& other, const char* name = 0); RooUnblindPrecision(const char* name, const char* title, const char* blindString, Double_t centralValue, Double_t scale, RooAbsReal& blindValue, Bool_t sin2betaMode = kFALSE); RooUnblindPrecision(const char* name, const char* title, const char* blindString, Double_t centralValue, Double_t scale, RooAbsReal& blindValue, RooAbsCategory& blindState, Bool_t sin2betaMode = kFALSE); virtual~RooUnblindPrecision(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName =",MatchSource.WIKI,root/html530/RooUnblindPrecision.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUnblindPrecision.html
Deployability,integrat,integration,s of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; static RooCategory*RooAbsHiddenReal::_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::,MatchSource.WIKI,root/html530/RooUnblindPrecision.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUnblindPrecision.html
Integrability,depend,dependentVars,"const char* rangeName = 0) const; virtual RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt)",MatchSource.WIKI,root/html530/RooUnblindPrecision.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUnblindPrecision.html
Modifiability,config,config,"bject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNum",MatchSource.WIKI,root/html530/RooUnblindPrecision.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUnblindPrecision.html
Performance,cache,cacheUniqueSuffix,"ol_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root/html530/RooUnblindPrecision.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUnblindPrecision.html
Security,validat,validate,,MatchSource.WIKI,root/html530/RooUnblindPrecision.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUnblindPrecision.html
Testability,test,testArg,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooUnblindPrecision.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUnblindPrecision.html
Usability,clear,clearEvalErrorLog,", const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none()",MatchSource.WIKI,root/html530/RooUnblindPrecision.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUnblindPrecision.html
Availability,error,error,,MatchSource.WIKI,root/html530/RooUnblindUniform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUnblindUniform.html
Deployability,integrat,integration,s of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; static RooCategory*RooAbsHiddenReal::_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::,MatchSource.WIKI,root/html530/RooUnblindUniform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUnblindUniform.html
Integrability,depend,dependentVars,"const char* rangeName = 0) const; virtual RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt)",MatchSource.WIKI,root/html530/RooUnblindUniform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUnblindUniform.html
Modifiability,config,config,"bject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNum",MatchSource.WIKI,root/html530/RooUnblindUniform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUnblindUniform.html
Performance,cache,cacheUniqueSuffix,"ol_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root/html530/RooUnblindUniform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUnblindUniform.html
Security,validat,validate,,MatchSource.WIKI,root/html530/RooUnblindUniform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUnblindUniform.html
Testability,test,testArg,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooUnblindUniform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUnblindUniform.html
Usability,clear,clearEvalErrorLog,", const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none()",MatchSource.WIKI,root/html530/RooUnblindUniform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUnblindUniform.html
Availability,error,error,,MatchSource.WIKI,root/html530/RooUniform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUniform.html
Deployability,integrat,integration,<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; ,MatchSource.WIKI,root/html530/RooUniform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUniform.html
Integrability,depend,dependentVars,"), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); virtual RooAbsReal*RooAbsPdf::createNLL(RooAbsData& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsPdf::createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t",MatchSource.WIKI,root/html530/RooUniform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUniform.html
Modifiability,extend,extendedTerm,,MatchSource.WIKI,root/html530/RooUniform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUniform.html
Performance,cache,cacheUniqueSuffix,"erverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tanalyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAb",MatchSource.WIKI,root/html530/RooUniform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUniform.html
Security,validat,validate,,MatchSource.WIKI,root/html530/RooUniform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUniform.html
Testability,test,testArg,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooUniform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUniform.html
Usability,clear,clearEvalError,"g::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCm",MatchSource.WIKI,root/html530/RooUniform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUniform.html
Availability,error,error,"ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsBinning*clone(const char* name = 0) const; virtual TObject*RooAbsBinning::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual Double_thighBound() const; virtual RooAbsReal*RooAbsBinning::highBoundFunc() const;",MatchSource.WIKI,root/html530/RooUniformBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooUniformBinning.html
Availability,error,error,". RooVoigtian. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFIT; » RooVoigtian. class RooVoigtian: public RooAbsPdf. RooVoigtian is an efficient implementation of the convolution of a ; Breit-Wigner with a Gaussian, making use of the complex error function.; RooFitCore provides two algorithms for the evaluation of the complex error ; function (the default CERNlib C335 algorithm, and a faster, look-up-table ; based method). By default, RooVoigtian employs the default (CERNlib) ; algorithm. Select the faster algorithm either in the constructor, or with; the selectFastAlgorithm() method.; . Function Members (Methods); public:. RooVoigtian(); RooVoigtian(const RooVoigtian& other, const char* name = 0); RooVoigtian(const char* name, const char* title, RooAbsReal& _x, RooAbsReal& _mean, RooAbsReal& _width, RooAbsReal& _sigma, Bool_t doFast = kFALSE); virtual~RooVoigtian(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsD",MatchSource.WIKI,root/html530/RooVoigtian.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooVoigtian.html
Deployability,integrat,integration,<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; ,MatchSource.WIKI,root/html530/RooVoigtian.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooVoigtian.html
Energy Efficiency,efficient,efficient,". RooVoigtian. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFIT; » RooVoigtian. class RooVoigtian: public RooAbsPdf. RooVoigtian is an efficient implementation of the convolution of a ; Breit-Wigner with a Gaussian, making use of the complex error function.; RooFitCore provides two algorithms for the evaluation of the complex error ; function (the default CERNlib C335 algorithm, and a faster, look-up-table ; based method). By default, RooVoigtian employs the default (CERNlib) ; algorithm. Select the faster algorithm either in the constructor, or with; the selectFastAlgorithm() method.; . Function Members (Methods); public:. RooVoigtian(); RooVoigtian(const RooVoigtian& other, const char* name = 0); RooVoigtian(const char* name, const char* title, RooAbsReal& _x, RooAbsReal& _mean, RooAbsReal& _width, RooAbsReal& _sigma, Bool_t doFast = kFALSE); virtual~RooVoigtian(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsD",MatchSource.WIKI,root/html530/RooVoigtian.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooVoigtian.html
Integrability,depend,dependentVars,"), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); virtual RooAbsReal*RooAbsPdf::createNLL(RooAbsData& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsPdf::createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t",MatchSource.WIKI,root/html530/RooVoigtian.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooVoigtian.html
Modifiability,extend,extendedTerm,,MatchSource.WIKI,root/html530/RooVoigtian.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooVoigtian.html
Performance,cache,cacheUniqueSuffix,"ool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAb",MatchSource.WIKI,root/html530/RooVoigtian.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooVoigtian.html
Security,validat,validate,,MatchSource.WIKI,root/html530/RooVoigtian.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooVoigtian.html
Testability,test,testArg,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooVoigtian.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooVoigtian.html
Usability,clear,clearEvalError,"g::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCm",MatchSource.WIKI,root/html530/RooVoigtian.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooVoigtian.html
Availability,error,error,"al voidTNamed::Clear(Option_t* option = """"); voidclearStudies(); virtual TObject*TNamed::Clone(const char* newname = """") const; Bool_tcommitTransaction(); virtual Int_tTNamed::Compare(const TObject* obj) const; TIterator*componentIterator() const; const RooArgSet&components() const; virtual voidTNamed::Copy(TObject& named) const; RooAbsData*data(const char* name) const; Bool_tdefineSet(const char* name, const char* contentList); Bool_tdefineSet(const char* name, const RooArgSet& aset, Bool_t importMissing = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&expensiveObjectCache(); voidexportToCint(const char* namespaceName = 0); Bool_textendSet(const char* name, const char* newContents); RooFactoryWSTool&factory(); RooAbsArg*factory(const char* expr); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsReal*function(const char* name) const; RooAbsArg*fundArg(const char* name) const; TObject*genobj(const char* name) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; st",MatchSource.WIKI,root/html530/RooWorkspace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooWorkspace.html
Integrability,message,message,"Bool_t import(const RooArgSet& args, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg()); Import multiple RooAbsArg objects into workspace. For details on arguments see documentation; of import() method for single RooAbsArg. Bool_t import(const RooAbsArg& arg, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg()); Import a RooAbsArg object, e.g. function, p.d.f or variable into the workspace. This import function clones the input argument and will; own the clone. If a composite object is offered for import, e.g. a p.d.f with parameters and observables, the; complete tree of objects is imported. If any of the _variables_ of a composite object (parameters/observables) are already; in the workspace the imported p.d.f. is connected to the already existing variables. If any of the _function_ objects (p.d.f, formulas); to be imported already exists in the workspace an error message is printed and the import of the entire tree of objects is cancelled.; Several optional arguments can be provided to modify the import procedure. Accepted arguments. RenameConflictNodes(const char* suffix) -- Add suffix to branch node name if name conflicts with existing node in workspace; RenameAllNodes(const char* suffix) -- Add suffix to all branch node names including top level node; RenameAllVariables(const char* suffix) -- Add suffix to all variables names; RenameAllVariablesExcept(const char* suffix, const char* exceptionList) -- Add suffix to all variables names, except ones listed; RenameVariable(const char* inputName, const char* outputName) -- Rename variable as specified upon import.; RecycleConflictNodes() -- If any of the function objects to be imported already exist in the name space, connect the; imported expression to the already existing nodes. WARNING: use with care! If function definitions; do not match, this alters the definition of your function upon import; S",MatchSource.WIKI,root/html530/RooWorkspace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooWorkspace.html
Modifiability,variab,variables,". RooWorkspace. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooWorkspace. class RooWorkspace: public TNamed. The RooWorkspace is a persistable container for RooFit projects. A workspace; can contain and own variables, p.d.f.s, functions and datasets. All objects; that live in the workspace are owned by the workspace. The import() method; enforces consistency of objects upon insertion into the workspace (e.g. no; duplicate object with the same name are allowed) and makes sure all objects; in the workspace are connected to each other. Easy accessor methods like; pdf(), var() and data() allow to refer to the contents of the workspace by; object name. The entire RooWorkspace can be saved into a ROOT TFile and organises; the consistent streaming of its contents without duplication.; ; If a RooWorkspace contains custom classes, i.e. classes not in the ; ROOT distribution, portability of workspaces can be enhanced by; storing the source code of those classes in the workspace as well.; This process is also organized by the workspace through the; importClassCode() method.; . Function Members (Methods); public:. RooWorkspace(); RooWorkspace(const RooWorkspace& other); RooWorkspace(const char* name, Bool_t doCINTExport); RooWorkspace(const char* name, const char* title = 0); virtual~RooWorkspace(); voidTObject::AbstractMethod(const char* method) const; static voidaddClassDeclImportDir(const char* dir); static voidaddClassImplImportDir(const char* dir); Bool_taddStudy(RooAbsStudy& study); RooArgSetallCatFunctions() const; RooArgSetallCats() const; list<RooAbsData*>allData() const; RooArgSetallFunctions() const; list<TObject*>allGenericObjects() const; RooArgSetallPdfs() const; RooArgSetallResolutionModels() const; RooArgSetallVars() const; virtual voidTObject::AppendPad(Option_t* option ",MatchSource.WIKI,root/html530/RooWorkspace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooWorkspace.html
Performance,load,loadSnapshot,"of all classes in the workspace that have a class name; that matches pattern 'pat' and which are not found to be part of; the standard ROOT distribution. If doReplace is true any existing; class code saved in the workspace is replaced. Bool_t saveSnapshot(const char* name, const char* paramNames); Save snapshot of values and attributes (including ""Constant"") of parameters 'params'; If importValues is FALSE, the present values from the object in the workspace are; saved. If importValues is TRUE, the values of the objects passed in the 'params'; argument are saved. Bool_t saveSnapshot(const char* name, const RooArgSet& params, Bool_t importValues = kFALSE); Save snapshot of values and attributes (including ""Constant"") of parameters 'params'; If importValues is FALSE, the present values from the object in the workspace are; saved. If importValues is TRUE, the values of the objects passed in the 'params'; argument are saved. Bool_t loadSnapshot(const char* name); Load the values and attributes of the parameters in the snapshot saved with; the given name. RooAbsPdf* pdf(const char* name) const; Retrieve p.d.f (RooAbsPdf) with given name. A null pointer is returned if not found. RooAbsReal* function(const char* name) const; Retrieve function (RooAbsReal) with given name. Note that all RooAbsPdfs are also RooAbsReals. A null pointer is returned if not found. RooRealVar* var(const char* name) const; Retrieve real-valued variable (RooRealVar) with given name. A null pointer is returned if not found. RooCategory* cat(const char* name) const; Retrieve discrete variable (RooCategory) with given name. A null pointer is returned if not found. RooAbsCategory* catfunc(const char* name) const; Retrieve discrete function (RooAbsCategory) with given name. A null pointer is returned if not found. RooAbsArg* arg(const char* name) const; Return RooAbsArg with given name. A null pointer is returned if none is found. RooArgSet argSet(const char* nameList) const; Return set of RooAbsArgs ma",MatchSource.WIKI,root/html530/RooWorkspace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooWorkspace.html
Security,access,accessor,". RooWorkspace. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooWorkspace. class RooWorkspace: public TNamed. The RooWorkspace is a persistable container for RooFit projects. A workspace; can contain and own variables, p.d.f.s, functions and datasets. All objects; that live in the workspace are owned by the workspace. The import() method; enforces consistency of objects upon insertion into the workspace (e.g. no; duplicate object with the same name are allowed) and makes sure all objects; in the workspace are connected to each other. Easy accessor methods like; pdf(), var() and data() allow to refer to the contents of the workspace by; object name. The entire RooWorkspace can be saved into a ROOT TFile and organises; the consistent streaming of its contents without duplication.; ; If a RooWorkspace contains custom classes, i.e. classes not in the ; ROOT distribution, portability of workspaces can be enhanced by; storing the source code of those classes in the workspace as well.; This process is also organized by the workspace through the; importClassCode() method.; . Function Members (Methods); public:. RooWorkspace(); RooWorkspace(const RooWorkspace& other); RooWorkspace(const char* name, Bool_t doCINTExport); RooWorkspace(const char* name, const char* title = 0); virtual~RooWorkspace(); voidTObject::AbstractMethod(const char* method) const; static voidaddClassDeclImportDir(const char* dir); static voidaddClassImplImportDir(const char* dir); Bool_taddStudy(RooAbsStudy& study); RooArgSetallCatFunctions() const; RooArgSetallCats() const; list<RooAbsData*>allData() const; RooArgSetallFunctions() const; list<TObject*>allGenericObjects() const; RooArgSetallPdfs() const; RooArgSetallResolutionModels() const; RooArgSetallVars() const; virtual voidTObject::AppendPad(Option_t* option ",MatchSource.WIKI,root/html530/RooWorkspace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooWorkspace.html
Usability,clear,clearStudies,"Bool_t replaceExisting = kFALSE); Import a clone of a generic TObject into workspace generic object container. Imported; object can be retrieved by name through the obj() method. The object is cloned upon; importation and the input argument does not need to live beyond the import call. Returns kTRUE if an error has occurred. Bool_t import(TObject& object, const char* aliasName, Bool_t replaceExisting = kFALSE); Import a clone of a generic TObject into workspace generic object container.; The imported object will be stored under the given alias name rather than its; own name. Imported object can be retrieved its alias name through the obj() method.; The object is cloned upon importation and the input argument does not need to live beyond the import call; This method is mostly useful for importing objects that do not have a settable name such as TMatrix. Returns kTRUE if an error has occurred. Bool_t addStudy(RooAbsStudy& study); Insert RooStudyManager module. void clearStudies(); Remove all RooStudyManager modules. TObject* obj(const char* name) const; Return any type of object (RooAbsArg, RooAbsData or generic object) with given name). TObject* genobj(const char* name) const; Return generic object with given name. Bool_t cd(const char* path = 0). Bool_t writeToFile(const char* fileName, Bool_t recreate = kTRUE); Save this current workspace into given file. RooFactoryWSTool& factory(); Return instance to factory tool. RooAbsArg* factory(const char* expr); Short-hand function for factory()->process(expr) ;. void Print(Option_t* opts = 0) const; Print contents of the workspace. void Streamer(TBuffer& b); Stream an object of class RooWorkspace. This is a standard ROOT streamer for the; I/O part. This custom function exists to detach all external client links; from the payload prior to writing the payload so that these client links; are not persisted. (Client links occur if external function objects use; objects contained in the workspace as input); After the actual writi",MatchSource.WIKI,root/html530/RooWorkspace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooWorkspace.html
Availability,error,error,"_t doReplace = kFALSE); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; RooWorkspace::CodeRepoCodeRepo(RooWorkspace* wspace = 0); RooWorkspace::CodeRepoCodeRepo(const RooWorkspace::CodeRepo&); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tcompileClasses(); Bool_tcompiledOK() const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html530/RooWorkspace__CodeRepo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooWorkspace__CodeRepo.html
Deployability,update,update,"unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. map<TString,ClassRelInfo>_c2fmapList of contained classes; Bool_t_compiledOK! Flag indicating that classes compiled OK; map<TString,ClassFiles>_fmapList of contained files; RooWorkspace*_wspaceowning workspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t autoImportClass(TClass* tc, Bool_t doReplace = kFALSE); Import code of class 'tc' into the repository. If code is already in repository it is only imported; again if doReplace is false. The names and location of the source files is determined from the information; in TClass. If no location is found in the TClass information, the files are searched in the workspace; search path, defined by addClassDeclImportDir() and addClassImplImportDir() for declaration and implementation; files respectively. If files cannot be found, abort with error status, otherwise update the internal; class-to-file map and import the contents of the files, if they are not imported yet. void Streamer(TBuffer& b); Custom streamer for the workspace. Stream contents of workspace; and code repository. When reading, read code repository first; and compile missing classes before proceeding with streaming; of workspace contents to avoid errors. std::string listOfClassNames() const; Return STL string with last of class names contained in the code repository. Bool_t compileClasses(); For all classes in the workspace for which no class definition is; found in the ROOT class table extract source code stored in code; repository into temporary directory set by; setClassFileExportDir(), compile classes and link them with; current ROOT session. If a compilation error occurs print; instructions for user how to fix errors and recover workspace and; abort import procedure. CodeRepo(RooWorkspace* wspace = 0); {}. virtual ~CodeRepo(); {}. Bool_t compiledOK() const; { return _compiledOK ; }. » Last change",MatchSource.WIKI,root/html530/RooWorkspace__CodeRepo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooWorkspace__CodeRepo.html
Modifiability,variab,variables,". RooWorkspace::CodeRepo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooWorkspace::CodeRepo. class RooWorkspace::CodeRepo: public TObject. The RooWorkspace is a persistable container for RooFit projects. A workspace; can contain and own variables, p.d.f.s, functions and datasets. All objects; that live in the workspace are owned by the workspace. The import() method; enforces consistency of objects upon insertion into the workspace (e.g. no; duplicate object with the same name are allowed) and makes sure all objects; in the workspace are connected to each other. Easy accessor methods like; pdf(), var() and data() allow to refer to the contents of the workspace by; object name. The entire RooWorkspace can be saved into a ROOT TFile and organises; the consistent streaming of its contents without duplication.; ; If a RooWorkspace contains custom classes, i.e. classes not in the ; ROOT distribution, portability of workspaces can be enhanced by; storing the source code of those classes in the workspace as well.; This process is also organized by the workspace through the; importClassCode() method.; . Function Members (Methods); public:. virtual~CodeRepo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tautoImportClass(TClass* tc, Bool_t doReplace = kFALSE); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; RooWorkspace::CodeRepoCodeRepo(RooWorkspace* wspace = 0); RooWorkspace::CodeRepoCodeRepo(const RooWorkspace::CodeRepo&); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tcompileClasses(); Bool_tcompiledOK() const; virtual voidTOb",MatchSource.WIKI,root/html530/RooWorkspace__CodeRepo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooWorkspace__CodeRepo.html
Safety,abort,abort,"unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. map<TString,ClassRelInfo>_c2fmapList of contained classes; Bool_t_compiledOK! Flag indicating that classes compiled OK; map<TString,ClassFiles>_fmapList of contained files; RooWorkspace*_wspaceowning workspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t autoImportClass(TClass* tc, Bool_t doReplace = kFALSE); Import code of class 'tc' into the repository. If code is already in repository it is only imported; again if doReplace is false. The names and location of the source files is determined from the information; in TClass. If no location is found in the TClass information, the files are searched in the workspace; search path, defined by addClassDeclImportDir() and addClassImplImportDir() for declaration and implementation; files respectively. If files cannot be found, abort with error status, otherwise update the internal; class-to-file map and import the contents of the files, if they are not imported yet. void Streamer(TBuffer& b); Custom streamer for the workspace. Stream contents of workspace; and code repository. When reading, read code repository first; and compile missing classes before proceeding with streaming; of workspace contents to avoid errors. std::string listOfClassNames() const; Return STL string with last of class names contained in the code repository. Bool_t compileClasses(); For all classes in the workspace for which no class definition is; found in the ROOT class table extract source code stored in code; repository into temporary directory set by; setClassFileExportDir(), compile classes and link them with; current ROOT session. If a compilation error occurs print; instructions for user how to fix errors and recover workspace and; abort import procedure. CodeRepo(RooWorkspace* wspace = 0); {}. virtual ~CodeRepo(); {}. Bool_t compiledOK() const; { return _compiledOK ; }. » Last change",MatchSource.WIKI,root/html530/RooWorkspace__CodeRepo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooWorkspace__CodeRepo.html
Security,access,accessor,". RooWorkspace::CodeRepo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooWorkspace::CodeRepo. class RooWorkspace::CodeRepo: public TObject. The RooWorkspace is a persistable container for RooFit projects. A workspace; can contain and own variables, p.d.f.s, functions and datasets. All objects; that live in the workspace are owned by the workspace. The import() method; enforces consistency of objects upon insertion into the workspace (e.g. no; duplicate object with the same name are allowed) and makes sure all objects; in the workspace are connected to each other. Easy accessor methods like; pdf(), var() and data() allow to refer to the contents of the workspace by; object name. The entire RooWorkspace can be saved into a ROOT TFile and organises; the consistent streaming of its contents without duplication.; ; If a RooWorkspace contains custom classes, i.e. classes not in the ; ROOT distribution, portability of workspaces can be enhanced by; storing the source code of those classes in the workspace as well.; This process is also organized by the workspace through the; importClassCode() method.; . Function Members (Methods); public:. virtual~CodeRepo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tautoImportClass(TClass* tc, Bool_t doReplace = kFALSE); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; RooWorkspace::CodeRepoCodeRepo(RooWorkspace* wspace = 0); RooWorkspace::CodeRepoCodeRepo(const RooWorkspace::CodeRepo&); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tcompileClasses(); Bool_tcompiledOK() const; virtual voidTOb",MatchSource.WIKI,root/html530/RooWorkspace__CodeRepo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooWorkspace__CodeRepo.html
Availability,error,error,"* newname = """") const; virtual TObject*TDirectoryFile::CloneObject(const TObject* obj, Bool_t autoadd = kTRUE); virtual voidTDirectoryFile::Close(Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTDirectoryFile::Copy(TObject&) const; static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle); virtual voidTDirectoryFile::Delete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTDirectory::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTDirectoryFile::FillBuffer(char*& buffer); virtual TKey*TDirectoryFile::FindKey(const char* keyname) const; virtual TKey*TDirectoryFile::FindKeyAny(const char* keyname) const; virtual TObject*TDirectory::FindObject(const char* name) const; virtual TObject*TDirectory::FindObject(const TObject* obj) const; virtual TObject*TDirectoryFile::FindObjectAny(const char* name) const; virtual TObject*TDirectoryFile::FindObjectAnyFile(const char* name) const; virtual TObject*TDirectoryFile::Get(const char* namecycle); virtual Int_tTDirectoryFile::GetBufferSize() const; const TDatime&TDirectoryFile::GetCreationDate() const; virtual TDirectory*TDirectoryFile::GetDirectory(const char* apath, Bool_t printError = false, const char* funcname = ""GetDirectory""); ",MatchSource.WIKI,root/html530/RooWorkspace__WSDir.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooWorkspace__WSDir.html
Integrability,interface,interface,"TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of objects in memory; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; TStringTNamed::fNameobject identifier; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Bool_tTDirectoryFile::fWritabletrue if directory is writable; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void InternalAppend(TObject* obj); Internal access to TDirectory append method. void Add(TObject* obj); Overload TDirectory interface method to prohibit insertion of objects in read-only directory workspace representation. void Append(TObject* obj); Overload TDirectory interface method to prohibit insertion of objects in read-only directory workspace representation. WSDir(const char* name, const char* title, RooWorkspace* wspace). virtual ~WSDir(); { Clear(""nodelete"") ; }. » Last changed: Mon Jul 4 15:24:51 2011 » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooWorkspace__WSDir.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooWorkspace__WSDir.html
Modifiability,variab,variables,". RooWorkspace::WSDir. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooWorkspace::WSDir. class RooWorkspace::WSDir: public TDirectoryFile. The RooWorkspace is a persistable container for RooFit projects. A workspace; can contain and own variables, p.d.f.s, functions and datasets. All objects; that live in the workspace are owned by the workspace. The import() method; enforces consistency of objects upon insertion into the workspace (e.g. no; duplicate object with the same name are allowed) and makes sure all objects; in the workspace are connected to each other. Easy accessor methods like; pdf(), var() and data() allow to refer to the contents of the workspace by; object name. The entire RooWorkspace can be saved into a ROOT TFile and organises; the consistent streaming of its contents without duplication.; ; If a RooWorkspace contains custom classes, i.e. classes not in the ; ROOT distribution, portability of workspaces can be enhanced by; storing the source code of those classes in the workspace as well.; This process is also organized by the workspace through the; importClassCode() method.; . Function Members (Methods); public:. virtual~WSDir(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject*, Bool_t); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidAppend(TObject*, Bool_t); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTDirectoryFile::Browse(TBrowser* b); virtual voidTDirectoryFile::Build(TFile* motherFile = 0, TDirectory* motherDir = 0); virtual Bool_tTDirectoryFile::cd(const char* path = 0); static Bool_tTDirectory::Cd(const char* path); static TClass*Class(); virtual const char*TObject::ClassName() co",MatchSource.WIKI,root/html530/RooWorkspace__WSDir.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooWorkspace__WSDir.html
Security,access,accessor,". RooWorkspace::WSDir. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooWorkspace::WSDir. class RooWorkspace::WSDir: public TDirectoryFile. The RooWorkspace is a persistable container for RooFit projects. A workspace; can contain and own variables, p.d.f.s, functions and datasets. All objects; that live in the workspace are owned by the workspace. The import() method; enforces consistency of objects upon insertion into the workspace (e.g. no; duplicate object with the same name are allowed) and makes sure all objects; in the workspace are connected to each other. Easy accessor methods like; pdf(), var() and data() allow to refer to the contents of the workspace by; object name. The entire RooWorkspace can be saved into a ROOT TFile and organises; the consistent streaming of its contents without duplication.; ; If a RooWorkspace contains custom classes, i.e. classes not in the ; ROOT distribution, portability of workspaces can be enhanced by; storing the source code of those classes in the workspace as well.; This process is also organized by the workspace through the; importClassCode() method.; . Function Members (Methods); public:. virtual~WSDir(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject*, Bool_t); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidAppend(TObject*, Bool_t); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTDirectoryFile::Browse(TBrowser* b); virtual voidTDirectoryFile::Build(TFile* motherFile = 0, TDirectory* motherDir = 0); virtual Bool_tTDirectoryFile::cd(const char* path = 0); static Bool_tTDirectory::Cd(const char* path); static TClass*Class(); virtual const char*TObject::ClassName() co",MatchSource.WIKI,root/html530/RooWorkspace__WSDir.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooWorkspace__WSDir.html
Availability,error,errors,". RooXYChi2Var. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooXYChi2Var. class RooXYChi2Var: public RooAbsOptTestStatistic. Class RooXYChi2Var implements a simple chi^2 calculation from a unbinned; dataset with values x,y with errors on y (and optionally on x) and a function.; The function can be either a RooAbsReal, or an extended RooAbsPdf where; the function value is calculated as the probability density times the; expected number of events; The chi^2 is calculated as. / (Data[y]-) - func \+2; Sum[point] | ------------------ |; \ Data[ErrY]. Function Members (Methods); public:. RooXYChi2Var(); RooXYChi2Var(const RooXYChi2Var& other, const char* name = 0); RooXYChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataSet& data, Bool_t integrate = kFALSE); RooXYChi2Var(const char* name, const char* title, RooAbsPdf& extPdf, RooDataSet& data, Bool_t integrate = kFALSE); RooXYChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataSet& data, RooRealVar& yvar, Bool_t integrate = kFALSE); RooXYChi2Var(const char* name, const char* title, RooAbsPdf& extPdf, RooDataSet& data, RooRealVar& yvar, Bool_t integrate = kFALSE); virtual~RooXYChi2Var(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal",MatchSource.WIKI,root/html530/RooXYChi2Var.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooXYChi2Var.html
Deployability,integrat,integrate," RooXYChi2Var(); RooXYChi2Var(const RooXYChi2Var& other, const char* name = 0); RooXYChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataSet& data, Bool_t integrate = kFALSE); RooXYChi2Var(const char* name, const char* title, RooAbsPdf& extPdf, RooDataSet& data, Bool_t integrate = kFALSE); RooXYChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataSet& data, RooRealVar& yvar, Bool_t integrate = kFALSE); RooXYChi2Var(const char* name, const char* title, RooAbsPdf& extPdf, RooDataSet& data, RooRealVar& yvar, Bool_t integrate = kFALSE); virtual~RooXYChi2Var(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal",MatchSource.WIKI,root/html530/RooXYChi2Var.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooXYChi2Var.html
Integrability,integrat,integrate," RooXYChi2Var(); RooXYChi2Var(const RooXYChi2Var& other, const char* name = 0); RooXYChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataSet& data, Bool_t integrate = kFALSE); RooXYChi2Var(const char* name, const char* title, RooAbsPdf& extPdf, RooDataSet& data, Bool_t integrate = kFALSE); RooXYChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataSet& data, RooRealVar& yvar, Bool_t integrate = kFALSE); RooXYChi2Var(const char* name, const char* title, RooAbsPdf& extPdf, RooDataSet& data, RooRealVar& yvar, Bool_t integrate = kFALSE); virtual~RooXYChi2Var(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal",MatchSource.WIKI,root/html530/RooXYChi2Var.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooXYChi2Var.html
Modifiability,extend,extended,". RooXYChi2Var. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooXYChi2Var. class RooXYChi2Var: public RooAbsOptTestStatistic. Class RooXYChi2Var implements a simple chi^2 calculation from a unbinned; dataset with values x,y with errors on y (and optionally on x) and a function.; The function can be either a RooAbsReal, or an extended RooAbsPdf where; the function value is calculated as the probability density times the; expected number of events; The chi^2 is calculated as. / (Data[y]-) - func \+2; Sum[point] | ------------------ |; \ Data[ErrY]. Function Members (Methods); public:. RooXYChi2Var(); RooXYChi2Var(const RooXYChi2Var& other, const char* name = 0); RooXYChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataSet& data, Bool_t integrate = kFALSE); RooXYChi2Var(const char* name, const char* title, RooAbsPdf& extPdf, RooDataSet& data, Bool_t integrate = kFALSE); RooXYChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataSet& data, RooRealVar& yvar, Bool_t integrate = kFALSE); RooXYChi2Var(const char* name, const char* title, RooAbsPdf& extPdf, RooDataSet& data, RooRealVar& yvar, Bool_t integrate = kFALSE); virtual~RooXYChi2Var(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal",MatchSource.WIKI,root/html530/RooXYChi2Var.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooXYChi2Var.html
Performance,cache,cacheUniqueSuffix,"const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; RooNumIntConfig&binIntegratorConfig(); const RooNumIntConfig&binIntegratorConfig() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsOptTestStatistic::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root/html530/RooXYChi2Var.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooXYChi2Var.html
Security,validat,validate,"[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. stringRooAbsTestStatistic::_addCoefRangeNameName of reference to be used for RooAddPdf components; list<RooAbsBinning*>_binList! Bin ranges; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*RooAbsOptTestStatistic::_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_t_extendedIs the input function and extended p.d.f.; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer",MatchSource.WIKI,root/html530/RooXYChi2Var.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooXYChi2Var.html
Testability,test,testArg,"ojectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsData&RooAbsOptTestStatistic::data(); const RooAbsData&RooAbsOptTestStatistic::data() const; virtual Double_tdefaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooXYChi2Var.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooXYChi2Var.html
Usability,simpl,simple,". RooXYChi2Var. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooXYChi2Var. class RooXYChi2Var: public RooAbsOptTestStatistic. Class RooXYChi2Var implements a simple chi^2 calculation from a unbinned; dataset with values x,y with errors on y (and optionally on x) and a function.; The function can be either a RooAbsReal, or an extended RooAbsPdf where; the function value is calculated as the probability density times the; expected number of events; The chi^2 is calculated as. / (Data[y]-) - func \+2; Sum[point] | ------------------ |; \ Data[ErrY]. Function Members (Methods); public:. RooXYChi2Var(); RooXYChi2Var(const RooXYChi2Var& other, const char* name = 0); RooXYChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataSet& data, Bool_t integrate = kFALSE); RooXYChi2Var(const char* name, const char* title, RooAbsPdf& extPdf, RooDataSet& data, Bool_t integrate = kFALSE); RooXYChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataSet& data, RooRealVar& yvar, Bool_t integrate = kFALSE); RooXYChi2Var(const char* name, const char* title, RooAbsPdf& extPdf, RooDataSet& data, RooRealVar& yvar, Bool_t integrate = kFALSE); virtual~RooXYChi2Var(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal",MatchSource.WIKI,root/html530/RooXYChi2Var.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooXYChi2Var.html
Availability,mask,mask,". SetWindowAttributes_t. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » SetWindowAttributes_t. class SetWindowAttributes_t. GuiTypes. Types used by the GUI classes. Function Members (Methods); public:. SetWindowAttributes_t(); SetWindowAttributes_t(const SetWindowAttributes_t&); ~SetWindowAttributes_t(); SetWindowAttributes_t&operator=(const SetWindowAttributes_t&). Data Members; public:. ULong_tfBackgroundPixelbackground pixel; Pixmap_tfBackgroundPixmapbackground or kNone or kParentRelative; ULong_tfBackingPixelvalue to use in restoring planes; ULong_tfBackingPlanesplanes to be preseved if possible; Int_tfBackingStorekNotUseful, kWhenMapped, kAlways; Int_tfBitGravityone of bit gravity values; ULong_tfBorderPixelborder pixel value; Pixmap_tfBorderPixmapborder of the window; UInt_tfBorderWidthborder width in pixels; Colormap_tfColormapcolor map to be associated with window; Cursor_tfCursorcursor to be displayed (or kNone); Long_tfDoNotPropagateMaskset of events that should not propagate; Long_tfEventMaskset of events that should be saved; Mask_tfMaskbit mask specifying which fields are valid; Bool_tfOverrideRedirectboolean value for override-redirect; Bool_tfSaveUndershould bits under be saved (popups)?; Int_tfWinGravityone of the window gravity values. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Last changed: Mon Jul 4 15:24:52 2011 » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/SetWindowAttributes_t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/SetWindowAttributes_t.html
Integrability,interface,interface,". SysInfo_t. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » SysInfo_t. class SysInfo_t. TSystem. Abstract base class defining a generic interface to the underlying; Operating System. Function Members (Methods); public:. SysInfo_t(); SysInfo_t(const SysInfo_t&); virtual~SysInfo_t(); static TClass*Class(); virtual TClass*IsA() const; SysInfo_t&operator=(const SysInfo_t&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. Int_tfBusSpeedbus speed in MHz; Int_tfCpuSpeedcpu speed in MHz; TStringfCpuTypetype of cpu; Int_tfCpusnumber of cpus; Int_tfL2Cachelevel 2 cache size in KB; TStringfModelcomputer model; TStringfOSOS; Int_tfPhysRamphysical RAM in MB. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SysInfo_t(); { }. virtual ~SysInfo_t(); { }. TSystem& operator=(const SysInfo_t& ). » Author: Fons Rademakers 15/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TSystem.h 37109 2010-11-30 16:30:58Z pcanal $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/SysInfo_t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/SysInfo_t.html
Performance,cache,cache,". SysInfo_t. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » SysInfo_t. class SysInfo_t. TSystem. Abstract base class defining a generic interface to the underlying; Operating System. Function Members (Methods); public:. SysInfo_t(); SysInfo_t(const SysInfo_t&); virtual~SysInfo_t(); static TClass*Class(); virtual TClass*IsA() const; SysInfo_t&operator=(const SysInfo_t&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. Int_tfBusSpeedbus speed in MHz; Int_tfCpuSpeedcpu speed in MHz; TStringfCpuTypetype of cpu; Int_tfCpusnumber of cpus; Int_tfL2Cachelevel 2 cache size in KB; TStringfModelcomputer model; TStringfOSOS; Int_tfPhysRamphysical RAM in MB. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SysInfo_t(); { }. virtual ~SysInfo_t(); { }. TSystem& operator=(const SysInfo_t& ). » Author: Fons Rademakers 15/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TSystem.h 37109 2010-11-30 16:30:58Z pcanal $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/SysInfo_t.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/SysInfo_t.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html530/TAdvancedGraphicsDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAdvancedGraphicsDialog.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TApplicationImp*GetApplicationImp(); static TList*GetApplications(); TApplication*GetAppRemote() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const char*GetIdleCommand() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virt",MatchSource.WIKI,root/html530/TApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TApplication.html
Energy Efficiency,monitor,monitoring,"system. void InitializeGraphics(); Initialize the graphics environment. void ClearInputFiles(); Clear list containing macro files passed as program arguments.; This method is called from TRint::Run() to ensure that the macro; files are only executed the first time Run() is called. char * Argv(Int_t index) const; Return specified argument. void GetOptions(Int_t* argc, char** argv); Get and handle command line options. Arguments handled are removed; from the argument array. The following arguments are handled:; -b : run in batch mode without graphics; -x : exit on exception; -n : do not execute logon and logoff macros as specified in .rootrc; -q : exit after processing command line macro files; -l : do not show splash screen; The last three options are only relevant in conjunction with TRint.; The following help and info arguments are supported:; -? : print usage; -h : print usage; --help : print usage; -config : print ./configure options; -memstat : run with memory usage monitoring; In addition to the above options the arguments that are not options,; i.e. they don't start with - or + are treated as follows (and also removed; from the argument array):; <dir> is considered the desired working directory and available; via WorkingDirectory(), if more than one dir is specified the; first one will prevail; <file> if the file exists its added to the InputFiles() list; <file>.root are considered ROOT files and added to the InputFiles() list,; the file may be a remote file url; <macro>.C are considered ROOT macros and also added to the InputFiles() list; In TRint we set the working directory to the <dir>, the ROOT files are; connected, and the macros are executed. If your main TApplication is not; TRint you have to decide yourself what to do whith these options.; All specified arguments (also the ones removed) can always be retrieved; via the TApplication::Argv() method. void HandleIdleTimer(); Handle idle timeout. When this timer expires the registered idle command; will be ",MatchSource.WIKI,root/html530/TApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TApplication.html
Integrability,interface,interfaces,". TApplication. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TApplication. class TApplication: public TObject, public TQObject. TApplication. This class creates the ROOT Application Environment that interfaces; to the windowing system eventloop and eventhandlers.; This class must be instantiated exactly once in any given; application. Normally the specific application class inherits from; TApplication (see TRint). Function Members (Methods); public:. TApplication(const char* appClassName, Int_t* argc, char** argv, void* options = 0, Int_t numOptions = 0); virtual~TApplication(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*ApplicationName() const; static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; Int_tArgc() const; char**Argv() const; char*Argv(Int_t index) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearInputFiles(); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::",MatchSource.WIKI,root/html530/TApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TApplication.html
Modifiability,inherit,inherits,". TApplication. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TApplication. class TApplication: public TObject, public TQObject. TApplication. This class creates the ROOT Application Environment that interfaces; to the windowing system eventloop and eventhandlers.; This class must be instantiated exactly once in any given; application. Normally the specific application class inherits from; TApplication (see TRint). Function Members (Methods); public:. TApplication(const char* appClassName, Int_t* argc, char** argv, void* options = 0, Int_t numOptions = 0); virtual~TApplication(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*ApplicationName() const; static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; Int_tArgc() const; char**Argv() const; char*Argv(Int_t index) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearInputFiles(); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::",MatchSource.WIKI,root/html530/TApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TApplication.html
Performance,load,loaded,"tFiles() list,; the file may be a remote file url; <macro>.C are considered ROOT macros and also added to the InputFiles() list; In TRint we set the working directory to the <dir>, the ROOT files are; connected, and the macros are executed. If your main TApplication is not; TRint you have to decide yourself what to do whith these options.; All specified arguments (also the ones removed) can always be retrieved; via the TApplication::Argv() method. void HandleIdleTimer(); Handle idle timeout. When this timer expires the registered idle command; will be executed by this routine and a signal will be emitted. void HandleException(Int_t sig); Handle exceptions (kSigBus, kSigSegmentationViolation,; kSigIllegalInstruction and kSigFloatingException) trapped in TSystem.; Specific TApplication implementations may want something different here. void Help(const char* line); Print help on interpreter. void LoadGraphicsLibs(); Load shared libs neccesary for graphics. These libraries are only; loaded when gROOT->IsBatch() is kFALSE. void MakeBatch(); Switch to batch mode. Int_t ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); Parse the content of a line starting with "".R"" (already stripped-off); The format is; [user@]host[:dir] [-l user] [-d dbg] [script]; The variable 'dir' is the remote directory to be used as working dir.; The username can be specified in two ways, ""-l"" having the priority; (as in ssh).; A 'dbg' value > 0 gives increasing verbosity.; The last argument 'script' allows to specify an alternative script to; be executed remotely to startup the session. Long_t ProcessRemote(const char* line, Int_t* error = 0); Process the content of a line starting with "".R"" (already stripped-off); The format is; [user@]host[:dir] [-l user] [-d dbg] [script] | [host] -close; The variable 'dir' is the remote directory to be used as working dir.; The username can be specified in two ways, ""-l"" having the priority; (as in ssh).; A 'dbg' valu",MatchSource.WIKI,root/html530/TApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TApplication.html
Safety,timeout,timeout,"config : print ./configure options; -memstat : run with memory usage monitoring; In addition to the above options the arguments that are not options,; i.e. they don't start with - or + are treated as follows (and also removed; from the argument array):; <dir> is considered the desired working directory and available; via WorkingDirectory(), if more than one dir is specified the; first one will prevail; <file> if the file exists its added to the InputFiles() list; <file>.root are considered ROOT files and added to the InputFiles() list,; the file may be a remote file url; <macro>.C are considered ROOT macros and also added to the InputFiles() list; In TRint we set the working directory to the <dir>, the ROOT files are; connected, and the macros are executed. If your main TApplication is not; TRint you have to decide yourself what to do whith these options.; All specified arguments (also the ones removed) can always be retrieved; via the TApplication::Argv() method. void HandleIdleTimer(); Handle idle timeout. When this timer expires the registered idle command; will be executed by this routine and a signal will be emitted. void HandleException(Int_t sig); Handle exceptions (kSigBus, kSigSegmentationViolation,; kSigIllegalInstruction and kSigFloatingException) trapped in TSystem.; Specific TApplication implementations may want something different here. void Help(const char* line); Print help on interpreter. void LoadGraphicsLibs(); Load shared libs neccesary for graphics. These libraries are only; loaded when gROOT->IsBatch() is kFALSE. void MakeBatch(); Switch to batch mode. Int_t ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); Parse the content of a line starting with "".R"" (already stripped-off); The format is; [user@]host[:dir] [-l user] [-d dbg] [script]; The variable 'dir' is the remote directory to be used as working dir.; The username can be specified in two ways, ""-l"" having the priority; (as in ssh).; A 'dbg' valu",MatchSource.WIKI,root/html530/TApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TApplication.html
Testability,log,logon,"med] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*fgApplicationsList of available applications. private:. TApplicationImp*fAppImp!Window system specific application implementation; Int_tfArgcNumber of com mand line arguments; char**fArgvCommand line arguments; TApplication::EExitOnExceptionfExitOnExceptionExit on exception option; TObjArray*fFilesArray of input files (TObjString's) specified via argv; TStringfIdleCommandCommand to execute while application is idle; TTimer*fIdleTimerIdle timer; Bool_tfIsRunningTrue when in event loop (Run() has been called); Bool_tfNoLogDo not process logon and logoff macros; Bool_tfNoLogoDo not show splash screen and welcome message; Bool_tfQuitExit after having processed input files; Bool_tfReturnFromRunWhen true return from Run(); TSignalHandler*fSigHandlerInterrupt handler; Bool_tfUseMemstatRun with TMemStat enabled; TStringfWorkDirWorking directory specified via argv; static Bool_tfgGraphInitTrue if graphics libs initialized; static Bool_tfgGraphNeededTrue if graphics libs need to be initialized. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TApplication(); Default ctor. Can be used by classes deriving from TApplication. TApplication(const char* appClassName, Int_t* argc, char** argv, void* options = 0, Int_t numOptions = 0); Create an application environment. The application environment; provides an interface to the graphics system and eventloop; (be it X, Windoze, MacOS or BeOS). After creating the application; object start the eventloop by calling its Run() method. T",MatchSource.WIKI,root/html530/TApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TApplication.html
Integrability,protocol,protocol,". TApplicationImp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TApplicationImp. class TApplicationImp. TApplicationImp. ABC describing GUI independent application implementation protocol. Function Members (Methods); public:. TApplicationImp(); TApplicationImp(const TApplicationImp&); TApplicationImp(const char* appClassName, int* argc, char** argv); virtual~TApplicationImp(); virtual const char*ApplicationName() const; static TClass*Class(); virtual Int_tExecCommand(TGWin32Command* code, Bool_t synch); virtual voidHide(); virtual voidIconify(); virtual voidInit(); virtual TClass*IsA() const; virtual Bool_tIsCmdThread(); virtual voidLower(); virtual voidOpen(); TApplicationImp&operator=(const TApplicationImp&); virtual voidRaise(); virtual voidShow(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. TStringfApplicationNameapplication name. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; inline TApplicationImp(const char* appClassName, int* argc, char** argv); { }. Int_t ExecCommand(TGWin32Command* code, Bool_t synch); { return 0; }. TApplicationImp(); { }. TApplicationImp(const char* appClassName, int* argc, char** argv). virtual ~TApplicationImp(); { }. const char * ApplicationName() const; { return fApplicationName.Data(); }. void Show(); { }. void Hide(); { }. void Iconify(); { }. Bool_t IsCmdThread(); { return kTRUE; }. void Init(); { }. void Open(); { }. void Raise(); { }. void Lower(); { }. » Author: Fons Rademakers 22/12/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TApplicationImp.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. ",MatchSource.WIKI,root/html530/TApplicationImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TApplicationImp.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); TApplication*TApplication::GetAppRemote() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const char*TApplication::GetIdleCommand() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*T",MatchSource.WIKI,root/html530/TApplicationRemote.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TApplicationRemote.html
Integrability,protocol,protocol,"erenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. THashList*fFileListList of files already uploaded; TSignalHandler*fIntHandlerinterrupt signal handler (ctrl-c); Bool_tfInterruptflag interrupt state; TStringfLogFilePathFull remote path to log file; TMonitor*fMonitormonitor for the input socket; TStringfNameUnique name identifying this instance; Int_tfProtocolserver protocol version number; TObject*fReceivedObjectlast received object; TSeqCollection*fRootFileslist of (remote) root files; TSocket*fSocketsocket connection to server; TUrlfUrlserver's url; TRemoteObject*fWorkingDirworking (remote) directory; static Int_tfgPortAttemptsnumber of attempts to find a port; static Int_tfgPortLowerlower bound for ports; static Int_tfgPortUpperupper bound for ports. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TApplicationRemote(const char* url, Int_t debug = 0, const char* script = 0); Main constructor: start a remote session at 'url' accepting callbacks; on local port 'port'; if port is already in use scan up to 'scan - 1'; ports starting from port + 1, i.e. port + 1, ... , port + scan - 1. ~TApplicationRemote(); Destructor. Int_t Broadcast(const TMessage& mess); Broadcast a message to the remote session.; Returns 0 on success, -1 in case of error. Int_t Broadcast(const char* mess, Int_t kind = kMESS_STRING, Int_t type = kRRT_Undef); Broadcast a cha",MatchSource.WIKI,root/html530/TApplicationRemote.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TApplicationRemote.html
Performance,cache,cache,"; Return 0 on success, -1 in case of error. Bool_t CheckFile(const char* file, Long_t modtime); Check if a file needs to be send to the server. Use the following; algorithm:; - check if file appears in file map; - if yes, get file's modtime and check against time in map,; if modtime not same get md5 and compare against md5 in map,; if not same return kTRUE.; - if no, get file's md5 and modtime and store in file map, ask; slave if file exists with specific md5, if yes return kFALSE,; if no return kTRUE.; Returns kTRUE in case file needs to be send, returns kFALSE in case; file is already on remote node. Int_t SendFile(const char* file, Int_t opt = kAscii, const char* rfile = 0); Send a file to the server. Return 0 on success, -1 in case of error.; If defined, the full path of the remote path will be rfile.; The mask 'opt' is an or of ESendFileOpt:. kAscii (0x0) if set true ascii file transfer is used; kBinary (0x1) if set true binary file transfer is used; kForce (0x2) if not set an attempt is done to find out; whether the file really needs to be downloaded; (a valid copy may already exist in the cache; from a previous run). void Terminate(Int_t status = 0); Terminate this session. void SetPortParam(Int_t lower = -1, Int_t upper = -1, Int_t attempts = -1); Set port parameters for tunnelling. A value of -1 means unchanged. Long_t ProcessLine(const char* line, Bool_t = kFALSE, Int_t* error = 0); Parse a single command line and forward the request to the remote server; where it will be processed. The line is either a C++ statement or an; interpreter command starting with a ""."".; Return the return value of the command casted to a long. void Print(Option_t* option = """") const; Print some info about this instance. void Interrupt(Int_t type = kRRI_Hard); Send interrupt OOB byte to server.; Returns 0 if ok, -1 in case of error. void Browse(TBrowser* b); Browse remote application (working directory and ROOT files). Int_t Broadcast(const TMessage& mess). Bool_t IsFolder() cons",MatchSource.WIKI,root/html530/TApplicationRemote.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TApplicationRemote.html
Safety,timeout,timeout,"t char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidTApplication::Help(const char* line); virtual voidTApplication::LoadGraphicsLibs(); virtual voidTApplication::MakeBatch(); voidTObject::MakeZombie(); static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual Long_tTApplication::ProcessRemote(const char* line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh). private:. Int_tBroadcast(const TMessage& mess); Int_tBroadcast(Int_t kind, Int_t type = kRRT_Undef); Int_tBroadcast(const char* mess, Int_t kind = kMESS_STRING, Int_t type = kRRT_Undef); Int_tBroadcastObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Int_tBroadcastRaw(const void* buffer, Int_t length); Bool_tCheckFile(const char* file, Long_t modtime); Int_tCollect(Long_t timeout = -1); Int_tCollectInput(); voidRecvLogFile(Int_t size). Data Members; public:. enum ESendFileOpt { kAscii; kBinary; kForce; };; enum EStatusBits { kCollecting; };; enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TApplication::EExitOnException { kDontExit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for sup",MatchSource.WIKI,root/html530/TApplicationRemote.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TApplicationRemote.html
Testability,log,log,"erenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. THashList*fFileListList of files already uploaded; TSignalHandler*fIntHandlerinterrupt signal handler (ctrl-c); Bool_tfInterruptflag interrupt state; TStringfLogFilePathFull remote path to log file; TMonitor*fMonitormonitor for the input socket; TStringfNameUnique name identifying this instance; Int_tfProtocolserver protocol version number; TObject*fReceivedObjectlast received object; TSeqCollection*fRootFileslist of (remote) root files; TSocket*fSocketsocket connection to server; TUrlfUrlserver's url; TRemoteObject*fWorkingDirworking (remote) directory; static Int_tfgPortAttemptsnumber of attempts to find a port; static Int_tfgPortLowerlower bound for ports; static Int_tfgPortUpperupper bound for ports. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TApplicationRemote(const char* url, Int_t debug = 0, const char* script = 0); Main constructor: start a remote session at 'url' accepting callbacks; on local port 'port'; if port is already in use scan up to 'scan - 1'; ports starting from port + 1, i.e. port + 1, ... , port + scan - 1. ~TApplicationRemote(); Destructor. Int_t Broadcast(const TMessage& mess); Broadcast a message to the remote session.; Returns 0 on success, -1 in case of error. Int_t Broadcast(const char* mess, Int_t kind = kMESS_STRING, Int_t type = kRRT_Undef); Broadcast a cha",MatchSource.WIKI,root/html530/TApplicationRemote.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TApplicationRemote.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); TApplication*TApplication::GetAppRemote() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetHost() const; virtual const char*TObject::GetIconName() const; const char*TApplication::GetIdleCommand() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOf",MatchSource.WIKI,root/html530/TApplicationServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TApplicationServer.html
Integrability,protocol,protocol,"Exit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. Bool_tfInterruptflag interrupt state; Bool_tfIsValidflag validity; FILE*fLogFilelog file; Int_tfLogFileDeslog file descriptor; TStringfLogFilePathPath to log file; Int_tfProtocoluser protocol version number; Bool_tfRealTimeLogTRUE if log messages should be send back in real-time; TList*fSentCanvasesList of canvases already sent; TStringfSessIdIdentifier for this session; TSocket*fSocketsocket connection to user; TUrlfUrluser's url; TStringfWorkDirWorking dir; TRemoteObject*fWorkingDirWorking (remote) directory. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TApplicationServer(Int_t* argc, char** argv, FILE* flog, const char* logfile); Main constructor. Create an application environment. The TApplicationServer; environment provides an eventloop via inheritance of TApplication. Int_t Setup(); Print the Remote Server logo on standard output.; Return 0 on success, -1 on failure. ~TApplicationServer(); Cleanup. Not really necessary since after this dtor there is no; live anyway. void GetOptions(Int_t* argc, char** argv); Get and handle command line options. Fixed format:; ""protocol url"". void Run(Bool_t retrn = kFALSE); Main server eventloop. void HandleSocketInput(); Handle input coming from the cli",MatchSource.WIKI,root/html530/TApplicationServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TApplicationServer.html
Modifiability,inherit,inheritance,"lsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. Bool_tfInterruptflag interrupt state; Bool_tfIsValidflag validity; FILE*fLogFilelog file; Int_tfLogFileDeslog file descriptor; TStringfLogFilePathPath to log file; Int_tfProtocoluser protocol version number; Bool_tfRealTimeLogTRUE if log messages should be send back in real-time; TList*fSentCanvasesList of canvases already sent; TStringfSessIdIdentifier for this session; TSocket*fSocketsocket connection to user; TUrlfUrluser's url; TStringfWorkDirWorking dir; TRemoteObject*fWorkingDirWorking (remote) directory. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TApplicationServer(Int_t* argc, char** argv, FILE* flog, const char* logfile); Main constructor. Create an application environment. The TApplicationServer; environment provides an eventloop via inheritance of TApplication. Int_t Setup(); Print the Remote Server logo on standard output.; Return 0 on success, -1 on failure. ~TApplicationServer(); Cleanup. Not really necessary since after this dtor there is no; live anyway. void GetOptions(Int_t* argc, char** argv); Get and handle command line options. Fixed format:; ""protocol url"". void Run(Bool_t retrn = kFALSE); Main server eventloop. void HandleSocketInput(); Handle input coming from the client or from the master server. void HandleUrgentData(); Handle Out-Of-Band data sent by the master or client. void HandleSigPipe(); Called when the client is not alive anymore (i.e. when kKeepAlive; has failed). void Reset(const char* dir); Reset environment to be ready for execution of next command. Int_t ReceiveFile(const char* file, Bool_t bin, Long64_t size); Receive a file, either sent by a client or a master server.; If bin is true it is a binary file, other wise it is an ASCII; file and we need to check for Windows",MatchSource.WIKI,root/html530/TApplicationServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TApplicationServer.html
Safety,abort,abort,"oidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; const char*TApplication::WorkingDirectory() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static voidTApplication::Close(TApplication* app); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static voidErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidHandleCheckFile(TMessage* mess); virtual voidTApplication::Help(const char* line); virtual voidTApplication::LoadGraphicsLibs(); virtual voidTApplication::MakeBatch(); voidTObject::MakeZombie(); static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual Long_tTApplication::ProcessRemote(const char* line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh). private:. voidExecLogon(); Int_tSendCanvases(); Int_tSetup(). Data Members; public:. enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TApplication::EExitOnException { kDontExit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu;",MatchSource.WIKI,root/html530/TApplicationServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TApplicationServer.html
Testability,log,logfile," TApplicationServer(Int_t* argc, char** argv, FILE* flog, const char* logfile); virtual~TApplicationServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TApplication::ApplicationName() const; static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; Int_tTApplication::Argc() const; char**TApplication::Argv() const; char*TApplication::Argv(Int_t index) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); Int_tBrowseDirectory(const char* dirname); Int_tBrowseFile(const char* fname); Int_tBrowseKey(const char* keyname); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTApplication::ClearInputFiles(); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const",MatchSource.WIKI,root/html530/TApplicationServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TApplicationServer.html
Availability,error,error,"char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& arc) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTEllipse::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTEllipse::Draw(Option_t* option = """"); virtual voidDrawArc(Double_t x1, Double_t y1, Double_t radius, Double_t phimin = 0, Double_t phimax = 360, Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTEllipse::DrawEllipse(Double_t x1, Double_t y1, Double_t r1, Double_t r2, Double_t phimin, Double_t phimax, Double_t theta, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTEllipse::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; Bool_tTEllipse::GetNoEdges() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTEllipse::GetPhimax() const; Doubl",MatchSource.WIKI,root/html530/TArc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TArc.html
Availability,down,down,"e file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TArcBall. class TArcBall. Implements the arc-ball rotation manipulator.; Used by plot-painters. Function Members (Methods); public:. TArcBall(UInt_t NewWidth = 100, UInt_t NewHeight = 100); virtual~TArcBall(); static TClass*Class(); voidClick(const TPoint& NewPt); voidDrag(const TPoint& NewPt); const Double_t*GetRotMatrix() const; virtual TClass*IsA() const; voidSetBounds(UInt_t NewWidth, UInt_t NewHeight); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidMapToSphere(const TPoint& NewPt, Double_t* NewVec) const. private:. TArcBall(const TArcBall&); TArcBall&operator=(const TArcBall&); voidResetMatrices(). Data Members; private:. Double_tfAdjustHeightMouse bounds height; Double_tfAdjustWidthMouse bounds width; Double_tfEnVec[3]Saved drag vector; Double_tfLastRot[9]; Double_tfStVec[3]Saved click vector; Double_tfThisRot[9]; Double_tfTransform[16]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void MapToSphere(const TPoint& NewPt, Double_t* NewVec) const; map to sphere. TArcBall(UInt_t NewWidth = 100, UInt_t NewHeight = 100); constructor. void Click(const TPoint& NewPt); Mouse down. void Drag(const TPoint& NewPt); Mouse drag, calculate rotation. void ResetMatrices(); Set rotation matrix as union. TArcBall(const TArcBall& ); Non-copyable. virtual ~TArcBall(); { }. void SetBounds(UInt_t NewWidth, UInt_t NewHeight). const Double_t * GetRotMatrix() const. » Author: Timur Pocheptsov 03/08/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TArcBall.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TArcBall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TArcBall.html
Availability,avail,available,". TArchiveFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TArchiveFile. class TArchiveFile: public TObject. TArchiveFile. This is an abstract class that describes an archive file containing; multiple sub-files, like a ZIP or TAR archive. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TArchiveFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetArchiveName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDto",MatchSource.WIKI,root/html530/TArchiveFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TArchiveFile.html
Integrability,depend,depending,"ct; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfArchiveNameArchive file name; TArchiveMember*fCurMemberCurrent archive member; TFile*fFileFile stream used to access the archive; Int_tfMemberIndexIndex of sub-file in archive; TStringfMemberNameSub-file name; TObjArray*fMembersMembers in this archive. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TArchiveFile(); Dtor. Long64_t GetMemberFilePosition() const; Return position in archive of current member. Int_t GetNumberOfMembers() const; Returns number of members in archive. Int_t SetMember(const char* member); Explicitely make the specified member the current member.; Returns -1 in case of error, 0 otherwise. Int_t SetMember(Int_t idx); Explicitely make the member with the specified index the current member.; Returns -1 in case of error, 0 otherwise. TArchiveFile * Open(const char* url, TFile* file); Return proper archive file handler depending on passed url.; The handler is loaded via the plugin manager and is triggered by; the extension of the archive file. In case no handler is found 0; is returned. The file argument is used to access the archive.; The archive should be specified as url with the member name as the; anchor, e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#tpc.root"",; where tpc.root is the file in the archive to be opened.; Alternatively the sub-file can be specified via its index number,; e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#3"".; This function is normally only called via TFile::Open(). Bool_t ParseUrl(const char* url, TString& archive, TString& member, TString& type); Try to determine if url contains an anchor specifying an archive member.; Returns kFALSE in case of an error. TArchiveFile& operator=(const TArchiveFile& ). Int_t OpenArchive(). Int_t SetCurrentMember(). TArchiveMember * GetMember() const; { return fCurMember; }. TObjArray * GetMembers() const; { ",MatchSource.WIKI,root/html530/TArchiveFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TArchiveFile.html
Modifiability,plugin,plugin,"Delete; };. protected:. TStringfArchiveNameArchive file name; TArchiveMember*fCurMemberCurrent archive member; TFile*fFileFile stream used to access the archive; Int_tfMemberIndexIndex of sub-file in archive; TStringfMemberNameSub-file name; TObjArray*fMembersMembers in this archive. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TArchiveFile(); Dtor. Long64_t GetMemberFilePosition() const; Return position in archive of current member. Int_t GetNumberOfMembers() const; Returns number of members in archive. Int_t SetMember(const char* member); Explicitely make the specified member the current member.; Returns -1 in case of error, 0 otherwise. Int_t SetMember(Int_t idx); Explicitely make the member with the specified index the current member.; Returns -1 in case of error, 0 otherwise. TArchiveFile * Open(const char* url, TFile* file); Return proper archive file handler depending on passed url.; The handler is loaded via the plugin manager and is triggered by; the extension of the archive file. In case no handler is found 0; is returned. The file argument is used to access the archive.; The archive should be specified as url with the member name as the; anchor, e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#tpc.root"",; where tpc.root is the file in the archive to be opened.; Alternatively the sub-file can be specified via its index number,; e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#3"".; This function is normally only called via TFile::Open(). Bool_t ParseUrl(const char* url, TString& archive, TString& member, TString& type); Try to determine if url contains an anchor specifying an archive member.; Returns kFALSE in case of an error. TArchiveFile& operator=(const TArchiveFile& ). Int_t OpenArchive(). Int_t SetCurrentMember(). TArchiveMember * GetMember() const; { return fCurMember; }. TObjArray * GetMembers() const; { return fMembers; }. const char * GetArchiveName() const; { return fArchiveName; }. const char * GetMemberN",MatchSource.WIKI,root/html530/TArchiveFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TArchiveFile.html
Performance,load,loaded,"Delete; };. protected:. TStringfArchiveNameArchive file name; TArchiveMember*fCurMemberCurrent archive member; TFile*fFileFile stream used to access the archive; Int_tfMemberIndexIndex of sub-file in archive; TStringfMemberNameSub-file name; TObjArray*fMembersMembers in this archive. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TArchiveFile(); Dtor. Long64_t GetMemberFilePosition() const; Return position in archive of current member. Int_t GetNumberOfMembers() const; Returns number of members in archive. Int_t SetMember(const char* member); Explicitely make the specified member the current member.; Returns -1 in case of error, 0 otherwise. Int_t SetMember(Int_t idx); Explicitely make the member with the specified index the current member.; Returns -1 in case of error, 0 otherwise. TArchiveFile * Open(const char* url, TFile* file); Return proper archive file handler depending on passed url.; The handler is loaded via the plugin manager and is triggered by; the extension of the archive file. In case no handler is found 0; is returned. The file argument is used to access the archive.; The archive should be specified as url with the member name as the; anchor, e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#tpc.root"",; where tpc.root is the file in the archive to be opened.; Alternatively the sub-file can be specified via its index number,; e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#3"".; This function is normally only called via TFile::Open(). Bool_t ParseUrl(const char* url, TString& archive, TString& member, TString& type); Try to determine if url contains an anchor specifying an archive member.; Returns kFALSE in case of an error. TArchiveFile& operator=(const TArchiveFile& ). Int_t OpenArchive(). Int_t SetCurrentMember(). TArchiveMember * GetMember() const; { return fCurMember; }. TObjArray * GetMembers() const; { return fMembers; }. const char * GetArchiveName() const; { return fArchiveName; }. const char * GetMemberN",MatchSource.WIKI,root/html530/TArchiveFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TArchiveFile.html
Security,access,access,"t; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); static Bool_tParseUrl(const char* url, TString& archive, TString& member, TString& type). private:. TArchiveFile&operator=(const TArchiveFile&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfArchiveNameArchive file name; TArchiveMember*fCurMemberCurrent archive member; TFile*fFileFile stream used to access the archive; Int_tfMemberIndexIndex of sub-file in archive; TStringfMemberNameSub-file name; TObjArray*fMembersMembers in this archive. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TArchiveFile(); Dtor. Long64_t GetMemberFilePosition() const; Return position in archive of current member. Int_t GetNumberOfMembers() const; Returns number of members in archive. Int_t SetMember(const char* member); Explicitely make the specified member the current member.; Returns -1 in case of error, 0 otherwise. Int_t SetMember(Int_t idx); Explicitely make the member with the specified index the current member.; Returns -1 in case of error, 0 otherwise. TArchiveFile * Open(const char* url, TFile* file); Return proper archive file handler depending on passed url.; The handler is loaded via the plugin manager and is triggered by; the extension of the archive file. In case no handler is found 0; is returned. The file argument is used to access the archive.; The arch",MatchSource.WIKI,root/html530/TArchiveFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TArchiveFile.html
Availability,error,error,"char* name); TArchiveMember(const TArchiveMember& member); virtual~TArchiveMember(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetComment() const; Long64_tGetCompressedSize() const; Long64_tGetDecompressedSize() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetFilePosition() const; virtual const char*TObject::GetIconName() const; TDatimeGetModTime() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Long64_tGetPosition() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer",MatchSource.WIKI,root/html530/TArchiveMember.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TArchiveMember.html
Availability,avail,available,". TArray. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TArray. class TArray. TArray. Abstract array base class. Used by TArrayC, TArrayS, TArrayI,; TArrayL, TArrayF and TArrayD.; Data member is public for historical reasons. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TArray(); static TClass*Class(); virtual Double_tGetAt(Int_t i) const; Int_tGetSize() const; virtual TClass*IsA() const; TArray&operator=(const TArray& rhs); static TArray*ReadArray(TBuffer& b, const TClass* clReq); virtual voidSet(Int_t n); virtual voidSetAt(Double_t v, Int_t i); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); static voidWriteArray(TBuffer& b, const TArray* a). protected:. Bool_tBoundsOk(const char* where, Int_t at) const; Bool_tOutOfBoundsError(const char* where, Int_t i) const. Data Members; public:. Int_tfNNumber of array elements. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t OutOfBoundsError(const char* where, Int_t i) const; Generate an out-of-bounds error. Always returns false. TArray * ReadArray(TBuffer& b, const TClass* clReq); Read TArray object from buffer. Simplified version of; TBuffer::ReadObject (does not keep track of multiple; references to same array). void WriteArray(TBuffer& b, const TArray* a); Write TArray object to buffer. Simplified version of; TBuffer::WriteObject (does not keep track of multiple; references to the same array). Bool_t BoundsOk(const char* where, Int_t at) const. TArray & operator=(const TArray& rhs); {if(this!=&rhs) fN = rhs.fN; return *this; }. virtual ~TArray(); { fN = 0; }. Int_t GetSize() const; { return fN; }",MatchSource.WIKI,root/html530/TArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TArray.html
Availability,error,error,"Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& arrow) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTLine::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidDrawArrow(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Float_t arrowsize = 0, Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TLine*TLine::DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual TLine*TLine::DrawLineNDC(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTLine::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Float_tGetAngle() const; Float_tGetArrowSize() const; static Float_tGetDefaultAngle(); static Float_tGetDefaultArrowSize(); static Option_t*GetDefaultOption(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; stati",MatchSource.WIKI,root/html530/TArrow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TArrow.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TArrowEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TArrowEditor.html
Integrability,interface,interface,". TArrowEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TArrowEditor. class TArrowEditor: public TGedFrame. Implements user interface for editing of arrow attributes: ; shape, size, angle.; The picture below shows this interface. . Function Members (Methods); public:. TArrowEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); virtual~TArrowEditor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidTGedFrame::ActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject",MatchSource.WIKI,root/html530/TArrowEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TArrowEditor.html
Availability,error,error,"olyLine(UInt_t nn, TPoint* xy, const char* col = ""#000000"", UInt_t thick = 1, TImage::ECoordMode mode = kCoordModeOrigin); virtual voidDrawRectangle(UInt_t x, UInt_t y, UInt_t w, UInt_t h, const char* col = ""#000000"", UInt_t thick = 1); virtual voidDrawSegments(UInt_t nseg, Segment_t* seg, const char* col = ""#000000"", UInt_t thick = 1); virtual voidDrawStraightEllips(Int_t x, Int_t y, Int_t rx, Int_t ry, const char* col = ""#000000"", Int_t thick = 1); virtual voidDrawText(TText* text, Int_t x = 0, Int_t y = 0); virtual voidDrawText(Int_t x = 0, Int_t y = 0, const char* text = """", Int_t size = 12, const char* color = 0, const char* font = ""fixed"", TImage::EText3DType type = TImage::kPlain, const char* fore_file = 0, Float_t angle = 0); virtual voidTObject::Dump() constMENU ; virtual voidTAttImage::EditorClosed(); virtual voidEndPaint(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFillPolygon(UInt_t npt, TPoint* ppt, TImage* tile); virtual voidFillPolygon(UInt_t npt, TPoint* ppt, const char* col = ""#000000"", const char* stipple = 0, UInt_t w = 16, UInt_t h = 16); virtual voidFillRectangle(const char* col = 0, Int_t x = 0, Int_t y = 0, UInt_t width = 0, UInt_t height = 0); virtual voidFillSpans(UInt_t npt, TPoint* ppt, UInt_t* widths, TImage* tile); virtual voidFillSpans(UInt_t npt, TPoint* ppt, UInt_t* widths, const char* col = ""#000000"", const char* stipple = 0, UInt_t w = 16, UInt_t h = 16); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFlip(Int_t flip = 180)MENU ; virtual voidFloodFill(Int_t",MatchSource.WIKI,root/html530/TASImage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TASImage.html
Energy Efficiency,reduce,reduced,"t_t width, UInt_t height); Scale the original image.; The size of the image on the screen does not change because it is defined; by the size of the pad.; This function can be used to change the size of an image before writing; it into a file. The colors of the new pixels are interpolated.; An image created with the SetImage() functions cannot be modified with; the function SetPalette() any more after a call of this function!. void Slice(UInt_t xStart, UInt_t xEnd, UInt_t yStart, UInt_t yEnd, UInt_t toWidth, UInt_t toHeight); Another method of enlarging images where corners remain unchanged,; but middle part gets tiled. void Tile(UInt_t width, UInt_t height); Tile the original image. void Zoom(UInt_t offX, UInt_t offY, UInt_t width, UInt_t height); The area of an image displayed in a pad is defined by this function.; Note: the size on the screen is defined by the size of the pad.; The original image is not modified by this function.; If width or height is larger than the original image they are reduced to; the width and height of the image.; If the off values are too large (off + width > image width) than the off; values are decreased. For example: offX = image width - width; Note: the parameters are always relative to the original image not to the; size of an already zoomed image. void UnZoom(); Un-zoom the image to original size.; UnZoom() - performs undo for Zoom,Crop,Scale actions. void Flip(Int_t flip = 180); Flip image in place.; Flip is either 90, 180, 270, 180 is default.; This function manipulates the original image and destroys the; scaled and zoomed image which will be recreated at the next call of; the Draw function. If the image is zoomed the zoom - coordinates are; now relative to the new image.; This function cannot be used for images which were created with the; SetImage() functions, because the original pixel values would be; destroyed. void Mirror(Bool_t vert = kTRUE); Mirror image in place.; If vert is true mirror in vertical axis, horizontal other",MatchSource.WIKI,root/html530/TASImage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TASImage.html
Integrability,interface,interface,". TASImage. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » ASIMAGE; » TASImage. class TASImage: public TImage. Image class; TASImage is the concrete interface to the image processing library; libAfterImage. It allows reading and writing of images in different formats, several image; manipulations (scaling, tiling, merging, etc.) and displaying in pads. The size; of the image on the screen does not depend on the original size of the image but; on the size of the pad. Therefore it is very easy to resize the image on the; screen by resizing the pad. Besides reading an image from a file an image can be defined by a two; dimensional array of values. A palette defines the color of each value. The image can be zoomed by defining a rectangle with the mouse. The color; palette can be modified with a GUI, just select StartPaletteEditor() from the; context menu.; . Function Members (Methods); public:. TASImage(); TASImage(const TASImage& img); TASImage(UInt_t w, UInt_t h); TASImage(const char* file, TImage::EImageFileTypes type = kUnknown); TASImage(const char* name, const TArrayD& imageData, UInt_t width, TImagePalette* palette = 0); TASImage(const char* name, const TVectorD& imageData, UInt_t width, TImagePalette* palette = 0); TASImage(const char* name, const Double_t* imageData, UInt_t width, UInt_t height, TImagePalette* palette = 0); virtual~TASImage(); voidTObject::AbstractMethod(const char* method) const; static UInt_tAlphaBlend(UInt_t bot, UInt_t top); virtual voidAppend(const TImage* im, const char* option = ""+"", const char* color = ""#00000000""); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginPaint(Bool_t fast = kTRUE); virtual voidBevel(Int_t x = 0, Int_t y = 0, UInt_t width = 0, UInt_t height = 0, const char* hi = ""#ffdddddd"", const char* lo = ""#ff555555"", UShort_t t",MatchSource.WIKI,root/html530/TASImage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TASImage.html
Modifiability,plugin,plugins,"gPoor; kImgFast; kImgGood; kImgBest; };. protected:. Bool_tTAttImage::fConstRatiokeep aspect ratio of image on the screen; Bool_tfEditable! kTRUE image can be resized, moved by resizing/moving gPad; ASImage*fGrayImage! gray image; ASImage*fImage! pointer to image structure of original image; UInt_tTAttImage::fImageCompressioncompression [0 .. 100] 0: no compression; TAttImage::EImageQualityTAttImage::fImageQuality*OPTION={GetMethod=""GetImageQuality"";SetMethod=""SetImageQuality"";Items=(kImgDefault=""Default"",kImgPoor=""Poor"",kImgFast=""Fast"",kImgGood=""Good"",kImgBest=""Best"")}*; Bool_tfIsGray! kTRUE if image is gray; Double_tfMaxValue! max value in image; Double_tfMinValue! min value in image; TStringTNamed::fNameobject identifier; Int_tfPaintMode! 1 - fast mode, 0 - low memory slow mode; TImagePaletteTAttImage::fPalettecolor palette for value -> color conversion; TPaletteEditor*TAttImage::fPaletteEditor! GUI to edit the color palette; Bool_tTAttImage::fPaletteEnabled! kTRUE - palette is drawn on the image; TASImage*fScaledImage! temporary scaled and zoomed image produced from original image; TStringTNamed::fTitleobject title; UInt_tfZoomHeight! hight of zoomed image in image pixels; UInt_tfZoomOffX! X - offset for zooming in image pixels; UInt_tfZoomOffY! Y - offset for zooming im image pixels; Int_tfZoomUpdate! kZoom - new zooming required, kZoomOps - other ops in action, kNoZoom - no zooming or ops; UInt_tfZoomWidth! width of zoomed image in image pixels; static Bool_tfgInitglobal flag to init afterimage only once; static THashTable*fgPlugList! hash table containing loaded plugins; static ASVisual*fgVisualpointer to visual structure. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DestroyImage(); Destroy image. void SetDefaults(); Set default parameters. TASImage(); Default image constructor. TASImage(UInt_t w, UInt_t h); Create an empty image. TASImage(const char* file, TImage::EImageFileTypes type = kUnknown); Create an i",MatchSource.WIKI,root/html530/TASImage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TASImage.html
Performance,load,loaded,"gPoor; kImgFast; kImgGood; kImgBest; };. protected:. Bool_tTAttImage::fConstRatiokeep aspect ratio of image on the screen; Bool_tfEditable! kTRUE image can be resized, moved by resizing/moving gPad; ASImage*fGrayImage! gray image; ASImage*fImage! pointer to image structure of original image; UInt_tTAttImage::fImageCompressioncompression [0 .. 100] 0: no compression; TAttImage::EImageQualityTAttImage::fImageQuality*OPTION={GetMethod=""GetImageQuality"";SetMethod=""SetImageQuality"";Items=(kImgDefault=""Default"",kImgPoor=""Poor"",kImgFast=""Fast"",kImgGood=""Good"",kImgBest=""Best"")}*; Bool_tfIsGray! kTRUE if image is gray; Double_tfMaxValue! max value in image; Double_tfMinValue! min value in image; TStringTNamed::fNameobject identifier; Int_tfPaintMode! 1 - fast mode, 0 - low memory slow mode; TImagePaletteTAttImage::fPalettecolor palette for value -> color conversion; TPaletteEditor*TAttImage::fPaletteEditor! GUI to edit the color palette; Bool_tTAttImage::fPaletteEnabled! kTRUE - palette is drawn on the image; TASImage*fScaledImage! temporary scaled and zoomed image produced from original image; TStringTNamed::fTitleobject title; UInt_tfZoomHeight! hight of zoomed image in image pixels; UInt_tfZoomOffX! X - offset for zooming in image pixels; UInt_tfZoomOffY! Y - offset for zooming im image pixels; Int_tfZoomUpdate! kZoom - new zooming required, kZoomOps - other ops in action, kNoZoom - no zooming or ops; UInt_tfZoomWidth! width of zoomed image in image pixels; static Bool_tfgInitglobal flag to init afterimage only once; static THashTable*fgPlugList! hash table containing loaded plugins; static ASVisual*fgVisualpointer to visual structure. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DestroyImage(); Destroy image. void SetDefaults(); Set default parameters. TASImage(); Default image constructor. TASImage(UInt_t w, UInt_t h); Create an empty image. TASImage(const char* file, TImage::EImageFileTypes type = kUnknown); Create an i",MatchSource.WIKI,root/html530/TASImage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TASImage.html
Security,hash,hash,"gPoor; kImgFast; kImgGood; kImgBest; };. protected:. Bool_tTAttImage::fConstRatiokeep aspect ratio of image on the screen; Bool_tfEditable! kTRUE image can be resized, moved by resizing/moving gPad; ASImage*fGrayImage! gray image; ASImage*fImage! pointer to image structure of original image; UInt_tTAttImage::fImageCompressioncompression [0 .. 100] 0: no compression; TAttImage::EImageQualityTAttImage::fImageQuality*OPTION={GetMethod=""GetImageQuality"";SetMethod=""SetImageQuality"";Items=(kImgDefault=""Default"",kImgPoor=""Poor"",kImgFast=""Fast"",kImgGood=""Good"",kImgBest=""Best"")}*; Bool_tfIsGray! kTRUE if image is gray; Double_tfMaxValue! max value in image; Double_tfMinValue! min value in image; TStringTNamed::fNameobject identifier; Int_tfPaintMode! 1 - fast mode, 0 - low memory slow mode; TImagePaletteTAttImage::fPalettecolor palette for value -> color conversion; TPaletteEditor*TAttImage::fPaletteEditor! GUI to edit the color palette; Bool_tTAttImage::fPaletteEnabled! kTRUE - palette is drawn on the image; TASImage*fScaledImage! temporary scaled and zoomed image produced from original image; TStringTNamed::fTitleobject title; UInt_tfZoomHeight! hight of zoomed image in image pixels; UInt_tfZoomOffX! X - offset for zooming in image pixels; UInt_tfZoomOffY! Y - offset for zooming im image pixels; Int_tfZoomUpdate! kZoom - new zooming required, kZoomOps - other ops in action, kNoZoom - no zooming or ops; UInt_tfZoomWidth! width of zoomed image in image pixels; static Bool_tfgInitglobal flag to init afterimage only once; static THashTable*fgPlugList! hash table containing loaded plugins; static ASVisual*fgVisualpointer to visual structure. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DestroyImage(); Destroy image. void SetDefaults(); Set default parameters. TASImage(); Default image constructor. TASImage(UInt_t w, UInt_t h); Create an empty image. TASImage(const char* file, TImage::EImageFileTypes type = kUnknown); Create an i",MatchSource.WIKI,root/html530/TASImage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TASImage.html
Usability,undo,undo,"Palette() any more after a call of this function!. void Slice(UInt_t xStart, UInt_t xEnd, UInt_t yStart, UInt_t yEnd, UInt_t toWidth, UInt_t toHeight); Another method of enlarging images where corners remain unchanged,; but middle part gets tiled. void Tile(UInt_t width, UInt_t height); Tile the original image. void Zoom(UInt_t offX, UInt_t offY, UInt_t width, UInt_t height); The area of an image displayed in a pad is defined by this function.; Note: the size on the screen is defined by the size of the pad.; The original image is not modified by this function.; If width or height is larger than the original image they are reduced to; the width and height of the image.; If the off values are too large (off + width > image width) than the off; values are decreased. For example: offX = image width - width; Note: the parameters are always relative to the original image not to the; size of an already zoomed image. void UnZoom(); Un-zoom the image to original size.; UnZoom() - performs undo for Zoom,Crop,Scale actions. void Flip(Int_t flip = 180); Flip image in place.; Flip is either 90, 180, 270, 180 is default.; This function manipulates the original image and destroys the; scaled and zoomed image which will be recreated at the next call of; the Draw function. If the image is zoomed the zoom - coordinates are; now relative to the new image.; This function cannot be used for images which were created with the; SetImage() functions, because the original pixel values would be; destroyed. void Mirror(Bool_t vert = kTRUE); Mirror image in place.; If vert is true mirror in vertical axis, horizontal otherwise.; Vertical is default.; This function manipulates the original image and destroys the; scaled and zoomed image which will be recreated at the next call of; the Draw function. If the image is zoomed the zoom - coordinates are; now relative to the new image.; This function cannot be used for images which were created with the; SetImage() functions, because the original pixel",MatchSource.WIKI,root/html530/TASImage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TASImage.html
Availability,error,error,"st TASImagePlugin&); virtual~TASImagePlugin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Bool_tASImage2File(ASImage*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual ASImage*File2ASImage(const char*); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTImagePlugin::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_t",MatchSource.WIKI,root/html530/TASImagePlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TASImagePlugin.html
Integrability,interface,interface,". TASImagePlugin. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » ASIMAGE; » TASImagePlugin. class TASImagePlugin: public TImagePlugin. Image class; TASImage is the concrete interface to the image processing library; libAfterImage. It allows reading and writing of images in different formats, several image; manipulations (scaling, tiling, merging, etc.) and displaying in pads. The size; of the image on the screen does not depend on the original size of the image but; on the size of the pad. Therefore it is very easy to resize the image on the; screen by resizing the pad. Besides reading an image from a file an image can be defined by a two; dimensional array of values. A palette defines the color of each value. The image can be zoomed by defining a rectangle with the mouse. The color; palette can be modified with a GUI, just select StartPaletteEditor() from the; context menu.; . Function Members (Methods); public:. TASImagePlugin(const char* ext); TASImagePlugin(const TASImagePlugin&); virtual~TASImagePlugin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Bool_tASImage2File(ASImage*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU",MatchSource.WIKI,root/html530/TASImagePlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TASImagePlugin.html
Availability,down,down,". TASPaletteEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » ASIMAGE; » TASPaletteEditor. class TASPaletteEditor: public TPaletteEditor, public TGMainFrame. TASPaletteEditor. This is a GUI window to edit a color palette.; It is called by a pull down menu item of TASImage. Function Members (Methods); public:. TASPaletteEditor(TAttImage* attImage, UInt_t w, UInt_t h); virtual~TASPaletteEditor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* s",MatchSource.WIKI,root/html530/TASPaletteEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TASPaletteEditor.html
Deployability,update,updated,"c Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TASPaletteEditor(TAttImage* attImage, UInt_t w, UInt_t h); Palette editor constructor.; The palette editor aloows the editing of the color palette of the image. ~TASPaletteEditor(); Palette editor destructor. Deletes all frames and their layout hints. void CloseWindow(); Close editor. Bool_t ProcessMessage(Long_t msg, Long_t param1, Long_t param2); Process all editor mouse events. void InsertNewPalette(TImagePalette* newPalette); The newPalette is inserted in the list of palettes (fPaletteList) and; fPalette is set to the newPalette. Protected method,. void Save(); Saves the current palette either into a ROOT file or in an ASCII file.; It is called by the Save - button. Protected method. void Open(); Opens either a ROOT file or an ASCII file and reads a palette.; It is called by the Open - button. Protected method. void UpdateScreen(Bool_t histoUpdate); All widgeds of the screen are updated with the current palette.; Protected method. void LogPalette(); The anchor points are rescaled by a log operation.; It is called by the log - button. Protected method. void ExpPalette(); The anchor points are rescaled by a exp operation.; It is called by the exp - button. Protected method. void LinPalette(); The anchor points are rescaled to be linar.; It is called by the lin - button. Protected method. void InvertPalette(); The palette is inverted.; It is called by the invert - button. Protected method. void NewPalette(Long_t id); A new palette is created, depending on the id.; It is called by the combo box. Protected method. void SetStep(); Create a step palette. This is called by the step - check button.; Protected method. void SetRamp(Long_t ramp); The palette is repeated up to 4 times.; This is called by one of the ramp radio buttons. Protected method. void UpdateRange(); Updates the range of the palette.; This is called after the blue limit lines were mo",MatchSource.WIKI,root/html530/TASPaletteEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TASPaletteEditor.html
Integrability,depend,depending,"ProcessMessage(Long_t msg, Long_t param1, Long_t param2); Process all editor mouse events. void InsertNewPalette(TImagePalette* newPalette); The newPalette is inserted in the list of palettes (fPaletteList) and; fPalette is set to the newPalette. Protected method,. void Save(); Saves the current palette either into a ROOT file or in an ASCII file.; It is called by the Save - button. Protected method. void Open(); Opens either a ROOT file or an ASCII file and reads a palette.; It is called by the Open - button. Protected method. void UpdateScreen(Bool_t histoUpdate); All widgeds of the screen are updated with the current palette.; Protected method. void LogPalette(); The anchor points are rescaled by a log operation.; It is called by the log - button. Protected method. void ExpPalette(); The anchor points are rescaled by a exp operation.; It is called by the exp - button. Protected method. void LinPalette(); The anchor points are rescaled to be linar.; It is called by the lin - button. Protected method. void InvertPalette(); The palette is inverted.; It is called by the invert - button. Protected method. void NewPalette(Long_t id); A new palette is created, depending on the id.; It is called by the combo box. Protected method. void SetStep(); Create a step palette. This is called by the step - check button.; Protected method. void SetRamp(Long_t ramp); The palette is repeated up to 4 times.; This is called by one of the ramp radio buttons. Protected method. void UpdateRange(); Updates the range of the palette.; This is called after the blue limit lines were moved to define; a new range. » Author: Reiner Rohlfs 24/03/2002 » Copyright (C) 1995-2002, Rene Brun, Fons Rademakers and Reiner Rohlfs *; » Last changed: root/asimage:$Id: TASPaletteEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TASPaletteEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TASPaletteEditor.html
Testability,log,log,"n documentation; TASPaletteEditor(TAttImage* attImage, UInt_t w, UInt_t h); Palette editor constructor.; The palette editor aloows the editing of the color palette of the image. ~TASPaletteEditor(); Palette editor destructor. Deletes all frames and their layout hints. void CloseWindow(); Close editor. Bool_t ProcessMessage(Long_t msg, Long_t param1, Long_t param2); Process all editor mouse events. void InsertNewPalette(TImagePalette* newPalette); The newPalette is inserted in the list of palettes (fPaletteList) and; fPalette is set to the newPalette. Protected method,. void Save(); Saves the current palette either into a ROOT file or in an ASCII file.; It is called by the Save - button. Protected method. void Open(); Opens either a ROOT file or an ASCII file and reads a palette.; It is called by the Open - button. Protected method. void UpdateScreen(Bool_t histoUpdate); All widgeds of the screen are updated with the current palette.; Protected method. void LogPalette(); The anchor points are rescaled by a log operation.; It is called by the log - button. Protected method. void ExpPalette(); The anchor points are rescaled by a exp operation.; It is called by the exp - button. Protected method. void LinPalette(); The anchor points are rescaled to be linar.; It is called by the lin - button. Protected method. void InvertPalette(); The palette is inverted.; It is called by the invert - button. Protected method. void NewPalette(Long_t id); A new palette is created, depending on the id.; It is called by the combo box. Protected method. void SetStep(); Create a step palette. This is called by the step - check button.; Protected method. void SetRamp(Long_t ramp); The palette is repeated up to 4 times.; This is called by one of the ramp radio buttons. Protected method. void UpdateRange(); Updates the range of the palette.; This is called after the blue limit lines were moved to define; a new range. » Author: Reiner Rohlfs 24/03/2002 » Copyright (C) 1995-2002, Rene Brun, Fons",MatchSource.WIKI,root/html530/TASPaletteEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TASPaletteEditor.html
Usability,undo,undo,tions! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; UInt_tTGMainFrame::fMWMFuncsMWM functions; UInt_tTGMainFrame::fMWMInputMWM input modes; UInt_tTGMainFrame::fMWMValueMWM decoration hints; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; Double_tfMaxValuemax value of image; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; Double_tfMinValuemin value of image; UInt_tTGFrame::fMinWidthminimal frame width; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; TASPaletteEditor::PaintPalette*fPaintPalette; TImagePalette*fPalettecurrent palette; TRootEmbeddedCanvas*fPaletteCanvascanvas to draw the current palette; TList*fPaletteListlist of palettes for undo and redo; const TGWindow*TGWindow::fParentParent window; Int_tfRampFactor; TGRadioButton*fRamps[3]; TGTextButton*fReDoButton; TStringTGMainFrame::fResourceNameWM resource name; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGCheckButton*fStepButton; TGTextButton*fUnDoButton; UInt_tTGMainFrame::fWMHeightWM height; UInt_tTGMainFrame::fWMHeightIncWM height increments; EInitialStateTGMainFrame::fWMInitStateWM initial state; UInt_tTGMainFrame::fWMMaxHeightWM max height; UInt_tTGMainFrame::fWMMaxWidthWM max width; UInt_tTGMainFrame::fWMMinHeightWM min height; UInt_tTGMainFrame::fWMMinWidthWM min width; UInt_tTGMainFrame::fWMWidthWM width; UInt_tTGMainFrame::fWMWidthIncWM width increments; Int_tTGMainFrame::fWMXWM x position; Int_tTGMainFrame::fWMYWM y position; UInt_tTGFrame::fWidthframe width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppr,MatchSource.WIKI,root/html530/TASPaletteEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TASPaletteEditor.html
Availability,error,error,"inGS&); virtual~TASPluginGS(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Bool_tTASImagePlugin::ASImage2File(ASImage*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual ASImage*File2ASImage(const char* filename); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTImagePlugin::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtu",MatchSource.WIKI,root/html530/TASPluginGS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TASPluginGS.html
Safety,safe,safe,". TAtomicCount. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TAtomicCount. class TAtomicCount. TAtomicCount. Class providing atomic operations on a long. Setting, getting,; incrementing and decrementing are atomic, thread safe, operations. TAtomicCount a(n);. (n is convertible to long). Effects: Constructs an TAtomicCount with an initial value of n. long(a);. Returns: (long) the current value of a. ++a;. Effects: Atomically increments the value of a.; Returns: nothing. --a;. Effects: Atomically decrements the value of a.; Returns: (long) zero if the new value of a is zero,; unspecified non-zero value otherwise; (usually the new value). a.Set(n);. Effects: Set a to the value n.; Returns: nothing. a.Get();. Returns: (long) the current value of a. Function Members (Methods); public:. TAtomicCount(Long_t v); ~TAtomicCount(); Long_tGet() const; longoperator long() const; voidoperator++(); Long_toperator--(); voidSet(Long_t v). private:. TAtomicCount(const TAtomicCount&); TAtomicCount&operator=(const TAtomicCount&). Data Members; private:. Long_tfCntcounter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAtomicCount(const TAtomicCount& ). TAtomicCount & operator=(const TAtomicCount& ). explicit TAtomicCount(Long_t v); { }. void operator++(); { ++fCnt; }. Long_t operator--(); { return --fCnt; }. operator long() const; { return fCnt; }. void Set(Long_t v); { fCnt = v; }. Long_t Get() const; { return fCnt; }. » Author: Fons Rademakers 14/11/06 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id: TAtomicCount.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TAtomicCount.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAtomicCount.html
Integrability,interface,interface,". TAtt3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TAtt3D. class TAtt3D. TAtt3D. Use this attribute class when an object should have 3D capabilities. Function Members (Methods); public:. TAtt3D(); TAtt3D(const TAtt3D&); virtual~TAtt3D(); static TClass*Class(); virtual TClass*IsA() const; TAtt3D&operator=(const TAtt3D&); virtual voidShowMembers(TMemberInspector& insp); virtual voidSizeof3D() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Sizeof3D() const; Set total size of this 3D object (used by X3D interface). TAtt3D(); { }. virtual ~TAtt3D(); { }. » Author: Fons Rademakers 08/09/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TAtt3D.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-07-04 15:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TAtt3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAtt3D.html
Performance,optimiz,optimized,"arts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAttAxis(); Constructor. ~TAttAxis(); Destructor. void Copy(TAttAxis& attaxis) const; Copy of the object. void ResetAttAxis(Option_t* option = """"); Reset axis attributes. void SaveAttributes(ostream& out, const char* name, const char* subname); Save axis attributes as C++ statement(s) on output stream out. void SetAxisColor(Color_t color = 1); Set color of the line axis and tick marks. void SetLabelColor(Color_t color = 1); Set color of labels. void SetLabelFont(Style_t font = 62); Set labels' font. void SetLabelOffset(Float_t offset = 0.005); Set distance between the axis and the labels; The distance is expressed in per cent of the pad width. void SetLabelSize(Float_t size = 0.04); Set size of axis labels; The size is expressed in per cent of the pad width. void SetNdivisions(Int_t n = 510, Bool_t optim = kTRUE); Set the number of divisions for this axis. if optim = kTRUE (default), the number of divisions will be; optimized around the specified value.; if optim = kFALSE, or n < 0, the axis will be forced to use; exactly n divisions. n = n1 + 100*n2 + 10000*n3. Where n1 is the number of primary divisions,; n2 is the number of second order divisions and; n3 is the number of third order divisions. e.g. 512 means 12 primary and 5 secondary divisions. If the number of divisions is ""optimized"" (see above) n1, n2, n3 are; maximum values. void SetNdivisions(Int_t n1, Int_t n2, Int_t n3, Bool_t optim = kTRUE); see function above. void SetTickLength(Float_t length = 0.03); Set tick mark length; The length is expressed in per cent of the pad width. void SetTitleOffset(Float_t offset = 1); Set distance between the axis and the axis title; Offset is a correction factor with respect to the ""standard"" value.; offset = 1 uses the default position that is computed in function; of the label offset and size.; offset = 1.2 will add 20 per cent more to the default offset. void SetTitleSize(Float_t size =",MatchSource.WIKI,root/html530/TAttAxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAttAxis.html
Availability,avail,available,". TAttBBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TAttBBox. class TAttBBox. TAttBBox. Helper for management of bounding-box information.; Optionally used by classes that use direct OpenGL rendering; via <Class>GL class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TAttBBox(); Float_t*AssertBBox(); static TClass*Class(); virtual voidComputeBBox(); Float_t*GetBBox(); Bool_tGetBBoxOK() const; virtual TClass*IsA() const; TAttBBox&operator=(const TAttBBox& tab); voidResetBBox(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidAssertBBoxExtents(Float_t epsilon = 0.005); voidBBoxCheckPoint(const Float_t* p); voidBBoxCheckPoint(Float_t x, Float_t y, Float_t z); voidBBoxClear(); voidBBoxInit(Float_t infinity = 1e6); voidBBoxZero(Float_t epsilon = 0, Float_t x = 0, Float_t y = 0, Float_t z = 0). Data Members; protected:. Float_t*fBBox! Dynamic Float_t[6] X(min,max), Y(min,max), Z(min,max). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void BBoxInit(Float_t infinity = 1e6); Allocate and prepare for incremental filling. void BBoxZero(Float_t epsilon = 0, Float_t x = 0, Float_t y = 0, Float_t z = 0); Create cube of volume (2*epsiolon)^3 at (x,y,z).; epsilon iz zero by default. void BBoxClear(); Remove BBox information. void AssertBBoxExtents(Float_t epsilon = 0.005); Assert extents of all sides of the bounding-box are at least epsilon. void BBoxCheckPoint(Float_t x, Float_t y, Float_t z). void BBoxCheckPoint(const Float_t* p). virtual ~TAttBBox(); { BBoxClear(); }. TAttBBox& operator=(const TAttBBox& tab). Bool_t GetBBoxOK() const; { ",MatchSource.WIKI,root/html530/TAttBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAttBBox.html
Availability,avail,available,"e PS, PDF and SVG. pattern_number can have any value from 1 to 25 (see table), or any; value from 100 to 999. For the latest the numbering convention is the following:. pattern_number = ijk (FillStyle = 3ijk); ; i (1-9) : specify the space between each hatch; 1 = 1/2mm 9 = 6mm; ; j (0-9) : specify angle between 0 and 90 degrees; 0 = 0; 1 = 10; 2 = 20; 3 = 30; 4 = 45; 5 = Not drawn; 6 = 60; 7 = 70; 8 = 80; 9 = 90; ; k (0-9) : specify angle between 90 and 180 degrees; 0 = 180; 1 = 170; 2 = 160; 3 = 150; 4 = 135; 5 = Not drawn; 6 = 120; 7 = 110; 8 = 100; 9 = 90. The following table shows the list of pattern styles.; The first table displays the 25 fixed patterns. They cannot be; customized unlike the hatches displayed in the second table which be; customized using:. gStyle->SetHatchesSpacing() to define the spacing between hatches.; gStyle->SetHatchesLineWidth() to define the hatches line width. Picture; Source. TCanvas * fillpatterns(); {; // Fill patterns example. This macro shows the available fill patterns.; // The first table displays the 25 fixed patterns. They cannot be; // customized unlike the hatches displayed in the second table which be ; // cutomized using:; // - gStyle->SetHatchesSpacing() to define the spacing between hatches.; SetHatchesLineWidth() to define the hatches line width.; ; ; ; TCanvas *Pat = new TCanvas(""Fill Patterns"", """",0,0,500,700);; Pat->Range(0,0,1,1);; Pat->SetBorderSize(2);; Pat->SetFrameFillColor(0);; Double_t bh = 0.059;; Double_t db = 0.01; ; Double_t y = 0.995;; Int_t i,j=3001;. ; for (i=1; i<=5; i++) {; box(j++, 0.01, y-bh, 0.19, y);; box(j++, 0.21, y-bh, 0.39, y);; box(j++, 0.41, y-bh, 0.59, y);; box(j++, 0.61, y-bh, 0.79, y);; box(j++, 0.81, y-bh, 0.99, y);; y = y-bh-db;; }. ; y = y-3*db;; gStyle->SetHatchesSpacing(2.0);; gStyle->SetHatchesLineWidth(1);; Int_t j1 = 3144;; Int_t j2 = 3305;; Int_t j3 = 3350;; Int_t j4 = 3490;; Int_t j5 = 3609;; for (i=1; i<=9; i++) {; if (i==6) {j2 += 10; j3 += 1; j4 += 1; j5 += 10;}; if (i==5) ",MatchSource.WIKI,root/html530/TAttFill.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAttFill.html
Modifiability,inherit,inheritance,". TAttFill. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TAttFill. class TAttFill. Fill Area Attributes class; This class is used (in general by secondary inheritance); by many other classes (graphics, histograms). It holds all the fill area; attributes.; Fill Area attributes; Fill Area attributes are:. Fill Area color.; Fill Area style. Fill Area color; The fill area color is a color index (integer) pointing in the ROOT; color table.; The fill area color of any class inheriting from TAttFill can; be changed using the method SetFillColor and retrieved using the; method GetFillColor.; The following table shows the first 50 default colors. Picture; Source. {; TCanvas *c = new TCanvas(""c"",""Fill Area colors"",0,0,500,200);; c.DrawColorTable();; return c;; }. The ROOT Color Wheel.; The wheel contains the recommended 216 colors to be used in web applications.; The colors in the Color Wheel are created by TColor::CreateColorWheel.; Using this color set for your text, background or graphics will give your; application a consistent appearance across different platforms and browsers.; Colors are grouped by hue, the aspect most important in human perception ; Touching color chips have the same hue, but with different brightness and vividness.; Colors of slightly different hues clash. If you intend to display; colors of the same hue together, you should pick them from the same group.; Each color chip is identified by a mnemonic (eg kYellow) and a number.; The keywords, kRed, kBlue, kYellow, kPink, etc are defined in the header file Rtypes.h; that is included in all ROOT other header files. We strongly recommend to use these keywords; in your code instead of hardcoded color numbers, eg:. myObject.SetFillColor(kRed);; myObject.SetFillColor(kYellow-10);; myLine.SetLineColor(kMagenta+2);. Picture; Sou",MatchSource.WIKI,root/html530/TAttFill.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAttFill.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TAttFillEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAttFillEditor.html
Energy Efficiency,allocate,allocated,"rate of the color data in the; internal image structure. Speed and memory depends; on this rate, but not the image display itself; 0: no compression; 100: max compression; Radio Flag: kTRUE the x/y radio of the displayed image is always; identical to the original image; kFALSE the x and y size of the displayed image depends; on the size of the pad; Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display). TImagePalette. A class to define a conversion from pixel values to pixel color.; A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predifined palettes:. o gHistImagePalette - palette used in TH2::Draw(""col""). o gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality convertion of images into; 2-D histograms. o TImagePalette(Int_t ncolors, Int_t *colors); if ncolors <= 0 a default palette (see below) of 50 colors; is defined. if ncolors == 1 && colors == 0, then; a Pretty Palette with a Spectrum Violet->Red is created. if ncolors > 50 and colors=0, the DeepSea palette is used.; (see TStyle::CreateGradientColorTable for more details). if ncolors > 0 and colors = 0, the default palette is used; with a maximum of ncolors. The default palette defines:; index 0->9 : ",MatchSource.WIKI,root/html530/TAttImage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAttImage.html
Integrability,depend,depends,". TAttImage. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TAttImage. class TAttImage. TAttImage. Image attributes are:; Image Quality (see EImageQuality for the list of qualities); Compression defines the compression rate of the color data in the; internal image structure. Speed and memory depends; on this rate, but not the image display itself; 0: no compression; 100: max compression; Radio Flag: kTRUE the x/y radio of the displayed image is always; identical to the original image; kFALSE the x and y size of the displayed image depends; on the size of the pad; Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display). TImagePalette. A class to define a conversion from pixel values to pixel color.; A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predifined palettes:. o gHistImagePalette - palette used in TH2::Draw(""col""). o gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality convertion of images into; 2-D histograms. o TImagePalette(Int_t ncolors, Int_t *colors); if ncolor",MatchSource.WIKI,root/html530/TAttImage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAttImage.html
Modifiability,inherit,inheritance,". TAttImage. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TAttImage. class TAttImage. TAttImage. Image attributes are:; Image Quality (see EImageQuality for the list of qualities); Compression defines the compression rate of the color data in the; internal image structure. Speed and memory depends; on this rate, but not the image display itself; 0: no compression; 100: max compression; Radio Flag: kTRUE the x/y radio of the displayed image is always; identical to the original image; kFALSE the x and y size of the displayed image depends; on the size of the pad; Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display). TImagePalette. A class to define a conversion from pixel values to pixel color.; A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predifined palettes:. o gHistImagePalette - palette used in TH2::Draw(""col""). o gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality convertion of images into; 2-D histograms. o TImagePalette(Int_t ncolors, Int_t *colors); if ncolor",MatchSource.WIKI,root/html530/TAttImage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAttImage.html
Modifiability,inherit,inheritance,". TAttLine. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TAttLine. class TAttLine. Line Attributes class; This class is used (in general by secondary inheritance); by many other classes (graphics, histograms). It holds all the line attributes.; Line attributes; Line attributes are:. Line Color.; Line Width.; Line Style. Line Color; The line color is a color index (integer) pointing in the ROOT; color table.; The line color of any class inheriting from TAttLine can; be changed using the method SetLineColor and retrieved using the; method GetLineColor.; The following table shows the first 50 default colors. Picture; Source. {; TCanvas *c = new TCanvas(""c"",""Line colors"",0,0,500,200);; c.DrawColorTable();; return c;; }. Line Width; The line width is expressed in pixel units.; The line width of any class inheriting from TAttLine can; be changed using the method SetLineWidth and retrieved using the; method GetLineWidth.; The following picture shows the line widths from 1 to 10 pixels. Picture; Source. {; TCanvas *Lw = new TCanvas(""Lw"",""test"",500,200);; TText t;; t.SetTextAlign(32);; t.SetTextSize(0.08);; Int_t i=1;; for (float s=0.1; s<1.0 ; s+=0.092) {; TLine *lh = new TLine(0.15,s,.85,s);; lh->SetLineWidth(i);; t.DrawText(0.1,s,Form(""%d"",i++));; lh->Draw();; }; return Lw;; }. Line Style; Line styles are identified via integer numbers. The line style of any class; inheriting from TAttLine can be changed using the method; SetLineStyle and retrieved using the method GetLineStyle. The first 10 line styles are predefined as shown on the following picture:. Picture; Source. {; TCanvas *Ls = new TCanvas(""Ls"",""test"",500,200);; TText t;; t.SetTextAlign(32);; t.SetTextSize(0.08);; Int_t i=1;; for (float s=0.1; s<1.0 ; s+=0.092) {; TLine *lh = new TLine(0.15,s,.85,s);; lh->SetLineStyle(i);; t.DrawTe",MatchSource.WIKI,root/html530/TAttLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAttLine.html
Testability,test,test,"ORE; » BASE; » TAttLine. class TAttLine. Line Attributes class; This class is used (in general by secondary inheritance); by many other classes (graphics, histograms). It holds all the line attributes.; Line attributes; Line attributes are:. Line Color.; Line Width.; Line Style. Line Color; The line color is a color index (integer) pointing in the ROOT; color table.; The line color of any class inheriting from TAttLine can; be changed using the method SetLineColor and retrieved using the; method GetLineColor.; The following table shows the first 50 default colors. Picture; Source. {; TCanvas *c = new TCanvas(""c"",""Line colors"",0,0,500,200);; c.DrawColorTable();; return c;; }. Line Width; The line width is expressed in pixel units.; The line width of any class inheriting from TAttLine can; be changed using the method SetLineWidth and retrieved using the; method GetLineWidth.; The following picture shows the line widths from 1 to 10 pixels. Picture; Source. {; TCanvas *Lw = new TCanvas(""Lw"",""test"",500,200);; TText t;; t.SetTextAlign(32);; t.SetTextSize(0.08);; Int_t i=1;; for (float s=0.1; s<1.0 ; s+=0.092) {; TLine *lh = new TLine(0.15,s,.85,s);; lh->SetLineWidth(i);; t.DrawText(0.1,s,Form(""%d"",i++));; lh->Draw();; }; return Lw;; }. Line Style; Line styles are identified via integer numbers. The line style of any class; inheriting from TAttLine can be changed using the method; SetLineStyle and retrieved using the method GetLineStyle. The first 10 line styles are predefined as shown on the following picture:. Picture; Source. {; TCanvas *Ls = new TCanvas(""Ls"",""test"",500,200);; TText t;; t.SetTextAlign(32);; t.SetTextSize(0.08);; Int_t i=1;; for (float s=0.1; s<1.0 ; s+=0.092) {; TLine *lh = new TLine(0.15,s,.85,s);; lh->SetLineStyle(i);; t.DrawText(0.1,s,Form(""%d"",i++));; lh->Draw();; }; return Ls;; }. Additional line styles can be defined using TStyle::SetLineStyleString.; For example the line style number 11 can be defined as follow:. gStyle->SetLineStyleString(11,""40",MatchSource.WIKI,root/html530/TAttLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAttLine.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TAttLineEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAttLineEditor.html
Availability,down,down,"etrieved using the; method GetMarkerColor.; The following table shows the first 50 default colors. Picture; Source. {; TCanvas *c = new TCanvas(""c"",""Marker colors"",0,0,500,200);; c.DrawColorTable();; return c;; }. Marker style; The Marker style defines the markers' shape.; The marker style of any class inheriting from TAttMarker can; be changed using the method SetMarkerStyle and retrieved using the; method GetMarkerStyle.; The following list gives the currently supported markers (screen; and PostScript) style. Each marker style is identified by an integer number; (first column) corresponding to a marker shape (second column) and can be also; accessed via a global name (third column). Marker number Marker shape Marker name; 1 dot kDot; 2 + kPlus; 3 * kStar; 4 o kCircle; 5 x kMultiply; 6 small dot kFullDotSmall; 7 medium dot kFullDotMedium; 8 large scalable dot kFullDotLarge; 9 -->19 large scalable dot; 20 full circle kFullCircle; 21 full square kFullSquare; 22 full triangle up kFullTriangleUp; 23 full triangle down kFullTriangleDown; 24 open circle kOpenCircle; 25 open square kOpenSquare; 26 open triangle up kOpenTriangleUp; 27 open diamond kOpenDiamond; 28 open cross kOpenCross; 29 full star kOpenStar; 30 open star kFullStar; 31 *; 32 open triangle down; 33 full diamond; 34 full cross. Picture; Source. {; TCanvas *c = new TCanvas(""c"",""Marker types"",0,0,500,200);; TMarker marker;; marker.DisplayMarkerTypes();; return c;; }. Marker size; Various marker sizes are shown in the figure below. The default marker size=1; is shown in the top left corner. Marker sizes smaller than 1 can be; specified. The marker size does not refer to any coordinate systems, it is an; absolute value. Therefore the marker size is not affected by any change; in TPad's scale. A marker size equl to 1 correspond to 8 pixels.; That is, a square marker with size 1 will be drawn with a side equal to 8; pixels on the screen.; The marker size of any class inheriting from TAttMarker can; be changed usi",MatchSource.WIKI,root/html530/TAttMarker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAttMarker.html
Modifiability,inherit,inheritance,". TAttMarker. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TAttMarker. class TAttMarker. Marker Attributes class; This class is used (in general by secondary inheritance); by many other classes (graphics, histograms). It holds all the markers; attributes.; Marker attributes; The marker attributes are:. Marker color.; Marker style.; Marker size. Marker color; The marker color is a color index (integer) pointing in the ROOT color; table.; The marker color of any class inheriting from TAttMarker can; be changed using the method SetMarkerColor and retrieved using the; method GetMarkerColor.; The following table shows the first 50 default colors. Picture; Source. {; TCanvas *c = new TCanvas(""c"",""Marker colors"",0,0,500,200);; c.DrawColorTable();; return c;; }. Marker style; The Marker style defines the markers' shape.; The marker style of any class inheriting from TAttMarker can; be changed using the method SetMarkerStyle and retrieved using the; method GetMarkerStyle.; The following list gives the currently supported markers (screen; and PostScript) style. Each marker style is identified by an integer number; (first column) corresponding to a marker shape (second column) and can be also; accessed via a global name (third column). Marker number Marker shape Marker name; 1 dot kDot; 2 + kPlus; 3 * kStar; 4 o kCircle; 5 x kMultiply; 6 small dot kFullDotSmall; 7 medium dot kFullDotMedium; 8 large scalable dot kFullDotLarge; 9 -->19 large scalable dot; 20 full circle kFullCircle; 21 full square kFullSquare; 22 full triangle up kFullTriangleUp; 23 full triangle down kFullTriangleDown; 24 open circle kOpenCircle; 25 open square kOpenSquare; 26 open triangle up kOpenTriangleUp; 27 open diamond kOpenDiamond; 28 open cross kOpenCross; 29 full star kOpenStar; 30 open star kFullStar; 31 *; 32 open tri",MatchSource.WIKI,root/html530/TAttMarker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAttMarker.html
Performance,scalab,scalable,"etrieved using the; method GetMarkerColor.; The following table shows the first 50 default colors. Picture; Source. {; TCanvas *c = new TCanvas(""c"",""Marker colors"",0,0,500,200);; c.DrawColorTable();; return c;; }. Marker style; The Marker style defines the markers' shape.; The marker style of any class inheriting from TAttMarker can; be changed using the method SetMarkerStyle and retrieved using the; method GetMarkerStyle.; The following list gives the currently supported markers (screen; and PostScript) style. Each marker style is identified by an integer number; (first column) corresponding to a marker shape (second column) and can be also; accessed via a global name (third column). Marker number Marker shape Marker name; 1 dot kDot; 2 + kPlus; 3 * kStar; 4 o kCircle; 5 x kMultiply; 6 small dot kFullDotSmall; 7 medium dot kFullDotMedium; 8 large scalable dot kFullDotLarge; 9 -->19 large scalable dot; 20 full circle kFullCircle; 21 full square kFullSquare; 22 full triangle up kFullTriangleUp; 23 full triangle down kFullTriangleDown; 24 open circle kOpenCircle; 25 open square kOpenSquare; 26 open triangle up kOpenTriangleUp; 27 open diamond kOpenDiamond; 28 open cross kOpenCross; 29 full star kOpenStar; 30 open star kFullStar; 31 *; 32 open triangle down; 33 full diamond; 34 full cross. Picture; Source. {; TCanvas *c = new TCanvas(""c"",""Marker types"",0,0,500,200);; TMarker marker;; marker.DisplayMarkerTypes();; return c;; }. Marker size; Various marker sizes are shown in the figure below. The default marker size=1; is shown in the top left corner. Marker sizes smaller than 1 can be; specified. The marker size does not refer to any coordinate systems, it is an; absolute value. Therefore the marker size is not affected by any change; in TPad's scale. A marker size equl to 1 correspond to 8 pixels.; That is, a square marker with size 1 will be drawn with a side equal to 8; pixels on the screen.; The marker size of any class inheriting from TAttMarker can; be changed usi",MatchSource.WIKI,root/html530/TAttMarker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAttMarker.html
Security,access,accessed,"ry inheritance); by many other classes (graphics, histograms). It holds all the markers; attributes.; Marker attributes; The marker attributes are:. Marker color.; Marker style.; Marker size. Marker color; The marker color is a color index (integer) pointing in the ROOT color; table.; The marker color of any class inheriting from TAttMarker can; be changed using the method SetMarkerColor and retrieved using the; method GetMarkerColor.; The following table shows the first 50 default colors. Picture; Source. {; TCanvas *c = new TCanvas(""c"",""Marker colors"",0,0,500,200);; c.DrawColorTable();; return c;; }. Marker style; The Marker style defines the markers' shape.; The marker style of any class inheriting from TAttMarker can; be changed using the method SetMarkerStyle and retrieved using the; method GetMarkerStyle.; The following list gives the currently supported markers (screen; and PostScript) style. Each marker style is identified by an integer number; (first column) corresponding to a marker shape (second column) and can be also; accessed via a global name (third column). Marker number Marker shape Marker name; 1 dot kDot; 2 + kPlus; 3 * kStar; 4 o kCircle; 5 x kMultiply; 6 small dot kFullDotSmall; 7 medium dot kFullDotMedium; 8 large scalable dot kFullDotLarge; 9 -->19 large scalable dot; 20 full circle kFullCircle; 21 full square kFullSquare; 22 full triangle up kFullTriangleUp; 23 full triangle down kFullTriangleDown; 24 open circle kOpenCircle; 25 open square kOpenSquare; 26 open triangle up kOpenTriangleUp; 27 open diamond kOpenDiamond; 28 open cross kOpenCross; 29 full star kOpenStar; 30 open star kFullStar; 31 *; 32 open triangle down; 33 full diamond; 34 full cross. Picture; Source. {; TCanvas *c = new TCanvas(""c"",""Marker types"",0,0,500,200);; TMarker marker;; marker.DisplayMarkerTypes();; return c;; }. Marker size; Various marker sizes are shown in the figure below. The default marker size=1; is shown in the top left corner. Marker sizes smaller than 1 can ",MatchSource.WIKI,root/html530/TAttMarker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAttMarker.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TAttMarkerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAttMarkerEditor.html
Availability,error,error,"tParticle(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; static Int_tConvertISAtoPDG(Int_t isaNumber); virtual voidTNamed::Copy(TObject& named) const; static voidDefinePDG(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tGetCharge() const; virtual Double_tGetDecayWidth() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tGetEnergyCut() const; virtual Double_tGetEnergyLimit() const; virtual Double_tGetGranularity() const; virtual const char*TObject::GetIconName() const; virtual Double_tGetMass() const; virtual Int_tGetMCNumber() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static TA",MatchSource.WIKI,root/html530/TAttParticle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAttParticle.html
Energy Efficiency,energy,energy,"voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. static THashList*fgList. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_tfEnergyCutLower energy cut off, the default is 10 keV; Double_tfEnergyLimitHigh energy cut off, the default is 10 TeV; Double_tfGranularityGranularity of the fLogEScale; Int_tfMCnumberOfPDGPDG MC number followed by; Double_tfPDGChargeCharge of the particle in units of e; Double_tfPDGDecayWidthLife time of the particle in sec.; Double_tfPDGMassMass of the particle in GeV/c2; Bool_tfPDGStableLogical indicator, if TRUE the particle can not decay; TStringfParticleTypeText indicator for the particle family. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAttParticle(). Particle definition default constructor. TAttParticle(const char* name, const char* title, Double_t Mass, Bool_t Stable, Double_t DecayWidth, Double_t Charge, const char* Type, Int_t MCnumber, Int_t granularity = 90, Double_t LowerCutOff = 1.e-5, Double_t HighCutOff = 1.e4). Particle definition normal constructor. If the particle is set to be; stable, the decay width parameter does have no meaning and can be set to; any value. The parameters granularity, LowerCutOff and HighCutOff are; used for the construction of the mean free path look ",MatchSource.WIKI,root/html530/TAttParticle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAttParticle.html
Testability,log,logwise,"fPDGChargeCharge of the particle in units of e; Double_tfPDGDecayWidthLife time of the particle in sec.; Double_tfPDGMassMass of the particle in GeV/c2; Bool_tfPDGStableLogical indicator, if TRUE the particle can not decay; TStringfParticleTypeText indicator for the particle family. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAttParticle(). Particle definition default constructor. TAttParticle(const char* name, const char* title, Double_t Mass, Bool_t Stable, Double_t DecayWidth, Double_t Charge, const char* Type, Int_t MCnumber, Int_t granularity = 90, Double_t LowerCutOff = 1.e-5, Double_t HighCutOff = 1.e4). Particle definition normal constructor. If the particle is set to be; stable, the decay width parameter does have no meaning and can be set to; any value. The parameters granularity, LowerCutOff and HighCutOff are; used for the construction of the mean free path look up tables. The; granularity will be the number of logwise energy points for which the; mean free path will be calculated. ~TAttParticle(). Particle destructor. Int_t ConvertISAtoPDG(Int_t isaNumber). Converts the ISAJET Particle number into the PDG MC number. void DefinePDG(). Defines particles according to the Particle Data Group. For questions regarding distribution or content of the MC particle; codes, contact; Gary Wagman (GSWagman@LBL.BITNET, LBL::GSWagman, or GSWagman@LBL.GOV).; (510)486-6610. TAttParticle* GetParticle(const char* name). Get a pointer to the particle object according to the name given. TAttParticle* GetParticle(Int_t mcnumber). Get a pointer to the particle object according to the MC code number. void Print(Option_t* option = """") const. Print the entire information of this kind of particle. Double_t SampleMass() const. Samples a mass according to the Breit-Wigner resonance distribution. Double_t SampleMass(Double_t widthcut) const. Samples a mass in the interval:. fPDGMass-widthcut*fPDGDecayWidtht - fPDGMass+widthcut*fPDGDecayW",MatchSource.WIKI,root/html530/TAttParticle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAttParticle.html
Integrability,depend,depend,"^{o}"");; t1->Draw();; return Ta;; }. Text Color; The text color is a color index (integer) pointing in the ROOT; color table.; The text color of any class inheriting from TAttText can; be changed using the method SetTextColor and retrieved using the; method GetTextColor.; The following table shows the first 50 default colors. Picture; Source. {; TCanvas *c = new TCanvas(""c"",""Text colors"",0,0,500,200);; c.DrawColorTable();; return c;; }. Text Size; If the text precision (see next paragraph) is smaller than 3, the text; size (textsize) is a fraction of the current pad size. Therefore the; same textsize value can generate text outputs with different absolute; sizes in two different pads.; The text size in pixels (charheight) is computed the following way:. pad_width = gPad->XtoPixel(gPad->GetX2());; pad_height = gPad->YtoPixel(gPad->GetY1());; if (pad_width < pad_height) charheight = textsize*pad_width;; else charheight = textsize*pad_height;. If the text precision is equal to 3, the text size doesn't depend on the pad's; dimensions. A given textsize value always generates the same absolute; size. The text size (charheight) is given in pixels:. charheight = textsize;. Note that to scale fonts to the same size as the old True Type package a; scale factor of 0.93376068 is apply to the text size before drawing. The text size of any class inheriting from TAttText can; be changed using the method SetTextSize and retrieved using the; method GetTextSize.; Text Font and Precision; The text font code is combination of the font number and the precision. Text font code = 10*fontnumber + precision. Font numbers must be between 1 and 14. The precision can be:; precision = 0 fast hardware fonts (steps in the size); precision = 1 scalable and rotatable hardware fonts (see below); precision = 2 scalable and rotatable hardware fonts; precision = 3 scalable and rotatable hardware fonts. Text size; is given in pixels. The text font and precision of any class inheriting from TAttText can;",MatchSource.WIKI,root/html530/TAttText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAttText.html
Modifiability,inherit,inheritance,". TAttText. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TAttText. class TAttText. Text Attributes class; This class is used (in general by secondary inheritance); by many other classes (graphics, histograms). It holds all the text attributes.; Text attributes; Text attributes are:. Text Alignment.; Text Angle.; Text Color.; Text Size.; Text Font and Precision. Font quality and speed.; How to use True Type Fonts.; List of the currently supported fonts. Text Alignment; The text alignment is an integer number (align) allowing to control; the horizontal and vertical position of the text string with respect; to the text position.; The text alignment of any class inheriting from TAttText can; be changed using the method SetTextAlign and retrieved using the; method GetTextAlign. align = 10*HorizontalAlign + VerticalAlign. For horizontal alignment the following convention applies:. 1=left adjusted, 2=centered, 3=right adjusted. For vertical alignment the following convention applies:. 1=bottom adjusted, 2=centered, 3=top adjusted. For example:. align = 11 = left adjusted and bottom adjusted; align = 32 = right adjusted and vertically centered. Picture; Source. {; TCanvas *Ta = new TCanvas(""Ta"",""Ta"",0,0,500,200);; Ta->Range(0,0,1,1);. TLine *lv = new TLine;; lv->SetLineStyle(3); lv->SetLineColor(kBlue);; lv->DrawLine(0.33,0.0,0.33,1.0);; lv->DrawLine(0.6,0.165,1.,0.165);; lv->DrawLine(0.6,0.493,1.,0.493);; lv->DrawLine(0.6,0.823,1.,0.823);. // Horizontal alignment.; TText *th1 = new TText(0.33,0.165,""Left adjusted"");; th1->SetTextAlign(11); th1->SetTextSize(0.12);; th1->Draw();. TText *th2 = new TText(0.33,0.493,""Center adjusted"");; th2->SetTextAlign(21); th2->SetTextSize(0.12);; th2->Draw();. TText *th3 = new TText(0.33,0.823,""Right adjusted"");; th3->SetTextAlign(31); th3->SetTextSize(0.12);",MatchSource.WIKI,root/html530/TAttText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAttText.html
Performance,scalab,scalable," = gPad->XtoPixel(gPad->GetX2());; pad_height = gPad->YtoPixel(gPad->GetY1());; if (pad_width < pad_height) charheight = textsize*pad_width;; else charheight = textsize*pad_height;. If the text precision is equal to 3, the text size doesn't depend on the pad's; dimensions. A given textsize value always generates the same absolute; size. The text size (charheight) is given in pixels:. charheight = textsize;. Note that to scale fonts to the same size as the old True Type package a; scale factor of 0.93376068 is apply to the text size before drawing. The text size of any class inheriting from TAttText can; be changed using the method SetTextSize and retrieved using the; method GetTextSize.; Text Font and Precision; The text font code is combination of the font number and the precision. Text font code = 10*fontnumber + precision. Font numbers must be between 1 and 14. The precision can be:; precision = 0 fast hardware fonts (steps in the size); precision = 1 scalable and rotatable hardware fonts (see below); precision = 2 scalable and rotatable hardware fonts; precision = 3 scalable and rotatable hardware fonts. Text size; is given in pixels. The text font and precision of any class inheriting from TAttText can; be changed using the method SetTextFont and retrieved using the; method GetTextFont.; Font quality and speed; When precision 0 is used, only the original non-scaled system fonts are; used. The fonts have a minimum (4) and maximum (37) size in pixels. These; fonts are fast and are of good quality. Their size varies with large steps; and they cannot be rotated.; Precision 1 and 2 fonts have a different behaviour depending if the; True Type Fonts (TTF) are used or not. If TTF are used, you always get very good; quality scalable and rotatable fonts. However TTF are slow.; How to use True Type Fonts; One can activate the TTF by adding (or activating) the following line; in the .rootrc file:. Unix.*.Root.UseTTFonts: true. It is possible to check the TTF are in use in a",MatchSource.WIKI,root/html530/TAttText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAttText.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TAttTextEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAttTextEditor.html
Integrability,message,message,"ox*fTypeCombofont style combo box; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAttTextEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor of text attributes GUI. ~TAttTextEditor(); Destructor of text editor. void SetModel(TObject* obj); Pick up the values of used text attributes. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process message. TGComboBox* BuildFontSizeComboBox(TGFrame* parent, Int_t id); Create text size combo box. TGComboBox* BuildTextAlignComboBox(TGFrame* parent, Int_t id); Create text align combo box. » Author: Ilka Antcheva 11/05/04 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id: TAttTextEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TAttTextEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAttTextEditor.html
Availability,error,error," TAuthenticate(const TAuthenticate&); TAuthenticate(TSocket* sock, const char* remote, const char* proto, const char* user = """"); virtual~TAuthenticate(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tAuthenticate(); static voidAuthError(const char* where, Int_t error); Int_tAuthExists(TString User, Int_t method, const char* Options, Int_t* Message, Int_t* Rflag, CheckSecCtx_t funcheck); virtual voidTObject::Browse(TBrowser* b); voidCatchTimeOut(); Bool_tCheckNetrc(TString& user, TString& passwd); Bool_tCheckNetrc(TString& user, TString& passwd, Bool_t& pwhash, Bool_t srppwd); static Bool_tCheckProofAuth(Int_t cSec, TString& det); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static Int_tDecodeRSAPublic(const char* rsapubexport, rsa_NUMBER& n, rsa_NUMBER& d, char** rsassl = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int",MatchSource.WIKI,root/html530/TAuthenticate.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAuthenticate.html
Deployability,update,update,"Int_t klen); Store RSA public keys from export string rsaPubExport.; Returns type of stored key, or -1 is not recognized. Int_t SendRSAPublicKey(TSocket* Socket, Int_t key = 0); Receives server RSA Public key; Sends local RSA public key encoded. Int_t ReadRootAuthrc(); Read authentication directives from $ROOTAUTHRC, $HOME/.rootauthrc or; <Root_etc_dir>/system.rootauthrc and create related THostAuth objects.; Files are read only if they changed since last reading; If 'proofconf' is defined, check also file proofconf for directives. Bool_t CheckProofAuth(Int_t cSec, TString& det); Check if the authentication method can be attempted for the client. void MergeHostAuthList(TList* Std, TList* New, Option_t* Opt = """"); Tool for updating fgAuthInfo or fgProofAuthInfo; 'nin' contains list of last input information through (re)reading; of a rootauthrc-alike file. 'nin' info has priority.; 'std' is cleaned from inactive members.; 'nin' members used to update existing members in 'std' are; removed from 'nin', do that they do not leak; opt = ""P"" for proofauthinfo. void RemoveSecContext(TRootSecContext* ctx); Tool for removing SecContext ctx from THostAuth listed in; fgAuthInfo or fgProofAuthInfo. Int_t ProofAuthSetup(); Authentication related stuff setup in TProofServ.; This is the place where the buffer send by the client / master is; decoded. It contains also password information, if the case requires.; Return 0 on success, -1 on failure. Int_t ProofAuthSetup(TSocket* sock, Bool_t client); Setup of authetication related stuff in PROOF run after a; successful authentication.; Return 0 on success, -1 on failure. Int_t GetClientProtocol(); Static method returning supported client protocol. Bool_t GetPwHash() const; { return fPwHash; }. Int_t GetRSAKey() const; { return fRSAKey; }. ESecurity GetSecurity() const; { return fSecurity; }. Bool_t GetSRPPwd() const; { return fSRPPwd; }. Int_t GetVersion() const; { return fVersion; }. TAuthenticate(TSocket* sock, const char* remote, con",MatchSource.WIKI,root/html530/TAuthenticate.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAuthenticate.html
Integrability,depend,dependent," voidFileExpand(const char* fin, FILE* ftmp); Int_tGenRSAKeys(); Bool_tGetPwHash() const; char*GetRandString(Int_t Opt, Int_t Len); Int_tGetRSAKey() const; TAuthenticate::ESecurityGetSecurity() const; Bool_tGetSRPPwd() const; const char*GetSshUser(TString user) const; Bool_tGetUserPasswd(TString& user, TString& passwd, Bool_t& pwhash, Bool_t srppwd); Int_tGetVersion() const; Int_tProofAuthSetup(); static Int_tProofAuthSetup(TSocket* sock, Bool_t client); static voidRemoveSecContext(TRootSecContext* ctx); Int_tRfioAuth(TString& user); voidSetEnvironment(); Int_tSshAuth(TString& user); Int_tSshError(const char* errfile). Data Members; public:. enum ESecurity { kClear; kSRP; kKrb5; kGlobus; kSSH; kRfio; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStringfDetailslogon details (method dependent ...); THostAuth*fHostAuthpointer to relevant authentication info; TStringfPasswduser's password; TStringfProtocolremote service (rootd, proofd); Bool_tfPwHashkTRUE if fPasswd is a passwd hash; Int_tfRSAKeyType of RSA key used; TStringfRemoteremote host to which we want to connect; Bool_tfSRPPwdkTRUE if fPasswd is a SRP passwd; TRootSecContext*fSecContextpointer to relevant sec context; TAuthenticate::ESecurityfSecurityactual logon security level; TSocket*fSocketconnection to remote daemon; Int_tfTimeOuttimeout flag; TStringfUseruser to be authenticated; Int_tfVersion0,1,2, ... accordingly to remote daemon version; static TList*fgAuthInfo; static TStringfgAuthMeth[6]; static Bool_tfgAuthReUsekTRUE is ReUse required; static Int_tfgAuthTOif > 0, timeout in sec; static TStringfgDefaultUserDefault user information; static TDatimefgExpDateExpiring date for new security contexts; static GlobusAuth_tfgGlobusAuthHook; static Krb5Auth_tfgKrb5AuthHook; static TStringfgKrb5P",MatchSource.WIKI,root/html530/TAuthenticate.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAuthenticate.html
Modifiability,plugin,plugin,"); Bool_tfPwHashkTRUE if fPasswd is a passwd hash; Int_tfRSAKeyType of RSA key used; TStringfRemoteremote host to which we want to connect; Bool_tfSRPPwdkTRUE if fPasswd is a SRP passwd; TRootSecContext*fSecContextpointer to relevant sec context; TAuthenticate::ESecurityfSecurityactual logon security level; TSocket*fSocketconnection to remote daemon; Int_tfTimeOuttimeout flag; TStringfUseruser to be authenticated; Int_tfVersion0,1,2, ... accordingly to remote daemon version; static TList*fgAuthInfo; static TStringfgAuthMeth[6]; static Bool_tfgAuthReUsekTRUE is ReUse required; static Int_tfgAuthTOif > 0, timeout in sec; static TStringfgDefaultUserDefault user information; static TDatimefgExpDateExpiring date for new security contexts; static GlobusAuth_tfgGlobusAuthHook; static Krb5Auth_tfgKrb5AuthHook; static TStringfgKrb5PrincipalPrincipal for Krb5 ticket; static TDatimefgLastAuthrcTime of last reading of fgRootAuthrc; static Int_tfgLastErrorLast error code processed by AuthError(); static TStringfgPasswd; static TPluginHandler*fgPasswdDialogPasswd dialog GUI plugin; static Int_tfgProcessIDID of the main thread as unique identifier; static Bool_tfgPromptUserkTRUE if user prompt required; static TList*fgProofAuthInfoSpecific lists of THostAuth fro proof; static Bool_tfgPwHashkTRUE if fgPasswd is a passwd hash; static Int_tfgRSAInit; static Int_tfgRSAKeyDefault type of RSA key to be tried; static rsa_KEYfgRSAPriKey; static rsa_KEY_exportfgRSAPubExport[2]; static rsa_KEYfgRSAPubKey; static Bool_tfgReadHomeAuthrckTRUE to look for $HOME/.rootauthrc; static TStringfgRootAuthrcPath to last rootauthrc-like file read; static Bool_tfgSRPPwdkTRUE if fgPasswd is a SRP passwd; static SecureAuth_tfgSecAuthHook; static TStringfgUser; static Bool_tfgUsrPwdCryptkTRUE if encryption for UsrPwd is required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAuthenticate(TSocket* sock, const char* remote, const char* proto, const char* user = """")",MatchSource.WIKI,root/html530/TAuthenticate.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAuthenticate.html
Performance,load,loaded,"wd(const char* passwd); Set global passwd to be used for authentication to rootd or proofd. void SetGlobalPwHash(Bool_t pwhash); Set global passwd hash flag to be used for authentication to rootd or proofd. void SetGlobalSRPPwd(Bool_t srppwd); Set global SRP passwd flag to be used for authentication to rootd or proofd. void SetReadHomeAuthrc(Bool_t readhomeauthrc); Set flag controlling the reading of $HOME/.rootauthrc.; In PROOF the administrator may want to switch off private settings.; Always true, may only be set false via option to proofd. void SetGlobalExpDate(TDatime expdate); Set default expiring date for new validity contexts. void SetDefaultUser(const char* defaultuser); Set default user name. void SetTimeOut(Int_t to); Set timeout (active if > 0). void SetAuthReUse(Bool_t authreuse); Set global AuthReUse flag. void SetPromptUser(Bool_t promptuser); Set global PromptUser flag. void SetSecureAuthHook(SecureAuth_t func); Set secure authorization function. Automatically called when libSRPAuth; is loaded. void SetKrb5AuthHook(Krb5Auth_t func); Set kerberos5 authorization function. Automatically called when; libKrb5Auth is loaded. void SetGlobusAuthHook(GlobusAuth_t func); Set Globus authorization function. Automatically called when; libGlobusAuth is loaded. Int_t SshError(const char* errfile); SSH error parsing: returns; 0 : no error or fatal; 1 : should retry (eg 'connection closed by remote host'). Int_t SshAuth(TString& user); SSH client authentication code. const char * GetSshUser(TString user) const; Method returning the user to be used for the ssh login.; Looks first at SSH.Login and finally at env USER.; If SSH.LoginPrompt is set to 'yes' it prompts for the 'login name'. Bool_t CheckHost(const char* Host, const char* host); Check if 'host' matches 'href':; this means either equal or ""containing"" it, even with wild cards *; in the first field (in the case 'href' is a name, ie not IP address); Returns kTRUE if the two matches. Int_t RfioAuth(TString& user);",MatchSource.WIKI,root/html530/TAuthenticate.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAuthenticate.html
Safety,timeout,timeout,"); Bool_tfPwHashkTRUE if fPasswd is a passwd hash; Int_tfRSAKeyType of RSA key used; TStringfRemoteremote host to which we want to connect; Bool_tfSRPPwdkTRUE if fPasswd is a SRP passwd; TRootSecContext*fSecContextpointer to relevant sec context; TAuthenticate::ESecurityfSecurityactual logon security level; TSocket*fSocketconnection to remote daemon; Int_tfTimeOuttimeout flag; TStringfUseruser to be authenticated; Int_tfVersion0,1,2, ... accordingly to remote daemon version; static TList*fgAuthInfo; static TStringfgAuthMeth[6]; static Bool_tfgAuthReUsekTRUE is ReUse required; static Int_tfgAuthTOif > 0, timeout in sec; static TStringfgDefaultUserDefault user information; static TDatimefgExpDateExpiring date for new security contexts; static GlobusAuth_tfgGlobusAuthHook; static Krb5Auth_tfgKrb5AuthHook; static TStringfgKrb5PrincipalPrincipal for Krb5 ticket; static TDatimefgLastAuthrcTime of last reading of fgRootAuthrc; static Int_tfgLastErrorLast error code processed by AuthError(); static TStringfgPasswd; static TPluginHandler*fgPasswdDialogPasswd dialog GUI plugin; static Int_tfgProcessIDID of the main thread as unique identifier; static Bool_tfgPromptUserkTRUE if user prompt required; static TList*fgProofAuthInfoSpecific lists of THostAuth fro proof; static Bool_tfgPwHashkTRUE if fgPasswd is a passwd hash; static Int_tfgRSAInit; static Int_tfgRSAKeyDefault type of RSA key to be tried; static rsa_KEYfgRSAPriKey; static rsa_KEY_exportfgRSAPubExport[2]; static rsa_KEYfgRSAPubKey; static Bool_tfgReadHomeAuthrckTRUE to look for $HOME/.rootauthrc; static TStringfgRootAuthrcPath to last rootauthrc-like file read; static Bool_tfgSRPPwdkTRUE if fgPasswd is a SRP passwd; static SecureAuth_tfgSecAuthHook; static TStringfgUser; static Bool_tfgUsrPwdCryptkTRUE if encryption for UsrPwd is required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAuthenticate(TSocket* sock, const char* remote, const char* proto, const char* user = """")",MatchSource.WIKI,root/html530/TAuthenticate.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAuthenticate.html
Security,authenticat,authentication,". TAuthenticate. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » AUTH; » TAuthenticate. class TAuthenticate: public TObject. TAuthenticate. An authentication module for ROOT based network services, like rootd; and proofd. Function Members (Methods); public:. TAuthenticate(const TAuthenticate&); TAuthenticate(TSocket* sock, const char* remote, const char* proto, const char* user = """"); virtual~TAuthenticate(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tAuthenticate(); static voidAuthError(const char* where, Int_t error); Int_tAuthExists(TString User, Int_t method, const char* Options, Int_t* Message, Int_t* Rflag, CheckSecCtx_t funcheck); virtual voidTObject::Browse(TBrowser* b); voidCatchTimeOut(); Bool_tCheckNetrc(TString& user, TString& passwd); Bool_tCheckNetrc(TString& user, TString& passwd, Bool_t& pwhash, Bool_t srppwd); static Bool_tCheckProofAuth(Int_t cSec, TString& det); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static Int_tDecodeRSAPublic(const char* rsapubexport, rsa_NUMBER& n, rsa_NUMBER& d, char** rsassl = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int",MatchSource.WIKI,root/html530/TAuthenticate.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAuthenticate.html
Testability,log,logon,"swd, Bool_t& pwhash, Bool_t srppwd); Int_tGetVersion() const; Int_tProofAuthSetup(); static Int_tProofAuthSetup(TSocket* sock, Bool_t client); static voidRemoveSecContext(TRootSecContext* ctx); Int_tRfioAuth(TString& user); voidSetEnvironment(); Int_tSshAuth(TString& user); Int_tSshError(const char* errfile). Data Members; public:. enum ESecurity { kClear; kSRP; kKrb5; kGlobus; kSSH; kRfio; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStringfDetailslogon details (method dependent ...); THostAuth*fHostAuthpointer to relevant authentication info; TStringfPasswduser's password; TStringfProtocolremote service (rootd, proofd); Bool_tfPwHashkTRUE if fPasswd is a passwd hash; Int_tfRSAKeyType of RSA key used; TStringfRemoteremote host to which we want to connect; Bool_tfSRPPwdkTRUE if fPasswd is a SRP passwd; TRootSecContext*fSecContextpointer to relevant sec context; TAuthenticate::ESecurityfSecurityactual logon security level; TSocket*fSocketconnection to remote daemon; Int_tfTimeOuttimeout flag; TStringfUseruser to be authenticated; Int_tfVersion0,1,2, ... accordingly to remote daemon version; static TList*fgAuthInfo; static TStringfgAuthMeth[6]; static Bool_tfgAuthReUsekTRUE is ReUse required; static Int_tfgAuthTOif > 0, timeout in sec; static TStringfgDefaultUserDefault user information; static TDatimefgExpDateExpiring date for new security contexts; static GlobusAuth_tfgGlobusAuthHook; static Krb5Auth_tfgKrb5AuthHook; static TStringfgKrb5PrincipalPrincipal for Krb5 ticket; static TDatimefgLastAuthrcTime of last reading of fgRootAuthrc; static Int_tfgLastErrorLast error code processed by AuthError(); static TStringfgPasswd; static TPluginHandler*fgPasswdDialogPasswd dialog GUI plugin; static Int_tfgProcessIDID of the main thread as unique identifier",MatchSource.WIKI,root/html530/TAuthenticate.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAuthenticate.html
Availability,error,error,"ar* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCenterLabels(Bool_t center = kTRUE)TOGGLE GETTER ; virtual voidCenterTitle(Bool_t center = kTRUE)TOGGLE GETTER ; const char*ChooseTimeFormat(Double_t axislength = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject& axis) const; virtual voidDelete(Option_t* = """"); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*DrawClone(Option_t* = """") const; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual Int_tFindBin(Double_t x); virtual Int_tFindBin(const char* label); virtual Int_tFindFixBin(Double_t x) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Color_tTAttAxis::GetAxisColor() const; virtual Double_tGetBinCenter(Int_t bin) const; virtual Double_tGetBinCenterLog(Int_t bin) const; const char*GetBinLabel(Int_t bin) const; virtual Double_tGetBinLowEdge(Int_t bin) const; virtual Double_tGetBinUpEdge(Int_t bin) const; virtual Double_tGetBinWidth(Int_t bin) const; virtual voidGetCenter(Double_t* center) const; Bool_tGetCenterLabels() const; Bool_tGetCenterTitle() const; Bool_tGetDecimals() const; virtual Option_t*TObject",MatchSource.WIKI,root/html530/TAxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAxis.html
Deployability,release,released,"Bool_t GetCenterLabels() const; Return kTRUE if kCenterLabels bit is set, kFALSE otherwise. void CenterTitle(Bool_t center = kTRUE); if center = kTRUE axis title will be centered; default is right adjusted. Bool_t GetCenterTitle() const; Return kTRUE if kCenterTitle bit is set, kFALSE otherwise. const char * ChooseTimeFormat(Double_t axislength = 0); Choose a reasonable time format from the coordinates in the active pad; and the number of divisions in this axis; If orientation = ""X"", the horizontal axis of the pad will be used for ref.; If orientation = ""Y"", the vertical axis of the pad will be used for ref. void Copy(TObject& axis) const; Copy axis structure to another axis. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to an axis. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when an axis is clicked with the locator. The axis range is set between the position where the mouse is pressed; and the position where it is released.; If the mouse position is outside the current axis range when it is released; the axis is unzoomed with the corresponding proportions.; Note that the mouse does not need to be in the pad or even canvas; when it is released. Int_t FindBin(Double_t x); Find bin number corresponding to abscissa x. If x is underflow or overflow, attempt to rebin histogram; if the TH1::kCanRebin bit is set otherwise return 0 or fNbins+1. Int_t FindBin(const char* label); Find bin number with label.; If the List of labels does not exist create it; If label is not in the list of labels do the following depending on the; bit TH1::kCanRebin of the parent histogram.; - if the bit is set add the new label and if the number of labels exceeds; the number of bins, double the number of bins via TH1::LabelsInflate; - if the bit is not set return 0 (underflow bin). -1 is returned only when the Axis has no parent histogram. Int_t FindFixBin(Double_t x) const; Find ",MatchSource.WIKI,root/html530/TAxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAxis.html
Integrability,depend,depending," Copy(TObject& axis) const; Copy axis structure to another axis. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to an axis. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when an axis is clicked with the locator. The axis range is set between the position where the mouse is pressed; and the position where it is released.; If the mouse position is outside the current axis range when it is released; the axis is unzoomed with the corresponding proportions.; Note that the mouse does not need to be in the pad or even canvas; when it is released. Int_t FindBin(Double_t x); Find bin number corresponding to abscissa x. If x is underflow or overflow, attempt to rebin histogram; if the TH1::kCanRebin bit is set otherwise return 0 or fNbins+1. Int_t FindBin(const char* label); Find bin number with label.; If the List of labels does not exist create it; If label is not in the list of labels do the following depending on the; bit TH1::kCanRebin of the parent histogram.; - if the bit is set add the new label and if the number of labels exceeds; the number of bins, double the number of bins via TH1::LabelsInflate; - if the bit is not set return 0 (underflow bin). -1 is returned only when the Axis has no parent histogram. Int_t FindFixBin(Double_t x) const; Find bin number corresponding to abscissa x. const char * GetBinLabel(Int_t bin) const; Return label for bin. Int_t GetFirst() const; return first bin on the axis; ie 1 if no range defined; NOTE: in some cases a zero is returned (see TAxis::SetRange). Int_t GetLast() const; return last bin on the axis; ie fNbins if no range defined; NOTE: in some cases a zero is returned (see TAxis::SetRange). Double_t GetBinCenter(Int_t bin) const; Return center of bin. Double_t GetBinCenterLog(Int_t bin) const; Return center of bin in log; With a log-equidistant binning for a bin with low and up edges, the mean is :; 0.5*(ln low + l",MatchSource.WIKI,root/html530/TAxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAxis.html
Modifiability,variab,variable,". TAxis. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TAxis. class TAxis: public TNamed, public TAttAxis. This class manages histogram axis. It is referenced by TH1 and TGraph.; To make a graphical representation of an histogram axis, this class; references the TGaxis class. TAxis supports axis with fixed or variable bin sizes.; Labels may be associated to individual bins. see examples of various axis representations drawn by class TGaxis. Function Members (Methods); public:. TAxis(); TAxis(const TAxis& axis); TAxis(Int_t nbins, const Double_t* xbins); TAxis(Int_t nbins, Double_t xmin, Double_t xmax); virtual~TAxis(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCenterLabels(Bool_t center = kTRUE)TOGGLE GETTER ; virtual voidCenterTitle(Bool_t center = kTRUE)TOGGLE GETTER ; const char*ChooseTimeFormat(Double_t axislength = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject& axis) const; virtual voidDelete(Option_t* = """"); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*DrawClone(Option_t* = """") const; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); v",MatchSource.WIKI,root/html530/TAxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAxis.html
Testability,log,log," label.; If the List of labels does not exist create it; If label is not in the list of labels do the following depending on the; bit TH1::kCanRebin of the parent histogram.; - if the bit is set add the new label and if the number of labels exceeds; the number of bins, double the number of bins via TH1::LabelsInflate; - if the bit is not set return 0 (underflow bin). -1 is returned only when the Axis has no parent histogram. Int_t FindFixBin(Double_t x) const; Find bin number corresponding to abscissa x. const char * GetBinLabel(Int_t bin) const; Return label for bin. Int_t GetFirst() const; return first bin on the axis; ie 1 if no range defined; NOTE: in some cases a zero is returned (see TAxis::SetRange). Int_t GetLast() const; return last bin on the axis; ie fNbins if no range defined; NOTE: in some cases a zero is returned (see TAxis::SetRange). Double_t GetBinCenter(Int_t bin) const; Return center of bin. Double_t GetBinCenterLog(Int_t bin) const; Return center of bin in log; With a log-equidistant binning for a bin with low and up edges, the mean is :; 0.5*(ln low + ln up) i.e. sqrt(low*up) in logx (e.g. sqrt(10^0*10^2) = 10).; Imagine a bin with low=1 and up=100 :; - the center in lin is (100-1)/2=50.5; - the center in log would be sqrt(1*100)=10 (!=log(50.5)); NB: if the low edge of the bin is negative, the function returns the bin center; as computed by TAxis::GetBinCenter. Double_t GetBinLowEdge(Int_t bin) const; Return low edge of bin. Double_t GetBinUpEdge(Int_t bin) const; Return up edge of bin. Double_t GetBinWidth(Int_t bin) const; Return bin width. void GetCenter(Double_t* center) const; Return an array with the center of all bins. void GetLowEdge(Double_t* edge) const; Return an array with the lod edge of all bins. const char * GetTimeFormatOnly() const; Return *only* the time format from the string fTimeFormat. const char * GetTicks() const; Return the ticks option (see SetTicks). void LabelsOption(Option_t* option = ""h""); Set option(s) to draw axi",MatchSource.WIKI,root/html530/TAxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAxis.html
Availability,down,down," client area. With Zoom mode on the user can access; TAxis3D context menu and set /change the attributes of axice all together; or separately. To add the 3D rulers to any 3D view one has to create; an instance of this class and Draw it. TAxis3D rulers;; rulers.Draw();. One can use a static method to create ruler and attach it to the current gPad. TAxis3D::ToggleRulers(); // Brings the 3D axice up; TAxis3D::ToggleRulers(); // next calls remove the rulers from the TPad etc. To activate Zoomer one may call. TAxis3D::ToggleZoom();. each time one needs move or zoom the image. Then the user can:; - move:; . - zoom:; . its 3D view with <left-mouse button> press / move.; The ""Zoom"" deactivates itself just the user release the <left-mouse button>. To change attributes of the rulers attached to the current Pad, one may; query its pointer first:. TAxis3D *axis = TAxis3D::GetPadAxis(); // Ask axis pointer; if (axis) {; TAxis3D::ToggleRulers() // To pop axice down; axis->SetLabelColor(kBlue); // Paint the axice labels with blue color; axis->SetAxisColor(kRed); // Paint the axice itself with blue color; TAxis3D::ToggleRulers() // To pop axice up; }. The attributes of the created axice are affected by the current style; (see TStyle class ) and Set... methods of this class. For example:. gStyle->SetAxisColor(kYellow,""X"");; gStyle->SetAxisColor(kYellow,""Y"");; gStyle->SetAxisColor(kYellow,""Z"");. gStyle->SetLabelColor(kYellow,""X"");; gStyle->SetLabelColor(kYellow,""Y"");; gStyle->SetLabelColor(kYellow,""Z"");. TAxis3D::ToggleRulers();; TAxis3D::ToggleRulers();. will draw all axice and labels with yellow color. Function Members (Methods); public:. TAxis3D(); TAxis3D(Option_t* option); TAxis3D(const TAxis3D& axis); virtual~TAxis3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """");",MatchSource.WIKI,root/html530/TAxis3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAxis3D.html
Deployability,release,release,"embers; data members; class charts. ROOT; » GRAF3D; » G3D; » TAxis3D. class TAxis3D: public TNamed. The 3D axis painter class. This class provide up to 3 axice to any 3D ROOT plot and; ""ZOOM"" service.; ExecuteEvent() method does provide zooming and moving a projection; 3D object within TPad client area. With Zoom mode on the user can access; TAxis3D context menu and set /change the attributes of axice all together; or separately. To add the 3D rulers to any 3D view one has to create; an instance of this class and Draw it. TAxis3D rulers;; rulers.Draw();. One can use a static method to create ruler and attach it to the current gPad. TAxis3D::ToggleRulers(); // Brings the 3D axice up; TAxis3D::ToggleRulers(); // next calls remove the rulers from the TPad etc. To activate Zoomer one may call. TAxis3D::ToggleZoom();. each time one needs move or zoom the image. Then the user can:; - move:; . - zoom:; . its 3D view with <left-mouse button> press / move.; The ""Zoom"" deactivates itself just the user release the <left-mouse button>. To change attributes of the rulers attached to the current Pad, one may; query its pointer first:. TAxis3D *axis = TAxis3D::GetPadAxis(); // Ask axis pointer; if (axis) {; TAxis3D::ToggleRulers() // To pop axice down; axis->SetLabelColor(kBlue); // Paint the axice labels with blue color; axis->SetAxisColor(kRed); // Paint the axice itself with blue color; TAxis3D::ToggleRulers() // To pop axice up; }. The attributes of the created axice are affected by the current style; (see TStyle class ) and Set... methods of this class. For example:. gStyle->SetAxisColor(kYellow,""X"");; gStyle->SetAxisColor(kYellow,""Y"");; gStyle->SetAxisColor(kYellow,""Z"");. gStyle->SetLabelColor(kYellow,""X"");; gStyle->SetLabelColor(kYellow,""Y"");; gStyle->SetLabelColor(kYellow,""Z"");. TAxis3D::ToggleRulers();; TAxis3D::ToggleRulers();. will draw all axice and labels with yellow color. Function Members (Methods); public:. TAxis3D(); TAxis3D(Option_t* option); TAxis3D(const TAxis3",MatchSource.WIKI,root/html530/TAxis3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAxis3D.html
Security,access,access,". TAxis3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TAxis3D. class TAxis3D: public TNamed. The 3D axis painter class. This class provide up to 3 axice to any 3D ROOT plot and; ""ZOOM"" service.; ExecuteEvent() method does provide zooming and moving a projection; 3D object within TPad client area. With Zoom mode on the user can access; TAxis3D context menu and set /change the attributes of axice all together; or separately. To add the 3D rulers to any 3D view one has to create; an instance of this class and Draw it. TAxis3D rulers;; rulers.Draw();. One can use a static method to create ruler and attach it to the current gPad. TAxis3D::ToggleRulers(); // Brings the 3D axice up; TAxis3D::ToggleRulers(); // next calls remove the rulers from the TPad etc. To activate Zoomer one may call. TAxis3D::ToggleZoom();. each time one needs move or zoom the image. Then the user can:; - move:; . - zoom:; . its 3D view with <left-mouse button> press / move.; The ""Zoom"" deactivates itself just the user release the <left-mouse button>. To change attributes of the rulers attached to the current Pad, one may; query its pointer first:. TAxis3D *axis = TAxis3D::GetPadAxis(); // Ask axis pointer; if (axis) {; TAxis3D::ToggleRulers() // To pop axice down; axis->SetLabelColor(kBlue); // Paint the axice labels with blue color; axis->SetAxisColor(kRed); // Paint the axice itself with blue color; TAxis3D::ToggleRulers() // To pop axice up; }. The attributes of the created axice are affected by the current style; (see TStyle class ) and Set... methods of this class. For example:. gStyle->SetAxisColor(kYellow,""X"");; gStyle->SetAxisColor(kYellow,""Y"");; gStyle->SetAxisColor(kYellow,""Z"");. gStyle->SetLabelColor(kYellow,""X"");; gStyle->SetLabelColor(kYellow,""Y"");; gStyle->SetLabelColor(kYellow,""Z"");. TAxis3D::ToggleR",MatchSource.WIKI,root/html530/TAxis3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAxis3D.html
Availability,avail,available,". TAxisEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TAxisEditor. class TAxisEditor: public TGedFrame. TAxisEditor. Implements GUI for axis attributes.; axis color; ticks parameters: length, setting on both axis sides,; logarithmic or linear scale along the selected axis,; primary, secondary and tertiary axis divisions,; setting more logarithmic labels,; optimizing labels' position if available; axis title - a title can be added via the text entry field; and can be set to be centered or rotated via the corresponding; check buttons, the title color, offset, font can be set easily; axis labels - their color, size, offset can be set similarly,; in addition there is a check box for no exponent choice,; and another one for setting the same decimal part for all labels //. /*. */. Function Members (Methods); public:. TAxisEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); virtual~TAxisEditor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidTGedFrame::ActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt",MatchSource.WIKI,root/html530/TAxisEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAxisEditor.html
Performance,optimiz,optimizing,". TAxisEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TAxisEditor. class TAxisEditor: public TGedFrame. TAxisEditor. Implements GUI for axis attributes.; axis color; ticks parameters: length, setting on both axis sides,; logarithmic or linear scale along the selected axis,; primary, secondary and tertiary axis divisions,; setting more logarithmic labels,; optimizing labels' position if available; axis title - a title can be added via the text entry field; and can be set to be centered or rotated via the corresponding; check buttons, the title color, offset, font can be set easily; axis labels - their color, size, offset can be set similarly,; in addition there is a check box for no exponent choice,; and another one for setting the same decimal part for all labels //. /*. */. Function Members (Methods); public:. TAxisEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); virtual~TAxisEditor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidTGedFrame::ActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt",MatchSource.WIKI,root/html530/TAxisEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAxisEditor.html
Testability,log,logarithmic,". TAxisEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TAxisEditor. class TAxisEditor: public TGedFrame. TAxisEditor. Implements GUI for axis attributes.; axis color; ticks parameters: length, setting on both axis sides,; logarithmic or linear scale along the selected axis,; primary, secondary and tertiary axis divisions,; setting more logarithmic labels,; optimizing labels' position if available; axis title - a title can be added via the text entry field; and can be set to be centered or rotated via the corresponding; check buttons, the title color, offset, font can be set easily; axis labels - their color, size, offset can be set similarly,; in addition there is a check box for no exponent choice,; and another one for setting the same decimal part for all labels //. /*. */. Function Members (Methods); public:. TAxisEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); virtual~TAxisEditor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidTGedFrame::ActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt",MatchSource.WIKI,root/html530/TAxisEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TAxisEditor.html
Availability,error,error,"t::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; boolContour(unsigned int ipar, unsigned int jpar, TGraph* gr, double confLevel = 0.683); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ipar); virtual voidGetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); virtual voidGetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.95); virtual Double_t*GetCovarianceMatrix() const; virtual Double_tGetCovarianceMatrixElement(Int_t i, Int_t j) const; static const char*TVirtualFitter::GetDefaultFitter(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static Double_tTVirtualFitter::G",MatchSource.WIKI,root/html530/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBackCompFitter.html
Deployability,configurat,configuration,". TBackCompFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TBackCompFitter. class TBackCompFitter: public TVirtualFitter. Backward compatible implementation of TVirtualFitter using the the class ROOT::Fit::Fitter.; This class is created after fitting an histogram (TH1), TGraph or TTree and provides in addition to the; methods of the TVirtualFitter hooks to access the fit result class (ROOT::Fit::FitResult), the fit configuration; (ROOT::Fit::FitConfig) or the fit data (ROOT::Fit::FitData) using; <pre>; TBackCompFitter * fitter = (TBackCompFitter *) TVirtualFitter::GetFitter();; ROOT::Fit::FitResult & result = fitter->GetFitResult();; result.Print(std::cout);; </pre>. Methods for getting the confidence level or contours are also provided.; Note that after a new calls to TH1::Fit (or similar) the class will be deleted and all reference to the FitResult, FitConfig; or minimizer will be invalid. One could eventually copying the class before issuing a new fit to avoid deleting this information. Function Members (Methods); public:. TBackCompFitter(); TBackCompFitter(const TBackCompFitter&); TBackCompFitter(auto_ptr<ROOT::Fit::Fitter> fitter, auto_ptr<ROOT::Fit::FitData> data); virtual~TBackCompFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; boolContour(unsigned int ipar, unsigned int jpar, TGraph* gr, double confLevel = 0.683); virtual voidTNamed::Copy(TObject& named) const; virtual vo",MatchSource.WIKI,root/html530/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBackCompFitter.html
Integrability,interface,interface," bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. vector<double>fCovarcached covariance matrix (NxN); auto_ptr<ROOT::Fit::FitData>fFitData! data of the fit (managed by TBackCompFitter); auto_ptr<ROOT::Fit::Fitter>fFitter! pointer to fitter object (managed by TBackCompFitter); ROOT::Math::Minimizer*fMinimizer; ROOT::Math::IParametricFunctionMultiDim*fModelFunc; ROOT::Math::IBaseFunctionMultiDim*fObjFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBackCompFitter(); Constructur needed by TVirtualFitter interface. Same behavior as default constructor.; initialize setting name and the global pointer. TBackCompFitter(auto_ptr<ROOT::Fit::Fitter> fitter, auto_ptr<ROOT::Fit::FitData> data); constructor used after having fit using directly ROOT::Fit::Fitter; will create a dummy fitter copying configuration and parameter settings. ~TBackCompFitter(); data are own here; if (fFitData) delete fFitData;. Double_t Chisquare(Int_t npar, Double_t* params) const; do chisquare calculations in case of likelihood fits; do evaluation a the minimum only. void Clear(Option_t* option = """"); clear resources for consecutive fits. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); execute the command (Fortran Minuit compatible interface). bool ValidParameterIndex(int ipar) const; check if ipar is a valid parameter index. void FixParameter(Int_t ipar); fix the paramter; std::cout<<""FixParameter""<<std::endl;. void GetConfidenceIntervals(Int_t n, Int_t ndim",MatchSource.WIKI,root/html530/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBackCompFitter.html
Modifiability,config,configuration,". TBackCompFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TBackCompFitter. class TBackCompFitter: public TVirtualFitter. Backward compatible implementation of TVirtualFitter using the the class ROOT::Fit::Fitter.; This class is created after fitting an histogram (TH1), TGraph or TTree and provides in addition to the; methods of the TVirtualFitter hooks to access the fit result class (ROOT::Fit::FitResult), the fit configuration; (ROOT::Fit::FitConfig) or the fit data (ROOT::Fit::FitData) using; <pre>; TBackCompFitter * fitter = (TBackCompFitter *) TVirtualFitter::GetFitter();; ROOT::Fit::FitResult & result = fitter->GetFitResult();; result.Print(std::cout);; </pre>. Methods for getting the confidence level or contours are also provided.; Note that after a new calls to TH1::Fit (or similar) the class will be deleted and all reference to the FitResult, FitConfig; or minimizer will be invalid. One could eventually copying the class before issuing a new fit to avoid deleting this information. Function Members (Methods); public:. TBackCompFitter(); TBackCompFitter(const TBackCompFitter&); TBackCompFitter(auto_ptr<ROOT::Fit::Fitter> fitter, auto_ptr<ROOT::Fit::FitData> data); virtual~TBackCompFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; boolContour(unsigned int ipar, unsigned int jpar, TGraph* gr, double confLevel = 0.683); virtual voidTNamed::Copy(TObject& named) const; virtual vo",MatchSource.WIKI,root/html530/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBackCompFitter.html
Performance,cache,cache,"anDeleteLast; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TVirtualFitter::fCache[fCacheSize] array of points data (fNpoints*fPointSize < fCacheSize words); Int_tTVirtualFitter::fCacheSizeSize of the fCache array; voidTVirtualFitter::fFCN; TMethodCall*TVirtualFitter::fMethodCallPointer to MethodCall in case of interpreted function; TStringTNamed::fNameobject identifier; Int_tTVirtualFitter::fNpointsNumber of points to fit; TObject*TVirtualFitter::fObjectFitpointer to object being fitted; Foption_tTVirtualFitter::fOptionstruct with the fit options; Int_tTVirtualFitter::fPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. vector<double>fCovarcached covariance matrix (NxN); auto_ptr<ROOT::Fit::FitData>fFitData! data of the fit (managed by TBackCompFitter); auto_ptr<ROOT::Fit::Fitter>fFitter! pointer to fitter object (managed by TBackCompFitter); ROOT::Math::Minimizer*fMinimizer; ROOT::Math",MatchSource.WIKI,root/html530/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBackCompFitter.html
Safety,avoid,avoid,"rce. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TBackCompFitter. class TBackCompFitter: public TVirtualFitter. Backward compatible implementation of TVirtualFitter using the the class ROOT::Fit::Fitter.; This class is created after fitting an histogram (TH1), TGraph or TTree and provides in addition to the; methods of the TVirtualFitter hooks to access the fit result class (ROOT::Fit::FitResult), the fit configuration; (ROOT::Fit::FitConfig) or the fit data (ROOT::Fit::FitData) using; <pre>; TBackCompFitter * fitter = (TBackCompFitter *) TVirtualFitter::GetFitter();; ROOT::Fit::FitResult & result = fitter->GetFitResult();; result.Print(std::cout);; </pre>. Methods for getting the confidence level or contours are also provided.; Note that after a new calls to TH1::Fit (or similar) the class will be deleted and all reference to the FitResult, FitConfig; or minimizer will be invalid. One could eventually copying the class before issuing a new fit to avoid deleting this information. Function Members (Methods); public:. TBackCompFitter(); TBackCompFitter(const TBackCompFitter&); TBackCompFitter(auto_ptr<ROOT::Fit::Fitter> fitter, auto_ptr<ROOT::Fit::FitData> data); virtual~TBackCompFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; boolContour(unsigned int ipar, unsigned int jpar, TGraph* gr, double confLevel = 0.683); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t",MatchSource.WIKI,root/html530/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBackCompFitter.html
Security,access,access,". TBackCompFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TBackCompFitter. class TBackCompFitter: public TVirtualFitter. Backward compatible implementation of TVirtualFitter using the the class ROOT::Fit::Fitter.; This class is created after fitting an histogram (TH1), TGraph or TTree and provides in addition to the; methods of the TVirtualFitter hooks to access the fit result class (ROOT::Fit::FitResult), the fit configuration; (ROOT::Fit::FitConfig) or the fit data (ROOT::Fit::FitData) using; <pre>; TBackCompFitter * fitter = (TBackCompFitter *) TVirtualFitter::GetFitter();; ROOT::Fit::FitResult & result = fitter->GetFitResult();; result.Print(std::cout);; </pre>. Methods for getting the confidence level or contours are also provided.; Note that after a new calls to TH1::Fit (or similar) the class will be deleted and all reference to the FitResult, FitConfig; or minimizer will be invalid. One could eventually copying the class before issuing a new fit to avoid deleting this information. Function Members (Methods); public:. TBackCompFitter(); TBackCompFitter(const TBackCompFitter&); TBackCompFitter(auto_ptr<ROOT::Fit::Fitter> fitter, auto_ptr<ROOT::Fit::FitData> data); virtual~TBackCompFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; boolContour(unsigned int ipar, unsigned int jpar, TGraph* gr, double confLevel = 0.683); virtual voidTNamed::Copy(TObject& named) const; virtual vo",MatchSource.WIKI,root/html530/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBackCompFitter.html
Testability,log,log,"rianceMatrix() const; get the error matrix in a pointer to a NxN array.; excluding the fixed parameters. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; get error matrix element (return all zero if matrix is not available). Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; get fit errors. Int_t GetNumberTotalParameters() const; number of total parameters. Int_t GetNumberFreeParameters() const; number of variable parameters. Double_t GetParError(Int_t ipar) const; parameter error. Double_t GetParameter(Int_t ipar) const; parameter value. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; get all parameter info (name, value, errors). const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; get fit statistical information. Double_t GetSumLog(Int_t i); sum of log . Un-needed. Bool_t IsFixed(Int_t ipar) const; query if parameter ipar is fixed. void PrintResults(Int_t level, Double_t amin) const; print the fit result; use PrintResults function in case of Minuit for old -style printing. void ReleaseParameter(Int_t ipar); release a fit parameter. void SetFitMethod(const char* name); set fit method (i.e. chi2 or likelihood); according to the method the appropriate FCN function will be created. Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set (add) a new fit parameter passing initial value, step size (verr) and parametr limits; if vlow > vhigh the parameter is unbounded; if the stepsize (verr) == 0 the parameter is treated as fixed. void ReCreateMinimizer(); Recreate a minimizer instance using the function and data; set objective function in minimizers function to re-create FCN from stored data object and fit options. void SetFCN(void fcn); override setFCN to us",MatchSource.WIKI,root/html530/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBackCompFitter.html
Usability,clear,clear,"FitData! data of the fit (managed by TBackCompFitter); auto_ptr<ROOT::Fit::Fitter>fFitter! pointer to fitter object (managed by TBackCompFitter); ROOT::Math::Minimizer*fMinimizer; ROOT::Math::IParametricFunctionMultiDim*fModelFunc; ROOT::Math::IBaseFunctionMultiDim*fObjFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBackCompFitter(); Constructur needed by TVirtualFitter interface. Same behavior as default constructor.; initialize setting name and the global pointer. TBackCompFitter(auto_ptr<ROOT::Fit::Fitter> fitter, auto_ptr<ROOT::Fit::FitData> data); constructor used after having fit using directly ROOT::Fit::Fitter; will create a dummy fitter copying configuration and parameter settings. ~TBackCompFitter(); data are own here; if (fFitData) delete fFitData;. Double_t Chisquare(Int_t npar, Double_t* params) const; do chisquare calculations in case of likelihood fits; do evaluation a the minimum only. void Clear(Option_t* option = """"); clear resources for consecutive fits. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); execute the command (Fortran Minuit compatible interface). bool ValidParameterIndex(int ipar) const; check if ipar is a valid parameter index. void FixParameter(Int_t ipar); fix the paramter; std::cout<<""FixParameter""<<std::endl;. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.95); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95; NOTE, that the intervals are approximate for nonlinear(in parameters) models. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); Computes confidence intervals at level cl. Default is 0.95; The TObject parameter c",MatchSource.WIKI,root/html530/TBackCompFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBackCompFitter.html
Integrability,message,messages,". TBase64. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBase64. class TBase64. TBase64. This code implements the Base64 encoding and decoding.; Base64 encoded messages are typically used in authentication; protocols and to pack binary data in HTTP messages. Function Members (Methods); public:. TBase64(); TBase64(const TBase64&); virtual~TBase64(); static TClass*Class(); static TStringDecode(const char* data); static TStringEncode(const char* data); static TStringEncode(const char* data, Int_t len); virtual TClass*IsA() const; TBase64&operator=(const TBase64&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TString Encode(const char* data); Transform data into a null terminated base64 string. TString Encode(const char* data, Int_t len); Transform len bytes from data into a null terminated base64 string. TString Decode(const char* data); Decode a base64 string date into a generic TString.; No check for base64-ness of input characters. virtual ~TBase64(); { }. » Author: Gerardo Ganis + Fons Rademakers 15/5/2009 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TBase64.h 28641 2009-05-15 15:20:08Z rdm $ » Last generated: 2011-07-04 15:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TBase64.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBase64.html
Security,authenticat,authentication,". TBase64. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBase64. class TBase64. TBase64. This code implements the Base64 encoding and decoding.; Base64 encoded messages are typically used in authentication; protocols and to pack binary data in HTTP messages. Function Members (Methods); public:. TBase64(); TBase64(const TBase64&); virtual~TBase64(); static TClass*Class(); static TStringDecode(const char* data); static TStringEncode(const char* data); static TStringEncode(const char* data, Int_t len); virtual TClass*IsA() const; TBase64&operator=(const TBase64&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TString Encode(const char* data); Transform data into a null terminated base64 string. TString Encode(const char* data, Int_t len); Transform len bytes from data into a null terminated base64 string. TString Decode(const char* data); Decode a base64 string date into a generic TString.; No check for base64-ness of input characters. virtual ~TBase64(); { }. » Author: Gerardo Ganis + Fons Rademakers 15/5/2009 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TBase64.h 28641 2009-05-15 15:20:08Z rdm $ » Last generated: 2011-07-04 15:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TBase64.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBase64.html
Availability,error,error," TBaseClass(BaseClassInfo_t* info = 0, TClass* cl = 0); virtual~TBaseClass(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TClass*GetClassPointer(B",MatchSource.WIKI,root/html530/TBaseClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBaseClass.html
Modifiability,inherit,inherited,". TBaseClass. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TBaseClass. class TBaseClass: public TDictionary. Each class (see TClass) has a linked list of its base class(es).; This class describes one single base class.; The base class info is obtained via the CINT api.; see class TCint. The base class information is used a.o. in to find all inherited; methods. Function Members (Methods); public:. TBaseClass(BaseClassInfo_t* info = 0, TClass* cl = 0); virtual~TBaseClass(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TClass*GetClassPointer(B",MatchSource.WIKI,root/html530/TBaseClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBaseClass.html
Performance,load,load,":Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TClass*GetClassPointer(Bool_t load = kTRUE); Int_tGetDelta() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; ",MatchSource.WIKI,root/html530/TBaseClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBaseClass.html
Availability,error,error,"AdjustSize(Int_t newsize); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTKey::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Long64_tCopyTo(TFile* to); virtual voidTKey::Delete(Option_t* option = """"); virtual voidTKey::DeleteBuffer(); virtual voidDeleteEntryOffset(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Int_tDropBuffers(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTKey::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*GetBranch() const; virtual char*TKey::GetBuffer() const; TBuffer*TKey::GetBufferRef() const; Int_tGetBufferSize() const; virtual const char*TKey::GetClassName() const; Short_tTKey::GetCycle() const; const TDatime&TKey::GetDatime() const; Int_t*GetDisplacement() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_t*GetEntryOffset() const; Int_tGetEntryPointer(Int_t Entry); TFile*TKey::GetFile() const; virtual const char*TKey::GetIconName() const; Short_tTKey::GetKeep() const; Int_tTKey::GetKeylen() const; Int_tGetLast() const; TDirectory*",MatchSource.WIKI,root/html530/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBasket.html
Performance,cache,cache,"onstructor, used during writing. ~TBasket(); Basket destructor. void AdjustSize(Int_t newsize); Increase the size of the current fBuffer up to newsize. Long64_t CopyTo(TFile* to); Copy the basket of this branch onto the file to. void DeleteEntryOffset(); Delete fEntryOffset array. Int_t DropBuffers(); Drop buffers of this basket if it is not the current basket. Int_t GetEntryPointer(Int_t Entry); Get pointer to buffer for internal entry. Int_t LoadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Load basket buffers in memory without unziping.; This function is called by TTreeCloner.; The function returns 0 in case of success, 1 in case of error. void MoveEntries(Int_t dentries); Remove the first dentries of this basket, moving entries at; dentries to the start of the buffer. Int_t ReadBasketBuffersUncompressedCase(); By-passing buffer unzipping has been requested and is; possible (only 1 entry in this basket). Int_t ReadBasketBuffersUnzip(char* , Int_t , Bool_t , TFile* ); We always create the TBuffer for the basket but it hold the buffer from the cache. void InitializeCompressedBuffer(Int_t len, TFile* file); Initialize the compressed buffer; either from the TTree or create a local one. Int_t ReadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Read basket buffers in memory and cleanup. Read a basket buffer. Check if buffers of previous ReadBasket; should not be dropped. Remember, we keep buffers in memory up to; fMaxVirtualSize.; The function returns 0 in case of success, 1 in case of error; This function was modified with the addition of the parallel; unzipping, it will try to get the unzipped file from the cache; receiving only a pointer to that buffer (so we shall not; delete that pointer), although we get a new buffer in case; it's not found in the cache.; There is a lot of code duplication but it was necesary to assure; the expected behavior when there is no cache. Int_t ReadBasketBytes(Long64_t pos, TFile* file); Read basket buffers in memory and clea",MatchSource.WIKI,root/html530/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBasket.html
Testability,log,logical,"rom the cache. void InitializeCompressedBuffer(Int_t len, TFile* file); Initialize the compressed buffer; either from the TTree or create a local one. Int_t ReadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Read basket buffers in memory and cleanup. Read a basket buffer. Check if buffers of previous ReadBasket; should not be dropped. Remember, we keep buffers in memory up to; fMaxVirtualSize.; The function returns 0 in case of success, 1 in case of error; This function was modified with the addition of the parallel; unzipping, it will try to get the unzipped file from the cache; receiving only a pointer to that buffer (so we shall not; delete that pointer), although we get a new buffer in case; it's not found in the cache.; There is a lot of code duplication but it was necesary to assure; the expected behavior when there is no cache. Int_t ReadBasketBytes(Long64_t pos, TFile* file); Read basket buffers in memory and cleanup. Read first bytes of a logical record starting at position pos; return record length (first 4 bytes of record). void Reset(); Reset the basket to the starting state. i.e. as it was after calling; the constructor (and potentially attaching a TBuffer.); Reduce memory used by fEntryOffset and the TBuffer if needed .. void SetReadMode(); Set read mode of basket. void SetWriteMode(); Set write mode of basket. void Streamer(TBuffer& b); Stream a class object. void Update(Int_t newlast, Int_t skipped); Update basket header and EntryOffset table. Int_t WriteBuffer(); Write buffer of this basket on the current file. The function returns the number of bytes committed to the memory.; If a write error occurs, the number of bytes returned is -1.; If no data are written, the number of bytes returned is 0. TBasket(const TBasket& ). TBasket& operator=(const TBasket& ). TBranch * GetBranch() const; {return fBranch;}. Int_t GetBufferSize() const; {return fBufferSize;}. Int_t * GetDisplacement() const; {return fDisplacement;}. Int_t * GetEntryOffset() const; ",MatchSource.WIKI,root/html530/TBasket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBasket.html
Availability,error,error,"ass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Long64_tTBasket::CopyTo(TFile* to); voidCreateBuffer(const char* name, TString title, vector<Int_t>* vc, TBranch* branch, TSQLResult** rs); virtual voidTKey::Delete(Option_t* option = """"); virtual voidTKey::DeleteBuffer(); virtual voidTBasket::DeleteEntryOffset(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Int_tTBasket::DropBuffers(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTKey::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TBasket::GetBranch() const; virtual char*TKey::GetBuffer() const; TBuffer*TKey::GetBufferRef() const; Int_tTBasket::GetBufferSize() const; virtual const char*TKey::GetClassName() const; Short_tTKey::GetCycle() const; const TDatime&TKey::GetDatime() const; Int_t*TBasket::GetDisplacement() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_t*TBasket::GetEntryOffset() const; Int_tTBasket::GetEntryPointer(Int_t Entry); TFile*TKey::GetFile() const; virtual const char*TKey::GetIconName() const; Short_tTKey::GetKeep() const; Int_tTKey::GetKeyl",MatchSource.WIKI,root/html530/TBasketSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBasketSQL.html
Availability,error,error," TBenchmark(); virtual~TBenchmark(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetBench(const char* name) const; Float_tGetCpuTime(const char* name); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObje",MatchSource.WIKI,root/html530/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBenchmark.html
Testability,benchmark,benchmarking,". TBenchmark. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBenchmark. class TBenchmark: public TNamed. This class is a ROOT utility to help benchmarking applications. Examples of use of this class are given in the tutorials macros. Function Members (Methods); public:. TBenchmark(); virtual~TBenchmark(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetBench(const char* name) const; Float_tGetCpuTime(const char* name); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObje",MatchSource.WIKI,root/html530/TBenchmark.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBenchmark.html
Availability,avail,available,". TBinomialEfficiencyFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TBinomialEfficiencyFitter. class TBinomialEfficiencyFitter: public TObject. TBinomialEfficiencyFitter. Binomial fitter for the division of two histograms.; Use when you need to calculate a selection's efficiency from two histograms,; one containing all entries, and one containing the subset of these entries; that pass the selection, and when you have a parametrization available for; the efficiency as a function of the variable(s) under consideration. A very common problem when estimating efficiencies is that of error estimation:; when no other information is available than the total number of events N and; the selected number n, the best estimate for the selection efficiency p is n/N.; Standard binomial statistics dictates that the uncertainty (this presupposes; sufficiently high statistics that an approximation by a normal distribution is; reasonable) on p, given N, is. However, when p is estimated as n/N, fluctuations from the true p to its; estimate become important, especially for low numbers of events, and giving; rise to biased results. When fitting a parametrized efficiency, these problems can largely be overcome,; as a hypothesized true efficiency is available by construction. Even so, simply; using the corresponding uncertainty still presupposes that Gaussian errors; yields a reasonable approximation. When using, instead of binned efficiency; histograms, the original numerator and denominator histograms, a binned maximum; likelihood can be constructed as the product of bin-by-bin binomial probabilities; to select n out of N events. Assuming that a correct parametrization of the; efficiency is provided, this construction in general yields less biased results; (and is much less sensitive to binning detail",MatchSource.WIKI,root/html530/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBinomialEfficiencyFitter.html
Deployability,integrat,integration,"Bit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfAverageTrue if the fit function must be averaged over the bin; TH1*fDenominatorDenominator histogram; Double_tfEpsilonPrecision required for function integration (option ""I""); Bool_tfFitDoneSet to kTRUE when the fit has been done; TF1*fFunctionFunction to fit; TH1*fNumeratorNumerator histogram; Bool_tfRangeTrue if the fit range must be taken from the function range; static TVirtualFitter*fgFitterpointer to the real fitter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBinomialEfficiencyFitter(); default constructor. TBinomialEfficiencyFitter(const TH1* numerator, const TH1* denominator); Constructor. Note that no objects are copied, so it is up to the user to ensure that the; histogram pointers remain valid. Both histograms need to be ""consistent"". This is not checked here, but in; TBinomialEfficiencyFitter::Fit(). ~TBinomialEfficiencyFitter(); destructor. void Set(const TH1* numerator, const TH1* denominator); Initialize with a new set of inputs. void SetPrecision(Double_t epsilon); Set the required integration precision, see TF1::Integral(). TVirtualFitter* GetFitter(); static: Provide access to the underlying fitter object.; This may be usefu",MatchSource.WIKI,root/html530/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBinomialEfficiencyFitter.html
Integrability,integrat,integration,"Bit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfAverageTrue if the fit function must be averaged over the bin; TH1*fDenominatorDenominator histogram; Double_tfEpsilonPrecision required for function integration (option ""I""); Bool_tfFitDoneSet to kTRUE when the fit has been done; TF1*fFunctionFunction to fit; TH1*fNumeratorNumerator histogram; Bool_tfRangeTrue if the fit range must be taken from the function range; static TVirtualFitter*fgFitterpointer to the real fitter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBinomialEfficiencyFitter(); default constructor. TBinomialEfficiencyFitter(const TH1* numerator, const TH1* denominator); Constructor. Note that no objects are copied, so it is up to the user to ensure that the; histogram pointers remain valid. Both histograms need to be ""consistent"". This is not checked here, but in; TBinomialEfficiencyFitter::Fit(). ~TBinomialEfficiencyFitter(); destructor. void Set(const TH1* numerator, const TH1* denominator); Initialize with a new set of inputs. void SetPrecision(Double_t epsilon); Set the required integration precision, see TF1::Integral(). TVirtualFitter* GetFitter(); static: Provide access to the underlying fitter object.; This may be usefu",MatchSource.WIKI,root/html530/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBinomialEfficiencyFitter.html
Modifiability,variab,variable,". TBinomialEfficiencyFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TBinomialEfficiencyFitter. class TBinomialEfficiencyFitter: public TObject. TBinomialEfficiencyFitter. Binomial fitter for the division of two histograms.; Use when you need to calculate a selection's efficiency from two histograms,; one containing all entries, and one containing the subset of these entries; that pass the selection, and when you have a parametrization available for; the efficiency as a function of the variable(s) under consideration. A very common problem when estimating efficiencies is that of error estimation:; when no other information is available than the total number of events N and; the selected number n, the best estimate for the selection efficiency p is n/N.; Standard binomial statistics dictates that the uncertainty (this presupposes; sufficiently high statistics that an approximation by a normal distribution is; reasonable) on p, given N, is. However, when p is estimated as n/N, fluctuations from the true p to its; estimate become important, especially for low numbers of events, and giving; rise to biased results. When fitting a parametrized efficiency, these problems can largely be overcome,; as a hypothesized true efficiency is available by construction. Even so, simply; using the corresponding uncertainty still presupposes that Gaussian errors; yields a reasonable approximation. When using, instead of binned efficiency; histograms, the original numerator and denominator histograms, a binned maximum; likelihood can be constructed as the product of bin-by-bin binomial probabilities; to select n out of N events. Assuming that a correct parametrization of the; efficiency is provided, this construction in general yields less biased results; (and is much less sensitive to binning detail",MatchSource.WIKI,root/html530/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBinomialEfficiencyFitter.html
Security,access,access,"on integration (option ""I""); Bool_tfFitDoneSet to kTRUE when the fit has been done; TF1*fFunctionFunction to fit; TH1*fNumeratorNumerator histogram; Bool_tfRangeTrue if the fit range must be taken from the function range; static TVirtualFitter*fgFitterpointer to the real fitter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBinomialEfficiencyFitter(); default constructor. TBinomialEfficiencyFitter(const TH1* numerator, const TH1* denominator); Constructor. Note that no objects are copied, so it is up to the user to ensure that the; histogram pointers remain valid. Both histograms need to be ""consistent"". This is not checked here, but in; TBinomialEfficiencyFitter::Fit(). ~TBinomialEfficiencyFitter(); destructor. void Set(const TH1* numerator, const TH1* denominator); Initialize with a new set of inputs. void SetPrecision(Double_t epsilon); Set the required integration precision, see TF1::Integral(). TVirtualFitter* GetFitter(); static: Provide access to the underlying fitter object.; This may be useful e.g. for the retrieval of additional information (such; as the output covariance matrix of the fit). Int_t Fit(TF1* f1, Option_t* option = """"); Carry out the fit of the given function to the given histograms. If option ""I"" is used, the fit function will be averaged over the; bin (the default is to evaluate it simply at the bin center). If option ""R"" is used, the fit range will be taken from the fit; function (the default is to use the entire histogram). Note that all parameter values, limits, and step sizes are copied; from the input fit function f1 (so they should be set before calling; this method. This is particularly relevant for the step sizes, taken; to be the ""error"" set on input, as a null step size usually fixes the; corresponding parameter. That is protected against, but in such cases; an arbitrary starting step size will be used, and the reliability of; the fit should be questioned). If parameters are to be fixed",MatchSource.WIKI,root/html530/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBinomialEfficiencyFitter.html
Usability,simpl,simply,"ne containing the subset of these entries; that pass the selection, and when you have a parametrization available for; the efficiency as a function of the variable(s) under consideration. A very common problem when estimating efficiencies is that of error estimation:; when no other information is available than the total number of events N and; the selected number n, the best estimate for the selection efficiency p is n/N.; Standard binomial statistics dictates that the uncertainty (this presupposes; sufficiently high statistics that an approximation by a normal distribution is; reasonable) on p, given N, is. However, when p is estimated as n/N, fluctuations from the true p to its; estimate become important, especially for low numbers of events, and giving; rise to biased results. When fitting a parametrized efficiency, these problems can largely be overcome,; as a hypothesized true efficiency is available by construction. Even so, simply; using the corresponding uncertainty still presupposes that Gaussian errors; yields a reasonable approximation. When using, instead of binned efficiency; histograms, the original numerator and denominator histograms, a binned maximum; likelihood can be constructed as the product of bin-by-bin binomial probabilities; to select n out of N events. Assuming that a correct parametrization of the; efficiency is provided, this construction in general yields less biased results; (and is much less sensitive to binning details). A generic use of this method is given below (note that the method works for 2D; and 3D histograms as well):. {; TH1* denominator; // denominator histogram; TH1* numerator; // corresponding numerator histogram; TF1* eff; // efficiency parametrization; .... // set step sizes and initial parameter; .... // values for the fit function; .... // possibly also set ranges, see TF1::SetRange(); TBinomialEfficiencyFitter* f = new TBinomialEfficiencyFitter(; numerator, denominator);; Int_t status = f->Fit(eff, ""I"");; if (status",MatchSource.WIKI,root/html530/TBinomialEfficiencyFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBinomialEfficiencyFitter.html
Availability,error,error,"t TBits&); virtual~TBits(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidCompact(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; UInt_tCountBits(UInt_t startBit = 0) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UInt_tFirstNullBit(UInt_t startBit = 0) const; UInt_tFirstSetBit(UInt_t startBit = 0) const; voidGet(Char_t* array) const; voidGet(UChar_t* array) const; voidGet(Short_t* array) const; voidGet(UShort_t* array) const; voidGet(Int_t* array) const; voidGet(UInt_t* array) const; voidGet(Long64_t* array) const; voidGet(ULong64_t* array) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; UInt_tGetNbits() const; UInt_tGetNbytes() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static B",MatchSource.WIKI,root/html530/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBits.html
Energy Efficiency,reduce,reduce,". TBits. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBits. class TBits: public TObject. TBits. Container of bits. This class provides a simple container of bits.; Each bit can be set and tested via the functions SetBitNumber and; TestBitNumber. .; The default value of all bits is kFALSE.; The size of the container is automatically extended when a bit; number is either set or tested. To reduce the memory size of the; container use the Compact function, this will discard the memory; occupied by the upper bits that are 0. Function Members (Methods); public:. TBits(UInt_t nbits = 8); TBits(const TBits&); virtual~TBits(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidCompact(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; UInt_tCountBits(UInt_t startBit = 0) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const ch",MatchSource.WIKI,root/html530/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBits.html
Modifiability,extend,extended,". TBits. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBits. class TBits: public TObject. TBits. Container of bits. This class provides a simple container of bits.; Each bit can be set and tested via the functions SetBitNumber and; TestBitNumber. .; The default value of all bits is kFALSE.; The size of the container is automatically extended when a bit; number is either set or tested. To reduce the memory size of the; container use the Compact function, this will discard the memory; occupied by the upper bits that are 0. Function Members (Methods); public:. TBits(UInt_t nbits = 8); TBits(const TBits&); virtual~TBits(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidCompact(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; UInt_tCountBits(UInt_t startBit = 0) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const ch",MatchSource.WIKI,root/html530/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBits.html
Testability,test,tested,". TBits. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBits. class TBits: public TObject. TBits. Container of bits. This class provides a simple container of bits.; Each bit can be set and tested via the functions SetBitNumber and; TestBitNumber. .; The default value of all bits is kFALSE.; The size of the container is automatically extended when a bit; number is either set or tested. To reduce the memory size of the; container use the Compact function, this will discard the memory; occupied by the upper bits that are 0. Function Members (Methods); public:. TBits(UInt_t nbits = 8); TBits(const TBits&); virtual~TBits(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidCompact(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; UInt_tCountBits(UInt_t startBit = 0) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const ch",MatchSource.WIKI,root/html530/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBits.html
Usability,simpl,simple,". TBits. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBits. class TBits: public TObject. TBits. Container of bits. This class provides a simple container of bits.; Each bit can be set and tested via the functions SetBitNumber and; TestBitNumber. .; The default value of all bits is kFALSE.; The size of the container is automatically extended when a bit; number is either set or tested. To reduce the memory size of the; container use the Compact function, this will discard the memory; occupied by the upper bits that are 0. Function Members (Methods); public:. TBits(UInt_t nbits = 8); TBits(const TBits&); virtual~TBits(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidCompact(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; UInt_tCountBits(UInt_t startBit = 0) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const ch",MatchSource.WIKI,root/html530/TBits.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBits.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(",MatchSource.WIKI,root/html530/TBonjourBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBonjourBrowser.html
Deployability,install,install,". TBonjourBrowser. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » BONJOUR; » TBonjourBrowser. class TBonjourBrowser: public TObject, public TQObject. TBonjourBrowser. This class consists of one main member function,; BrowseForServiceType(), that looks for the service.; The rest of the class wraps the various bits of Bonjour service; browser. The static callback function is marked with the DNSSD_API; macro to make sure that the callback has the correct calling; convention on Windows. Bonjour works out-of-the-box on MacOS X. On Linux you have to; install the Avahi package and run the avahi-daemon. To compile; these classes and run Avahi on Linux you need to install the:; avahi; avahi-compat-libdns_sd-devel; nss-mdns; packages. After installation make sure the avahi-daemon is started. Function Members (Methods); public:. TBonjourBrowser(); virtual~TBonjourBrowser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); voidBonjourSocketReadyRead(); virtual voidTObject::Browse(TBrowser* b); Int_tBrowseForServiceType(const char* serviceType); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, ",MatchSource.WIKI,root/html530/TBonjourBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBonjourBrowser.html
Integrability,wrap,wraps,". TBonjourBrowser. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » BONJOUR; » TBonjourBrowser. class TBonjourBrowser: public TObject, public TQObject. TBonjourBrowser. This class consists of one main member function,; BrowseForServiceType(), that looks for the service.; The rest of the class wraps the various bits of Bonjour service; browser. The static callback function is marked with the DNSSD_API; macro to make sure that the callback has the correct calling; convention on Windows. Bonjour works out-of-the-box on MacOS X. On Linux you have to; install the Avahi package and run the avahi-daemon. To compile; these classes and run Avahi on Linux you need to install the:; avahi; avahi-compat-libdns_sd-devel; nss-mdns; packages. After installation make sure the avahi-daemon is started. Function Members (Methods); public:. TBonjourBrowser(); virtual~TBonjourBrowser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); voidBonjourSocketReadyRead(); virtual voidTObject::Browse(TBrowser* b); Int_tBrowseForServiceType(const char* serviceType); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, ",MatchSource.WIKI,root/html530/TBonjourBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBonjourBrowser.html
Availability,error,error,"rd(); voidTObject::AbstractMethod(const char* method) const; voidAddTXTRecord(const char* record); voidAddTXTRecord(const TString& record); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetRegisteredType() const; const char*GetReplyDomain() const; const char*GetServiceName() const; virtual const char*TObject::GetTitle() const; const char*GetTXTRecords() const; Int_tGetTXTRecordsLength() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer",MatchSource.WIKI,root/html530/TBonjourRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBonjourRecord.html
Availability,alive,alive,". TBonjourRegistrar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » BONJOUR; » TBonjourRegistrar. class TBonjourRegistrar: public TObject, public TQObject. TBonjourRegistrar. This class consists of one main member function, RegisterService(),; that registers the service. As long as the object is alive, the; service stays registered. The rest of the class wraps the various; bits of Bonjour service registration. The static callback function; is marked with the DNSSD_API macro to make sure that the callback; has the correct calling convention on Windows. Bonjour works out-of-the-box on MacOS X. On Linux you have to; install the Avahi package and run the avahi-daemon. To compile; these classes and run Avahi on Linux you need to install the:; avahi; avahi-compat-libdns_sd-devel; nss-mdns; packages. After installation make sure the avahi-daemon is started. Function Members (Methods); public:. TBonjourRegistrar(); virtual~TBonjourRegistrar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); voidBonjourSocketReadyRead(); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender",MatchSource.WIKI,root/html530/TBonjourRegistrar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBonjourRegistrar.html
Deployability,install,install,". TBonjourRegistrar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » BONJOUR; » TBonjourRegistrar. class TBonjourRegistrar: public TObject, public TQObject. TBonjourRegistrar. This class consists of one main member function, RegisterService(),; that registers the service. As long as the object is alive, the; service stays registered. The rest of the class wraps the various; bits of Bonjour service registration. The static callback function; is marked with the DNSSD_API macro to make sure that the callback; has the correct calling convention on Windows. Bonjour works out-of-the-box on MacOS X. On Linux you have to; install the Avahi package and run the avahi-daemon. To compile; these classes and run Avahi on Linux you need to install the:; avahi; avahi-compat-libdns_sd-devel; nss-mdns; packages. After installation make sure the avahi-daemon is started. Function Members (Methods); public:. TBonjourRegistrar(); virtual~TBonjourRegistrar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); voidBonjourSocketReadyRead(); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender",MatchSource.WIKI,root/html530/TBonjourRegistrar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBonjourRegistrar.html
Integrability,wrap,wraps,". TBonjourRegistrar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » BONJOUR; » TBonjourRegistrar. class TBonjourRegistrar: public TObject, public TQObject. TBonjourRegistrar. This class consists of one main member function, RegisterService(),; that registers the service. As long as the object is alive, the; service stays registered. The rest of the class wraps the various; bits of Bonjour service registration. The static callback function; is marked with the DNSSD_API macro to make sure that the callback; has the correct calling convention on Windows. Bonjour works out-of-the-box on MacOS X. On Linux you have to; install the Avahi package and run the avahi-daemon. To compile; these classes and run Avahi on Linux you need to install the:; avahi; avahi-compat-libdns_sd-devel; nss-mdns; packages. After installation make sure the avahi-daemon is started. Function Members (Methods); public:. TBonjourRegistrar(); virtual~TBonjourRegistrar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); voidBonjourSocketReadyRead(); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender",MatchSource.WIKI,root/html530/TBonjourRegistrar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBonjourRegistrar.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TInetAddressGetInetAddress() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetPort() const; virtual const char*TObject::GetTitle() const; const char*GetTXTRecord() const; virtual UInt_tTObject::GetUniqueID() const",MatchSource.WIKI,root/html530/TBonjourResolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBonjourResolver.html
Integrability,wrap,wraps,". TBonjourResolver. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » BONJOUR; » TBonjourResolver. class TBonjourResolver: public TObject, public TQObject. TBonjourResolver. This class consists of one main member function,; ResolveBonjourRecord(), that resolves the service to an actual; IP address and port number. The rest of the class wraps the various; bits of Bonjour service resolver. The static callback function; is marked with the DNSSD_API macro to make sure that the callback; has the correct calling convention on Windows. Function Members (Methods); public:. TBonjourResolver(); virtual~TBonjourResolver(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); voidBonjourSocketReadyRead(); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTObject::Copy(TObject& object) const; virtual void",MatchSource.WIKI,root/html530/TBonjourResolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBonjourResolver.html
Availability,error,error,"dTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& box) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const",MatchSource.WIKI,root/html530/TBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBox.html
Integrability,depend,depending,"to be drawn, specify option ""l"". TBox * DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw this box with new coordinates. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a BOX/WBOX/PAD object is clicked. If the mouse is clicked in one of the 4 corners of the box (pA,pB,pC,pD); the box is resized with the rubber rectangle. If the mouse is clicked inside the box, the box is moved. If the mouse is clicked on the 4 edges (pL,pR,pTop,pBot), the box is; rescaled parallel to this edge (same as Motif window manager). pA pTop pB; +--------------------------------------------+; | |; | |; | |; pL| pINSIDE |pR; | |; | |; | |; | |; +--------------------------------------------+; pD pBot pC. Note that this function is duplicated on purpose by TPad::ExecuteEvent.; If somebody modifies this function, may be similar changes should also; be applied to TPad::ExecuteEvent. void HideToolTip(Int_t event); Hide tool tip depending on the event type. Typically tool tips; are hidden when event is not a kMouseEnter and not a kMouseMotion; event. Int_t IsInside(Double_t x, Double_t y) const; Function which returns 1 if point x,y lies inside the box, 0 otherwise. void ls(Option_t* option = """") const; List this box with its attributes. void Paint(Option_t* option = """"); Paint this box with its current attributes. void PaintBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Option_t* option = """"); Draw this box with new coordinates. void Print(Option_t* option = """") const; Dump this box with its attributes. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetToolTipText(const char* text, Long_t delayms = 1000); Set tool tip text associated with this box. The delay is in; milliseconds (minimum 250). To remove tool tip call method with; text = 0. void Streamer(TBuffer& b); Stream an object of class TBox. Bool_t IsBeingResized(",MatchSource.WIKI,root/html530/TBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBox.html
Availability,error,error," virtual voidAddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFillLeaves(TBuffer& b); virtual TBranch*FindBranch(const char* name); virtual TLeaf*FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tFlushBaskets(); Int_tFlushOneBasket(UInt_t which); virtual char*GetAddress() const; TBasket*GetBasket(Int_t basket); Int_t*GetBasketBytes() const; Long64_t*GetBasketEntry() const; virtual Long64_tGetBasketSeek(Int_t basket) const; virtual Int_tGetBasketSize() const; virtual TList*GetBrowsables(); virtual const char*GetClassName() const; Int_tGetCompressionAlgorithm() const; Int_tGetCompressionLevel() const; Int_tGe",MatchSource.WIKI,root/html530/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranch.html
Deployability,update,updateSubBranches,"etAttFill(Option_t* option = """"); voidTObject::ResetBit(UInt_t f); static voidResetCount(); virtual voidResetReadEntry(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAddress(void* add); virtual voidSetAutoDelete(Bool_t autodel = kTRUE); virtual voidSetBasketSize(Int_t buffsize); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBufferAddress(TBuffer* entryBuffer); voidSetCompressionAlgorithm(Int_t algorithm = 0); voidSetCompressionLevel(Int_t level = 1); voidSetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEntries(Long64_t entries); virtual voidSetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidSetFile(TFile* file = 0); virtual voidSetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidSetFirstEntry(Long64_t entry); virtual Bool_tSetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOffset(Int_t offset = 0); virtual voidSetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidSetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetupAddresses(); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(con",MatchSource.WIKI,root/html530/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranch.html
Integrability,rout,routine," the output buffer. Example:; X ; variable X, type Float_t; Y/I : variable Y, type Int_t; Y/I2 ; variable Y, type Int_t converted to a 16 bits integer. Arrays of values are supported with the following syntax:; If leaf name has the form var[nelem], where nelem is alphanumeric, then; If nelem is a leaf name, it is used as the variable size of the array.; The leaf refered to by neleme **MUST** be an int (/I).; If leaf name has the form var[nelem], where nelem is a digit, then; it is used as the fixed size of the array.; If leaf name has the form of a multi dimenantion array (eg var[nelem][nelem2]); where nelem and nelem2 are digits) then; it is used as a 2 dimensional array of fixed size.; Any of other form is not supported. See an example of a Branch definition in the TTree constructor. Note that in case the data type is an object, this branch can contain; only this object. Note that this function is invoked by TTree::Branch. *. void Init(const char* name, const char* leaflist, Int_t compress); Initialization routine called from the constructor. This should NOT be made virtual. ~TBranch(); Destructor. void AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); Add the basket to this branch. void AddLastBasket(Long64_t startEntry); Add the start entry of the write basket (not yet created). void Browse(TBrowser* b); Browser interface. void DeleteBaskets(Option_t* option = """"); Loop on all branch baskets. If the file where branch buffers reside is; writable, free the disk space associated to the baskets of the branch,; then call Reset(). If the option contains ""all"", delete also the baskets; for the subbranches.; The branch is reset.; NOTE that this function must be used with extreme care. Deleting branch baskets; fragments the file and may introduce inefficiencies when adding new entries; in the Tree or later on when reading the Tree. void DropBaskets(Option_t* option = """"); Loop on all branch baskets. Drop all baskets from memory except readbasket.; If the option c",MatchSource.WIKI,root/html530/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranch.html
Modifiability,variab,variable,"nst char* name, const char* leaflist, Int_t compress); voidTObject::MakeZombie(); voidReadLeaves0Impl(TBuffer& b); voidReadLeaves1Impl(TBuffer& b); voidReadLeaves2Impl(TBuffer& b); voidReadLeavesImpl(TBuffer& b); voidSetSkipZip(Bool_t skip = kTRUE); Int_tWriteBasket(TBasket* basket, Int_t where). private:. TBranch(const TBranch&); TBranch&operator=(const TBranch&). Data Members; public:. enum EStatusBits { kAutoDelete; kDoNotUseBufferMap; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fAddress! Address of 1st leaf (variable or object); Int_t*fBasketBytes[fMaxBaskets] Lenght of baskets on file; Long64_t*fBasketEntry[fMaxBaskets] Table of first entry in eack basket; Long64_t*fBasketSeek[fMaxBaskets] Addresses of baskets on file; Int_tfBasketSizeInitial Size of Basket Buffer; TObjArrayfBaskets-> List of baskets of this branch; TObjArrayfBranches-> List of Branches of this branch; TList*fBrowsables! List of TVirtualBranchBrowsables used for Browse(); Int_tfCompressCompression level and algorithm; TBasket*fCurrentBasket! Pointer to the current basket.; TDirectory*fDirectory! Pointer to directory where this branch buffers are stored; Long64_tfEntriesNumber of entries; TBuffer*fEntryBuffer! Buffer used to directly pass the content without streaming; Long64_tfEntryNumberCurrent entry number (last one filled in this branch); Int_tfEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TStringfFileNameName of file where buffers are stored ("""" if in same file as Tree header); Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Long64_tfFirstBasketEntry! First entry in the current basket.; Long64_tfFirstEntryNumber of the first entry in this branch; TObjArrayfLeaves-> List of leaves of this branch; In",MatchSource.WIKI,root/html530/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranch.html
Performance,load,load," current buffer); if option =""*"" includes all sub-branches of this branch too. Long64_t GetZipBytes(Option_t* option = """") const; Return total number of zip bytes in the branch; if option =""*"" includes all sub-branches of this branch too. Bool_t IsAutoDelete() const; Return kTRUE if an existing object in a TBranchObject must be deleted. Bool_t IsFolder() const; Return kTRUE if more than one leaf or browsables, kFALSE otherwise. void KeepCircular(Long64_t maxEntries); keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(); Baskets associated to this branch are forced to be in memory.; You can call TTree::SetMaxVirtualSize(maxmemory) to instruct; the system that the total size of the imported baskets does not; exceed maxmemory bytes.; The function returns the number of baskets that have been put in memory.; This method may be called to force all baskets of one or more branches; in memory when random access to entries in this branch is required.; See also TTree::LoadBaskets to load all baskets of all branches in memory. void Print(Option_t* option = """") const; Print TBranch parameters. void ReadBasket(TBuffer& b); Loop on all leaves of this branch to read Basket buffer. void ReadLeavesImpl(TBuffer& b); Loop on all leaves of this branch to read Basket buffer. void ReadLeaves0Impl(TBuffer& b); Loop on all leaves of this branch to read Basket buffer. void ReadLeaves1Impl(TBuffer& b); Loop on all leaves of this branch to read Basket buffer. void ReadLeaves2Impl(TBuffer& b); Loop on all leaves of this branch to read Basket buffer. void Refresh(TBranch* b); refresh this branch using new information in b; This function is called by TTree::Refresh. void Reset(Option_t* option = """"); Reset a Branch. Existing buffers are deleted.; Entries, max and min are reset. void ResetAddress(); Reset the address of the branch. void ResetCount(); Static function resetting fgCount. void SetAddress(void* add); Set address of this branch. void SetAutoDelete(Bool_t autodel = kTRUE); Set th",MatchSource.WIKI,root/html530/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranch.html
Safety,avoid,avoid,"ption = """"); Reset a Branch. Existing buffers are deleted.; Entries, max and min are reset. void ResetAddress(); Reset the address of the branch. void ResetCount(); Static function resetting fgCount. void SetAddress(void* add); Set address of this branch. void SetAutoDelete(Bool_t autodel = kTRUE); Set the automatic delete bit. This bit is used by TBranchObject::ReadBasket to decide if an object; referenced by a TBranchObject must be deleted or not before reading; a new entry. If autodel is kTRUE, this existing object will be deleted, a new object; created by the default constructor, then read from disk by the streamer. If autodel is kFALSE, the existing object is not deleted. Root assumes; that the user is taking care of deleting any internal object or array; (this can be done in the streamer). void SetBasketSize(Int_t buffsize); Set the basket size; The function makes sure that the basket size is greater than fEntryOffsetlen. void SetBufferAddress(TBuffer* entryBuffer); -- Set address of this branch directly from a TBuffer to avoid streaming. Note: We do not take ownership of the buffer. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). void SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); Update the default value for the branch's fEntryOffsetLen if and only if; it was already non zero (and the new value is not zero); If updateExisting is true, also update all the existing branches. void SetEntries(Long64_t entries); Set the number of entries in this branch. void SetFile(TFile* file = 0); Set file where this branch writes/reads its buffers.; By default the branch buffers reside in the file where the; Tree was created.; If the file name where the tree was created is an absolute; path name or an URL (e.g. /castor/... or root://host/...); and if the fname is not an absolute path name or an URL then; the path of the tree file is prepended to fname to make the; b",MatchSource.WIKI,root/html530/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranch.html
Security,access,access," nelem is a leaf name, it is used as the variable size of the array,; otherwise return 0.; The leaf refered to by neleme **MUST** be an int (/I),; If leaf name has the form var[nelem], where nelem is a digit, then; it is used as the fixed size of the array.; If leaf name has the form of a multi dimenantion array (eg var[nelem][nelem2]); where nelem and nelem2 are digits) then; it is used as a 2 dimensional array of fixed size.; Any of other form is not supported. Note that the TTree will assume that all the item are contiguous in memory.; On some platform, this is not always true of the member of a struct or a class,; due to padding and alignment. Sorting your data member in order of decreasing; sizeof usually leads to their being contiguous in memory. * bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (eg 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. See an example of a Branch definition in the TTree constructor. Note that in case the data type is an object, this branch can contain; only this object. Note that this function is invoked by TTree::Branch. *. TBranch(TBranch* parent, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1); Create a Branch*-*-; *-* =====================. * address is the address of the first item of a structure; or the address of a pointer to an object (see example).; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a slash (/).; The variable type may be 0,1 or 2 characters. If no type is given,; the type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is assumed; of",MatchSource.WIKI,root/html530/TBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranch.html
Availability,error,error,"stBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTBranch::FillLeaves(TBuffer& b); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; virtual TList*TBranch::GetBrowsables(); vir",MatchSource.WIKI,root/html530/TBranchClones.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranchClones.html
Deployability,update,updateSubBranches,"anch::ResetCount(); virtual voidTBranch::ResetReadEntry(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAddress(void* add); virtual voidTBranch::SetAutoDelete(Bool_t autodel = kTRUE); virtual voidSetBasketSize(Int_t buffsize); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTBranch::SetBufferAddress(TBuffer* entryBuffer); voidTBranch::SetCompressionAlgorithm(Int_t algorithm = 0); voidTBranch::SetCompressionLevel(Int_t level = 1); voidTBranch::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTBranch::SetEntries(Long64_t entries); virtual voidTBranch::SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBranch::SetupAddresses(); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer",MatchSource.WIKI,root/html530/TBranchClones.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranchClones.html
Modifiability,variab,variable,"ReadLeaves0Impl(TBuffer& b); voidTBranch::ReadLeaves1Impl(TBuffer& b); voidTBranch::ReadLeaves2Impl(TBuffer& b); voidTBranch::ReadLeavesImpl(TBuffer& b); voidTBranch::SetSkipZip(Bool_t skip = kTRUE); Int_tTBranch::WriteBasket(TBasket* basket, Int_t where). Data Members; public:. enum TBranch::EStatusBits { kAutoDelete; kDoNotUseBufferMap; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*TBranch::fAddress! Address of 1st leaf (variable or object); Int_t*TBranch::fBasketBytes[fMaxBaskets] Lenght of baskets on file; Long64_t*TBranch::fBasketEntry[fMaxBaskets] Table of first entry in eack basket; Long64_t*TBranch::fBasketSeek[fMaxBaskets] Addresses of baskets on file; Int_tTBranch::fBasketSizeInitial Size of Basket Buffer; TObjArrayTBranch::fBaskets-> List of baskets of this branch; TBranch*fBranchCountBranch with clones count; TObjArrayTBranch::fBranches-> List of Branches of this branch; TList*TBranch::fBrowsables! List of TVirtualBranchBrowsables used for Browse(); TStringfClassNamename of the class of the objets in the ClonesArray; Int_tTBranch::fCompressCompression level and algorithm; TBasket*TBranch::fCurrentBasket! Pointer to the current basket.; TDirectory*TBranch::fDirectory! Pointer to directory where this branch buffers are stored; Long64_tTBranch::fEntriesNumber of entries; TBuffer*TBranch::fEntryBuffer! Buffer used to directly pass the content without streaming; Long64_tTBranch::fEntryNumberCurrent entry number (last one filled in this branch); Int_tTBranch::fEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TStringTBranch::fFileNameName of file where buffers are stored ("""" if in same file as Tree header); Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Long64_tTBranch::fFi",MatchSource.WIKI,root/html530/TBranchClones.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranchClones.html
Availability,error,error,"stBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFillLeaves(TBuffer& b); virtual TBranch*FindBranch(const char* name); virtual TLeaf*FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; TBranchElement*GetBranchCount() const; TBranchElement*GetBranchCount2() const; ",MatchSource.WIKI,root/html530/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranchElement.html
Deployability,update,updateSubBranches,"::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAddress(void* addobj); virtual voidTBranch::SetAutoDelete(Bool_t autodel = kTRUE); virtual voidSetBasketSize(Int_t buffsize); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBranchFolder(); virtual voidTBranch::SetBufferAddress(TBuffer* entryBuffer); virtual voidSetClassName(const char* name); voidTBranch::SetCompressionAlgorithm(Int_t algorithm = 0); voidTBranch::SetCompressionLevel(Int_t level = 1); voidTBranch::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTBranch::SetEntries(Long64_t entries); virtual voidTBranch::SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tSetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOffset(Int_t offset); voidSetParentClass(TClass* clparent); virtual voidSetParentName(const char* name); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidSetTargetClass(const char* name); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidSetType(Int_t btype); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidS",MatchSource.WIKI,root/html530/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranchElement.html
Energy Efficiency,allocate,allocated,"; -- Read leaves into i/o buffers for this branch.; Case of a data member within a TClonesArray (fType == 31). void ReadLeavesMember(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are not a counter. void ReadLeavesMemberBranchCount(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do have a branch count and are not a counter. void ReadLeavesMemberCounter(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For split-class branch, base class branch, data member branch, or top-level branch.; which do not have a branch count and are a counter. void ReadLeavesCustomStreamer(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Non TObject, Non collection classes with a custom streamer. void ReleaseObject(); -- Delete any object we may have allocated on a previous call to SetAddress. void Reset(Option_t* option = """"); -- Reset a Branch. Existing i/o buffers are deleted.; Entries, max and min are reset. void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch ",MatchSource.WIKI,root/html530/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranchElement.html
Integrability,interface,interface,"tected:. char*TBranch::fAddress! Address of 1st leaf (variable or object); Int_t*TBranch::fBasketBytes[fMaxBaskets] Lenght of baskets on file; Long64_t*TBranch::fBasketEntry[fMaxBaskets] Table of first entry in eack basket; Long64_t*TBranch::fBasketSeek[fMaxBaskets] Addresses of baskets on file; Int_tTBranch::fBasketSizeInitial Size of Basket Buffer; TObjArrayTBranch::fBaskets-> List of baskets of this branch; TClassReffBranchClass! Reference to class definition in fClassName; TBranchElement*fBranchCountpointer to primary branchcount branch; TBranchElement*fBranchCount2pointer to secondary branchcount branch; Int_tfBranchID! ID number assigned by a TRefTable.; Int_t*fBranchOffset! Sub-Branch offsets with respect to current transient class; TObjArrayTBranch::fBranches-> List of Branches of this branch; TList*TBranch::fBrowsables! List of TVirtualBranchBrowsables used for Browse(); UInt_tfCheckSumCheckSum of class; TStringfClassNameClass name of referenced object; Int_tfClassVersionVersion number of class; TClassReffClonesClass! Reference to class definition in fClonesName; TStringfClonesNameName of class in TClonesArray (if any); TVirtualCollectionProxy*fCollProxy! collection interface (if any); Int_tTBranch::fCompressCompression level and algorithm; TBasket*TBranch::fCurrentBasket! Pointer to the current basket.; TClassReffCurrentClass! Reference to current (transient) class definition; TDirectory*TBranch::fDirectory! Pointer to directory where this branch buffers are stored; Long64_tTBranch::fEntriesNumber of entries; TBuffer*TBranch::fEntryBuffer! Buffer used to directly pass the content without streaming; Long64_tTBranch::fEntryNumberCurrent entry number (last one filled in this branch); Int_tTBranch::fEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TStringTBranch::fFileNameName of file where buffers are stored ("""" if in same file as Tree header); Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Lon",MatchSource.WIKI,root/html530/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranchElement.html
Modifiability,variab,variable,"teAddress() const; Int_tTBranch::WriteBasket(TBasket* basket, Int_t where). private:. TBranchElement(const TBranchElement&); TBranchElement&operator=(const TBranchElement&); static voidSwitchContainer(TObjArray*). Data Members; public:. enum { kBranchFolder; kDeleteObject; kCache; kOwnOnfileObj; kAddressSet; kMakeClass; kDecomposedObj; };; enum TBranch::EStatusBits { kAutoDelete; kDoNotUseBufferMap; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*TBranch::fAddress! Address of 1st leaf (variable or object); Int_t*TBranch::fBasketBytes[fMaxBaskets] Lenght of baskets on file; Long64_t*TBranch::fBasketEntry[fMaxBaskets] Table of first entry in eack basket; Long64_t*TBranch::fBasketSeek[fMaxBaskets] Addresses of baskets on file; Int_tTBranch::fBasketSizeInitial Size of Basket Buffer; TObjArrayTBranch::fBaskets-> List of baskets of this branch; TClassReffBranchClass! Reference to class definition in fClassName; TBranchElement*fBranchCountpointer to primary branchcount branch; TBranchElement*fBranchCount2pointer to secondary branchcount branch; Int_tfBranchID! ID number assigned by a TRefTable.; Int_t*fBranchOffset! Sub-Branch offsets with respect to current transient class; TObjArrayTBranch::fBranches-> List of Branches of this branch; TList*TBranch::fBrowsables! List of TVirtualBranchBrowsables used for Browse(); UInt_tfCheckSumCheckSum of class; TStringfClassNameClass name of referenced object; Int_tfClassVersionVersion number of class; TClassReffClonesClass! Reference to class definition in fClonesName; TStringfClonesNameName of class in TClonesArray (if any); TVirtualCollectionProxy*fCollProxy! collection interface (if any); Int_tTBranch::fCompressCompression level and algorithm; TBasket*TBranch::fCurrentBasket! Pointer to the current basket.; TCl",MatchSource.WIKI,root/html530/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranchElement.html
Performance,load,loaded,"ill be deleted and recreate; each time an entry is read, whether or not the; TTree owns the object. void SetBasketSize(Int_t buffsize); -- Reset the basket size for all sub-branches of this branch element. void SetBranchCount(TBranchElement* bre); -- Set the branch counter for this branch. Bool_t SetMakeClass(Bool_t decomposeObj = kTRUE); Set the branch in a mode where the object are decomposed; (Also known as MakeClass mode).; Return whether the setting was possible (it is not possible for; TBranch and TBranchObject). void SetObject(void* objadd); Set object this branch is pointing to. void SetOffset(Int_t offset); Set offset of the object (to which the data member represented by this; branch belongs) inside its containing object (if any). void SetReadActionSequence(); Set the sequence of actions needed to read the data out of the buffer. void SetReadLeavesPtr(); Set the ReadLeaves pointer to execute the expected operations. void SetTargetClass(const char* name); Set the name of the class of the in-memory object into which the data will; loaded. void SetupAddresses(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. This is required to be done in order for; GetOffset to be correct and for GetEntry to run. void Streamer(TBuffer& b); -- Stream an object of class TBranchElement. Int_t Unroll(const char* name, TClass* cltop, TClass* cl, char* ptr, Int_t basketsize, Int_t splitlevel, Int_t btype); -- Split class cl into sub-branches of this branch. Create a sub-branch of this branch for each non-empty,; non-abstract base class of cl (unless we are a sub-branch; of a TClonesArray or an STL container, in which case we; do *not* create a sub-branch), and for each non-split data; member of cl. Note: We do *not* create sub-branches for base classes of cl; if we are a sub-branch of a TClonesArray or an STL container. Note: We do *not* create sub-branches for data members which; have a class type and which we are splitting. N",MatchSource.WIKI,root/html530/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranchElement.html
Safety,detect,detect,"o that when; SetAddress recursively sets their address, they will get the; same address as their containing class because i/o is based; on streamer info offsets from the addresss of the containing; class. Offsets are non-zero for base-class sub-branches that are; not the leftmost direct base class. They are laid out in; memory sequentially and only the leftmost direct base class; has the same address as the derived class. The streamer; offsets need to be added to the address of the base class; subobject which is not the same as the address of the; derived class for the non-leftmost direct base classes. Bool_t IsFolder() const; -- Return kTRUE if more than one leaf, kFALSE otherwise. Bool_t IsMissingCollection() const; -- Detect a collection written using a zero pointer in old versions of root.; In versions of ROOT older than 4.00/03, if a collection (TClonesArray; or STL container) was split but the pointer to the collection was zeroed; out, nothing was saved. Hence there is no __easy__ way to detect the; case. In newer versions, a zero is written so that a 'missing' collection; appears to be an empty collection. void Print(Option_t* option = """") const; Print branch parameters. void PrintValue(Int_t i) const; -- Prints values of leaves. void ReadLeavesImpl(TBuffer& b); -- Unconfiguration Read Leave function. void ReadLeavesMakeClass(TBuffer& b); -- Read leaves into i/o buffers for this branch.; For the case where the branch is set in MakeClass mode (decomposed object). void ReadLeavesCollection(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Case of a collection (fType == 4). void ReadLeavesCollectionSplitPtrMember(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Case of a data member within a collection (fType == 41). void ReadLeavesCollectionSplitVectorPtrMember(TBuffer& b); -- Read leaves into i/o buffers for this branch.; Case of a data member within a collection (fType == 41). void ReadLeavesCollectionMember(TBuffer& b); -- Read lea",MatchSource.WIKI,root/html530/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranchElement.html
Testability,test,test,"ent = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), and TChain::SetBranchAddress(); as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 = 0;. An example of a branch with an object allocated by us,; but owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = 0;; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. Notice that the only difference between this example; and the following example is that the event pointer; is zero when the branch is created. An example of a branch with an object allocated and; owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = new Event();; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. If AutoDelete is on (see TBranch::SetAutoDelete),; the top level objet will be deleted and recreate; each time an entry is read, whether or not the; TTree owns the object. void SetBasketSiz",MatchSource.WIKI,root/html530/TBranchElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranchElement.html
Availability,error,error,"stBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTBranch::FillLeaves(TBuffer& b); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; virtual TList*TBranch::GetBrowsables(); vir",MatchSource.WIKI,root/html530/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranchObject.html
Deployability,update,updateSubBranches,"oidTBranch::ResetCount(); virtual voidTBranch::ResetReadEntry(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAddress(void* addobj); virtual voidSetAutoDelete(Bool_t autodel = kTRUE); virtual voidSetBasketSize(Int_t buffsize); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTBranch::SetBufferAddress(TBuffer* entryBuffer); voidTBranch::SetCompressionAlgorithm(Int_t algorithm = 0); voidTBranch::SetCompressionLevel(Int_t level = 1); voidTBranch::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTBranch::SetEntries(Long64_t entries); virtual voidTBranch::SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetupAddresses(); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&",MatchSource.WIKI,root/html530/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranchObject.html
Energy Efficiency,efficient,efficient,"parameters. void Reset(Option_t* option = """"); Reset a branch. Existing buffers are deleted.; Entries, max and min are reset. void SetAddress(void* addobj); Set address of this branch. void SetAutoDelete(Bool_t autodel = kTRUE); Set the AutoDelete bit. This function can be used to instruct Root in TBranchObject::ReadBasket; to not delete the object referenced by a branchobject before reading a; new entry. By default, the object is deleted.; If autodel is kTRUE, this existing object will be deleted, a new object; created by the default constructor, then object->Streamer called.; If autodel is kFALSE, the existing object is not deleted. Root assumes; that the user is taking care of deleting any internal object or array; This can be done in Streamer itself.; If this branch has sub-branches, the function sets autodel for these; branches as well.; We STRONGLY suggest to activate this option by default when you create; the top level branch. This will make the read phase more efficient; because it minimizes the numbers of new/delete operations.; Once this option has been set and the Tree is written to a file, it is; not necessary to specify the option again when reading, unless you; want to set the opposite mode. void SetBasketSize(Int_t buffsize); Reset basket size for all subbranches of this branch. void Streamer(TBuffer& b); Stream an object of class TBranchObject. void SetupAddresses(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. This is required to be done in order for; GetOffset to be correct and for GetEntry to run. void UpdateAddress(); Update branch addresses if a new object was created. const char* GetClassName() const; { return fClassName.Data(); }. const char* GetObjClassName(); { return fClassName.Data(); }. » Author: Rene Brun 11/02/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBranchObject.h 39635 2011-06-09 15:37:27Z pcanal $ » Last generated: 2011-07-",MatchSource.WIKI,root/html530/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranchObject.html
Integrability,rout,routine,"leobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchObject(); Default constructor for BranchObject. TBranchObject(TTree* tree, const char* name, const char* classname, void* addobj, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1, Bool_t isptrptr = kTRUE); Create a BranchObject. TBranchObject(TBranch* parent, const char* name, const char* classname, void* addobj, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t compress = -1, Bool_t isptrptr = kTRUE); Create a BranchObject. void Init(TTree* tree, TBranch* parent, const char* name, const char* classname, void* addobj, Int_t basketsize, Int_t splitlevel, Int_t compress, Bool_t isptrptr); Initialization routine (run from the constructor so do not make this function virtual). ~TBranchObject(); Destructor for a BranchObject. void Browse(TBrowser* b); Browse the branch content. Int_t Fill(); Loop on all leaves of this branch to fill Basket buffer. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all branches of a BranchObject and return total number of bytes. If entry = 0 take current entry number + 1; If entry < 0 reset entry number to 0. The function returns the number of bytes read from the input buffer.; If entry does not exist the function returns 0.; If an I/O error occurs, the function returns -1. Int_t GetExpectedType(TClass*& clptr, EDataType& type); Fill expectedClass and expectedType with information on the data type of the; object/values contained in this branch (and thus the type of pointers; expected to be passed to Set[Branch]Address; return 0 in case of success and > 0 in case of failure. Bool_t IsFolder() co",MatchSource.WIKI,root/html530/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranchObject.html
Modifiability,variab,variable," voidTBranch::ReadLeaves0Impl(TBuffer& b); voidTBranch::ReadLeaves1Impl(TBuffer& b); voidTBranch::ReadLeaves2Impl(TBuffer& b); voidTBranch::ReadLeavesImpl(TBuffer& b); voidTBranch::SetSkipZip(Bool_t skip = kTRUE); Int_tTBranch::WriteBasket(TBasket* basket, Int_t where). Data Members; public:. enum { kWarn; };; enum TBranch::EStatusBits { kAutoDelete; kDoNotUseBufferMap; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*TBranch::fAddress! Address of 1st leaf (variable or object); Int_t*TBranch::fBasketBytes[fMaxBaskets] Lenght of baskets on file; Long64_t*TBranch::fBasketEntry[fMaxBaskets] Table of first entry in eack basket; Long64_t*TBranch::fBasketSeek[fMaxBaskets] Addresses of baskets on file; Int_tTBranch::fBasketSizeInitial Size of Basket Buffer; TObjArrayTBranch::fBaskets-> List of baskets of this branch; TObjArrayTBranch::fBranches-> List of Branches of this branch; TList*TBranch::fBrowsables! List of TVirtualBranchBrowsables used for Browse(); TStringfClassNameClass name of referenced object; Int_tTBranch::fCompressCompression level and algorithm; TBasket*TBranch::fCurrentBasket! Pointer to the current basket.; TDirectory*TBranch::fDirectory! Pointer to directory where this branch buffers are stored; Long64_tTBranch::fEntriesNumber of entries; TBuffer*TBranch::fEntryBuffer! Buffer used to directly pass the content without streaming; Long64_tTBranch::fEntryNumberCurrent entry number (last one filled in this branch); Int_tTBranch::fEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TStringTBranch::fFileNameName of file where buffers are stored ("""" if in same file as Tree header); Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Long64_tTBranch::fFirstBasketEntry! First entry in t",MatchSource.WIKI,root/html530/TBranchObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranchObject.html
Availability,error,error,"tBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTBranch::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFillLeaves(TBuffer& b); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; virtual TList*TBranch::GetBrowsables(); virtual cons",MatchSource.WIKI,root/html530/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranchRef.html
Deployability,update,updateSubBranches,"; virtual voidTBranch::ResetReadEntry(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTBranch::SetAddress(void* add); virtual voidTBranch::SetAutoDelete(Bool_t autodel = kTRUE); virtual voidTBranch::SetBasketSize(Int_t buffsize); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTBranch::SetBufferAddress(TBuffer* entryBuffer); voidTBranch::SetCompressionAlgorithm(Int_t algorithm = 0); voidTBranch::SetCompressionLevel(Int_t level = 1); voidTBranch::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTBranch::SetEntries(Long64_t entries); virtual voidTBranch::SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual Int_tSetParent(const TObject* obj, Int_t branchID); virtual voidSetRequestedEntry(Long64_t entry); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBranch::SetupAddresses();",MatchSource.WIKI,root/html530/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranchRef.html
Modifiability,variab,variable,"eaflist, Int_t compress); voidTObject::MakeZombie(); voidTBranch::ReadLeaves0Impl(TBuffer& b); voidTBranch::ReadLeaves1Impl(TBuffer& b); voidTBranch::ReadLeaves2Impl(TBuffer& b); voidReadLeavesImpl(TBuffer& b); voidTBranch::SetSkipZip(Bool_t skip = kTRUE); Int_tTBranch::WriteBasket(TBasket* basket, Int_t where). Data Members; public:. enum TBranch::EStatusBits { kAutoDelete; kDoNotUseBufferMap; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*TBranch::fAddress! Address of 1st leaf (variable or object); Int_t*TBranch::fBasketBytes[fMaxBaskets] Lenght of baskets on file; Long64_t*TBranch::fBasketEntry[fMaxBaskets] Table of first entry in eack basket; Long64_t*TBranch::fBasketSeek[fMaxBaskets] Addresses of baskets on file; Int_tTBranch::fBasketSizeInitial Size of Basket Buffer; TObjArrayTBranch::fBaskets-> List of baskets of this branch; TObjArrayTBranch::fBranches-> List of Branches of this branch; TList*TBranch::fBrowsables! List of TVirtualBranchBrowsables used for Browse(); Int_tTBranch::fCompressCompression level and algorithm; TBasket*TBranch::fCurrentBasket! Pointer to the current basket.; TDirectory*TBranch::fDirectory! Pointer to directory where this branch buffers are stored; Long64_tTBranch::fEntriesNumber of entries; TBuffer*TBranch::fEntryBuffer! Buffer used to directly pass the content without streaming; Long64_tTBranch::fEntryNumberCurrent entry number (last one filled in this branch); Int_tTBranch::fEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TStringTBranch::fFileNameName of file where buffers are stored ("""" if in same file as Tree header); Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Long64_tTBranch::fFirstBasketEntry! First entry in the current basket.; Long6",MatchSource.WIKI,root/html530/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranchRef.html
Performance,load,loads,". TBranchRef. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TBranchRef. class TBranchRef: public TBranch. A branch containing and managing a TRefTable for TRef autoloading.; It loads the TBranch containing a referenced object when requested; by TRef::GetObject(), so the reference can be resolved. The; information which branch to load is stored by TRefTable. Once a; TBranch has read the TBranchRef's current entry it will not be told; to re-read, in case the use has changed objects read from the; branch. LIMITATION; Note that this does NOT allow for autoloading of references spanning; different entries. The TBranchRef's current entry has to correspond; to the entry of the TBranch containing the referenced object. The TRef cannot be stored in a top-level branch which is a; TBranchObject for the auto-loading to work. E.g. you cannot store; the TRefs in TObjArray, and create a top-level branch storing this; TObjArray. Function Members (Methods); public:. TBranchRef(); TBranchRef(TTree* tree); virtual~TBranchRef(); voidTObject::AbstractMethod(const char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTBranch::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option =",MatchSource.WIKI,root/html530/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranchRef.html
Usability,clear,cleared,"re compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter. private:. Long64_tfRequestedEntry! Cursor indicating which entry is being requested. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchRef(); Default constructor. TBranchRef(TTree* tree); Main constructor called by TTree::BranchRef. ~TBranchRef(); Typical destructor. void Clear(Option_t* option = """"); Clear entries in the TRefTable. Int_t Fill(); Fill the branch basket with the referenced objects parent numbers. void FillLeaves(TBuffer& b); This function called by TBranch::Fill overloads TBranch::FillLeaves. Bool_t Notify(); This function is called by TRefTable::Notify, itself called by; TRef::GetObject.; The function reads the branch containing the object referenced; by the TRef. void Print(Option_t* option = """") const; Print the TRefTable branch. void ReadLeavesImpl(TBuffer& b); This function called by TBranch::GetEntry overloads TBranch::ReadLeaves. void Reset(Option_t* option = """"); Existing buffers are deleted; Entries, max and min are reset; TRefTable is cleared. Int_t SetParent(const TObject* obj, Int_t branchID); -- Set the current parent branch. This function is called by TBranchElement::GetEntry(); and TBranchElement::Fill() when reading or writing; branches that may contain referenced objects. TRefTable * GetRefTable() const; {return fRefTable;}. void SetRequestedEntry(Long64_t entry); {fRequestedEntry = entry;}. » Author: Rene Brun 19/08/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBranchRef.h 39635 2011-06-09 15:37:27Z pcanal $ » Last generated: 2011-07-04 15:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TBranchRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranchRef.html
Availability,error,error,"stBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFillLeaves(TBuffer& b); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; virtual TList*TBranch::GetBrowsables(); virtual cons",MatchSource.WIKI,root/html530/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranchSTL.html
Deployability,update,updateSubBranches,"tCount(); virtual voidTBranch::ResetReadEntry(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAddress(void* addr); virtual voidTBranch::SetAutoDelete(Bool_t autodel = kTRUE); virtual voidTBranch::SetBasketSize(Int_t buffsize); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTBranch::SetBufferAddress(TBuffer* entryBuffer); voidTBranch::SetCompressionAlgorithm(Int_t algorithm = 0); voidTBranch::SetCompressionLevel(Int_t level = 1); voidTBranch::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTBranch::SetEntries(Long64_t entries); virtual voidTBranch::SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBranch::SetupAddresses(); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer",MatchSource.WIKI,root/html530/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranchSTL.html
Modifiability,variab,variable,"nt_t compress); voidTObject::MakeZombie(); voidTBranch::ReadLeaves0Impl(TBuffer& b); voidTBranch::ReadLeaves1Impl(TBuffer& b); voidTBranch::ReadLeaves2Impl(TBuffer& b); voidTBranch::SetSkipZip(Bool_t skip = kTRUE); Int_tTBranch::WriteBasket(TBasket* basket, Int_t where). private:. voidReadLeavesImpl(TBuffer& b). Data Members; public:. enum TBranch::EStatusBits { kAutoDelete; kDoNotUseBufferMap; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*TBranch::fAddress! Address of 1st leaf (variable or object); Int_t*TBranch::fBasketBytes[fMaxBaskets] Lenght of baskets on file; Long64_t*TBranch::fBasketEntry[fMaxBaskets] Table of first entry in eack basket; Long64_t*TBranch::fBasketSeek[fMaxBaskets] Addresses of baskets on file; Int_tTBranch::fBasketSizeInitial Size of Basket Buffer; TObjArrayTBranch::fBaskets-> List of baskets of this branch; TObjArrayTBranch::fBranches-> List of Branches of this branch; TList*TBranch::fBrowsables! List of TVirtualBranchBrowsables used for Browse(); Int_tTBranch::fCompressCompression level and algorithm; TBasket*TBranch::fCurrentBasket! Pointer to the current basket.; TDirectory*TBranch::fDirectory! Pointer to directory where this branch buffers are stored; Long64_tTBranch::fEntriesNumber of entries; TBuffer*TBranch::fEntryBuffer! Buffer used to directly pass the content without streaming; Long64_tTBranch::fEntryNumberCurrent entry number (last one filled in this branch); Int_tTBranch::fEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TStringTBranch::fFileNameName of file where buffers are stored ("""" if in same file as Tree header); Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Long64_tTBranch::fFirstBasketEntry! First entry in the current basket.; Long6",MatchSource.WIKI,root/html530/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranchSTL.html
Performance,queue,queues,". TBranchSTL. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TBranchSTL. class TBranchSTL: public TBranch. TBranchSTL. A Branch handling STL collection of pointers (vectors, lists, queues,; sets and multisets) while storing them in split mode. Function Members (Methods); public:. TBranchSTL(); TBranchSTL(TTree* tree, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel); TBranchSTL(TBranch* parent, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel, TStreamerInfo* info, Int_t id); virtual~TBranchSTL(); voidTObject::AbstractMethod(const char* method) const; virtual voidTBranch::AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); virtual voidTBranch::AddLastBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_",MatchSource.WIKI,root/html530/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranchSTL.html
Security,checksum,checksum,"s branch; TBranch*TBranch::fParent! Pointer to parent branch.; Int_tTBranch::fReadBasket! Current basket number when reading; Long64_tTBranch::fReadEntry! Current entry number when reading; G__p2memfuncTBranch::fReadLeaves! Pointer to the ReadLeaves implementation to use. ; Bool_tTBranch::fSkipZip! After being read, the buffer will not be unziped.; Int_tTBranch::fSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter. private:. UInt_tfClCheckSumClass checksum; TStringfClassNameName of the parent class, if we're the data member; Int_tfClassVersionVersion number of the class; TVirtualCollectionProxy*fCollProxy! Collection proxy; TStringfContNameClass name of referenced object; Int_tfIDElement serial number in the streamer info; TIndArrayfInd! Indices; TClass*fIndArrayCl! Class of the ind array; TStreamerInfo*fInfo! The streamer info; char*fObject! Pointer to object at address or the; TBranch*fParent! Parent of this branch. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchSTL(); Default constructor. TBranchSTL(TTree* tree, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel); Normal constructor, called from TTree. TBranchSTL(TBranch* parent, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel, TStreamerInfo* info, Int_t id); Normal constructor, called from another branch. ~TBranchSTL(); destructor. void Browse(TBrowser* b); browse a STL branch. Int_t Fill(). Cleanup after revious fill. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0). Check if we should be doing this at all. TStreamerInfo* GetInfo() const. Check if we don't have the stre",MatchSource.WIKI,root/html530/TBranchSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBranchSTL.html
Availability,error,error,"stractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tGetDx() const; Float_tGetDy() const; Float_tGetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_t",MatchSource.WIKI,root/html530/TBRIK.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBRIK.html
Availability,error,error,"bject(TObject* obj); voidCheckObjectItem(TObject* obj, Bool_t check = kFALSE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreate(TObject* obj = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Long_tExecPlugin(const char* name = 0, const char* fname = 0, const char* cmd = 0, Int_t pos = 1, Int_t subpos = -1); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); voidExecuteDefaultAction(TObject* obj); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBrowserImp*GetBrowserImp() const; TContextMenu*GetContextMenu() const; virtual Option_t*GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Bool_tGetRefreshFlag() const; TObject*GetSelected() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTOb",MatchSource.WIKI,root/html530/TBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBrowser.html
Integrability,depend,depending,"tor=(const TBrowser&). Data Members; public:. enum { kNoHidden; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TContextMenu*fContextMenu!Context menu pointer; TBrowserImp*fImp!Window system specific browser implementation; TStringTNamed::fNameobject identifier; Bool_tfNeedRefreshTrue if the browser needs refresh; TBrowserTimer*fTimer!Browser's timer; TStringTNamed::fTitleobject title. private:. TObject*fLastSelectedObject!The last TObject selected by user. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBrowser(const char* name = ""Browser"", const char* title = ""ROOT Object Browser"", TBrowserImp* extimp = 0, Option_t* opt = """"); Create a new browser with a name, title. Width and height are by; default set to 640x400 and (optionally) adjusted by the screen factor; (depending on Rint.Canvas.UseScreenFactor to be true or false, default; is true). TBrowser(const char* name, const char* title, UInt_t width, UInt_t height, TBrowserImp* extimp = 0, Option_t* opt = """"); Create a new browser with a name, title, width and height. TBrowser(const char* name, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, TBrowserImp* extimp = 0, Option_t* opt = """"); Create a new browser with a name, title, position, width and height. TBrowser(const char* name, TObject* obj, const char* title = ""ROOT Object Browser"", Option_t* opt = """"); Create a new browser with a name, title, width and height for TObject *obj. TBrowser(const char* name, TObject* obj, const char* title, UInt_t width, UInt_t height, Option_t* opt = """"); Create a new browser with a name, title, width and height for TObject *obj. TBrowser(const char* name, TObject* obj, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """,MatchSource.WIKI,root/html530/TBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBrowser.html
Integrability,protocol,protocol,". TBrowserImp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBrowserImp. class TBrowserImp. TBrowserImp. ABC describing GUI independent browser implementation protocol. Function Members (Methods); public:. TBrowserImp(TBrowser* b = 0); TBrowserImp(TBrowser* b, const char* title, UInt_t width, UInt_t height, Option_t* opt = """"); TBrowserImp(TBrowser* b, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """"); virtual~TBrowserImp(); virtual voidAdd(TObject*, const char*, Int_t); virtual voidAddCheckBox(TObject*, Bool_t = kFALSE); virtual voidBrowseObj(TObject*); TBrowser*Browser() const; virtual voidCheckObjectItem(TObject*, Bool_t = kFALSE); static TClass*Class(); virtual voidCloseTabs(); virtual Long_tExecPlugin(const char*, const char*, const char*, Int_t, Int_t); virtual voidExecuteDefaultAction(TObject*); virtual TBrowser*GetBrowser() const; virtual Option_t*GetDrawOption() const; virtual TGMainFrame*GetMainFrame() const; virtual voidIconify(); virtual TClass*IsA() const; virtual voidRecursiveRemove(TObject*); virtual voidRefresh(Bool_t = kFALSE); virtual voidRemoveCheckBox(TObject*); virtual voidSetBrowser(TBrowser* b); virtual voidSetDrawOption(Option_t* option = """"); virtual voidSetStatusText(const char*, Int_t); virtual voidShow(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStartEmbedding(Int_t, Int_t); virtual voidStopEmbedding(const char*); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TBrowserImp(const TBrowserImp& br); TBrowserImp&operator=(const TBrowserImp& br). Data Members; protected:. TBrowser*fBrowserTBrowser associated with this implementation; Bool_tfShowCyclesShow object cycle numbers in browser. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation",MatchSource.WIKI,root/html530/TBrowserImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBrowserImp.html
Availability,error,error,"e, const char* cmd = """", Int_t tab = 1, Int_t sub = -1); virtual~TBrowserPlugin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObj",MatchSource.WIKI,root/html530/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBrowserPlugin.html
Modifiability,plugin,plugins,". TBrowserPlugin. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TBrowserPlugin. class TBrowserPlugin: public TNamed. TBrowserPlugin. Helper class used to manage plugins (command or macro to be executed). Function Members (Methods); public:. TBrowserPlugin(const TBrowserPlugin&); TBrowserPlugin(const char* name, const char* cmd = """", Int_t tab = 1, Int_t sub = -1); virtual~TBrowserPlugin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName(",MatchSource.WIKI,root/html530/TBrowserPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBrowserPlugin.html
Availability,error,error,"; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*First() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject*) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const;",MatchSource.WIKI,root/html530/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBtree.html
Energy Efficiency,adapt,adapt,". TBtree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBtree. class TBtree: public TSeqCollection. TBtree. B-tree class. TBtree inherits from the TSeqCollection ABC. ; B-tree Implementation notes; This implements B-trees with several refinements. Most of them can be found; in Knuth Vol 3, but some were developed to adapt to restrictions imposed; by C++. First, a restatement of Knuth's properties that a B-tree must; satisfy, assuming we make the enhancement he suggests in the paragraph; at the bottom of page 476. Instead of storing null pointers to non-existent; nodes (which Knuth calls the leaves) we utilize the space to store keys.; Therefore, what Knuth calls level (l-1) is the bottom of our tree, and; we call the nodes at this level LeafNodes. Other nodes are called InnerNodes.; The other enhancement we have adopted is in the paragraph at the bottom of; page 477: overflow control. The following are modifications of Knuth's properties on page 478:. Every InnerNode has at most Order keys, and at most Order+1 sub-trees.; Every LeafNode has at most 2*(Order+1) keys.; An InnerNode with k keys has k+1 sub-trees.; Every InnerNode that is not the root has at least InnerLowWaterMark keys.; Every LeafNode that is not the root has at least LeafLowWaterMark keys.; If the root is a LeafNode, it has at least one key.; If the root is an InnerNode, it has at least one key and two sub-trees.; All LeafNodes are the same distance from the root as all the other; LeafNodes.; For InnerNode n with key n[i].key, then sub-tree n[i-1].tree contains; all keys < n[i].key, and sub-tree n[i].tree contains all keys; >= n[i].key.; Order is at least 3. The values of InnerLowWaterMark and LeafLowWaterMark may actually be set; by the user when the tree is initialized, but currently they are set; automatically to:. ",MatchSource.WIKI,root/html530/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBtree.html
Modifiability,inherit,inherits,". TBtree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TBtree. class TBtree: public TSeqCollection. TBtree. B-tree class. TBtree inherits from the TSeqCollection ABC. ; B-tree Implementation notes; This implements B-trees with several refinements. Most of them can be found; in Knuth Vol 3, but some were developed to adapt to restrictions imposed; by C++. First, a restatement of Knuth's properties that a B-tree must; satisfy, assuming we make the enhancement he suggests in the paragraph; at the bottom of page 476. Instead of storing null pointers to non-existent; nodes (which Knuth calls the leaves) we utilize the space to store keys.; Therefore, what Knuth calls level (l-1) is the bottom of our tree, and; we call the nodes at this level LeafNodes. Other nodes are called InnerNodes.; The other enhancement we have adopted is in the paragraph at the bottom of; page 477: overflow control. The following are modifications of Knuth's properties on page 478:. Every InnerNode has at most Order keys, and at most Order+1 sub-trees.; Every LeafNode has at most 2*(Order+1) keys.; An InnerNode with k keys has k+1 sub-trees.; Every InnerNode that is not the root has at least InnerLowWaterMark keys.; Every LeafNode that is not the root has at least LeafLowWaterMark keys.; If the root is a LeafNode, it has at least one key.; If the root is an InnerNode, it has at least one key and two sub-trees.; All LeafNodes are the same distance from the root as all the other; LeafNodes.; For InnerNode n with key n[i].key, then sub-tree n[i-1].tree contains; all keys < n[i].key, and sub-tree n[i].tree contains all keys; >= n[i].key.; Order is at least 3. The values of InnerLowWaterMark and LeafLowWaterMark may actually be set; by the user when the tree is initialized, but currently they are set; automatically to:. ",MatchSource.WIKI,root/html530/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBtree.html
Performance,perform,perform,"e of a different order). The variable ""order""; is the order of the tree, and the inclusive upper limit on the indices of; the keys in the interior nodes. The variable ""order2"" is the inclusive; upper limit on the indices of the leaf nodes, and is designed; >; (1) to keep the sizes of the two kinds of nodes the same;; (2) to keep the expressions involving the arrays of keys looking; somewhat the same: lower limit upper limit; for inner nodes: 1 order; for leaf nodes: 0 order2; Remember that index 0 of the inner nodes is special. Currently, order2 = 2*(order+1).; >; Picture: (also see Knuth Vol 3 pg 478); +--+--+--+--+--+--...; | | | | | |; parent--->| | | |; | | | |; +*-+*-+*-+--+--+--...; | | |; +----+ | +-----+; | +-----+ |; V | V; +----------+ | +----------+; | | | | |; this->| | | | |<--sib; +----------+ | +----------+; V; data. It is conceptually VERY convenient to think of the data as being the; very first element of the sib node. Any primitive that tells sib to; perform some action on n nodes should include this 'hidden' element.; For InnerNodes, the hidden element has (physical) index 0 in the array,; and in LeafNodes, the hidden element has (virtual) index -1 in the array.; Therefore, there are two 'size' primitives for nodes:; >; Psize - the physical size: how many elements are contained in the; array in the node.; Vsize - the 'virtual' size; if the node is pointed to by; element 0 of the parent node, then Vsize == Psize;; otherwise the element in the parent item that points to this; node 'belongs' to this node, and Vsize == Psize+1;. Parent nodes are always InnerNodes. These are the primitive operations on Nodes:; >; Append(elt) - adds an element to the end of the array of elements in a; node. It must never be called where appending the element; would fill the node.; Split() - divide a node in two, and create two new nodes.; SplitWith(sib) - create a third node between this node and the sib node,; divvying up the elements of their arrays.; PushLeft(n) - mo",MatchSource.WIKI,root/html530/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBtree.html
Security,access,access,"ains all keys; >= n[i].key.; Order is at least 3. The values of InnerLowWaterMark and LeafLowWaterMark may actually be set; by the user when the tree is initialized, but currently they are set; automatically to:. InnerLowWaterMark = ceiling(Order/2); LeafLowWaterMark = Order - 1. If the tree is only filled, then all the nodes will be at least 2/3 full.; They will almost all be exactly 2/3 full if the elements are added to the; tree in order (either increasing or decreasing). [Knuth says McCreight's; experiments showed almost 100% memory utilization. I don't see how that; can be given the algorithms that Knuth gives. McCreight must have used; a different scheme for balancing. [No, he used a different scheme for; splitting: he did a two-way split instead of the three way split as we do; here. Which means that McCreight does better on insertion of ordered data,; but we should do better on insertion of random data.]]. It must also be noted that B-trees were designed for DISK access algorithms,; not necessarily in-memory sorting, as we intend it to be used here. However,; if the order is kept small (< 6?) any inefficiency is negligible for; in-memory sorting. Knuth points out that balanced trees are actually; preferable for memory sorting. I'm not sure that I believe this, but; it's interesting. Also, deleting elements from balanced binary trees, being; beyond the scope of Knuth's book (p. 465), is beyond my scope. B-trees; are good enough. A B-tree is declared to be of a certain ORDER (3 by default). This number; determines the number of keys contained in any interior node of the tree.; Each interior node will contain ORDER keys, and therefore ORDER+1 pointers; to sub-trees. The keys are numbered and indexed 1 to ORDER while the; pointers are numbered and indexed 0 to ORDER. The 0th ptr points to the; sub-tree of all elements that are less than key[1]. Ptr[1] points to the; sub-tree that contains all the elements greater than key[1] and less than; key[2]. etc. The array",MatchSource.WIKI,root/html530/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBtree.html
Testability,log,log,"ny elements are contained in the; array in the node.; Vsize - the 'virtual' size; if the node is pointed to by; element 0 of the parent node, then Vsize == Psize;; otherwise the element in the parent item that points to this; node 'belongs' to this node, and Vsize == Psize+1;. Parent nodes are always InnerNodes. These are the primitive operations on Nodes:; >; Append(elt) - adds an element to the end of the array of elements in a; node. It must never be called where appending the element; would fill the node.; Split() - divide a node in two, and create two new nodes.; SplitWith(sib) - create a third node between this node and the sib node,; divvying up the elements of their arrays.; PushLeft(n) - move n elements into the left sibling; PushRight(n) - move n elements into the right sibling; BalanceWithRight() - even up the number of elements in the two nodes.; BalanceWithLeft() - ditto. To allow this implementation of btrees to also be an implementation of; sorted arrays/lists, the overhead is included to allow O(log n) access; of elements by their rank (`give me the 5th largest element').; Therefore, each Item keeps track of the number of keys in and below it; in the tree (remember, each item's tree is all keys to the RIGHT of the; item's own key).; >; [ [ < 0 1 2 3 > 4 < 5 6 7 > 8 < 9 10 11 12 > ] 13 [ < 14 15 16 > 17 < 18 19 20 > ] ]; 4 1 1 1 1 4 1 1 1 5 1 1 1 1 7 3 1 1 1 4 1 1 1. Function Members (Methods); public:. TBtree(Int_t ordern = 3); virtual~TBtree(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAfter(const TObject*, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t); virtual voidAddBefore(const TObject*, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddLast(TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual TObject*After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCo",MatchSource.WIKI,root/html530/TBtree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBtree.html
Availability,avail,available,". TBuffer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBuffer. class TBuffer: public TObject. TBuffer. Buffer base class used for serializing objects. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TBuffer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidAutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*Buffer() const; Int_tBufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tCheckObject(const TObject* obj); virtual Bool_tCheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char*",MatchSource.WIKI,root/html530/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBuffer.html
Integrability,rout,routine,"ction documentation; ~TBuffer(); Delete an I/O buffer object. void AutoExpand(Int_t size_needed); Automatically calculate a new size and expand the buffer to fit at least size_needed.; The goals is to minimize the number of memory allocation and the memory allocation; which avoiding too much memory wastage.; If the size_needed is larger than the current size, the policy; is to expand to double the current size or the size_needed which ever is largest. void SetBuffer(void* buf, UInt_t bufsiz = 0, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; new buffer is expected to have the same size as the previous buffer.; The current buffer position is reset to the start of the buffer.; If the TBuffer owned the previous buffer, it will be deleted prior; to accepting the new buffer. By default the new buffer will be; adopted unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. void Expand(Int_t newsize, Bool_t copy = kTRUE); Expand (or shrink) the I/O buffer to newsize bytes.; If copy is true (the default), the existing content of the; buffer is preserved, otherwise the buffer is returned zero-ed out. TObject * GetParent() const; Return pointer to parent of this buffer. void SetParent(TObject* parent); Set parent owning this buffer. ReAllocCharFun_t GetReAllocFunc() const; Return the reallocation method currently used. void SetReAllocFunc(ReAllocCharFun_t reallocfunc = 0); Set which memory reallocation method to use. If reallocafunc is null,; reset it to the defaul value (TStorage::ReAlloc). void SetReadMode(); Set buffer in read mode. void SetWriteMode(); Set buffer in write mode. TClass * GetClass(const type_info& typeinfo); Forward to TROOT::GetClass(). TClass * GetClass(const char* className); Forward to TROOT::GetClass(). TProcessID * ReadProcessID(UShort_t pidf); Return the curre",MatchSource.WIKI,root/html530/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBuffer.html
Modifiability,extend,extending,"const TClass* cl, Bool_t useBcnt = kFALSE). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidoperator=(const TBuffer&); virtual Int_tRead(const char* name); virtual Int_tWrite(const char* name, Int_t opt, Int_t bufs); virtual Int_tWrite(const char* name, Int_t opt, Int_t bufs) const. Data Members; public:. enum EMode { kRead; kWrite; };; enum { kIsOwner; kCannotHandleMemberWiseStreaming; kInitialSize; kMinimalSize; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBufCurCurrent position in buffer; char*fBufMaxEnd of buffer; Int_tfBufSizeSize of buffer; char*fBufferBuffer used to store objects; vector<TVirtualArray*>fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Bool_tfModeRead or write mode; TObject*fParentPointer to parent object owning this buffer; ReAllocCharFun_tfReAllocFunc! Realloc function to be used when extending the buffer.; Int_tfVersionBuffer format version. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TBuffer(); Delete an I/O buffer object. void AutoExpand(Int_t size_needed); Automatically calculate a new size and expand the buffer to fit at least size_needed.; The goals is to minimize the number of memory allocation and the memory allocation; which avoiding too much memory wastage.; If the size_needed is larger than the current size, the policy; is to expand to double the current size or the size_needed which ever is largest. void SetBuffer(void* buf, UInt_t bufsiz = 0, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; new buffer is expected to have the same si",MatchSource.WIKI,root/html530/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBuffer.html
Performance,cache,cache,"const TClass* cl, Bool_t useBcnt = kFALSE). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidoperator=(const TBuffer&); virtual Int_tRead(const char* name); virtual Int_tWrite(const char* name, Int_t opt, Int_t bufs); virtual Int_tWrite(const char* name, Int_t opt, Int_t bufs) const. Data Members; public:. enum EMode { kRead; kWrite; };; enum { kIsOwner; kCannotHandleMemberWiseStreaming; kInitialSize; kMinimalSize; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBufCurCurrent position in buffer; char*fBufMaxEnd of buffer; Int_tfBufSizeSize of buffer; char*fBufferBuffer used to store objects; vector<TVirtualArray*>fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Bool_tfModeRead or write mode; TObject*fParentPointer to parent object owning this buffer; ReAllocCharFun_tfReAllocFunc! Realloc function to be used when extending the buffer.; Int_tfVersionBuffer format version. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TBuffer(); Delete an I/O buffer object. void AutoExpand(Int_t size_needed); Automatically calculate a new size and expand the buffer to fit at least size_needed.; The goals is to minimize the number of memory allocation and the memory allocation; which avoiding too much memory wastage.; If the size_needed is larger than the current size, the policy; is to expand to double the current size or the size_needed which ever is largest. void SetBuffer(void* buf, UInt_t bufsiz = 0, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; new buffer is expected to have the same si",MatchSource.WIKI,root/html530/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBuffer.html
Safety,avoid,avoiding,"nCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBufCurCurrent position in buffer; char*fBufMaxEnd of buffer; Int_tfBufSizeSize of buffer; char*fBufferBuffer used to store objects; vector<TVirtualArray*>fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Bool_tfModeRead or write mode; TObject*fParentPointer to parent object owning this buffer; ReAllocCharFun_tfReAllocFunc! Realloc function to be used when extending the buffer.; Int_tfVersionBuffer format version. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TBuffer(); Delete an I/O buffer object. void AutoExpand(Int_t size_needed); Automatically calculate a new size and expand the buffer to fit at least size_needed.; The goals is to minimize the number of memory allocation and the memory allocation; which avoiding too much memory wastage.; If the size_needed is larger than the current size, the policy; is to expand to double the current size or the size_needed which ever is largest. void SetBuffer(void* buf, UInt_t bufsiz = 0, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; new buffer is expected to have the same size as the previous buffer.; The current buffer position is reset to the start of the buffer.; If the TBuffer owned the previous buffer, it will be deleted prior; to accepting the new buffer. By default the new buffer will be; adopted unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. void Expand(Int_t newsize, Bool_t copy = kTRUE); Expand (or shrink) the I/O buffer to newsize bytes.; If copy is true (the default), the existing content of the; buffer is",MatchSource.WIKI,root/html530/TBuffer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBuffer.html
Availability,error,error,"city = 0); virtual~TBuffer3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearSectionsValid(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static UInt_tDecCSLevel(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static UInt_tGetCSLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; UInt_tGetSections(UInt_t mask) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; static voidIncCSLevel(); virtual voidTObject::Info(const char* method,",MatchSource.WIKI,root/html530/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBuffer3D.html
Energy Efficiency,efficient,efficient,"s required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; SetSectionsValid(TBuffer3D::kBoundingBox);; will generate IDs for each physical object internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); methods have an addChildren parameter. The viewer will complete this (if passed); indicating if children (contained within the one just sent) are worth adding. Recyling TBuffer3D ; Once add AddObject() has been called, the contents are copied to the viewer; internally. You are free to destroy this object, or recycle it for the next; object if suitable. Function Members (Methods); public:. TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacit",MatchSource.WIKI,root/html530/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBuffer3D.html
Integrability,interface,interface,". TBuffer3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBuffer3D. class TBuffer3D: public TObject. TBuffer3D. Generic 3D primitive description class - see TBuffer3DTypes for; producer classes. ; Filling TBuffer3D and Adding to Viewer; The viewers behind the TVirtualViewer3D interface differ greatly in their; capabilities e.g. Some know how to draw certain shapes natively (e.g. spheres/tubes in; OpenGL) - others always require a raw tessellation description of points/lines/segments.; Some; need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). . The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D; are used to test/set/clear these section valid flags.; The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw); are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section; in derived shape specific classes allows a more abstract shape description; (""a sphere of inner radius x, outer radius y""). This enables a viewer; which knows how to draw (tessellate) the shape itself to do so, which can bring; considerable performance and quality benefits, while providing a generic fallback; suitable for all viewers.; The rules for client negotiation with the viewer are:. If suitable specialized TBuffer3D class exists, use it, otherwise use; TBuffer3D.; Complete the mandatory Core section.; Complete the ShapeSpecific section; if applicable.; Complete the BoundingBox if you can.; Pass this b",MatchSource.WIKI,root/html530/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBuffer3D.html
Performance,perform,performance,". TBuffer3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBuffer3D. class TBuffer3D: public TObject. TBuffer3D. Generic 3D primitive description class - see TBuffer3DTypes for; producer classes. ; Filling TBuffer3D and Adding to Viewer; The viewers behind the TVirtualViewer3D interface differ greatly in their; capabilities e.g. Some know how to draw certain shapes natively (e.g. spheres/tubes in; OpenGL) - others always require a raw tessellation description of points/lines/segments.; Some; need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). . The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D; are used to test/set/clear these section valid flags.; The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw); are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section; in derived shape specific classes allows a more abstract shape description; (""a sphere of inner radius x, outer radius y""). This enables a viewer; which knows how to draw (tessellate) the shape itself to do so, which can bring; considerable performance and quality benefits, while providing a generic fallback; suitable for all viewers.; The rules for client negotiation with the viewer are:. If suitable specialized TBuffer3D class exists, use it, otherwise use; TBuffer3D.; Complete the mandatory Core section.; Complete the ShapeSpecific section; if applicable.; Complete the BoundingBox if you can.; Pass this b",MatchSource.WIKI,root/html530/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBuffer3D.html
Safety,detect,detect," drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicating it does not require you to provide further information about; this object. You should; not try to make any assumptions about what the viewer did with it.; This enables the viewer to be connected to a client which sends potentially; millions of objects, and only accept those that are of interest at a certain; time, caching the relatively small number of CPU/memory costly logical shapes,; and retaining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; SetSectionsValid(TBuffer3D::kBoundingBox);; will generate IDs for each physical object internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); ",MatchSource.WIKI,root/html530/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBuffer3D.html
Testability,test,test,"e. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBuffer3D. class TBuffer3D: public TObject. TBuffer3D. Generic 3D primitive description class - see TBuffer3DTypes for; producer classes. ; Filling TBuffer3D and Adding to Viewer; The viewers behind the TVirtualViewer3D interface differ greatly in their; capabilities e.g. Some know how to draw certain shapes natively (e.g. spheres/tubes in; OpenGL) - others always require a raw tessellation description of points/lines/segments.; Some; need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). . The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D; are used to test/set/clear these section valid flags.; The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw); are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section; in derived shape specific classes allows a more abstract shape description; (""a sphere of inner radius x, outer radius y""). This enables a viewer; which knows how to draw (tessellate) the shape itself to do so, which can bring; considerable performance and quality benefits, while providing a generic fallback; suitable for all viewers.; The rules for client negotiation with the viewer are:. If suitable specialized TBuffer3D class exists, use it, otherwise use; TBuffer3D.; Complete the mandatory Core section.; Complete the ShapeSpecific section; if applicable.; Complete the BoundingBox if you can.; Pass this buffer to the viewer using; one of the AddObject() methods - see below. If the viewer requires more sections to be completed (Raw/RawSizes) A",MatchSource.WIKI,root/html530/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBuffer3D.html
Usability,clear,clear,"e. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBuffer3D. class TBuffer3D: public TObject. TBuffer3D. Generic 3D primitive description class - see TBuffer3DTypes for; producer classes. ; Filling TBuffer3D and Adding to Viewer; The viewers behind the TVirtualViewer3D interface differ greatly in their; capabilities e.g. Some know how to draw certain shapes natively (e.g. spheres/tubes in; OpenGL) - others always require a raw tessellation description of points/lines/segments.; Some; need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). . The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D; are used to test/set/clear these section valid flags.; The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw); are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section; in derived shape specific classes allows a more abstract shape description; (""a sphere of inner radius x, outer radius y""). This enables a viewer; which knows how to draw (tessellate) the shape itself to do so, which can bring; considerable performance and quality benefits, while providing a generic fallback; suitable for all viewers.; The rules for client negotiation with the viewer are:. If suitable specialized TBuffer3D class exists, use it, otherwise use; TBuffer3D.; Complete the mandatory Core section.; Complete the ShapeSpecific section; if applicable.; Complete the BoundingBox if you can.; Pass this buffer to the viewer using; one of the AddObject() methods - see below. If the viewer requires more sections to be completed (Raw/RawSizes) A",MatchSource.WIKI,root/html530/TBuffer3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBuffer3D.html
Availability,error,error,"Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidForceWriteInfoClones(TClonesArray* a); virtual Int_tGetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static Int_tGetGlobalReadParam(); static Int_tGetGlobalWriteParam(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*GetInfo(); virtual TProcessID*",MatchSource.WIKI,root/html530/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBufferFile.html
Energy Efficiency,allocate,allocated,"its. IMPORTANT NOTEs. --NOTE 1; Lets assume an original variable double x:; When using the format [0,0,8] (ie range not specified) you get the best; relative precision when storing and reading back the truncated x, say xt.; The variance of (x-xt)/x will be better than when specifying a range; for the same number of bits. However the precision relative to the; range (x-xt)/(xmax-xmin) will be worst, and vice-versa.; The format [0,0,8] is also interesting when the range of x is infinite; or unknown. --NOTE 2; It is important to understand the difference with the meaning of nbits; -in case of [-1,1,nbits], nbits is the total number of bits used to make; the conversion from a double to an integer; -in case of [0,0,nbits], nbits is the number of bits used for the mantissa. see example of use of the Double32_t data type in tutorial double32.C. /*; ; */. Int_t ReadArray(Bool_t*& b); Read array of bools from the I/O buffer. Returns the number of; bools read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Char_t*& c); Read array of characters from the I/O buffer. Returns the number of; characters read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Short_t*& h); Read array of shorts from the I/O buffer. Returns the number of shorts; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Int_t*& i); Read array of ints from the I/O buffer. Returns the number of ints; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long_t*& l); Read array of longs from the I/O buffer. Returns the number of longs; read. If argument is a 0 pointer then space will be allocated for the; array. Int_t ReadArray(Long64_t*& l); Read array of long longs from the I/O buffer. Returns the number of; long longs read. If argument is a 0 pointer then space will be; allocated for the array. Int_t ReadArray(Float_t*& f); Read array of floats from ",MatchSource.WIKI,root/html530/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBufferFile.html
Integrability,rout,routine,":fVersionBuffer format version; static Int_tfgMapSizeDefault map size for all TBuffer objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferFile(TBuffer::EMode mode); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBufferFile(TBuffer::EMode mode, Int_t bufsiz); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. TBufferFile(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; to TBuffer via the buf argument. By default this buffer will be adopted; unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. ~TBufferFile(); Delete an I/O buffer object. Int_t GetVersionOwner() const; Return the version number of the owner file. void TagStreamerInfo(TVirtualStreamerInfo* info); Mark the classindex of the current file as using this TStreamerInfo. void IncrementLevel(TVirtualStreamerInfo* info); Increment level. void DecrementLevel(TVirtualStreamerInfo* ); Decrement level. void ReadLong(Long_t& l); Read Long from TBuffer. void ReadTString(TString& s); Read string from TBuffer. void WriteTString(const TString& s); Write string to TBuffer. void SetByteCount(UInt_t cntpos, Bool_t packInVersion = kFALSE); Set byte count at position cntpos in the buffer. Generate warning if; count larger than kMaxMapCount. The count is excluded its own size. Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss, const char* classname); Check byte count with current buffer position. They should; match. If not print warning and ",MatchSource.WIKI,root/html530/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBufferFile.html
Modifiability,extend,extending,"write; kWriteDelete; };. protected:. char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; vector<TVirtualArray*>TBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*fClassMapMap containing object,class pairs for reading; Int_tfDisplacementValue to be added to the map offsets; TStreamerInfo*fInfoPointer to TStreamerInfo object writing/reading the buffer; vector<TStreamerInfo*>fInfoStackStack of pointers to the TStreamerInfos; TExMap*fMapMap containing object,offset pairs for reading/writing; Int_tfMapCountNumber of objects or classes in map; Int_tfMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tfPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tfgMapSizeDefault map size for all TBuffer objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferFile(TBuffer::EMode mode); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBufferFile(TBuffer::EMode mode, Int_t bufsiz); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. TBufferFile(TBuffer::EMode mode, Int_t bufsiz, void* buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. An external buffer can be passed; to TBuffer via the buf argument. By default this buffer will be adopted; unless adopt is false.; If the ne",MatchSource.WIKI,root/html530/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBufferFile.html
Performance,cache,cache,"lass). Data Members; public:. enum { kMapSize; kStreamedMemberWise; kNotDecompressed; kTextBasedStreaming; kUser1; kUser2; kUser3; };; enum TBuffer::EMode { kRead; kWrite; };; enum TBuffer::[unnamed] { kIsOwner; kCannotHandleMemberWiseStreaming; kInitialSize; kMinimalSize; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; vector<TVirtualArray*>TBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*fClassMapMap containing object,class pairs for reading; Int_tfDisplacementValue to be added to the map offsets; TStreamerInfo*fInfoPointer to TStreamerInfo object writing/reading the buffer; vector<TStreamerInfo*>fInfoStackStack of pointers to the TStreamerInfos; TExMap*fMapMap containing object,offset pairs for reading/writing; Int_tfMapCountNumber of objects or classes in map; Int_tfMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tfPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tfgMapSizeDefault map size for all TBuffer objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferFile(TBuffer::EMode mode); Create an I/O buffer object. Mode should be either TBuffer::kRead or; TBuffer::kWrite. By default the I/O buffer has a size of; TBuffer::kInitialSize (1024) bytes. TBufferFile(TBuffer::EMode mode, Int_t bufsiz); ",MatchSource.WIKI,root/html530/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBufferFile.html
Safety,safe,safely,"te object to I/O buffer.; This function assumes that the value in 'obj' is the value stored in; a pointer to a ""ptrClass"". The actual type of the object pointed to; can be any class derived from ""ptrClass"".; Return:; 0: failure; 1: success; 2: truncated success (i.e actual class is missing. Only ptrClass saved.). TClass * ReadClass(const TClass* cl = 0, UInt_t* objTag = 0); Read class definition from I/O buffer. clReq can be used to cross check; if the actually read object is of the requested class. objTag is; set in case the object is a reference to an already read object. void WriteClass(const TClass* cl); Write class description to I/O buffer. void SkipVersion(const TClass* cl = 0); Skip class version from I/O buffer. Version_t ReadVersion(UInt_t* start = 0, UInt_t* bcnt = 0, const TClass* cl = 0); Read class version from I/O buffer. Version_t ReadVersionForMemberWise(const TClass* cl = 0); Read class version from I/O buffer ; to be used when streaming out; memberwise streamed collection where we do not care (not save) about; the byte count and can safely ignore missing streamerInfo (since they; usually indicate empty collections). UInt_t WriteVersion(const TClass* cl, Bool_t useBcnt = kFALSE); Write class version to I/O buffer. UInt_t WriteVersionMemberWise(const TClass* cl, Bool_t useBcnt = kFALSE); Write class version to I/O buffer after setting the kStreamedMemberWise; bit in the version number. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); Stream an object given its C++ typeinfo information. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); Stream an object given the name of its actual class. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); Stream an object given a pointer to its actual class. void StreamObject(TObject* obj); Stream an object inheriting from TObject using its streamer. void CheckCount(UInt_t offset); Check if offset is not too large (< k",MatchSource.WIKI,root/html530/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBufferFile.html
Security,hash,hashtable,"1); Add object to the fMap container.; If obj is not 0 add object to the map (in read mode also add 0 objects to; the map). This method may only be called outside this class just before; calling obj->Streamer() to prevent self reference of obj, in case obj; contains (via via) a pointer to itself. In that case offset must be 1; (default value for offset). void SetReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the map does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; This method can only be called directly after the creation of; the TBuffer, before any reading is done. Globally this option; can be changed using SetGlobalReadParam(). void SetWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; This method can only be called directly after the creation of; the TBuffer, before any writing is done. Globally this option; can be changed using SetGlobalWriteParam(). void InitMap(); Create the fMap container and initialize them; with the null object. void ResetMap(); Delete existing fMap and reset map counter. Int_t ReadBuf(void* buf, Int_t max); Read max bytes from the I/O buffer into buf. The function returns; the actual number of bytes read. void WriteBuf(const void* buf, Int_t max); Write max bytes from buf into the I/O buffer. char * ReadString(char* s, Int_t max",MatchSource.WIKI,root/html530/TBufferFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBufferFile.html
Availability,error,error,"Class*, Version_t = -1); virtual voidTBufferFile::ClassEnd(const TClass*); virtual voidTBufferFile::ClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTBufferFile::DecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTBufferFile::ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static Int_tTBufferFile::GetGlobalReadParam(); static Int_tTBufferFile::GetGlobalWriteParam(); virtual const char*TObject::GetIconName() c",MatchSource.WIKI,root/html530/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBufferSQL.html
Modifiability,extend,extending,"MaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; vector<TVirtualArray*>TBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*TBufferFile::fClassMapMap containing object,class pairs for reading; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; vector<TStreamerInfo*>TBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. vector<Int_t>*fColumnVec!; TString*fInsertQuery!; vector<int,allocator<int> >::iteratorfIter; TSQLRow**fRowPtr!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferSQL(TBuffer::EMode mode, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr); Constructor. TBufferSQL(TBuffer::EMode mode, Int_t bufsiz, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr); Constructor. TBufferSQL(TBuffer::EMode mode, Int_t bufsiz, vector<Int_t>* vc, TString* insert_query, TSQLRow** rowPtr, void* buf, Bool_t adopt = kTRUE); Constructor. TBufferSQL(); Constructor. ~TBufferSQL(); Destructo. void ReadBool(Bool_t& b); Operator>>. void ReadChar(Char_t& c); Operator>>. void ReadShort(Short_t& s); Operator>>. void ReadInt(Int_t& i); Operator>>. void ReadFloat(Float_t& f); Oper",MatchSource.WIKI,root/html530/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBufferSQL.html
Performance,cache,cache,"amedMemberWise; kNotDecompressed; kTextBasedStreaming; kUser1; kUser2; kUser3; };; enum TBuffer::EMode { kRead; kWrite; };; enum TBuffer::[unnamed] { kIsOwner; kCannotHandleMemberWiseStreaming; kInitialSize; kMinimalSize; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; vector<TVirtualArray*>TBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*TBufferFile::fClassMapMap containing object,class pairs for reading; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; vector<TStreamerInfo*>TBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. vector<Int_t>*fColumnVec!; TString*fInsertQuery!; vector<int,allocator<int> >::iteratorfIter; TSQLRow**fRowPtr!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferSQL(TBuffer::EMode mode, vector<Int_t>* vc, TString",MatchSource.WIKI,root/html530/TBufferSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBufferSQL.html
Availability,error,error,"const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTBufferFile::ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetErrorFlag() const; static const char*GetFloatFormat(); static Int_tTBufferFile::GetGlobalReadParam(); static Int_tTBufferFile::Get",MatchSource.WIKI,root/html530/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBufferSQL2.html
Modifiability,extend,extending,"ng64_tfFirstObjId! id of first object to be read from the database; Bool_tfIgnoreVerification! ignore verification of names ; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; vector<TStreamerInfo*>TBufferFile::fInfoStackStack of pointers to the TStreamerInfos; Long64_tfLastObjId! id of last object correspond to this key; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; Long64_tfObjIdCounter! counter of objects id; TExMap*fObjMap! Map between stored objects and object id; TObjArray*fObjectsInfos! array of objects info for selected key ; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; TMap*fPoolsMap! map of pools with data from different tables; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfReadBuffer! Buffer for read value; Int_tfReadVersionBuffer! buffer, used to by ReadVersion method; TSQLFile*fSQL! instance of TSQLFile; TSQLStructure*fStk! pointer on current active structure (stack head); TSQLStructure*fStructure! structures, created by object storing; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferSQL2(); Default constructor, should not be used. TBufferSQL2(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from sql.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferSQL2(TBuffer::EMode mode, TSQLFile* file); Creates buffer object to serailize/deserialize data to/from sql.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be ",MatchSource.WIKI,root/html530/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBufferSQL2.html
Performance,cache,cache,"; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; vector<TVirtualArray*>TBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*TBufferFile::fClassMapMap containing object,class pairs for reading; Int_tfCompressLevel! compress level used to minimize size of data in database; TSQLObjectData*fCurrentData! ; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; Int_tfErrorFlag! Error id value ; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; Long64_tfFirstObjId! id of first object to be read from the database; Bool_tfIgnoreVerification! ignore verification of names ; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; vector<TStreamerInfo*>TBufferFile::fInfoStackStack of pointers to the TStreamerInfos; Long64_tfLastObjId! id of last object correspond to this key; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; Long64_tfObjIdCounter! counter of objects id; TExMap*fObjMap! Map between stored objects and object id; TObjArray*fObjectsInfos! array of objects info for selected key ; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; TMap*fPoolsMap! map of pools with data from different tables; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfReadBuffer! Buff",MatchSource.WIKI,root/html530/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBufferSQL2.html
Safety,avoid,avoid," TClass** cl, void* obj = 0); Recreate object from sql structure.; Return pointer to read object.; if (cl!=0) returns pointer to class of object. Bool_t SqlObjectInfo(Long64_t objid, TString& clname, Version_t& version); Returns object info like classname and version; Should be taken from buffer, which is produced in the begginnig. TSQLObjectData* SqlObjectData(Long64_t objid, TSQLClassInfo* sqlinfo); creates TSQLObjectData for specifed object id and specified class; Object data for each class can be stored in two different tables.; First table contains data in column-wise form for simple types like integer,; strings and so on when second table contains any other data which cannot; be converted into column-wise representation.; TSQLObjectData will contain results of the requests to both such tables for; concrete object id. void WriteObject(const TObject* obj); Convert object into sql structures.; !!! Should be used only by TBufferSQL2 itself.; Use SqlWrite() functions to convert your object to sql; Redefined here to avoid gcc 3.x warning. Int_t SqlWriteObject(const void* obj, const TClass* objClass, TMemberStreamer* streamer = 0, Int_t streamer_index = 0); Write object to buffer; If object was written before, only pointer will be stored; Return id of saved object. void* SqlReadObject(void* obj, TClass** cl = 0, TMemberStreamer* streamer = 0, Int_t streamer_index = 0, const TClass* onFileClass = 0); Read object from the buffer. void* SqlReadObjectDirect(void* obj, TClass** cl, Long64_t objid, TMemberStreamer* streamer = 0, Int_t streamer_index = 0, const TClass* onFileClass = 0); Read object data.; Class name and version are taken from special objects table. void IncrementLevel(TVirtualStreamerInfo* ); Function is called from TStreamerInfo WriteBuffer and Readbuffer functions; and indent new level in data structure.; This call indicates, that TStreamerInfo functions starts streaming; object data of correspondent class. void DecrementLevel(TVirtualStreamerInfo* ); Fun",MatchSource.WIKI,root/html530/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBufferSQL2.html
Usability,simpl,simple,". TBufferSQL2. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » SQL; » TBufferSQL2. class TBufferSQL2: public TBufferFile. Class for serializing/deserializing object to/from SQL data base.; It redefines most of TBuffer class function to convert simple types,; array of simple types and objects to/from TSQLStructure objects.; TBufferSQL2 class uses streaming mechanism, provided by ROOT system,; therefore most of ROOT and user classes can be stored. There are; limitations for complex objects like TTree, TClonesArray, TDirectory and; few other, which can not be converted to SQL (yet). Function Members (Methods); public:. TBufferSQL2(TBuffer::EMode mode); TBufferSQL2(TBuffer::EMode mode, TSQLFile* file); virtual~TBufferSQL2(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tTBufferFile::CheckObject(const TObject* obj); virtual Bool_tTBufferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo",MatchSource.WIKI,root/html530/TBufferSQL2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBufferSQL2.html
Availability,error,error,"E); static void*ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); static TStringConvertToXML(TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); static TStringConvertToXML(void* obj, TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); virtual voidTObject::Copy(TObject& object) const; virtual voidDecrementLevel(TVirtualStreamerInfo*); static TStringTXMLSetup::DefaultXmlSetup(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize, Bool_t copy = kTRUE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTBufferFile::ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; static TClass*TBuffer::GetClass(const type_info& typeinfo); static TClass*TBuffer::GetClass(const char* className); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static const char*GetFloatFormat(); static Int_tTBufferFile::GetGlobalReadParam(); static Int_tTBufferFile::GetGlobalWriteParam(); virtual",MatchSource.WIKI,root/html530/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBufferXML.html
Deployability,configurat,configuration,"ument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects; static TStringTXMLSetup::fgNameSpaceBase. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferXML(); Default constructor. TBufferXML(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from xml.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferXML(TBuffer::EMode mode, TXMLFile* file); Creates buffer object to serailize/deserialize data to/from xml.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferXML(); destroy xml buffer. TXMLFile* XmlFile(); returns pointer to TXMLFile object; access to file is necessary to produce unique identifier for object references. TString ConvertToXML(TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts object, inherited from TObject class, to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TString ConvertToXML(void* obj, TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts any type of object to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TObject* ConvertFromXML(const char* str, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object from XML, produced by ConvertToXML() method.; If object does not inherit from TObject class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, produced by ConvertToXML() method.; If cl!=0, return actual class of object.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). XMLNodePointer_t XmlWriteAny(const voi",MatchSource.WIKI,root/html530/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBufferXML.html
Integrability,message,message,"er. void ReadFastArray(UShort_t* h, Int_t n); read array of UShort_t from buffer. void ReadFastArray(Int_t* i, Int_t n); read array of Int_t from buffer. void ReadFastArray(UInt_t* i, Int_t n); read array of UInt_t from buffer. void ReadFastArray(Long_t* l, Int_t n); read array of Long_t from buffer. void ReadFastArray(ULong_t* l, Int_t n); read array of ULong_t from buffer. void ReadFastArray(Long64_t* l, Int_t n); read array of Long64_t from buffer. void ReadFastArray(ULong64_t* l, Int_t n); read array of ULong64_t from buffer. void ReadFastArray(Float_t* f, Int_t n); read array of Float_t from buffer. void ReadFastArray(Double_t* d, Int_t n); read array of Double_t from buffer. void ReadFastArrayFloat16(Float_t* f, Int_t n, TStreamerElement* ele = 0); read array of Float16_t from buffer. void ReadFastArrayDouble32(Double_t* d, Int_t n, TStreamerElement* ele = 0); read array of Double32_t from buffer. void ReadFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void ReadFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void WriteArray(const Bool_t* b, Int_t n); Write array of Bool_t to buffer. void WriteArray(const Char_t* c, Int_t n); Write array of Char_t to buffer. void WriteArray(const UChar_t* c, Int_t n); Write array of UChar_t to buffer. void WriteArray(const Short_t* h, Int_t n); Write array of Short_t to buffer. void WriteArray(const UShort_t* h, Int_t n); Write array of UShort_t to buffer. void WriteArray(const Int_t* i, Int_t n); Write array of Int_ to buffer. void WriteArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteArray(const Lon",MatchSource.WIKI,root/html530/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBufferXML.html
Modifiability,extend,extending," reading; Int_tfCompressLevel! compression level and algorithm; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; Int_tfErrorFlag!; TClass*fExpectedBaseClass! pointer to class, which should be stored as parent of current; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; TObjArray*fIdArray!; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; vector<TStreamerInfo*>TBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TExMap*fObjMap!; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTXMLSetup::fRefCounter! counter , used to build id of xml references; TObjArrayfStack!; Bool_tTXMLSetup::fStoreStreamerInfos; TStringTXMLSetup::fStrBuf! buffer, used in XmlDefineClass() function; Bool_tTXMLSetup::fUseDtd; Bool_tTXMLSetup::fUseNamespaces; TStringfValueBuf!; Int_tTBuffer::fVersionBuffer format version; Version_tfVersionBuf!; TXMLEngine*fXML!; TXMLSetup::EXMLLayoutTXMLSetup::fXmlLayout; static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects; static TStringTXMLSetup::fgNameSpaceBase. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferXML(); Default constructor. TBufferXML(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from xml.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferXML(TBuffer::EMode mode,",MatchSource.WIKI,root/html530/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBufferXML.html
Performance,cache,cache,"; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum TXMLSetup::EXMLLayout { kSpecialized; kGeneralized; };. protected:. char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; vector<TVirtualArray*>TBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Bool_tfCanUseCompact! flag indicate that basic type (like Int_t) can be placed in the same tag; TExMap*TBufferFile::fClassMapMap containing object,class pairs for reading; Int_tfCompressLevel! compression level and algorithm; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; Int_tfErrorFlag!; TClass*fExpectedBaseClass! pointer to class, which should be stored as parent of current; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; TObjArray*fIdArray!; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; vector<TStreamerInfo*>TBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TExMap*fObjMap!; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTXMLSetup::fRefCounter! counter , used to build id of xml references; TObjArrayfStack!; Bool_tTXMLSetup::fStoreStreamerInfos; TStringTXMLSetup::fStrBuf! buffer, used in XmlDefineClass()",MatchSource.WIKI,root/html530/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBufferXML.html
Safety,avoid,avoid,"= kFALSE); Read object from XML, produced by ConvertToXML() method.; If object does not inherit from TObject class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, produced by ConvertToXML() method.; If cl!=0, return actual class of object.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). XMLNodePointer_t XmlWriteAny(const void* obj, const TClass* cl); Convert object of any class to xml structures; Return pointer on top xml element. void* XmlReadAny(XMLNodePointer_t node, void* obj, TClass** cl); Recreate object from xml structure.; Return pointer to read object.; if (cl!=0) returns pointer to class of object. void WriteObject(const TObject* obj); Convert object into xml structures.; !!! Should be used only by TBufferXML itself.; Use ConvertToXML() methods to convert your object to xml; Redefined here to avoid gcc 3.x warning. TXMLStackObj* PushStack(XMLNodePointer_t current, Bool_t simple = kFALSE); add new level to xml stack. TXMLStackObj* PopStack(); remove one level from xml stack. TXMLStackObj* Stack(Int_t depth = 0); return xml stack object of specified depth. XMLNodePointer_t StackNode(); return pointer on current xml node. void ShiftStack(const char* info = 0); shift stack node to next. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0 no compression.; level = 1 minimal compression level but fast. level = 9 maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negativ",MatchSource.WIKI,root/html530/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBufferXML.html
Security,access,access,"Int_tTBuffer::fVersionBuffer format version; Version_tfVersionBuf!; TXMLEngine*fXML!; TXMLSetup::EXMLLayoutTXMLSetup::fXmlLayout; static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects; static TStringTXMLSetup::fgNameSpaceBase. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferXML(); Default constructor. TBufferXML(TBuffer::EMode mode); Creates buffer object to serailize/deserialize data to/from xml.; Mode should be either TBuffer::kRead or TBuffer::kWrite. TBufferXML(TBuffer::EMode mode, TXMLFile* file); Creates buffer object to serailize/deserialize data to/from xml.; This constructor should be used, if data from buffer supposed to be stored in file.; Mode should be either TBuffer::kRead or TBuffer::kWrite. ~TBufferXML(); destroy xml buffer. TXMLFile* XmlFile(); returns pointer to TXMLFile object; access to file is necessary to produce unique identifier for object references. TString ConvertToXML(TObject* obj, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts object, inherited from TObject class, to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TString ConvertToXML(void* obj, TClass* cl, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); converts any type of object to XML string; fmt contains configuration of XML layout. See TXMLSetup class for detatils. TObject* ConvertFromXML(const char* str, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object from XML, produced by ConvertToXML() method.; If object does not inherit from TObject class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, produced by ConvertT",MatchSource.WIKI,root/html530/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBufferXML.html
Usability,simpl,simple,". TBufferXML. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » XML; » TBufferXML. class TBufferXML: public TBufferFile, public TXMLSetup. Class for serializing/deserializing object to/from xml.; It redefines most of TBuffer class function to convert simple types,; array of simple types and objects to/from xml.; Instead of writing a binary data it creates a set of xml structures as; nodes and attributes; TBufferXML class uses streaming mechanism, provided by ROOT system,; therefore most of ROOT and user classes can be stored to xml. There are; limitations for complex objects like TTree, which can not be yet converted to xml. Function Members (Methods); public:. TBufferXML(TBuffer::EMode mode); TBufferXML(TBuffer::EMode mode, TXMLFile* file); virtual~TBufferXML(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidTBuffer::AutoExpand(Int_t size_needed); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tCheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tTBufferFile::CheckObject(const TObject* obj); virtual Bool_tTBufferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidClassBegin(const TClass*, Version_t = -1); virtual voidClassEnd(const TClass*); virtual voidClassMember(const char* name, const char* typeName = 0, Int_t arrsize1 = -1, Int_t arrsize2 = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; static TObject*ConvertFromXML(const char* str, Bool_t Ge",MatchSource.WIKI,root/html530/TBufferXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TBufferXML.html
Availability,error,error,"ar* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*TPad::GetCanvas() const; virtual Int_tTPad::GetCanvasID() const; virtual TCanvasImp*TPad::GetCanvasImp() const; Int_tTPad::GetCrosshair() con",MatchSource.WIKI,root/html530/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TButton.html
Integrability,interface,interface,". TButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GPAD; » TButton. class TButton: public TPad, public TAttText. A TButton object is a user interface object.; A TButton has a name and an associated action.; When the button is clicked with the left mouse button, the cooresponding; action is executed.; A Tbutton can be created by direct invokation of the constructors; or via the graphics editor.; The Action can be set via TButton::SetMethod.; The action can be any command. Examples of actions:; ""34+78"" When the button is clicked, the result of addition is printed.; "".x macro.C"" . Clicking the button executes the macro macro.C; The action can be modified at any time via TButton::SetMethod. To modify the layout/size/contents of one or several buttons; in a canvas, you must set the canvas editable via TCanvas::SetEditable.; By default a TCanvas is editable.; By default a TDialogCanvas is not editable.; TButtons are in general placed in a TDialogCanvas. A TButton being a TPad, one can draw graphics primitives in it; when the TCanvas/TDialogCanvas is editable. Example of a macro creating a dialogcanvas with buttons; void but() {; example of a dialogcanvas with a few buttons. TDialogCanvas *dialog = new TDialogCanvas(""dialog"","""",200,300);. Create first button. Clicking on this button will execute 34+56; TButton *but1 = new TButton(""button1"",""34+56"",.05,.8,.45,.88);; but1->Draw();. Create second button. Clicking on this button will create a new canvas; TButton *but2 = new TButton(""canvas"",""c2 = new TCanvas(\""c2\"")"",.55,.8,.95,.88);; but2->Draw();. Create third button. Clicking on this button will invoke the browser; but3 = new TButton(""Browser"",""br = new TBrowser(\""br\"")"",0.25,0.54,0.75,0.64);; but3->SetFillColor(42);; but3->Draw();. Create last button with no name. Instead a graph is draw insi",MatchSource.WIKI,root/html530/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TButton.html
Testability,log,log,"e if fixed aspect ratio; TFrame*TPad::fFrame! Pointer to 2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); TStringfMethodMethod to be executed by this button; Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TObject*TPad::fPadView3D! 3D View of this TPad; Double_tTPad::fPhiphi angle to view as lego/surface; Double_tTPad::fPixeltoXxworld = fPixeltoXk + fPixeltoX*xpixel; Double_tTPad::fPixeltoXkConversion coefficient for pixel to X World; Double_tTPad::fPixeltoYyworld = fPixeltoYk + fPixeltoY*ypixel; Double_tTPad::fPixeltoYkConversion coefficient for pixel to Y World; Int_tTPad::fPixmapID! Off-screen pixmap identifier; TList*TPad::fPrimitives->List of primitives (subpads); Bool_tTVirtualPad::fResizing!true when resizing the pad; Float_tTAttPad::fRightMarg",MatchSource.WIKI,root/html530/TButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TButton.html
Availability,avail,available,"*************** *; * * * * * *; * * * * * *; * * * * * *; * * * * * *; * * * * * *; * * * * * *; * * Pad 1 * * Pad 2 * *; * * * * * *; * * * * * *; * * * * * *; * * * * * *; * * * * * *; * * * * * *; * ************************************ ************************* *; * *; ***********************************************************************. This canvas contains two pads named P1 and P2. Both Canvas, P1 and P2 can be; moved, grown, shrinked using the normal rules of the Display manager. The image below shows a canvas with 4 pads:. Once objects have been drawn in a canvas, they can be edited/moved by pointing; directly to them. The cursor shape is changed to suggest the type of action that; one can do on this object. Clicking with the right mouse button on an object; pops-up a contextmenu with a complete list of actions possible on this object. A graphical editor may be started from the canvas ""View"" menu under the menu; entry ""Toolbar"". An interactive HELP is available by clicking on the HELP button at the top right; of the canvas. It gives a short explanation about the canvas' menus. A canvas may be automatically divided into pads via TPad::Divide. At creation time, the canvas size defines the size of the canvas window; (including the window manager's decoration). To define precisely the graphics; area size of a canvas, the following four lines of code should be used:. {; Double_t w = 600;; Double_t h = 600;; TCanvas * c1 = new TCanvas(""c"", ""c"", w, h);; c->SetWindowSize(w + (w - c->GetWw()), h + (h - c->GetWh()));; }. . Function Members (Methods); public:. TCanvas(Bool_t build = kTRUE); TCanvas(const char* name, const char* title = """", Int_t form = 1); TCanvas(const char* name, const char* title, Int_t ww, Int_t wh); TCanvas(const char* name, Int_t ww, Int_t wh, Int_t winid); TCanvas(const char* name, const char* title, Int_t wtopx, Int_t wtopy, Int_t ww, Int_t wh); virtual~TCanvas(); virtual voidTPad::AbsCoordinates(Bool_t set); virtual Double_tTPad::AbsPixeltoX(",MatchSource.WIKI,root/html530/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TCanvas.html
Energy Efficiency,allocate,allocated,"r(Bool_t isfolder = kTRUE); If isfolder=kTRUE, the canvas can be browsed like a folder; by default a canvas is not browsable. void SetSelected(TObject* obj); Set selected canvas. void SetTitle(const char* title = """"); Set canvas title. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); Set the canvas scale in centimeters. This information is used by PostScript to set the page size.; xsize = size of the canvas in centimeters along X; ysize = size of the canvas in centimeters along Y; if xsize and ysize are not equal to 0, then the scale factors will; be computed to keep the ratio ysize/xsize independently of the canvas; size (parts of the physical canvas will be unused). if xsize = 0 and ysize is not zero, then xsize will be computed; to fit to the current canvas scale. If the canvas is resized,; a new value for xsize will be recomputed. In this case the aspect; ratio is not preserved. if both xsize = 0 and ysize = 0, then the scaling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& b); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. TC",MatchSource.WIKI,root/html530/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TCanvas.html
Integrability,depend,depending,":; Root > Tfile f(""file.root"");; Root > canvas.Draw();. TObject * DrawClone(Option_t* option = """") const; Draw a clone of this canvas; A new canvas is created that is a clone of this canvas. TObject * DrawClonePad(); Draw a clone of this canvas into the current pad; In an interactive session, select the destination/current pad; with the middle mouse button, then point to the canvas area to select; the canvas context menu item DrawClonePad.; Note that the original canvas may have subpads. void DrawEventStatus(Int_t event, Int_t x, Int_t y, TObject* selected); Report name and title of primitive below the cursor. This function is called when the option ""Event Status""; in the canvas menu ""Options"" is selected. void EditorBar(); Get editor bar. void EmbedInto(Int_t winid, Int_t ww, Int_t wh); Embedded a canvas into a TRootEmbeddedCanvas. This method is only called; via TRootEmbeddedCanvas::AdoptCanvas. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); Generate kMouseEnter and kMouseLeave events depending on the previously; selected object and the currently selected object. Does nothing if the; selected object does not change. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function must be implemented to realize the action; corresponding to the mouse click on the object in the canvas. Only handle mouse motion events in TCanvas, all other events are; ignored for the time being. void FeedbackMode(Bool_t set); Turn rubberband feedback mode on or off. void Flush(); Flush canvas buffers. void UseCurrentStyle(); Force a copy of current style for all objects in canvas. Int_t GetWindowTopX(); Returns current top x position of window on screen. Int_t GetWindowTopY(); Returns current top y position of window on screen. void HandleInput(EEventType button, Int_t x, Int_t y); Handle Input Events. Handle input events, like button up/down in current canvas. Bool_t IsFolder() const; Is folder ?. void ls(Option_t* option = ",MatchSource.WIKI,root/html530/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TCanvas.html
Modifiability,variab,variable,"cessedEvent() signal. void Resize(Option_t* option = """"); Recompute canvas parameters following a X11 Resize. void ResizeOpaque(Int_t set = 1); Set option to resize objects/pads in a canvas. if set = 1 (default) graphics objects are resized in opaque mode; = 0 only the outline of objects is drawn when resizing them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void RunAutoExec(); Execute the list of TExecs in the current pad. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitives in this canvas in C++ macro file with GUI. void SaveSource(const char* filename = """", Option_t* option = """"); Save primitives in this canvas as a C++ macro file.; This function loops on all the canvas primitives and for each primitive; calls the object SavePrimitive function.; When outputing floating point numbers, the default precision is 7 digits.; The precision can be changed (via system.rootrc) by changing the value; of the environment variable ""Canvas.SavePrecision"". void SetBatch(Bool_t batch = kTRUE); Toggle batch mode. However, if the canvas is created without a window; then batch mode always stays set. void SetCanvasSize(UInt_t ww, UInt_t wh); Set Width and Height of canvas to ww and wh respectively; If ww and/or wh are greater than the current canvas window; a scroll bar is automatically generated.; Use this function to zoom in a canvas and naviguate via; the scroll bars. void SetCursor(ECursor cursor); Set cursor. void SetDoubleBuffer(Int_t mode = 1); Set Double Buffer On/Off. void SetFixedAspectRatio(Bool_t fixed = kTRUE); Fix canvas aspect ratio to current value if fixed is true. void SetFolder(Bool_t isfolder = kTRUE); If isfolder=kTRUE, the canvas can be browsed like a folder; by default a canvas is not browsable. void SetSelected(TObject* obj); Set selected canvas. void SetTitle(const char* title = """"); Set canvas title. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); Set the canv",MatchSource.WIKI,root/html530/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TCanvas.html
Performance,response time,response time,"dle mouse motion events in TCanvas, all other events are; ignored for the time being. void FeedbackMode(Bool_t set); Turn rubberband feedback mode on or off. void Flush(); Flush canvas buffers. void UseCurrentStyle(); Force a copy of current style for all objects in canvas. Int_t GetWindowTopX(); Returns current top x position of window on screen. Int_t GetWindowTopY(); Returns current top y position of window on screen. void HandleInput(EEventType button, Int_t x, Int_t y); Handle Input Events. Handle input events, like button up/down in current canvas. Bool_t IsFolder() const; Is folder ?. void ls(Option_t* option = """") const; List all pads. TCanvas * MakeDefCanvas(); Static function to build a default canvas. void MoveOpaque(Int_t set = 1); Set option to move objects/pads in a canvas. if set = 1 (default) graphics objects are moved in opaque mode; = 0 only the outline of objects is drawn when moving them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void Paint(Option_t* option = """"); Paint canvas. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); Prepare for pick, call TPad::Pick() and when selected object; is different from previous then emit Picked() signal. void Picked(TPad* selpad, TObject* selected, Int_t event); Emit Picked() signal. void Selected(TVirtualPad* pad, TObject* obj, Int_t event); Emit Selected() signal. void ProcessedEvent(Int_t event, Int_t x, Int_t y, TObject* selected); Emit ProcessedEvent() signal. void Resize(Option_t* option = """"); Recompute canvas parameters following a X11 Resize. void ResizeOpaque(Int_t set = 1); Set option to resize objects/pads in a canvas. if set = 1 (default) graphics objects are resized in opaque mode; = 0 only the outline of objects is drawn when resizing them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void RunAutoExec(); Execute the list of TExecs in the current pad. v",MatchSource.WIKI,root/html530/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TCanvas.html
Testability,log,log,"TPad::fEditableTrue if canvas is editable; Bool_tTPad::fEmbeddedGL!; Int_tfEvent!Type of current or last handled event; Int_tfEventX!Last X mouse position in canvas; Int_tfEventY!Last Y mouse position in canvas; TList*TPad::fExecsList of commands to be executed when a pad event occurs; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Bool_tTPad::fFixedAspectRatioTrue if fixed aspect ratio; TFrame*TPad::fFrame! Pointer to 2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Color_tfHighLightColorHighlight color of active pad; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TPad*fPadSave!Pointer to saved pad in HandleInput; TObject*TPad::fPadView3D! 3D View of this TPad; TVirtualPadPainter*fPainter!Canvas (pad) painter.",MatchSource.WIKI,root/html530/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TCanvas.html
Usability,clear,cleared," ww is the canvas size in pixels along X; wh is the canvas size in pixels along Y. If ""name"" starts with ""gl"" the canvas is ready to receive GL output. void Constructor(const char* name, const char* title, Int_t wtopx, Int_t wtopy, Int_t ww, Int_t wh); Create a new canvas. wtopx,wtopy are the pixel coordinates of the top left corner of; the canvas (if wtopx < 0) the menubar is not shown); ww is the canvas size in pixels along X; wh is the canvas size in pixels along Y. void Init(); Initialize the TCanvas members. Called by all constructors. void Build(); Build a canvas. Called by all constructors. ~TCanvas(); Canvas destructor. void Browse(TBrowser* b); Browse. void Destructor(); Actual canvas destructor. TVirtualPad * cd(Int_t subpadnumber = 0); Set current canvas & pad. Returns the new current pad,; or 0 in case of failure.; See TPad::cd() for an explanation of the parameter. void Clear(Option_t* option = """"); Remove all primitives from the canvas.; If option ""D"" is specified, direct subpads are cleared but not deleted.; This option is not recursive, i.e. pads in direct subpads are deleted. void Cleared(TVirtualPad* pad); Emit pad Cleared signal. void Closed(); Emit Closed signal. void Close(Option_t* option = """"); Close canvas. Delete window/pads data structure. void CopyPixmaps(); Copy the canvas pixmap of the pad to the canvas. void Draw(Option_t* option = """"); Draw a canvas.; If a canvas with the name is already on the screen, the canvas is repainted.; This function is useful when a canvas object has been saved in a Root file.; One can then do:; Root > Tfile f(""file.root"");; Root > canvas.Draw();. TObject * DrawClone(Option_t* option = """") const; Draw a clone of this canvas; A new canvas is created that is a clone of this canvas. TObject * DrawClonePad(); Draw a clone of this canvas into the current pad; In an interactive session, select the destination/current pad; with the middle mouse button, then point to the canvas area to select; the canvas context menu i",MatchSource.WIKI,root/html530/TCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TCanvas.html
Availability,avail,available,"ile path are determined, the file will be accessed; via the rootd daemon. File names have to be specified like:; castor:/castor/cern.ch/user/r/rdm/bla.root. If Castor 2.1 is used the file names can also be specified; in the following ways:. castor://stager_host:stager_port/?path=/castor/cern.ch/user/; r/rdm/bla.root&svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION. castor://stager_host/?path=/castor/cern.ch/user/; r/rdm/bla.root&svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION. castor:///castor?path=/castor/cern.ch/user/; r/rdm/bla.root&svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION. path is mandatory as parameter but all the other ones are optional. Use ""&rootAuth=<auth_prot_code>"" in the option field to force the; specified authentication protocol when contacting the server, e.g. castor:///castor?path=/castor/cern.ch/user/r/rdm/bla.root; &svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION&rootAuth=3. will try first the globus/GSI protocol; available protocols are; 0: passwd, 1: srp, 2: krb5, 3: globus, 4: ssh, 5 uidgid; The defaul is taken from the env ROOTCASTORAUTH. Function Members (Methods); public:. TCastorFile(); TCastorFile(const char* url, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual~TCastorFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual voidTDirectoryFile::Browse(TBrowser* b); virtual voidTDirectoryFile::Build(TFile* motherFile = 0, TDirectory* motherDir = 0); virtual Bool_tTDirectoryFile::cd",MatchSource.WIKI,root/html530/TCastorFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TCastorFile.html
Integrability,protocol,protocol,"members; data members; class charts. ROOT; » IO; » CASTOR; » TCastorFile. class TCastorFile: public TNetFile. TCastorFile. A TCastorFile is like a normal TNetFile except that it obtains the; remote node (disk server) via the CASTOR API, once the disk server; and the local file path are determined, the file will be accessed; via the rootd daemon. File names have to be specified like:; castor:/castor/cern.ch/user/r/rdm/bla.root. If Castor 2.1 is used the file names can also be specified; in the following ways:. castor://stager_host:stager_port/?path=/castor/cern.ch/user/; r/rdm/bla.root&svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION. castor://stager_host/?path=/castor/cern.ch/user/; r/rdm/bla.root&svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION. castor:///castor?path=/castor/cern.ch/user/; r/rdm/bla.root&svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION. path is mandatory as parameter but all the other ones are optional. Use ""&rootAuth=<auth_prot_code>"" in the option field to force the; specified authentication protocol when contacting the server, e.g. castor:///castor?path=/castor/cern.ch/user/r/rdm/bla.root; &svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION&rootAuth=3. will try first the globus/GSI protocol; available protocols are; 0: passwd, 1: srp, 2: krb5, 3: globus, 4: ssh, 5 uidgid; The defaul is taken from the env ROOTCASTORAUTH. Function Members (Methods); public:. TCastorFile(); TCastorFile(const char* url, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual~TCastorFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncO",MatchSource.WIKI,root/html530/TCastorFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TCastorFile.html
Performance,cache,cacheDir,"oryFile::ReadTObject(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tTNetFile::ReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTNetFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t",MatchSource.WIKI,root/html530/TCastorFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TCastorFile.html
Safety,timeout,timeout,"dTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = 0); static voidTFile::SetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector& insp); virtual voidTFile::ShowStreamerInfo(); static Bool_tTFile::ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tTFile::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTFile::SumBuffer(Int_t bufsize); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f",MatchSource.WIKI,root/html530/TCastorFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TCastorFile.html
Security,access,accessed,". TCastorFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » CASTOR; » TCastorFile. class TCastorFile: public TNetFile. TCastorFile. A TCastorFile is like a normal TNetFile except that it obtains the; remote node (disk server) via the CASTOR API, once the disk server; and the local file path are determined, the file will be accessed; via the rootd daemon. File names have to be specified like:; castor:/castor/cern.ch/user/r/rdm/bla.root. If Castor 2.1 is used the file names can also be specified; in the following ways:. castor://stager_host:stager_port/?path=/castor/cern.ch/user/; r/rdm/bla.root&svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION. castor://stager_host/?path=/castor/cern.ch/user/; r/rdm/bla.root&svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION. castor:///castor?path=/castor/cern.ch/user/; r/rdm/bla.root&svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION. path is mandatory as parameter but all the other ones are optional. Use ""&rootAuth=<auth_prot_code>"" in the option field to force the; specified authentication protocol when contacting the server, e.g. castor:///castor?path=/castor/cern.ch/user/r/rdm/bla.root; &svcClass=MYSVCLASS&castorVersion=MYCASTORVERSION&rootAuth=3. will try first the globus/GSI protocol; available protocols are; 0: passwd, 1: srp, 2: krb5, 3: globus, 4: ssh, 5 uidgid; The defaul is taken from the env ROOTCASTORAUTH. Function Members (Methods); public:. TCastorFile(); TCastorFile(const char* url, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual~TCastorFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Appen",MatchSource.WIKI,root/html530/TCastorFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TCastorFile.html
Availability,error,error,":Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidDirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); virtual Long64_tDraw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTTree::DropBaskets(); virtual voidTTree::DropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*FindBranch(const char* name); virtual TLeaf*FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTTree::Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Int_tTTree::FlushBaskets() const; virtual const char*GetAlias(const char* aliasName) const; virtual Long64_tTTree::GetAutoFlush() const; virtual Long64_tTTree::GetAutoSave() const; virtual TBranch*GetBranch(const char* name); virtual TBranchRef*TTree::GetBranchRef() const;",MatchSource.WIKI,root/html530/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TChain.html
Deployability,update,updateExisting,"00); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tSetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidSetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual voidTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual voidTTree::SetCacheSize(Long64_t cachesize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidSetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidSetEntryList(TEntryList* elist, Option_t* opt = """"); virtual voidSetEntryListFile(const char* filename = """", Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 10000); virtual voidSetEventList(TEventList* evlist); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidSetMakeClass(Int_t make); virtual voidTAttMarker::SetMarkerAttributes()MENU ; virtual voidTAttMarker::SetMarkerC",MatchSource.WIKI,root/html530/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TChain.html
Energy Efficiency,allocate,allocated,"entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histogram limits; TEventList*TTree::fEventList! Pointer to event selection list (if one); TFile*fFile! Pointer to current file (We own the file).; Int_tTTree::fFileNumber! current file number (if file extensions); TObjArray*fFiles-> List of file names containing the trees (TChainElement, owned); Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Long64_tTTree::fFlushedBytesNumber of autoflushed bytes; UInt_tTTree::fFriendLockStatus! Record which method is locking the friend recursion; TList*TTree::fFriendspointer to list of friend elements; TArrayITTree::fIndexIndex of sorted values; TArrayDTTree::fIndexValuesSorted index values; TObjArrayTTree::fLeavesDirect pointers to individual branch leaves; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTTree::fMaxClusterRange! Memory allocated for the cluster range.; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tTTree::fNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'; TStringTNamed::fNameobject identifier; Int_tTTree::fNfill! Local for EntryLoop; TObject*TTree::fNotify! Object to be notified when loading a Tree; Int_tfNtreesNumber of trees; In",MatchSource.WIKI,root/html530/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TChain.html
Integrability,rout,routine,"failure. Long64_t GetEntryNumber(Long64_t entry) const; -- Return entry number corresponding to entry. if no TEntryList set returns entry; else returns entry #entry from this entry list and; also computes the global entry number (loads all tree headers). Int_t GetEntryWithIndex(Int_t major, Int_t minor = 0); -- Return entry corresponding to major and minor number. The function returns the total number of bytes read.; If the Tree has friend trees, the corresponding entry with; the index values (major,minor) is read. Note that the master Tree; and its friend may have different entry serial numbers corresponding; to (major,minor). TFile* GetFile() const; -- Return a pointer to the current file.; If no file is connected, the first file is automatically loaded. TLeaf* GetLeaf(const char* name); -- Return a pointer to the leaf name in the current tree. TObjArray* GetListOfBranches(); -- Return a pointer to the list of branches of the current tree. Warning: If there is no current TTree yet, this routine will open the; first in the chain. Returns 0 on failure. TObjArray* GetListOfLeaves(); -- Return a pointer to the list of leaves of the current tree. Warning: May set the current tree!. Double_t GetMaximum(const char* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all baskets of all trees in the chain.; For the time being use TChain::Merge and ",MatchSource.WIKI,root/html530/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TChain.html
Modifiability,variab,variables,"hen going to be processed by PROOF; Long64_tTTree::fReadEntry! Number of the entry being processed; Long64_tTTree::fSavedBytesNumber of autosaved bytes; Int_tTTree::fScanFieldNumber of runs before prompting in Scan; TList*fStatus-> List of active/inactive branches (TChainElement, owned); Int_tTTree::fTimerIntervalTimer interval in milliseconds; TStringTNamed::fTitleobject title; Long64_tTTree::fTotBytesTotal number of bytes in all branches before compression; Long64_tTTree::fTotalBuffers! Total number of bytes in branch buffers; TBuffer*TTree::fTransientBuffer! Pointer to the current transient buffer.; TTree*fTree! Pointer to current tree (Note: We do *not* own this tree.); TVirtualIndex*TTree::fTreeIndexPointer to the tree Index (if any); Int_tfTreeNumber! Current Tree number in fTreeOffset table; Long64_t*fTreeOffset[fTreeOffsetLen] Array of variables; Int_tfTreeOffsetLenCurrent size of fTreeOffset array; Int_tTTree::fUpdateUpdate frequency for EntryLoop; TList*TTree::fUserInfopointer to a list of user objects associated to this Tree; Double_tTTree::fWeightTree weight (see TTree::SetWeight); Long64_tTTree::fZipBytesTotal number of bytes in all branches after compression; static Int_tTTree::fgBranchStyleOld/New branch style; static Long64_tTTree::fgMaxTreeSizeMaximum size of a file containg a Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TChain(); -- Default constructor. TChain(const char* name, const char* title = """"); -- Create a chain. A TChain is a collection of TFile objects.; the first parameter ""name"" is the name of the TTree object; in the files added with Add.; Use TChain::Add to add a new element to this chain. In case the Tree is in a subdirectory, do, eg:; TChain ch(""subdir/treename"");. Example:; Suppose we have 3 files f1.root, f2.root and f3.root. Each file; contains a TTree object named ""T"".; TChain ch(""T""); creates a chain to process a Tree called ""T""; ch.Add(""f1.root"");; ch.Add(""f2.root"");; ch.Add(",MatchSource.WIKI,root/html530/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TChain.html
Performance,cache,cachesize,"st char* aliasName, const char* aliasFormula); virtual voidSetAutoDelete(Bool_t autodel = kTRUE); virtual voidTTree::SetAutoFlush(Long64_t autof = 30000000); virtual voidTTree::SetAutoSave(Long64_t autos = 300000000); virtual voidTTree::SetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tSetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidSetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual voidTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual voidTTree::SetCacheSize(Long64_t cachesize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidSetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidSetEntryList(TEntryList* elist, Option_t* opt = """"); virtual voidSetEntryListFile(const char* filename = """", Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 10000); virtual voidSetEventList(TEventList* evlist); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttribut",MatchSource.WIKI,root/html530/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TChain.html
Security,access,access," kBigNumber); Add all files referenced in the list to the chain. The object type in the; list must be either TFileInfo or TObjString or TUrl .; The function return 1 if successful, 0 otherwise. TFriendElement* AddFriend(const char* chainname, const char* dummy = """"); -- Add a TFriendElement to the list of friends of this chain. A TChain has a list of friends similar to a tree (see TTree::AddFriend).; You can add a friend to a chain with the TChain::AddFriend method, and you; can retrieve the list of friends with TChain::GetListOfFriends.; This example has four chains each has 20 ROOT trees from 20 ROOT files. TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; Now we can add the friends to the first chain. ch.AddFriend(""t1""); ch.AddFriend(""t2""); ch.AddFriend(""t3""). /*; ; */. The parameter is the name of friend chain (the name of a chain is always; the name of the tree from which it was created).; The original chain has access to all variable in its friends.; We can use the TChain::Draw method as if the values in the friends were; in the original chain.; To specify the chain to use in the Draw method, use the syntax:. <chainname>.<branchname>.<varname>; If the variable name is enough to uniquely identify the variable, you can; leave out the chain and/or branch name.; For example, this generates a 3-d scatter plot of variable ""var"" in the; TChain ch versus variable v1 in TChain t1 versus variable v2 in TChain t2. ch.Draw(""var:t1.v1:t2.v2"");; When a TChain::Draw is executed, an automatic call to TTree::AddFriend; connects the trees in the chain. When a chain is deleted, its friend; elements are also deleted. The number of entries in the friend must be equal or greater to the number; of entries of the original chain. If the friend has fewer entries a warning; is given and the resulting histogram will have missing entries.; For additional information see TTree::AddFriend. TFriendElement* AddFriend(const char* ch",MatchSource.WIKI,root/html530/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TChain.html
Testability,test,test,"E"");; file->mkdir(""mydir"")->cd();; ch.Merge(file);. Long64_t Merge(TCollection* list, Option_t* option = """"); Merge all chains in the collection. (NOT IMPLEMENTED). Long64_t Merge(TCollection* list, TFileMergeInfo* info); Merge all chains in the collection. (NOT IMPLEMENTED). Long64_t Merge(TFile* file, Int_t basketsize, Option_t* option = """"); Merge all the entries in the chain into a new tree in the current file. Note: The ""file"" parameter is *not* the file where the new; tree will be inserted. The new tree is inserted into; gDirectory, which is usually the most recently opened; file, or the directory most recently cd()'d to. If option = ""C"" is given, the compression level for all branches; in the new Tree is set to the file compression level. By default,; the compression level of all branches is the original compression; level in the old trees. If basketsize > 1000, the basket size for all branches of the; new tree will be set to basketsize. Example using the file generated in $ROOTSYS/test/Event; merge two copies of Event.root. gSystem.Load(""libEvent"");; TChain ch(""T"");; ch.Add(""Event1.root"");; ch.Add(""Event2.root"");; ch.Merge(""all.root"");. If the chain is expecting the input tree inside a directory,; this directory is NOT created by this routine. So if you do:. TChain ch(""mydir/mytree"");; ch.Merge(""newfile.root"");. The resulting file will not have subdirectories. In order to; preserve the directory structure do the following instead:. TFile* file = TFile::Open(""newfile.root"", ""RECREATE"");; file->mkdir(""mydir"")->cd();; ch.Merge(file);. If 'option' contains the word 'fast' the merge will be done without; unzipping or unstreaming the baskets (i.e., a direct copy of the raw; bytes on disk). When 'fast' is specified, 'option' can also contains a; sorting order for the baskets in the output file. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are wri",MatchSource.WIKI,root/html530/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TChain.html
Usability,undo,undo,"nchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*TTree::Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidBrowse(TBrowser*); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual voidCanDeleteRefs(Bool_t flag = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*TTree::CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*TTree::CreateBasket(TBranch*); virtual voidCreatePackets(); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidDirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); virtual Long64_tDraw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObje",MatchSource.WIKI,root/html530/TChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TChain.html
Availability,error,error,"itle, const char* filename); virtual~TChainElement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreatePackets(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual void*GetBaddress() const; virtual const char*GetBaddressClassName() const; virtual Bool_tGetBaddressIsPtr() const; virtual UInt_tGetBaddressType() const; virtual TBranch**GetBranchPtr() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual char*GetPackets() const",MatchSource.WIKI,root/html530/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TChainElement.html
Deployability,update,updated,"r* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EStatusBits { kHasBeenLookedUp; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. void*fBaddress!branch address when used as a branch; TStringfBaddressClassName!Name of the class pointed to by fBaddress; Bool_tfBaddressIsPtr!True if the address is a pointer to an address; UInt_tfBaddressType!Type of the value pointed to by fBaddress; TBranch**fBranchPtr!Address of user branch pointer (to updated upon loading a file); Long64_tfEntriesNumber of entries in the tree of this chain element; Int_tfNPacketsNumber of packets; TStringTNamed::fNameobject identifier; Int_tfPacketSizeNumber of events in one packet for parallel root; char*fPackets!Packet descriptor string; Int_tfStatusbranch status when used as a branch; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TChainElement(); Default constructor for a chain element. TChainElement(const char* title, const char* filename); Create a chain element. ~TChainElement(); Default destructor for a chain element. void CreatePackets(); Initialize the packet descriptor string. void ls(Option_t* option = """") const; List files in the chain. void SetPacketSize(Int_t size = 100); Set number of entries per packet for parallel root. void SetLookedUp(Bool_t y = kTRUE); Set/Reset the looked-up bit. TChainElement(). void * GetBaddress() const; {return fBaddress;}. const char * GetBaddressClassN",MatchSource.WIKI,root/html530/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TChainElement.html
Performance,load,loading,"r* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EStatusBits { kHasBeenLookedUp; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. void*fBaddress!branch address when used as a branch; TStringfBaddressClassName!Name of the class pointed to by fBaddress; Bool_tfBaddressIsPtr!True if the address is a pointer to an address; UInt_tfBaddressType!Type of the value pointed to by fBaddress; TBranch**fBranchPtr!Address of user branch pointer (to updated upon loading a file); Long64_tfEntriesNumber of entries in the tree of this chain element; Int_tfNPacketsNumber of packets; TStringTNamed::fNameobject identifier; Int_tfPacketSizeNumber of events in one packet for parallel root; char*fPackets!Packet descriptor string; Int_tfStatusbranch status when used as a branch; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TChainElement(); Default constructor for a chain element. TChainElement(const char* title, const char* filename); Create a chain element. ~TChainElement(); Default destructor for a chain element. void CreatePackets(); Initialize the packet descriptor string. void ls(Option_t* option = """") const; List files in the chain. void SetPacketSize(Int_t size = 100); Set number of entries per packet for parallel root. void SetLookedUp(Bool_t y = kTRUE); Set/Reset the looked-up bit. TChainElement(). void * GetBaddress() const; {return fBaddress;}. const char * GetBaddressClassN",MatchSource.WIKI,root/html530/TChainElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TChainElement.html
Availability,error,error,"ChainIndex(); voidTObject::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntryNumberFriend(const TTree* parent); virtual Long64_tGetEntryNumberWithBestIndex(Int_t major, Int_t minor) const; virtual Long64_tGetEntryNumberWithIndex(Int_t major, Int_t minor) const; virtual const char*TObject::GetIconName() const; virtual TTreeFormula*GetMajorFormulaParent(const TTree* parent); virtual const char*GetMajorName() const; virtual TTreeFormula*GetMinorFormulaParent(const TTree* parent); virtual const char*GetMinorName() const; virtual Long64_tGetN() const; virtual ",MatchSource.WIKI,root/html530/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TChainIndex.html
Deployability,release,released,"ainIndex. See TTreeIndex::TTreeIndex for the description of the; parameters.; The tree must be a TChain.; All the index values in the first tree of the chain must be; less then any index value in the second one, and so on.; If any of those requirements isn't met the object becomes a zombie.; If some subtrees don't have indices the indices are created and stored inside this; TChainIndex. void Append(const TVirtualIndex* , Bool_t delaySort = kFALSE); add an index to this chain; if delaySort is kFALSE (default) check if the indices of different trees are in order. void DeleteIndices(); Delete all the indices which were built by this object. ~TChainIndex(); The destructor. std::pair<TVirtualIndex*, Int_t> GetSubTreeIndex(Int_t major, Int_t minor) const; Returns a TVirtualIndex for a tree which holds the entry with the specified; major and minor values and the number of that tree.; If the index for that tree was created by this object it's set to the tree.; The tree index should be later released using ReleaseSubTreeIndex();. void ReleaseSubTreeIndex(TVirtualIndex* index, Int_t treeNo) const; Releases the tree index got using GetSubTreeIndex. If the index was; created by this object it is removed from the current tree, so that it isn't; deleted in its destructor. Long64_t GetEntryNumberFriend(const TTree* parent); see TTreeIndex::GetEntryNumberFriend for description. Long64_t GetEntryNumberWithBestIndex(Int_t major, Int_t minor) const; See TTreeIndex::GetEntryNumberWithBestIndex for details. Long64_t GetEntryNumberWithIndex(Int_t major, Int_t minor) const; Returns the entry number with given index values.; See TTreeIndex::GetEntryNumberWithIndex for details. TTreeFormula * GetMajorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the majorname in parent tree T. TTreeFormula * GetMinorFormulaParent(const TTree* parent); return a pointer to the TreeFormula corresponding to the minorname in parent tree T. void UpdateFormulaLeaves(const ",MatchSource.WIKI,root/html530/TChainIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TChainIndex.html
Availability,error,error,"(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tCopyRows(const TChair* srcChair, Int_t srcRow = 0, Int_t dstRow = 0, Int_t nRows = 0, Bool_t expand = kFALSE); virtual voidCopySet(TChair& chair); virtual voidTDataSet::Delete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual TH1*Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidFit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual Char_t*GetArray() const; v",MatchSource.WIKI,root/html530/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TChair.html
Integrability,interface,interface,". TChair. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TChair. class TChair: public TDataSet. TChair. It is a base class to create a custom interface for TTable objects. Function Members (Methods); public:. TChair(TTable* table); TChair(const TChair& org); virtual~TChair(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDataSet::Add(TDataSet* dataset); virtual voidAddAt(TDataSet* dataset, Int_t idx); virtual voidAddAt(const void* c, Int_t i); virtual voidTDataSet::AddAtAndExpand(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddFirst(TDataSet* dataset); virtual voidTDataSet::AddLast(TDataSet* dataset); virtual voidAdopt(Int_t n, void* array); virtual voidTObject::AppendPad(Option_t* option = """"); const void*At(Int_t i) const; virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TDataSet::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tCopyRows(const TChair* srcChair, Int_t srcRow = 0, Int_t dstRow = 0, Int_t nRows = 0, Bool_t expand = kFALSE); virtual voidCopySet(TChair& chair); virtual voidTDataSet::Delete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual TH1*Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObj",MatchSource.WIKI,root/html530/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TChair.html
Testability,assert,assert,"ointer to the last used table row; fLastRow = table[fLastIndx]; TSeqCollection*TDataSet::fListList of the the the objects included into this dataset; TStringTNamed::fNameobject identifier; TDataSet*TDataSet::fParentpointer to mother of the directory; TTable*fTablethe ""TTable"" object this object is pthe proxy for; TStringTNamed::fTitleobject title; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void AddAt(TDataSet* dataset, Int_t idx); {TDataSet::AddAt(dataset,idx);}. void * operator[](Int_t i). const void * operator[](Int_t i) const; if (!GetThisTable()->BoundsOk(""TChair::operator[]"", i)); i = 0;. TTable * GetThisTable(); {return fTable; }. const TTable * GetThisTable() const; {return fTable; }. void * GetOffset(const void* base, ULong_t offset); { return (void *)((Char_t *)base + offset);}. TChair(); { ; }. TChair(TTable* table); { ; }. TChair(const TChair& org); TChair &operator=(const TChair &rhs){ assert(0); return rhs;}. {assert(0);}. virtual ~TChair(); {;}. void Adopt(Int_t n, void* array); {GetThisTable()->Adopt(n,array);}. void AddAt(TDataSet* dataset, Int_t idx). const void * At(Int_t i) const; {return GetThisTable()->At(i);}. void Browse(TBrowser* b); {GetThisTable()->Browse(b);}. void CopySet(TChair& chair); {GetThisTable()->CopySet(*chair.GetThisTable());}. Int_t CopyRows(const TChair* srcChair, Int_t srcRow = 0, Int_t dstRow = 0, Int_t nRows = 0, Bool_t expand = kFALSE); {return GetThisTable()->CopyRows(srcChair->GetThisTable(),srcRow,dstRow,nRows,expand);}. void Draw(Option_t* opt); {GetThisTable()->Draw(opt);}. TH1 * Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); {return GetThisTable()->Draw(varexp,selection,option,nentries,firstentry);}. TH1 * Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0). Char_t * GetArray() c",MatchSource.WIKI,root/html530/TChair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TChair.html
Availability,error,error,"ncludePath(const char* path); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tAutoLoad(const char* classname); static intAutoLoadCallback(const char* cls, const char* lib); virtual voidBaseClassInfo_Delete(BaseClassInfo_t* bcinfo) const; virtual BaseClassInfo_t*BaseClassInfo_Factory(ClassInfo_t* info) const; virtual const char*BaseClassInfo_FullName(BaseClassInfo_t* bcinfo) const; virtual const char*BaseClassInfo_Name(BaseClassInfo_t* bcinfo) const; virtual intBaseClassInfo_Next(BaseClassInfo_t* bcinfo) const; virtual intBaseClassInfo_Next(BaseClassInfo_t* bcinfo, int onlyDirect) const; virtual Long_tBaseClassInfo_Offset(BaseClassInfo_t* bcinfo) const; virtual Long_tBaseClassInfo_Property(BaseClassInfo_t* bcinfo) const; virtual Long_tBaseClassInfo_Tagnum(BaseClassInfo_t* bcinfo) const; virtual const char*BaseClassInfo_TmpltName(BaseClassInfo_t* bcinfo) const; virtual voidTObject::Browse(TBrowser* b); virtual Long_tCalc(const char* line, TInterpreter::EErrorCode* error = 0); virtual voidCallFunc_Delete(void* func) const; virtual voidCallFunc_Exec(CallFunc_t* func, void* address) const; virtual Double_tCallFunc_ExecDouble(CallFunc_t* func, void* address) const; virtual Long_tCallFunc_ExecInt(CallFunc_t* func, void* address) const; virtual Long_tCallFunc_ExecInt64(CallFunc_t* func, void* address) const; virtual CallFunc_t*CallFunc_Factory() const; virtual CallFunc_t*CallFunc_FactoryCopy(CallFunc_t* func) const; virtual MethodInfo_t*CallFunc_FactoryMethod(CallFunc_t* func) const; virtual voidCallFunc_Init(CallFunc_t* func) const; virtual boolCallFunc_IsValid(CallFunc_t* func) const; virtual voidCallFunc_ResetArg(CallFunc_t* func) const; virtual voidCallFunc_SetArg(CallFunc_t* func, Long_t param) const; virtual voidCallFunc_SetArg(CallFunc_t* func, Double_t param) const; virtual voidCallFunc_SetArg(CallFunc_t* func, Long64_t param) const; virtual voidCallFunc_SetArg(CallFunc_t* func, ULong64_t param) const; virtual voidCallFunc_SetArgArray(CallFunc_t*",MatchSource.WIKI,root/html530/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TCint.html
Deployability,update,update," Int_t UnloadLibraryMap(const char* library); Unload library map entries coming from the specified library.; Returns -1 in case no entries for the specified library were found,; 0 otherwise. Int_t AutoLoad(const char* classname); Load library containing the specified class. Returns 0 in case of error; and 1 in case if success. Int_t AutoLoadCallback(const char* cls, const char* lib); Load library containing specified class. Returns 0 in case of error; and 1 in case if success. void * FindSpecialObject(const char* name, Cint::G__ClassInfo* type, void** prevObj, void** assocPtr); Static function called by CINT when it finds an un-indentified object.; This function tries to find the UO in the ROOT files, directories, etc.; This functions has been registered by the TCint ctor. void UpdateClassInfo(char* name, Long_t tagnum); Static function called by CINT when it changes the tagnum for; a class (e.g. after re-executing the setup function). In such; cases we have to update the tagnum in the G__ClassInfo used by; the TClass for class ""item"". void UpdateClassInfoWork(const char* name, Long_t tagnum); This does the actual work of UpdateClassInfo. void UpdateAllCanvases(); Update all canvases at end the terminal input command. const char* GetSharedLibs(); Return the list of shared libraries known to CINT. const char * GetClassSharedLibs(const char* cls); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the library is not found. const char * GetSharedLibDeps(const char* lib); Get the list a libraries on which the specified lib depends. The; returned string contains as first element the lib itself.; Returns 0 in case the lib does not exist or does not have; any dependencies. Bool_t IsErrorMessagesEnabled() const; If error messages are disabled, the interpreter should suppress its; failures and warning messages from stdout",MatchSource.WIKI,root/html530/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TCint.html
Integrability,interface,interface,". TCint. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TCint. class TCint: public TInterpreter. This class defines an interface to the CINT C/C++ interpreter made; by Masaharu Goto from HP Japan. CINT is an almost full ANSI compliant C/C++ interpreter. Function Members (Methods); public:. TCint(const char* name, const char* title); virtual~TCint(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddIncludePath(const char* path); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tAutoLoad(const char* classname); static intAutoLoadCallback(const char* cls, const char* lib); virtual voidBaseClassInfo_Delete(BaseClassInfo_t* bcinfo) const; virtual BaseClassInfo_t*BaseClassInfo_Factory(ClassInfo_t* info) const; virtual const char*BaseClassInfo_FullName(BaseClassInfo_t* bcinfo) const; virtual const char*BaseClassInfo_Name(BaseClassInfo_t* bcinfo) const; virtual intBaseClassInfo_Next(BaseClassInfo_t* bcinfo) const; virtual intBaseClassInfo_Next(BaseClassInfo_t* bcinfo, int onlyDirect) const; virtual Long_tBaseClassInfo_Offset(BaseClassInfo_t* bcinfo) const; virtual Long_tBaseClassInfo_Property(BaseClassInfo_t* bcinfo) const; virtual Long_tBaseClassInfo_Tagnum(BaseClassInfo_t* bcinfo) const; virtual const char*BaseClassInfo_TmpltName(BaseClassInfo_t* bcinfo) const; virtual voidTObject::Browse(TBrowser* b); virtual Long_tCalc(const char* line, TInterpreter::EErrorCode* error = 0); virtual voidCallFunc_Delete(void* func) const; virtual voidCallFunc_Exec(CallFunc_t* func, void* address) const; virtual Double_tCallFunc_ExecDouble(CallFunc_t* func, void* address) const; virtual Long_tCallFunc_ExecInt(CallFunc_t* func, void* address) const; virtual Long_tCallFunc_ExecInt64(CallFunc_t* func, void* address) const; virtual CallFunc_t*CallFunc_Factory() const; virtual",MatchSource.WIKI,root/html530/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TCint.html
Modifiability,variab,variables,"st; voidTObject::MakeZombie(). private:. TCint(); TCint(const TCint&); virtual voidExecute(TMethod*, TObjArray*, int* = 0); TCint&operator=(const TCint&). Data Members; public:. enum TInterpreter::EErrorCode { kNoError; kRecoverable; kDangerous; kFatal; kProcessing; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. G__dictpositionfDictPosCINT dictionary context after init; G__dictpositionfDictPosGlobalsCINT dictionary context after ResetGlobals(); Int_tfExitCodevalue passed to exit() in interpreter; TStringfIncludePathlist of CINT include paths; Bool_tfLockProcessLinetrue if ProcessLine should lock gCINTMutex; TEnv*fMapfilemap of classes and libraries; Int_tfMore1 if more input is required; charfPrompt[64]proposed prompt string; TObjArray*fRootmapFileslist of non-default rootmap files loaded; TStringfRootmapLoadPathdynamic load path used for loading rootmap files; TStringfSharedLibslist of shared libraries loaded by G__loadfile; Int_tfSharedLibsSerialIndicator of the last time we set fSharedLibs; static void*fgSetOfSpecialsset of TObject*s used in CINT variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCint(const char* name, const char* title); Initialize the CINT interpreter interface. ~TCint(); Destroy the CINT interpreter interface. void ClearFileBusy(); Reset CINT internal state in case a previous action was not correctly; terminated by G__init_cint() and G__dlmod(). void ClearStack(); Delete existing temporary values. Int_t InitializeDictionaries(); Initialize all registered dictionaries. Normally this is already done; by G__init_cint() and G__dlmod(). void EnableAutoLoading(); Enable the automatic loading of shar",MatchSource.WIKI,root/html530/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TCint.html
Performance,load,loaded,"st; voidTObject::MakeZombie(). private:. TCint(); TCint(const TCint&); virtual voidExecute(TMethod*, TObjArray*, int* = 0); TCint&operator=(const TCint&). Data Members; public:. enum TInterpreter::EErrorCode { kNoError; kRecoverable; kDangerous; kFatal; kProcessing; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. G__dictpositionfDictPosCINT dictionary context after init; G__dictpositionfDictPosGlobalsCINT dictionary context after ResetGlobals(); Int_tfExitCodevalue passed to exit() in interpreter; TStringfIncludePathlist of CINT include paths; Bool_tfLockProcessLinetrue if ProcessLine should lock gCINTMutex; TEnv*fMapfilemap of classes and libraries; Int_tfMore1 if more input is required; charfPrompt[64]proposed prompt string; TObjArray*fRootmapFileslist of non-default rootmap files loaded; TStringfRootmapLoadPathdynamic load path used for loading rootmap files; TStringfSharedLibslist of shared libraries loaded by G__loadfile; Int_tfSharedLibsSerialIndicator of the last time we set fSharedLibs; static void*fgSetOfSpecialsset of TObject*s used in CINT variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCint(const char* name, const char* title); Initialize the CINT interpreter interface. ~TCint(); Destroy the CINT interpreter interface. void ClearFileBusy(); Reset CINT internal state in case a previous action was not correctly; terminated by G__init_cint() and G__dlmod(). void ClearStack(); Delete existing temporary values. Int_t InitializeDictionaries(); Initialize all registered dictionaries. Normally this is already done; by G__init_cint() and G__dlmod(). void EnableAutoLoading(); Enable the automatic loading of shar",MatchSource.WIKI,root/html530/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TCint.html
Security,access,accessed,"ction and help message. void SetGetline(const char *(*)(const char* prompt) getlineFunc, void (*)(const char* line) histaddFunc); Set a getline function to call when input is needed. void RecursiveRemove(TObject* obj); Delete object from CINT symbol table so it can not be used anymore.; CINT objects are always on the heap. void Reset(); Reset the CINT state to the state saved by the last call to; TCint::SaveContext(). void ResetAll(); Reset the CINT state to its initial state. void ResetGlobals(); Reset the CINT global object state to the state saved by the last; call to TCint::SaveGlobalsContext(). void ResetGlobalVar(void* obj); Reset the CINT global object state to the state saved by the last; call to TCint::SaveGlobalsContext(). void RewindDictionary(); Rewind CINT dictionary to the point where it was before executing; the current macro. This function is typically called after SEGV or; ctlr-C after doing a longjmp back to the prompt. Int_t DeleteGlobal(void* obj); Delete obj from CINT symbol table so it cannot be accessed anymore.; Returns 1 in case of success and 0 in case object was not in table. void SaveContext(); Save the current CINT state. void SaveGlobalsContext(); Save the current CINT state of global objects. void UpdateListOfGlobals(); Update the list of pointers to global variables. This function; is called by TROOT::GetListOfGlobals(). void UpdateListOfGlobalFunctions(); Update the list of pointers to global functions. This function; is called by TROOT::GetListOfGlobalFunctions(). void UpdateListOfTypes(); Update the list of pointers to Datatype (typedef) definitions. This; function is called by TROOT::GetListOfTypes(). void SetClassInfo(TClass* cl, Bool_t reload = kFALSE); Set pointer to CINT's G__ClassInfo in TClass. Bool_t CheckClassInfo(const char* name, Bool_t autoload = kTRUE); Checks if a class with the specified name is defined in CINT.; Returns kFALSE is class is not defined. void CreateListOfBaseClasses(TClass* cl); Create list of pointers ",MatchSource.WIKI,root/html530/TCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TCint.html
Integrability,interface,interface,". TCL. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TCL. class TCL. The set of methods to work with the plain matrix / vector; ""derived"" from http://wwwinfo.cern.ch/asdoc/shortwrupsdir/f110/top.html; ""derived"" from http://wwwinfo.cern.ch/asdoc/shortwrupsdir/f112/top.html. Revision 1.7 2006/05/21 18:05:26 brun; Fix more coding conventions violations. Revision 1.6 2006/05/20 14:06:09 brun; Fix a VERY long list of coding conventions violations. Revision 1.5 2003/09/30 09:52:49 brun; Add references to the original CERNLIB packages. Revision 1.4 2003/05/28 15:17:03 brun; From Valeri Fine. A new version of the table package.; It fixes a couple of memory leaks:; class TTableDescriptorm; class TVolumePosition; and provides some clean up; for the TCL class interface. Revision 1.3 2003/04/03 17:39:39 fine; Make merge with ROOT 3.05.03 and add TR package; 122; Revision 1.2 2003/02/04 23:35:20 fine; Clean up. Revision 1.1 2002/04/15 20:23:39 fine; NEw naming schema for RootKErnel classes and a set of classes to back geometry OO. Revision 1.2 2001/05/29 19:08:08 brun; New version of some STAR classes from Valery. Revision 1.2 2001/05/27 02:38:14 fine; New method trsedu to solev Ax=B from Victor. Revision 1.1.1.1 2000/11/27 22:57:14 fisyak. Revision 1.1.1.1 2000/05/16 17:00:48 rdm; Initial import of ROOT into CVS. Function Members (Methods); public:. TCL(); TCL(const TCL&); virtual~TCL(); static TClass*Class(); virtual TClass*IsA() const; static float*mxmad(const float* a, const float* b, float* c, int i, int j, int k); static double*mxmad(const double* a, const double* b, double* c, int i, int j, int k); static float*mxmad1(const float* a, const float* q, float* c, int i, int j, int k); static double*mxmad1(const double* a, const double* b, double* c, int i, int j, int k); static float*mxmad2(con",MatchSource.WIKI,root/html530/TCL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TCL.html
Modifiability,variab,variables,"inal documentation of CERNLIB package F112. double * trasat(const double* a, const double* s, double* r, int m, int n); Transformation of Symmetric Matrix; CERN PROGLIB# F112 TRASAT .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *; trasat.F -- translated by f2c (version 19970219). ; see original documentation of CERNLIB package F112. float * trasat(const double* a, const float* s, float* r, int m, int n); Transformation of Symmetric Matrix; CERN PROGLIB# F112 TRASAT .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *; trasat.F -- translated by f2c (version 19970219). ; see original documentation of CERNLIB package F112. float * trata(const float* a, float* r, int m, int n); trata.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRATA .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trats(const float* a, const float* s, float* b, int m, int n). ; see original documentation of CERNLIB package F112. Local variables. float * trchlu(const float* a, float* b, int n). ; see original documentation of CERNLIB package F112. Local variables. float * trpck(const float* s, float* u, int n); trpck.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRPCK .VERSION KERNFOR 2.08 741218 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trqsq(const float* q, const float* s, float* r, int m); trqsq.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRQSQ .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. float * trsa(const float* s, const float* a, float* b, int m, int n); trsa.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRSA .VERSION KERNFOR 4.15 861204 *; ORIG. 18/12/74 WH *. ; see original documentation of CERNLIB package F112. Local variables. float * trupck(const float* u, float* s, int m); trupck.F -- translated by f2c (version 19970219).; CERN PROGLIB# F112 TRUPCK .V",MatchSource.WIKI,root/html530/TCL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TCL.html
Availability,error,error,"t char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidCopyCollectionProxy(const TVirtualCollectionProxy&); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteArray(void* ary, Bool_t dtorOnly = kFALSE); voidDestructor(void* obj, Bool_t dtorOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() const; voidDump(void* obj) const; void*DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* base); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(UInt_t code = 0) const; static TClass*GetClass(const char* name, Bool_t load = kTRUE, ",MatchSource.WIKI,root/html530/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClass.html
Deployability,update,updated,"or the long form; [type=Read] sourceClass=classname [targetclass=newClassname] [ source=""type membername; [type2 membername2]"" ]; [target=""membername3;membername4""] [attributes=... ] [version=...] [checksum=...] [code={...}|functionname]. For example to set HepMC::GenVertex::m_event to _not_ owned the object it is pointing to:; HepMC::GenVertex m_event attributes=NotOwner. Semantic of the tags:; type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; sourceClass : the name of the class as it is on the rule file; targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; source : the types and names of the data members from the class on file that are needed, the list is separated by semi-colons ';'; oldtype: in the short form only, indicates the type on disk of the data member.; target : the names of the data members updated by this rule, the list is separated by semi-colons ';'; attributes : list of possible qualifiers amongs:; Owner, NotOwner; version : list of the version of the class layout that this rule applies to. The syntax can be [1,4,5] or [2-] or [1-3] or [-3]; checksum : comma delimited list of the checksums of the class layout that this rule applies to.; code={...} : code to be executed for the rule or name of the function implementing it. void AdoptSchemaRules(ROOT::TSchemaRuleSet* rules); Adopt a new set of Data Model Evolution rules. const ROOT::TSchemaRuleSet* GetSchemaRules() const; Return the set of the schema rules if any. ROOT::TSchemaRuleSet* GetSchemaRules(Bool_t create = kFALSE); Return the set of the schema rules if any.; If create is true, create an empty set. void AddImplFile(const char* filename, int line). void AddRef(TClassRef* ref); Register a TClassRef object which points to this TClass object.; When this TClass object is deleted, 'ref' will be 'Reset'. Int_t AutoBrowse(TObject* obj, TBrowser* browser); Browse external object inherited from TObject",MatchSource.WIKI,root/html530/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClass.html
Energy Efficiency,allocate,allocated,"rom TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Class()->IgnoreTObjectStreamer();; To be effective for object streamed member-wise or split in a TTree,; this function must be called for the most derived class (i.e. BigTrack). Bool_t InheritsFrom(const char* cl) const; Return kTRUE if this class inherits from a class with name ""classname"".; note that the function returns KTRUE in case classname is the class itself. Bool_t InheritsFrom(const TClass* cl) const; Return kTRUE if this class inherits from class cl.; note that the function returns KTRUE in case cl is the class itself. void * DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); Cast obj of this class type up to baseclass cl if up is true.; Cast obj of this class type down from baseclass cl if up is false.; If this class is not a baseclass of cl return 0, else the pointer; to the cl part of this (up) or to this (down). void * New(TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a newly allocated object of this class.; The class must have a default constructor. For meaning of; defConstructor, see TClass::IsCallingNew(). The constructor actually called here can be customized by; using the rootcint pragma:; #pragma link C++ ioctortype UserClass;; For example, with this pragma and a class named MyClass,; this method will called the first of the following 3; constructors which exists and is public:; MyClass(UserClass*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. When more than one pragma ioctortype is used, the first seen as priority; For example with:; #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look in the following order:; MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted. void * New(void* arena, TClass::ENewType defConstructor = kClassNew) const; Return a pointer to a n",MatchSource.WIKI,root/html530/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClass.html
Integrability,interface,interface,"ew; };; enum { kLoading; kDefault; kEmulated; kTObject; kInstrumented; kForeign; kExternal; };; enum TDictionary::ESTLType { kNone; kVector; kList; kDeque; kMap; kMultimap; kSet; kMultiset; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TList*fAllPubDataall public data members (including from base classes); TList*fAllPubMethodall public methods (including from base classes); TList*fBaselinked list for base classes; Int_tfCanSplit!Indicates whether this class can be split or not.; UInt_tfCheckSumchecksum of data members and base classes; ClassInfo_t*fClassInfopointer to CINT class info class; TList*fClassMenuListlist of class menu items; Version_tfClassVersionClass version Identifier; TVirtualCollectionProxy*fCollectionProxyCollection interface; TStringfContextMenuTitlecontext menu title; map<std::string,TObjArray*>*fConversionStreamerInfoArray of the streamer infos derived from another class.; TVirtualStreamerInfo*fCurrentInfo!cached current streamer info.; TList*fDatalinked list for data members; Short_tfDeclFileLineline of class declaration; const char*fDeclFileNamename of class declaration file; void*fDeletepointer to a function deleting one object.; void*fDeleteArraypointer to a function deleting an array of objects.; void*fDestructorpointer to a function call an object's destructor.; void*fDirAutoAddpointer which implements the Directory Auto Add feature for this class.']'; IsAGlobalFunc_tfGlobalIsApointer to a global IsA function.; Short_tfImplFileLineline of class implementation; const char*fImplFileNamename of class implementation file; UInt_tfInstanceCountnumber of instances of this class; void*fInterShowMembersInterpreter call setup for ShowMembers; TVirtu",MatchSource.WIKI,root/html530/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClass.html
Modifiability,inherit,inherited,"eparated by semi-colons ';'; attributes : list of possible qualifiers amongs:; Owner, NotOwner; version : list of the version of the class layout that this rule applies to. The syntax can be [1,4,5] or [2-] or [1-3] or [-3]; checksum : comma delimited list of the checksums of the class layout that this rule applies to.; code={...} : code to be executed for the rule or name of the function implementing it. void AdoptSchemaRules(ROOT::TSchemaRuleSet* rules); Adopt a new set of Data Model Evolution rules. const ROOT::TSchemaRuleSet* GetSchemaRules() const; Return the set of the schema rules if any. ROOT::TSchemaRuleSet* GetSchemaRules(Bool_t create = kFALSE); Return the set of the schema rules if any.; If create is true, create an empty set. void AddImplFile(const char* filename, int line). void AddRef(TClassRef* ref); Register a TClassRef object which points to this TClass object.; When this TClass object is deleted, 'ref' will be 'Reset'. Int_t AutoBrowse(TObject* obj, TBrowser* browser); Browse external object inherited from TObject.; It passes through inheritance tree and calls TBrowser::Add; in appropriate cases. Static function. Int_t Browse(void* obj, TBrowser* b) const; Browse objects of of the class described by this TClass object. void Browse(TBrowser* b); This method is called by a browser to get the class information. void BuildRealData(void* pointer = 0, Bool_t isTransient = kFALSE); Build a full list of persistent data members.; Scans the list of all data members in the class itself and also; in all base classes. For each persistent data member, inserts a; TRealData object in the list fRealData. If pointer is not 0, uses the object at pointer; otherwise creates a temporary object of this class. void BuildEmulatedRealData(const char* name, Long_t offset, TClass* cl); Build the list of real data for an emulated class. void CalculateStreamerOffset() const; Calculate the offset between an object of this class to; its base class TObject. The pointer can be adj",MatchSource.WIKI,root/html530/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClass.html
Performance,load,load,". TClass. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TClass. class TClass: public TDictionary. The ROOT global object gROOT contains a list of all defined; classes. This list is build when a reference to a class dictionary; is made. When this happens, the static ""class""::Dictionary(); function is called to create a TClass object describing the; class. The Dictionary() function is defined in the ClassDef; macro and stored (at program startup or library load time) together; with the class name in the TClassTable singleton object.; For a description of all dictionary classes see TDictionary. Function Members (Methods); public:. TClass(); TClass(const char* name, Bool_t silent = kFALSE); TClass(const char* name, Version_t cversion, const char* dfil = 0, const char* ifil = 0, Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE); TClass(const char* name, Version_t cversion, const type_info& info, TVirtualIsAProxy* isa, ShowMembersFunc_t showmember, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent = kFALSE); virtual~TClass(); voidTObject::AbstractMethod(const char* method) const; static voidAddClass(TClass* cl); voidAddImplFile(const char* filename, int line); voidAddInstance(Bool_t heap = kFALSE); voidAddRef(TClassRef* ref); static Bool_tAddRule(const char* rule); voidAdoptMemberStreamer(const char* name, TMemberStreamer* strm); voidAdoptReferenceProxy(TVirtualRefProxy* proxy); voidAdoptSchemaRules(ROOT::TSchemaRuleSet* rules); voidAdoptStreamer(TClassStreamer* strm); virtual voidTObject::AppendPad(Option_t* option = """"); static Int_tAutoBrowse(TObject* obj, TBrowser* browser); virtual voidBrowse(TBrowser* b); Int_tBrowse(void* obj, TBrowser* b) const; voidBuildEmulatedRealData(const char* name, Long_t offset, TClass* cl); voidBuildRealData(void* pointer = 0, Bool_t is",MatchSource.WIKI,root/html530/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClass.html
Safety,safe,safe,"the class is missing its shared library. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title); Change (i.e. set) the title of the TNamed. void SetGlobalIsA(IsAGlobalFunc_t ); This function installs a global IsA function for this class.; The global IsA function will be used if there is no local IsA function (fIsA). A global IsA function has the signature:. TClass *func( TClass *cl, const void *obj);. 'cl' is a pointer to the TClass object that corresponds to the; 'pointer type' used to retrieve the value 'obj'. For example with:; TNamed * m = new TNamed(""example"",""test"");; TObject* o = m; and; the global IsA function would be called with TObject::Class() as; the first parameter and the exact numerical value in the pointer; 'o'. In other word, inside the global IsA function. it is safe to C-style; cast the value of 'obj' into a pointer to the class described by 'cl'. void SetUnloaded(); Call this method to indicate that the shared library containing this; class's code has been removed (unloaded) from the process's memory. TVirtualStreamerInfo * SetStreamerInfo(Int_t version, const char* info = """"); Info is a string describing the names and types of attributes; written by the class Streamer function.; If info is an empty string (when called by TObject::StreamerInfo); the default Streamer info string is build. This corresponds to; the case of an automatically generated Streamer.; In case of user defined Streamer function, it is the user responsability; to implement a StreamerInfo function (override TObject::StreamerInfo).; The user must call IsA()->SetStreamerInfo(info) from this function. UInt_t GetCheckSum(UInt_t code = 0) const; Compute and/or return the class check sum.; The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is bu",MatchSource.WIKI,root/html530/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClass.html
Security,checksum,checksum,"ay(void* ary, Bool_t dtorOnly = kFALSE); voidDestructor(void* obj, Bool_t dtorOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() const; voidDump(void* obj) const; void*DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* base); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(UInt_t code = 0) const; static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; Version_tGetClassVersion() const; TVirtualCollectionProxy*GetCollectionProxy() const; const char*GetContextMenuTitle() const; TVirtualStreamerInfo*GetConversionStreamerInfo(const char* onfile_classname, Int_t version)",MatchSource.WIKI,root/html530/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClass.html
Testability,test,test,"erits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulated: the class is missing its shared library. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title); Change (i.e. set) the title of the TNamed. void SetGlobalIsA(IsAGlobalFunc_t ); This function installs a global IsA function for this class.; The global IsA function will be used if there is no local IsA function (fIsA). A global IsA function has the signature:. TClass *func( TClass *cl, const void *obj);. 'cl' is a pointer to the TClass object that corresponds to the; 'pointer type' used to retrieve the value 'obj'. For example with:; TNamed * m = new TNamed(""example"",""test"");; TObject* o = m; and; the global IsA function would be called with TObject::Class() as; the first parameter and the exact numerical value in the pointer; 'o'. In other word, inside the global IsA function. it is safe to C-style; cast the value of 'obj' into a pointer to the class described by 'cl'. void SetUnloaded(); Call this method to indicate that the shared library containing this; class's code has been removed (unloaded) from the process's memory. TVirtualStreamerInfo * SetStreamerInfo(Int_t version, const char* info = """"); Info is a string describing the names and types of attributes; written by the class Streamer function.; If info is an empty string (when called by TObject::StreamerInfo); the default Streamer info string is build. This corresponds to; the case of an automatically generated Streamer.; In case of user defined Streamer function, it is the user responsability; to implement a StreamerInfo function (override TObject::StreamerInfo).; The user must call IsA()->SetStreamerInfo(info) from this function. UInt_t GetChe",MatchSource.WIKI,root/html530/TClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClass.html
Availability,error,error,"onst char* fsimpl = """", const char* decl = 0, const char* impl = 0); virtual~TClassDocInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictionary*GetClass() const; const char*GetDeclFileName() const; const char*GetDeclFileSysName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetHtmlFileName() const; virtual const char*TObject::GetIconName() const; const char*GetImplFileName() const; const char*GetImplFileSysName() const; TList&GetListOfTypedefs(); TModuleDocInfo*GetModule() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; ",MatchSource.WIKI,root/html530/TClassDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClassDocInfo.html
Availability,error,error,"erarchy(ostream& out, const char* docFileName); virtual voidTDocOutput::CreateClassIndex(); virtual voidTDocOutput::CreateClassTypeDefs(); virtual voidTDocOutput::CreateHierarchy(); virtual voidTDocOutput::CreateModuleIndex(); virtual voidTDocOutput::CreateProductIndex(); virtual voidTDocOutput::CreateTypeIndex(); virtual voidTDocOutput::DecorateEntityBegin(TString& str, Ssiz_t& pos, TDocParser::EParseContext type); virtual voidTDocOutput::DecorateEntityEnd(TString& str, Ssiz_t& pos, TDocParser::EParseContext type); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTDocOutput::FixupAuthorSourceInfo(TString& authors); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*TDocOutput::GetExtension() const; THtml*TDocOutput::GetHtml(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() con",MatchSource.WIKI,root/html530/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClassDocOutput.html
Deployability,update,updates,"TML header is written to out. void DescendHierarchy(ostream& out, TClass* basePtr, Int_t maxLines = 0, Int_t depth = 1); Descend hierarchy recursively; loop over all classes and look for classes with base class basePtr. void MakeTree(Bool_t force = kFALSE); Create an output file with a graphical representation of the class; inheritance. If force, replace existing output file.; This routine does nothing if fHtml->HaveDot() is true - use; ClassDotCharts() instead!. void WriteClassDescription(ostream& out, const TString& description); Called by TDocParser::LocateMethods(), this hook writes out the class description; found by TDocParser. It's even called if none is found, i.e. if the first method; has occurred before a class description is found, so missing class descriptions; can be handled.; For HTML, its creates the description block, the list of functions and data; members, and the inheritance tree or, if Graphviz's dot is found, the class charts. void WriteClassDocHeader(ostream& classFile); Write out the introduction of a class description (shortcuts and links). void WriteMethod(ostream& out, TString& ret, TString& name, TString& params, const char* file, TString& anchor, TString& comment, TString& codeOneLiner, TDocMethodWrapper* guessedMethod); Write method name with return type ret and parameters param to out.; Build a link using file and anchor. Cooment it with comment, and; show the code codeOneLiner (set if the func consists of only one line; of code, immediately surrounded by ""{"",""}""). Also updates fMethodNames's; count of method names. TClassDocOutput(THtml& html, TClass* cl, TList* typedefs). » Author: Axel Naumann 2007-01-09 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/html:$Id: TClassDocOutput.h 31111 2009-11-12 09:57:56Z axel $ » Last generated: 2011-07-04 15:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClassDocOutput.html
Integrability,interface,interfaces,". TClassDocOutput. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HTML; » TClassDocOutput. class TClassDocOutput: public TDocOutput. Write the documentation for a class or namespace. The documentation is; parsed by TDocParser and then passed to TClassDocOutput to generate; the class doc header, the class description, members overview, and method; documentation. All generic output functionality is in TDocOutput; it is; re-used in this derived class. You usually do not use this class yourself; it is invoked indirectly by; THtml. Customization of the output should happen via the interfaces defined; by THtml. Function Members (Methods); public:. TClassDocOutput(const TClassDocOutput&); TClassDocOutput(THtml& html, TClass* cl, TList* typedefs); virtual~TClassDocOutput(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDocOutput::AdjustSourcePath(TString& line, const char* relpath = ""../""); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); voidClass2Html(Bool_t force = kFALSE); Bool_tClassDotCharts(ostream& out); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidTDocOutput::Convert(istream& in, const char* infilename, const char* outfilename, const char* title, const char* relpath = ""../"", Int_t includeOutput = 0, const char* context = """", TGClient* gclient = 0); virtual voidTObject::Copy(TObject& object) const; Bool_tTDocOutput::CopyHtmlFile(const char* sourceName, const char* destName = """"); voidCreateClassHierarchy(ostream& out, const char* docFileName); virtual voidTDocOutput::CreateClassIndex(); virtual voidTDocOutput::CreateClassTypeDefs(); virtual vo",MatchSource.WIKI,root/html530/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClassDocOutput.html
Modifiability,inherit,inheritance,"; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TClass*fCurrentClassclass to generate output for; TList*fCurrentClassesTypedefstypedefs to the current class; Int_tfHierarchyLinescounter for no. lines in hierarchy; THtml*TDocOutput::fHtmlTHtml object we belong to; TDocParser*fParserparser we use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassDocOutput(THtml& html, TClass* cl, TList* typedefs); Create an object given the invoking THtml object, and the TClass; object that we will generate output for. ~TClassDocOutput(); Destructor, deletes fParser. void Class2Html(Bool_t force = kFALSE); Create HTML files for a single class. void ListFunctions(ostream& classFile); Write the list of functions. void ListDataMembers(ostream& classFile); Write the list of data members and enums. Bool_t ClassDotCharts(ostream& out); This function builds the class charts for one class in GraphViz/Dot format,; i.e. the inheritance diagram, the include dependencies, and the library; dependency. Input: out - output file stream. void ClassHtmlTree(ostream& out, TClass* classPtr, TClassDocOutput::ETraverse dir = kBoth, int depth = 1); This function builds the class tree for one class in HTML; (inherited and succeeding classes, called recursively). Input: out - output file stream; classPtr - pointer to the class; dir - direction to traverse tree: up, down or both. void ClassTree(TVirtualPad* canvas, Bool_t force = kFALSE); It makes a graphical class tree. Input: psCanvas - pointer to the current canvas; classPtr - pointer to the class. Bool_t CreateDotClassChartInh(const char* filename); Build the class tree for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartInhMem(const char* filename); Build the class tree of inherited members for one class in GraphViz/Dot format. Input: filename - output dot file incl. path. Bool_t CreateDotClassChartIncl(const char* filename); Build the include",MatchSource.WIKI,root/html530/TClassDocOutput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClassDocOutput.html
Testability,test,testAlloc,". TClassEdit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; namespace description; function members; data members; class charts. ROOT; » CORE; » METAUTILS; » TClassEdit. namespace TClassEdit. Function Members (Methods); public:. stringCleanType(const char* typeDesc, int mode = 0, const char** tail = 0); stringGetLong64_Name(const string& original); intGetSplit(const char* type, vector<std::string>& output, int& nestedLoc, TClassEdit::EModType mode = TClassEdit::kNone); stringInsertStd(const char* tname); boolIsDefAlloc(const char* alloc, const char* classname); boolIsDefAlloc(const char* alloc, const char* keyclassname, const char* valueclassname); boolIsDefComp(const char* comp, const char* classname); boolIsStdClass(const char* type); boolIsSTLBitset(const char* type); intIsSTLCont(const char* type, int testAlloc = 0); boolIsVectorBool(const char* name); stringResolveTypedef(const char* tname, bool resolveAll = false); stringShortType(const char* typeDesc, int mode); intSTLArgs(int kind); intSTLKind(const char* type). Data Members. Class Charts; Function documentation; int IsSTLCont(int testAlloc=0). void ShortType(const char* typeDesc, int mode). std::string CleanType(const char* typeDesc, int mode = 0, const char** tail = 0). bool IsDefAlloc(const char* alloc, const char* classname). bool IsDefAlloc(const char* alloc, const char* keyclassname, const char* valueclassname). bool IsDefComp(const char* comp, const char* classname). bool IsSTLBitset(const char* type). bool IsStdClass(const char* type). bool IsVectorBool(const char* name). std::string GetLong64_Name(const string& original). int GetSplit(const char* type, vector<std::string>& output, int& nestedLoc, TClassEdit::EModType mode = TClassEdit::kNone). int STLKind(const char* type). int STLArgs(int kind). std::string ResolveTypedef(const char* tname, bool resolveAll = false). std::string InsertStd(const char* tname). » Author: Victor Pere",MatchSource.WIKI,root/html530/TClassEdit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClassEdit.html
Availability,avail,available,". TClassGenerator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TClassGenerator. class TClassGenerator: public TObject. TClassGenerator. Objects following this interface can be passed onto the TROOT object; to implement a user customized way to create the TClass objects. Use TROOT::AddClassGenerator to register a concrete instance. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TClass*GetClass(const char* cla",MatchSource.WIKI,root/html530/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClassGenerator.html
Integrability,interface,interface,". TClassGenerator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TClassGenerator. class TClassGenerator: public TObject. TClassGenerator. Objects following this interface can be passed onto the TROOT object; to implement a user customized way to create the TClass objects. Use TROOT::AddClassGenerator to register a concrete instance. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TClass*GetClass(const char* cla",MatchSource.WIKI,root/html530/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClassGenerator.html
Performance,load,load,"virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TClass*GetClass(const char* classname, Bool_t load); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load); virtual TClass*GetClass(const char* classname, Bool_t load, Bool_t silent); virtual TClass*GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UIn",MatchSource.WIKI,root/html530/TClassGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClassGenerator.html
Availability,error,error,"s = """", Int_t selfobjposition = -1, Bool_t self = kFALSE); virtual~TClassMenuItem(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetArgs() const; virtual TObject*GetCalledObject() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetFunctionName() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tGetSelfObjectPos() const; virtual const char*GetTitle() const; virtual Int_tGetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* ",MatchSource.WIKI,root/html530/TClassMenuItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClassMenuItem.html
Deployability,toggle,toggle,"r* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCall(TObject* obj, const char* method, const char* args = """", Int_t selfobjposition = 0); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetSelf(Bool_t self); virtual voidSetTitle(const char* title); virtual voidSetToggle(Bool_t toggle = kTRUE); virtual voidSetType(Int_t type); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html530/TClassMenuItem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClassMenuItem.html
Integrability,rout,routine,"s TClassStreamer. TClassStreamer is used to stream an object of a specific class. The address passed to operator() will be the address of the start; of the object. Function Members (Methods); public:. TClassStreamer(ClassStreamerFunc_t pointer); TClassStreamer(const TClassStreamer& rhs); virtual~TClassStreamer(); virtual TClassStreamer*Generate() const; virtual const TClass*GetOnFileClass() const; virtual voidoperator()(TBuffer& b, void* objp); TClassStreamer&operator=(const TClassStreamer&); virtual voidSetOnFileClass(const TClass* cl); virtual voidStream(TBuffer& b, void* objp, const TClass* onfileClass). protected:. TClassStreamer(). Data Members; protected:. TClassReffOnFileClass. private:. ClassStreamerFunc_tfStreamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassStreamer(); {}. TClassStreamer(ClassStreamerFunc_t pointer); {}. TClassStreamer(const TClassStreamer& rhs); {}. void SetOnFileClass(const TClass* cl); { fOnFileClass = const_cast<TClass*>(cl); }. const TClass* GetOnFileClass() const; { return fOnFileClass; }. TClassStreamer * Generate() const; Virtual copy constructor. virtual ~TClassStreamer(); {}. void operator()(TBuffer& b, void* objp); The address passed to operator() will be the address of the start of the; object. void Stream(TBuffer& b, void* objp, const TClass* onfileClass); The address passed to operator() will be the address of the start of the; object. Overload this routine, if your derived class can optimize; the handling of the onfileClass (rather than storing and restoring from the; fOnFileClass member. » Author: Victor Perev and Philippe Canal 08/05/02 » Copyright (C) 1995-2003, Rene Brun, Fons Rademakers and al. *; » Last changed: root/base:$Id: TClassStreamer.h 36096 2010-10-05 21:27:26Z pcanal $ » Last generated: 2011-07-04 15:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TClassStreamer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClassStreamer.html
Performance,optimiz,optimize,"s TClassStreamer. TClassStreamer is used to stream an object of a specific class. The address passed to operator() will be the address of the start; of the object. Function Members (Methods); public:. TClassStreamer(ClassStreamerFunc_t pointer); TClassStreamer(const TClassStreamer& rhs); virtual~TClassStreamer(); virtual TClassStreamer*Generate() const; virtual const TClass*GetOnFileClass() const; virtual voidoperator()(TBuffer& b, void* objp); TClassStreamer&operator=(const TClassStreamer&); virtual voidSetOnFileClass(const TClass* cl); virtual voidStream(TBuffer& b, void* objp, const TClass* onfileClass). protected:. TClassStreamer(). Data Members; protected:. TClassReffOnFileClass. private:. ClassStreamerFunc_tfStreamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassStreamer(); {}. TClassStreamer(ClassStreamerFunc_t pointer); {}. TClassStreamer(const TClassStreamer& rhs); {}. void SetOnFileClass(const TClass* cl); { fOnFileClass = const_cast<TClass*>(cl); }. const TClass* GetOnFileClass() const; { return fOnFileClass; }. TClassStreamer * Generate() const; Virtual copy constructor. virtual ~TClassStreamer(); {}. void operator()(TBuffer& b, void* objp); The address passed to operator() will be the address of the start of the; object. void Stream(TBuffer& b, void* objp, const TClass* onfileClass); The address passed to operator() will be the address of the start of the; object. Overload this routine, if your derived class can optimize; the handling of the onfileClass (rather than storing and restoring from the; fOnFileClass member. » Author: Victor Perev and Philippe Canal 08/05/02 » Copyright (C) 1995-2003, Rene Brun, Fons Rademakers and al. *; » Last changed: root/base:$Id: TClassStreamer.h 36096 2010-10-05 21:27:26Z pcanal $ » Last generated: 2011-07-04 15:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TClassStreamer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClassStreamer.html
Availability,error,error,"Add(const char* cname, Version_t id, const type_info& info, VoidFuncPtr_t dict, Int_t pragmabits); virtual voidTObject::AppendPad(Option_t* option = """"); static char*At(int index); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); intClasses(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static VoidFuncPtr_tGetDict(const char* cname); static VoidFuncPtr_tGetDict(const type_info& info); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; static Version_tGetID(const char* cname); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static Int_tGetPragmaBits(const char* name); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TT",MatchSource.WIKI,root/html530/TClassTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClassTable.html
Security,hash,hash,". TClassTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TClassTable. class TClassTable: public TObject. This class registers for all classes their name, id and dictionary; function in a hash table. Classes are automatically added by the; ctor of a special init class when a global of this init class is; initialized when the program starts (see the ClassImp macro). Function Members (Methods); public:. TClassTable(const TClassTable&); virtual~TClassTable(); voidTObject::AbstractMethod(const char* method) const; static voidAdd(const char* cname, Version_t id, const type_info& info, VoidFuncPtr_t dict, Int_t pragmabits); virtual voidTObject::AppendPad(Option_t* option = """"); static char*At(int index); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); intClasses(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* nam",MatchSource.WIKI,root/html530/TClassTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClassTable.html
Availability,down,down,". TClassTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GPAD; » TClassTree. class TClassTree: public TNamed. Draw inheritance tree and their relations for a list of classes; The following options are supported; - Direct inheritance (default); - Multiple inheritance; - Composition; - References by data members and member functions; - References from Code. The list of classes is specified:; - either in the TClassTree constructor as a second argument; - or the parameter to TClassTRee::Draw. Note that the ClassTree viewer can also be started from the canvas; pull down menu ""Classes"". In the list of classes, class names are separated by a "":""; wildcarding is supported.; The following formats are supported, eg in TClassTree::Draw; 1- Draw(""ClassA""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; 2- Draw(""*ClassB""); Draw inheritance tree for ClassB; and all the classes deriving from ClassB; 3- Draw("">ClassC""); Draw inheritance tree for ClassC; Show classes referencing ClassC; 4- Draw(""ClassD<""); Draw inheritance tree for ClassD; Show classes referenced by ClassD; Show all classes referencing ClassD; 5- Draw(""Cla*""); Draw inheritance tree for all classes with name starting with ""Cla""; Show classes referenced by these classes; 6- Draw(""ClassA:ClassB<""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; Draw inheritance tree for ClassB; Show classes referenced by ClassB; Show all classes referencing ClassB. example; Draw(""TTree<""); Draw inheritance tree for the Root class TTree; Show all classes referenced by TTree; Show all classes using TTree. By default, only direct inheritance is drawn.; Use TClassTree::ShowLinks(option) to show additional references; option = ""H"" to show links to embedded classes; option = ""M"" to show multiple inheritance; opti",MatchSource.WIKI,root/html530/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClassTree.html
Deployability,configurat,configuration,"d examples. Int_t FindClass(const char* classname); Find class number corresponding to classname in list of local classes. void FindClassesUsedBy(Int_t iclass); Select all classes used/referenced by the class number iclass. void FindClassesUsing(Int_t iclass); Select all classes using/referencing the class number iclass. void FindClassPosition(const char* classname, Float_t& x, Float_t& y); Search the TPaveClass object in the pad with label=classname; returns the x and y position of the center of the pave. void Init(); Initialize the data structures. void ls(Option_t* option = """") const; list classes names and titles. TObjString * Mark(const char* classname, TList* los, Int_t abit); set bit abit in class classname in list los. void Paint(Option_t* option = """"); Draw the current class setting in fClasses and fStatus. void PaintClass(Int_t iclass, Float_t xleft, Float_t y); Paint one class level. void SaveAs(const char* filename = """", Option_t* option = """") const; save current configuration in a Root file; if filename is blank, the name of the file will be the current objectname.root; all the current settings are preserved; the Root file produced can be looked at by a another Root session; with no access to the original classes.; By default a message is printed. Specify option ""Q"" to remove the message. void ScanClasses(Int_t iclass); Select all classes used by/referenced/referencing the class number iclass; and build the list of these classes. void SetClasses(const char* classes, Option_t* option = ""ID""); Set the list of classes for which the hierarchy is to be drawn; See Paint for the syntax. void SetLabelDx(Float_t labeldx = 0.15); Set the size along x of the TPavellabel showing the class name. void SetYoffset(Float_t offset = 0); Set the offset at the top of the picture; The default offset is computed automatically taking into account; classes not inheriting from TObject. void ShowClassesUsedBy(const char* classes); mark classes used by the list of classes in class",MatchSource.WIKI,root/html530/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClassTree.html
Energy Efficiency,green,green,"; It shows all the classes derived from the base class TH1. /*. */. The ClassTree class uses the services of the class TPaveClass to; show the class names. By clicking with the right mouse button in; one TPaveClass object, one can invoke the following functions of TClassTree:; - ShowLinks(option) with by default option = ""HMR""; - Draw(classes). By default the class drawn is the one being pointed; - ShowClassesUsedBy(classes) (by default the pointed class); - ShowClassesUsing(classes) (by default the pointed class). The following picture has been generated with the following statements; TClassTree tc1(""tc1"",""TObject"");; tc1.SetShowLinks(""HMR"");. /*. */. Note that in case of embedded classes or pointers to classes,; the corresponding dashed lines or arrows respectively start; in the TPaveClass object at an X position reflecting the position; in the list of data members. - References by data members to other classes are show with a full red line; - Multiple inheritance is shown with a dashed blue line; - ""Has a"" relation is shown with a dotted cyan line; - References from code is shown by a full green line. Use TClassTree::SetSourceDir to specify the search path for source files.; By default the search path includes the ROOTSYS/src directory, the current; directory and the subdirectory src. The first time TClassTree::Draw is invoked, all the classes in the; current application are processed, including the parsing of the code; to find all classes referenced by the include statements.; This process may take a few seconds. The following commands will be; much faster. A TClassTree object may be saved in a Root file.; This object can be processed later by a Root program that ignores; the original classes. This interesting possibility allows to send; the class structure of an application to a colleague who does not have; your classes.; Example:; TFile f(""myClasses.root"",""recreate""); TClassTree *ct = new TClassTree(""ct"",""ATLF*""); ct->Write();; You can send at this point the fi",MatchSource.WIKI,root/html530/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClassTree.html
Integrability,depend,dependencies,"ry and the subdirectory src. The first time TClassTree::Draw is invoked, all the classes in the; current application are processed, including the parsing of the code; to find all classes referenced by the include statements.; This process may take a few seconds. The following commands will be; much faster. A TClassTree object may be saved in a Root file.; This object can be processed later by a Root program that ignores; the original classes. This interesting possibility allows to send; the class structure of an application to a colleague who does not have; your classes.; Example:; TFile f(""myClasses.root"",""recreate""); TClassTree *ct = new TClassTree(""ct"",""ATLF*""); ct->Write();; You can send at this point the file myClass.root to a colleague who can; run the following Root basic session; TFile f(""myClass.root""); //connect the file; tt.ls(); //to list all classes and titles; tt.Draw(""ATLFDisplay"") //show class ATLFDisplay with all its dependencies; At this point, one has still access to all the classes present; in the original session and select any combination of these classes; to be displayed. Function Members (Methods); public:. TClassTree(); TClassTree(const TClassTree&); TClassTree(const char* name, const char* classes = """"); virtual~TClassTree(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(const char* classes = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voi",MatchSource.WIKI,root/html530/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClassTree.html
Modifiability,inherit,inheritance,". TClassTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GPAD; » TClassTree. class TClassTree: public TNamed. Draw inheritance tree and their relations for a list of classes; The following options are supported; - Direct inheritance (default); - Multiple inheritance; - Composition; - References by data members and member functions; - References from Code. The list of classes is specified:; - either in the TClassTree constructor as a second argument; - or the parameter to TClassTRee::Draw. Note that the ClassTree viewer can also be started from the canvas; pull down menu ""Classes"". In the list of classes, class names are separated by a "":""; wildcarding is supported.; The following formats are supported, eg in TClassTree::Draw; 1- Draw(""ClassA""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; 2- Draw(""*ClassB""); Draw inheritance tree for ClassB; and all the classes deriving from ClassB; 3- Draw("">ClassC""); Draw inheritance tree for ClassC; Show classes referencing ClassC; 4- Draw(""ClassD<""); Draw inheritance tree for ClassD; Show classes referenced by ClassD; Show all classes referencing ClassD; 5- Draw(""Cla*""); Draw inheritance tree for all classes with name starting with ""Cla""; Show classes referenced by these classes; 6- Draw(""ClassA:ClassB<""); Draw inheritance tree for ClassA; Show all classes referenced by ClassA; Draw inheritance tree for ClassB; Show classes referenced by ClassB; Show all classes referencing ClassB. example; Draw(""TTree<""); Draw inheritance tree for the Root class TTree; Show all classes referenced by TTree; Show all classes using TTree. By default, only direct inheritance is drawn.; Use TClassTree::ShowLinks(option) to show additional references; option = ""H"" to show links to embedded classes; option = ""M"" to show multiple inheritance; opti",MatchSource.WIKI,root/html530/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClassTree.html
Security,access,access,"ry and the subdirectory src. The first time TClassTree::Draw is invoked, all the classes in the; current application are processed, including the parsing of the code; to find all classes referenced by the include statements.; This process may take a few seconds. The following commands will be; much faster. A TClassTree object may be saved in a Root file.; This object can be processed later by a Root program that ignores; the original classes. This interesting possibility allows to send; the class structure of an application to a colleague who does not have; your classes.; Example:; TFile f(""myClasses.root"",""recreate""); TClassTree *ct = new TClassTree(""ct"",""ATLF*""); ct->Write();; You can send at this point the file myClass.root to a colleague who can; run the following Root basic session; TFile f(""myClass.root""); //connect the file; tt.ls(); //to list all classes and titles; tt.Draw(""ATLFDisplay"") //show class ATLFDisplay with all its dependencies; At this point, one has still access to all the classes present; in the original session and select any combination of these classes; to be displayed. Function Members (Methods); public:. TClassTree(); TClassTree(const TClassTree&); TClassTree(const char* name, const char* classes = """"); virtual~TClassTree(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(const char* classes = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voi",MatchSource.WIKI,root/html530/TClassTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClassTree.html
Availability,error,error,"arge number of new and delete calls in large; loops like this (O(100000) x O(10000) times new/delete):. TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; a[i] = new TTrack(x,y,z,...);. }. a.Delete();; }. One better uses a TClonesArray which reduces the number of; new/delete calls to only O(10000):. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; new(a[i]) TTrack(x,y,z,...);. }. a.Delete();; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method. The diffrent Add() methods of; TObjArray and its base classes are not allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offer the possibility to allocate and delete memory.; Forgetting to delete allocated memory is a programming error that originate ""leaks"",; i.e. the memory of your process grows and eventually your program crashes.; Even if you *always* delete the allocated memory, the recovered space may not be; efficiently reused. The process knows that there are portions of free memory,; but when you allocate it again, a fresh piece of memory is grabbed.; Your program is free from semantic errors, but the total memory of your process; still grows. Moreover your program's memory is full of ""holes"" which reduce the; efficiency of memory access, this is called ""memory fragmentation"".; Moreover new / delete are expensive operations in terms of CPU time. Without entering into technical details, the TClonesArray allow to ""reuse"" the; same portion of memory for new/delete avoiding memory fragmentation and memory; growth and improving by orders of magnitude the performance. Every time the; memory of the TClonesArray has to be reused, the Clear() method is employed.; To provide its benefits, each TClone",MatchSource.WIKI,root/html530/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClonesArray.html
Energy Efficiency,allocate,allocated,". TClonesArray. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TClonesArray. class TClonesArray: public TObjArray. An array of clone (identical) objects. Memory for the objects; stored in the array is allocated only once in the lifetime of the; clones array. All objects must be of the same class. For the rest; this class has the same properties as TObjArray. To reduce the very large number of new and delete calls in large; loops like this (O(100000) x O(10000) times new/delete):. TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; a[i] = new TTrack(x,y,z,...);. }. a.Delete();; }. One better uses a TClonesArray which reduces the number of; new/delete calls to only O(10000):. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; new(a[i]) TTrack(x,y,z,...);. }. a.Delete();; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method. The diffrent Add() methods of; TObjArray and its base classes are not allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offer the possibility to allocate and delete memory.; Forgetting to delete allocated memory is a programming error that originate ""leaks"",; i.e. the memory of your process grows and eventually your program crashes.; Even if you *always* delete the allocated memory, the recovered space may not be; efficiently reused. The process knows that there are portions of free memory,; but when you allocate it again, a fresh piece of memory is grabbed.; Your program is free from semantic errors, but the total memory of your process; still ",MatchSource.WIKI,root/html530/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClonesArray.html
Integrability,rout,routine,"se the StreamerInfo for the class Bar is created; in optimized mode in such a way that data members of the same type; are written as an array improving the I/O performance.; 3- In a new program, T1 is read and a new Tree T2 is created; with the object Foo in split>1; 4- When the T2 branch is created, the StreamerInfo for the class Bar; is created with no optimization (mandatory for the split mode).; The optimized Bar StreamerInfo is going to be used to read; the TClonesArray in T1. The result will be Bar objects with; data member values not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shr",MatchSource.WIKI,root/html530/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClonesArray.html
Modifiability,inherit,inherit,"tCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TClass*fClass!Pointer to the class; TObject**TObjArray::fCont!Array contents; TObjArray*fKeep!Saved copies of pointers to objects; Int_tTObjArray::fLastLast element in array containing an object; Int_tTObjArray::fLowerBoundLower bound of the array; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClonesArray(); Default Constructor. TClonesArray(const char* classname, Int_t size = 1000, Bool_t call_dtor = kFALSE); Create an array of clone objects of classname. The class must inherit from; TObject. If the class defines its own operator delete(), make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument s indicates an approximate number of objects; that will be entered in the array. If more than s objects are entered,; the array will be automatically expanded. The third argument is not used anymore and only there for backward; compatibility reasons. TClonesArray(const TClass* cl, Int_t size = 1000, Bool_t call_dtor = kFALSE); Create an array of clone objects of class cl. The class must inherit from; TObject. If the class defines an own operator delete(), make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument, s, indicates an approximate num",MatchSource.WIKI,root/html530/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClonesArray.html
Performance,perform,performance," are not allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offer the possibility to allocate and delete memory.; Forgetting to delete allocated memory is a programming error that originate ""leaks"",; i.e. the memory of your process grows and eventually your program crashes.; Even if you *always* delete the allocated memory, the recovered space may not be; efficiently reused. The process knows that there are portions of free memory,; but when you allocate it again, a fresh piece of memory is grabbed.; Your program is free from semantic errors, but the total memory of your process; still grows. Moreover your program's memory is full of ""holes"" which reduce the; efficiency of memory access, this is called ""memory fragmentation"".; Moreover new / delete are expensive operations in terms of CPU time. Without entering into technical details, the TClonesArray allow to ""reuse"" the; same portion of memory for new/delete avoiding memory fragmentation and memory; growth and improving by orders of magnitude the performance. Every time the; memory of the TClonesArray has to be reused, the Clear() method is employed.; To provide its benefits, each TClonesArray must be allocated *once* per process; and disposed of (deleted) *only when not needed any more*.; So a job should see *only one* deletion for each TClonesArray, which should be; ""Cleared()"" in between several times. Keep deleting a TClonesArray is a double; waste. Not only you do not avoid memory fragmentation, but you worsen it because; the TClonesArray itself is a rather heavy structure, and there is quite some; code in the destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve program; execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoi",MatchSource.WIKI,root/html530/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClonesArray.html
Safety,recover,recovered,"O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; a[i] = new TTrack(x,y,z,...);. }. a.Delete();; }. One better uses a TClonesArray which reduces the number of; new/delete calls to only O(10000):. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; new(a[i]) TTrack(x,y,z,...);. }. a.Delete();; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method. The diffrent Add() methods of; TObjArray and its base classes are not allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offer the possibility to allocate and delete memory.; Forgetting to delete allocated memory is a programming error that originate ""leaks"",; i.e. the memory of your process grows and eventually your program crashes.; Even if you *always* delete the allocated memory, the recovered space may not be; efficiently reused. The process knows that there are portions of free memory,; but when you allocate it again, a fresh piece of memory is grabbed.; Your program is free from semantic errors, but the total memory of your process; still grows. Moreover your program's memory is full of ""holes"" which reduce the; efficiency of memory access, this is called ""memory fragmentation"".; Moreover new / delete are expensive operations in terms of CPU time. Without entering into technical details, the TClonesArray allow to ""reuse"" the; same portion of memory for new/delete avoiding memory fragmentation and memory; growth and improving by orders of magnitude the performance. Every time the; memory of the TClonesArray has to be reused, the Clear() method is employed.; To provide its benefits, each TClonesArray must be allocated *once* per process; and disposed of (deleted) *only when not needed any more*.; So a job should see *only one* deletion for each TClonesArray, w",MatchSource.WIKI,root/html530/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClonesArray.html
Security,access,access,">Ntracks; i++) { // O(10000) tracks; new(a[i]) TTrack(x,y,z,...);. }. a.Delete();; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method. The diffrent Add() methods of; TObjArray and its base classes are not allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offer the possibility to allocate and delete memory.; Forgetting to delete allocated memory is a programming error that originate ""leaks"",; i.e. the memory of your process grows and eventually your program crashes.; Even if you *always* delete the allocated memory, the recovered space may not be; efficiently reused. The process knows that there are portions of free memory,; but when you allocate it again, a fresh piece of memory is grabbed.; Your program is free from semantic errors, but the total memory of your process; still grows. Moreover your program's memory is full of ""holes"" which reduce the; efficiency of memory access, this is called ""memory fragmentation"".; Moreover new / delete are expensive operations in terms of CPU time. Without entering into technical details, the TClonesArray allow to ""reuse"" the; same portion of memory for new/delete avoiding memory fragmentation and memory; growth and improving by orders of magnitude the performance. Every time the; memory of the TClonesArray has to be reused, the Clear() method is employed.; To provide its benefits, each TClonesArray must be allocated *once* per process; and disposed of (deleted) *only when not needed any more*.; So a job should see *only one* deletion for each TClonesArray, which should be; ""Cleared()"" in between several times. Keep deleting a TClonesArray is a double; waste. Not only you do not avoid memory fragmentation, but you worsen it because; the TClonesArray itself is a rather heavy structure, and there is quite some; code in the destructor, so you have more memory fragmentation and slower code. NOTE 2",MatchSource.WIKI,root/html530/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClonesArray.html
Usability,clear,clearing," and memory; growth and improving by orders of magnitude the performance. Every time the; memory of the TClonesArray has to be reused, the Clear() method is employed.; To provide its benefits, each TClonesArray must be allocated *once* per process; and disposed of (deleted) *only when not needed any more*.; So a job should see *only one* deletion for each TClonesArray, which should be; ""Cleared()"" in between several times. Keep deleting a TClonesArray is a double; waste. Not only you do not avoid memory fragmentation, but you worsen it because; the TClonesArray itself is a rather heavy structure, and there is quite some; code in the destructor, so you have more memory fragmentation and slower code. NOTE 2. When investigating misuse of TClonesArray, please make sure of the following:. * Use Clear() or Clear(""C"") instead of Delete(). This will improve program; execution time.; * TClonesArray object classes containing pointers allocate memory.; To avoid causing memory leaks, special Clear(""C"") must be used for; clearing TClonesArray. When option ""C"" is specified, ROOT automatically; executes the Clear() method (by default it is empty contained in TObject).; This method must be overridden in the relevant TClonesArray object class,; implementing the reset procedure for pointer objects.; * To reduce memory fragmentation, please make sure that the TClonesArrays; are not destroyed and created on every event.; They must only be constructed/destructed at the beginning/end of the run. Function Members (Methods); public:. TClonesArray(); TClonesArray(const TClonesArray& tc); TClonesArray(const char* classname, Int_t size = 1000, Bool_t call_dtor = kFALSE); TClonesArray(const TClass* cl, Int_t size = 1000, Bool_t call_dtor = kFALSE); virtual~TClonesArray(); voidAbsorbObjects(TClonesArray* tc); voidAbsorbObjects(TClonesArray* tc, Int_t idx1, Int_t idx2); voidTObject::AbstractMethod(const char* method) const; virtual voidTObjArray::Add(TObject* obj); virtual voidAddAfter(const TOb",MatchSource.WIKI,root/html530/TClonesArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TClonesArray.html
Availability,avail,available," describes the base; protocol all collection classes have to implement. The ROOT; collection classes always store pointers to objects that inherit; from TObject. They never adopt the objects. Therefore, it is the; user's responsability to take care of deleting the actual objects; once they are not needed anymore. In exceptional cases, when the; user is 100% sure nothing else is referencing the objects in the; collection, one can delete all objects and the collection at the; same time using the Delete() function. Collections can be iterated using an iterator object (see; TIterator). Depending on the concrete collection class there may be; some additional methods of iterating. See the repective classes. TCollection inherits from TObject since we want to be able to have; collections of collections. In a later release the collections may become templatized. /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TCollection(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAll(const TCollection* col); voidAddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tAssertClass(TClass* cl) const; virtual voidBrowse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; Bool_tContains(const char* name) const; Bool_tContains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() ",MatchSource.WIKI,root/html530/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TCollection.html
Deployability,release,release,"ion; function members; data members; class charts. ROOT; » CORE; » CONT; » TCollection. class TCollection: public TObject. Collection abstract base class. This class describes the base; protocol all collection classes have to implement. The ROOT; collection classes always store pointers to objects that inherit; from TObject. They never adopt the objects. Therefore, it is the; user's responsability to take care of deleting the actual objects; once they are not needed anymore. In exceptional cases, when the; user is 100% sure nothing else is referencing the objects in the; collection, one can delete all objects and the collection at the; same time using the Delete() function. Collections can be iterated using an iterator object (see; TIterator). Depending on the concrete collection class there may be; some additional methods of iterating. See the repective classes. TCollection inherits from TObject since we want to be able to have; collections of collections. In a later release the collections may become templatized. /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TCollection(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAll(const TCollection* col); voidAddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tAssertClass(TClass* cl) const; virtual voidBrowse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; Bool_tContains(const char* name) const; Bool_tContains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual vo",MatchSource.WIKI,root/html530/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TCollection.html
Energy Efficiency,efficient,efficient,"= """") const; Make a clone of an collection using the Streamer facility.; If newname is specified, this will be the name of the new collection. Int_t Compare(const TObject* obj) const; Compare two TCollection objects. Returns 0 when equal, -1 when this is; smaller and +1 when bigger (like strcmp()). void Draw(Option_t* option = """"); Draw all objects in this collection. void Dump() const; Dump all objects in this collection. TObject * FindObject(const char* name) const; Find an object in this collection using its name. Requires a sequential; scan till the object has been found. Returns 0 if object with specified; name is not found. TObject * operator()(const char* name) const; Find an object in this collection by name. TObject * FindObject(const TObject* obj) const; Find an object in this collection using the object's IsEqual(); member function. Requires a sequential scan till the object has; been found. Returns 0 if object is not found.; Typically this function is overridden by a more efficient version; in concrete collection classes (e.g. THashTable). const char * GetName() const; Return name of this collection.; if no name, return the collection class name. Int_t GrowBy(Int_t delta) const; Increase the collection's capacity by delta slots. Bool_t IsArgNull(const char* where, const TObject* obj) const; Returns true if object is a null pointer. void ls(Option_t* option = """") const; List (ls) all objects in this collection.; Wildcarding supported, eg option=""xxx*"" lists only objects; with names xxx*. void Paint(Option_t* option = """"); Paint all objects in this collection. void PrintCollectionHeader(Option_t* option) const; Print the collection header. const char* GetCollectionEntryName(TObject* entry) const; For given collection entry return the string that is used to; identify the object and, potentially, perform wildcard/regexp; filtering on. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print the collection entry. void Print(Optio",MatchSource.WIKI,root/html530/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TCollection.html
Integrability,protocol,protocol,". TCollection. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TCollection. class TCollection: public TObject. Collection abstract base class. This class describes the base; protocol all collection classes have to implement. The ROOT; collection classes always store pointers to objects that inherit; from TObject. They never adopt the objects. Therefore, it is the; user's responsability to take care of deleting the actual objects; once they are not needed anymore. In exceptional cases, when the; user is 100% sure nothing else is referencing the objects in the; collection, one can delete all objects and the collection at the; same time using the Delete() function. Collections can be iterated using an iterator object (see; TIterator). Depending on the concrete collection class there may be; some additional methods of iterating. See the repective classes. TCollection inherits from TObject since we want to be able to have; collections of collections. In a later release the collections may become templatized. /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TCollection(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAll(const TCollection* col); voidAddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tAssertClass(TClass* cl) const; virtual voidBrowse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; Bool_tContains(const char* name) const; Bool_tContains(const TObject* obj) co",MatchSource.WIKI,root/html530/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TCollection.html
Modifiability,inherit,inherit,". TCollection. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TCollection. class TCollection: public TObject. Collection abstract base class. This class describes the base; protocol all collection classes have to implement. The ROOT; collection classes always store pointers to objects that inherit; from TObject. They never adopt the objects. Therefore, it is the; user's responsability to take care of deleting the actual objects; once they are not needed anymore. In exceptional cases, when the; user is 100% sure nothing else is referencing the objects in the; collection, one can delete all objects and the collection at the; same time using the Delete() function. Collections can be iterated using an iterator object (see; TIterator). Depending on the concrete collection class there may be; some additional methods of iterating. See the repective classes. TCollection inherits from TObject since we want to be able to have; collections of collections. In a later release the collections may become templatized. /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TCollection(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAll(const TCollection* col); voidAddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tAssertClass(TClass* cl) const; virtual voidBrowse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; Bool_tContains(const char* name) const; Bool_tContains(const TObject* obj) co",MatchSource.WIKI,root/html530/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TCollection.html
Performance,perform,perform,"Find an object in this collection using the object's IsEqual(); member function. Requires a sequential scan till the object has; been found. Returns 0 if object is not found.; Typically this function is overridden by a more efficient version; in concrete collection classes (e.g. THashTable). const char * GetName() const; Return name of this collection.; if no name, return the collection class name. Int_t GrowBy(Int_t delta) const; Increase the collection's capacity by delta slots. Bool_t IsArgNull(const char* where, const TObject* obj) const; Returns true if object is a null pointer. void ls(Option_t* option = """") const; List (ls) all objects in this collection.; Wildcarding supported, eg option=""xxx*"" lists only objects; with names xxx*. void Paint(Option_t* option = """"); Paint all objects in this collection. void PrintCollectionHeader(Option_t* option) const; Print the collection header. const char* GetCollectionEntryName(TObject* entry) const; For given collection entry return the string that is used to; identify the object and, potentially, perform wildcard/regexp; filtering on. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print the collection entry. void Print(Option_t* option = """") const; Defualt print for collections, calls Print(option, 1).; This will print the collection header and Print() methods of; all the collection entries. If you want to override Print() for a collection class, first; see if you can accomplish it by overriding the following protected; methods:; void PrintCollectionHeader(Option_t* option) const;; const char* GetCollectionEntryName(TObject* entry) const;; void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const;; Otherwise override the Print(Option_t *option, Int_t); variant. Remember to declare:; using TCollection::Print;; somewhere close to the method declaration. void Print(Option_t* option, Int_t recurse) const; Print the collection header and its elements. If recurse is n",MatchSource.WIKI,root/html530/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TCollection.html
Security,access,accessible,"n col from this collection. void Streamer(TBuffer& b); Stream all objects in the collection to or from the I/O buffer. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Write all objects in this collection. By default all objects in; the collection are written individually (each object gets its; own key). Note, this is recursive, i.e. objects in collections; in the collection are also written individually. To write all; objects using a single key specify a name and set option to; TObject::kSingleKey (i.e. 1). Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); Write all objects in this collection. By default all objects in; the collection are written individually (each object gets its; own key). Note, this is recursive, i.e. objects in collections; in the collection are also written individually. To write all; objects using a single key specify a name and set option to; TObject::kSingleKey (i.e. 1). TCollection * GetCurrentCollection(); Return the globally accessible collection. void SetCurrentCollection(); Set this collection to be the globally accesible collection. void StartGarbageCollection(); Set up for garbage collection. void EmptyGarbageCollection(); Do the garbage collection. void GarbageCollect(TObject* obj); Add to the list of things to be cleaned up. void SetOwner(Bool_t enable = kTRUE); Set whether this collection is the owner (enable==true); of its content. If it is the owner of its contents,; these objects will be deleted whenever the collection itself; is delete. The objects might also be deleted or destructed when Clear; is called (depending on the collection). void operator=(const TCollection& ). virtual ~TCollection(); { }. void Add(TObject* obj). Int_t Capacity() const; { return fSize; }. void Clear(Option_t* option = """"). Bool_t Contains(const char* name) const; { return FindObject(name) != 0; }. Bool_t Contains(const TObject* obj) const; { return FindObject(obj) != 0; }. void Delete(Option_t* optio",MatchSource.WIKI,root/html530/TCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TCollection.html
Availability,error,error,"CollectionMethodBrowsable&); virtual~TCollectionMethodBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualBranchBrowsable::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); static Int_tTVirtualBranchBrowsable::FillListOfBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TBranch*TVirtualBranchBrowsable::GetBranch() const; static Int_tGetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); TClass*TVirtualBranchBrowsable::GetClassType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TMethodBrowsable::GetIconName() const; TList*TVirtualBranchBrowsable::GetLeaves() const; virtual const char*TNamed::GetName() const; ",MatchSource.WIKI,root/html530/TCollectionMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TCollectionMethodBrowsable.html
Integrability,depend,depending,"eListOfBrowsables_t generator). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCollectionMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0); Contructor, see TMethodBrowsable's constructor.; Prepends ""@"" to the name to make this method work on the container. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's collection class and its base classes,; and returns the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being browsed. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... ~TCollectionMethodBrowsable(); {}. TCollectionMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0). » Author: Axel Naumann 14/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBranchBrowsable.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TCollectionMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TCollectionMethodBrowsable.html
